@_i1.JS('go')
library go; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'package:js/js.dart' as _i1;
import 'dart:core' as _i2;
import 'go_go_d.dart' as _i3;
import '/d/core.dart' as _i4;
import 'dart:js_util' as _i5;

@_i1.JS('go')
external _i2.Object _self;
typedef MarginLike = _i2.Object;
typedef DiagramEventHandler = void Function(_i3.DiagramEvent);
typedef DiagramEventName = DiagramEventNameOptions;
typedef ChangedEventHandler = void Function(_i3.ChangedEvent);
typedef EasingFunction = _i2.num Function(
  _i2.num,
  _i2.num,
  _i2.num,
  _i2.num,
);
typedef DiagramInitOptions = _i4.Partial;
typedef DiagramEvents = _i2.dynamic;
typedef ConstructorType<
        T extends _i4.InstanceType Function(_i2.Iterable<_i2.dynamic>?)>
    = _i4.InstanceType Function(_i2.Iterable<_i2.dynamic>?);
typedef MakeAllow<CT extends _i3.ConstructorType<CT>, C, E> = _i2.dynamic;
typedef BrushLike = _i2.dynamic;
typedef Key = _i2.dynamic;
typedef TargetConversion = _i2.dynamic Function(
  _i2.dynamic,
  _i2.dynamic,
)?;
typedef BackConversion = _i2.dynamic Function(
  _i2.dynamic,
  _i2.dynamic,
  _i3.Model,
)?;

/* Closure: () => String from Function 'makeDoc':. */
enum Renderer {
  default$(r'default'),
  svg(r'svg'),
  canvas(r'canvas');

  const Renderer(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum Scroll {
  pixel(r'pixel'),
  line(r'line'),
  page(r'page'),
  document(r'document');

  const Scroll(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum ScrollOptions {
  up(r'up'),
  down(r'down'),
  left(r'left'),
  right(r'right');

  const ScrollOptions(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum Make {
  toolTip(r'ToolTip'),
  contextMenu(r'ContextMenu');

  const Make(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum MakeOptions {
  button(r'Button'),
  treeExpanderButton(r'TreeExpanderButton'),
  subGraphExpanderButton(r'SubGraphExpanderButton'),
  contextMenuButton(r'ContextMenuButton'),
  panelExpanderButton(r'PanelExpanderButton'),
  checkBoxButton(r'CheckBoxButton'),
  checkBox(r'CheckBox');

  const MakeOptions(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum StrokeCap {
  butt(r'butt'),
  round(r'round'),
  square(r'square');

  const StrokeCap(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum StrokeJoin {
  miter(r'miter'),
  bevel(r'bevel'),
  round(r'round');

  const StrokeJoin(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum TextAlign {
  start(r'start'),
  end(r'end'),
  left(r'left'),
  right(r'right'),
  center(r'center');

  const TextAlign(this.value);

  final _i2.String value;
}

/* Closure: () => String from Function 'makeDoc':. */
enum DiagramEventNameOptions {
  initialAnimationStarting(r'InitialAnimationStarting'),
  animationStarting(r'AnimationStarting'),
  animationFinished(r'AnimationFinished'),
  backgroundSingleClicked(r'BackgroundSingleClicked'),
  backgroundDoubleClicked(r'BackgroundDoubleClicked'),
  backgroundContextClicked(r'BackgroundContextClicked'),
  changingSelection(r'ChangingSelection'),
  changedSelection(r'ChangedSelection'),
  clipboardChanged(r'ClipboardChanged'),
  clipboardPasted(r'ClipboardPasted'),
  documentBoundsChanged(r'DocumentBoundsChanged'),
  externalObjectsDropped(r'ExternalObjectsDropped'),
  gainedFocus(r'GainedFocus'),
  initialLayoutCompleted(r'InitialLayoutCompleted'),
  layoutCompleted(r'LayoutCompleted'),
  linkDrawn(r'LinkDrawn'),
  linkRelinked(r'LinkRelinked'),
  linkReshaped(r'LinkReshaped'),
  lostFocus(r'LostFocus'),
  modified(r'Modified'),
  objectSingleClicked(r'ObjectSingleClicked'),
  objectDoubleClicked(r'ObjectDoubleClicked'),
  objectContextClicked(r'ObjectContextClicked'),
  partCreated(r'PartCreated'),
  partResized(r'PartResized'),
  partRotated(r'PartRotated'),
  selectionMoved(r'SelectionMoved'),
  selectionCopied(r'SelectionCopied'),
  selectionDeleted(r'SelectionDeleted'),
  selectionDeleting(r'SelectionDeleting'),
  selectionGrouped(r'SelectionGrouped'),
  selectionUngrouped(r'SelectionUngrouped'),
  subGraphCollapsed(r'SubGraphCollapsed'),
  subGraphExpanded(r'SubGraphExpanded'),
  textEdited(r'TextEdited'),
  treeCollapsed(r'TreeCollapsed'),
  treeExpanded(r'TreeExpanded'),
  viewportBoundsChanged(r'ViewportBoundsChanged'),
  invalidateDraw(r'InvalidateDraw');

  const DiagramEventNameOptions(this.value);

  final _i2.String value;
}

@_i1.JS()
@_i1.staticInterop
class EnumValue {
  factory EnumValue(
    _i2.Function classfunc,
    _i2.String name,
    _i2.num val,
  ) =>
      _i5.callConstructor(
        _declaredEnumValue,
        [
          classfunc,
          name,
          val,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('EnumValue')
external _i2.Object _declaredEnumValue;

extension EnumValue$Typings on EnumValue {
  /* #37
  source: 
    /**
     */
    get classType(): Function; */
  _i2.Function get classType => _i5.getProperty(
        this,
        'classType',
      );
  /* #37
  source: 
    /**
     */
    get classType(): Function; */
  // Type InteropStaticType.function
  set classType(_i2.Function value) {
    _i5.setProperty(
      this,
      'classType',
      value,
    );
  }

  /* #40
  source: 
    /**
     */
    get name(): string; */
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #40
  source: 
    /**
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Iterable<T> {}

extension Iterable$Typings<T> on Iterable<T> {
  /* #70
  source: 
    /**
     * Gets an Iterator that can iterate over the items in the collection.
     *
     * Typical usage is:
     * ```js
     *  var it = anIterableCollection.iterator;
     *  while (it.next()) {
     *    var item = it.value;
     *  }
     * ```
     * @return {Iterator.<T>}
     */
    iterator: Iterator<T>; */
  /// Gets an Iterator that can iterate over the items in the collection.
  ///
  ///  Typical usage is:
  ///  ```js
  ///   var it = anIterableCollection.iterator;
  ///   while (it.next()) {
  ///     var item = it.value;
  ///   }
  ///  ```
  ///  @return {Iterator.<T>}
  _i3.Iterator<T> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #70
  source: 
    /**
     * Gets an Iterator that can iterate over the items in the collection.
     *
     * Typical usage is:
     * ```js
     *  var it = anIterableCollection.iterator;
     *  while (it.next()) {
     *    var item = it.value;
     *  }
     * ```
     * @return {Iterator.<T>}
     */
    iterator: Iterator<T>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.Iterator<T> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  /* #79
  source: 
    /**
     * This read-only property is the number of elements in the collection.
     */
    readonly count: number; */
  /// This read-only property is the number of elements in the collection.
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  T? first() => _i5.callMethod(
        this,
        'first',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Iterator<T> implements _i3.Iterable<T> {}

extension Iterator$Typings<T> on Iterator<T> {
  /* #111
  source: 
    /**
     * Returns itself, which is convenient for code that expects an Iterable
     * instead of an Iterator.
     * @return {Iterator.<T>}
     */
    iterator: Iterator<T>; */
  /// Returns itself, which is convenient for code that expects an Iterable
  ///  instead of an Iterator.
  ///  @return {Iterator.<T>}
  _i3.Iterator<T> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #111
  source: 
    /**
     * Returns itself, which is convenient for code that expects an Iterable
     * instead of an Iterator.
     * @return {Iterator.<T>}
     */
    iterator: Iterator<T>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.Iterator<T> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  /* #197
  source: 
    /**
     * Gets the current item in the collection, assuming #next has just returned true.
     */
    readonly value: T; */
  /// Gets the current item in the collection, assuming #next has just returned true.
  T get value => _i5.getProperty(
        this,
        'value',
      );
  /* #201
  source: 
    /**
     * Gets the current index to the item in the collection, assuming #next has just returned true.
     */
    readonly key: any; */
  /// Gets the current index to the item in the collection, assuming #next has just returned true.
  _i2.dynamic get key => _i5.getProperty(
        this,
        'key',
      );
  /* #205
  source: 
    /**
     * This read-only property is the total number of items in the iterated collection.
     */
    readonly count: number; */
  /// This read-only property is the total number of items in the iterated collection.
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  _i2.bool next() => _i5.callMethod(
        this,
        'next',
        [],
      );
  _i2.bool hasNext() => _i5.callMethod(
        this,
        'hasNext',
        [],
      );
  T? first() => _i5.callMethod(
        this,
        'first',
        [],
      );
  void reset() {
    _i5.callMethod(
      this,
      'reset',
      [],
    );
  }

  _i2.bool any(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'any',
        [_i5.allowInterop(pred)],
      );
  _i2.bool all(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'all',
        [_i5.allowInterop(pred)],
      );
  void each(void Function(T) func) {
    _i5.callMethod(
      this,
      'each',
      [_i5.allowInterop(func)],
    );
  }

  _i3.Iterator<S> map<S>(S Function(T) func) => _i5.callMethod(
        this,
        'map',
        [_i5.allowInterop(func)],
      );
  _i3.Iterator<T> filter(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'filter',
        [_i5.allowInterop(pred)],
      );
}

@_i1.JS()
@_i1.staticInterop
class ISurface {}

extension ISurface$Typings on ISurface {
  /* #211
  source: 
    domElement: Element; */
  _i4.Element get domElement => _i5.getProperty(
        this,
        'domElement',
      );
  /* #211
  source: 
    domElement: Element; */
  // Type Instance of 'ExternalInteropType'
  set domElement(_i4.Element value) {
    _i5.setProperty(
      this,
      'domElement',
      value,
    );
  }

  /* #212
  source: 
    context: IContext; */
  _i3.IContext get context => _i5.getProperty(
        this,
        'context',
      );
  /* #212
  source: 
    context: IContext; */
  // Type Instance of 'InteropInterface'
  set context(_i3.IContext value) {
    _i5.setProperty(
      this,
      'context',
      value,
    );
  }

  /* #213
  source: 
    width: number; */
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #213
  source: 
    width: number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #214
  source: 
    height: number; */
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #214
  source: 
    height: number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  /* #215
  source: 
    ownerDocument: Document; */
  _i4.Document get ownerDocument => _i5.getProperty(
        this,
        'ownerDocument',
      );
  /* #215
  source: 
    ownerDocument: Document; */
  // Type Instance of 'ExternalInteropType'
  set ownerDocument(_i4.Document value) {
    _i5.setProperty(
      this,
      'ownerDocument',
      value,
    );
  }

  /* #217
  source: 
    elementFinished: ((a: GraphObject, b: SVGElement) => void) | null; */
  void Function(
    _i3.GraphObject,
    _i4.SVGElement,
  )? get elementFinished => _i5.getProperty(
        this,
        'elementFinished',
      );
  /* #217
  source: 
    elementFinished: ((a: GraphObject, b: SVGElement) => void) | null; */
  // Type InteropUnion#1046358210(parent: InteropGetter#786004815(name: elementFinished))
  set elementFinished(
      void Function(
        _i3.GraphObject,
        _i4.SVGElement,
      )? value) {
    _i5.setProperty(
      this,
      'elementFinished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #221
  source: 
    style: CSSStyleDeclaration; */
  _i4.CSSStyleDeclaration get style => _i5.getProperty(
        this,
        'style',
      );
  /* #221
  source: 
    style: CSSStyleDeclaration; */
  // Type Instance of 'ExternalInteropType'
  set style(_i4.CSSStyleDeclaration value) {
    _i5.setProperty(
      this,
      'style',
      value,
    );
  }

  _i2.bool resize(
    _i2.num pixelWidth,
    _i2.num pixelHeight,
    _i2.num width,
    _i2.num height,
  ) =>
      _i5.callMethod(
        this,
        'resize',
        [
          pixelWidth,
          pixelHeight,
          width,
          height,
        ],
      );
  _i4.DOMRect getBoundingClientRect() => _i5.callMethod(
        this,
        'getBoundingClientRect',
        [],
      );
  void focus() {
    _i5.callMethod(
      this,
      'focus',
      [],
    );
  }

  void dispose() {
    _i5.callMethod(
      this,
      'dispose',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class IContext {}

extension IContext$Typings on IContext {
  /* #227
  source: 
    fillStyle: string | CanvasGradient | CanvasPattern | SGradient; */
  _i2.Object get fillStyle => _i5.getProperty(
        this,
        'fillStyle',
      );
  /* #227
  source: 
    fillStyle: string | CanvasGradient | CanvasPattern | SGradient; */
  // Type InteropUnion#913839391(parent: InteropGetter#1060557252(name: fillStyle))
  set fillStyle(_i2.Object value) {
    _i5.setProperty(
      this,
      'fillStyle',
      value,
    );
  }

  /* #228
  source: 
    font: string; */
  _i2.String get font => _i5.getProperty(
        this,
        'font',
      );
  /* #228
  source: 
    font: string; */
  // Type InteropStaticType.string
  set font(_i2.String value) {
    _i5.setProperty(
      this,
      'font',
      value,
    );
  }

  /* #229
  source: 
    globalAlpha: number; */
  _i2.num get globalAlpha => _i5.getProperty(
        this,
        'globalAlpha',
      );
  /* #229
  source: 
    globalAlpha: number; */
  // Type InteropStaticType.number
  set globalAlpha(_i2.num value) {
    _i5.setProperty(
      this,
      'globalAlpha',
      value,
    );
  }

  /* #230
  source: 
    lineCap: string; */
  _i2.String get lineCap => _i5.getProperty(
        this,
        'lineCap',
      );
  /* #230
  source: 
    lineCap: string; */
  // Type InteropStaticType.string
  set lineCap(_i2.String value) {
    _i5.setProperty(
      this,
      'lineCap',
      value,
    );
  }

  /* #231
  source: 
    lineDashOffset: number; */
  _i2.num get lineDashOffset => _i5.getProperty(
        this,
        'lineDashOffset',
      );
  /* #231
  source: 
    lineDashOffset: number; */
  // Type InteropStaticType.number
  set lineDashOffset(_i2.num value) {
    _i5.setProperty(
      this,
      'lineDashOffset',
      value,
    );
  }

  /* #232
  source: 
    lineJoin: string; */
  _i2.String get lineJoin => _i5.getProperty(
        this,
        'lineJoin',
      );
  /* #232
  source: 
    lineJoin: string; */
  // Type InteropStaticType.string
  set lineJoin(_i2.String value) {
    _i5.setProperty(
      this,
      'lineJoin',
      value,
    );
  }

  /* #233
  source: 
    lineWidth: number; */
  _i2.num get lineWidth => _i5.getProperty(
        this,
        'lineWidth',
      );
  /* #233
  source: 
    lineWidth: number; */
  // Type InteropStaticType.number
  set lineWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'lineWidth',
      value,
    );
  }

  /* #234
  source: 
    miterLimit: number; */
  _i2.num get miterLimit => _i5.getProperty(
        this,
        'miterLimit',
      );
  /* #234
  source: 
    miterLimit: number; */
  // Type InteropStaticType.number
  set miterLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'miterLimit',
      value,
    );
  }

  /* #235
  source: 
    shadowBlur: number; */
  _i2.num get shadowBlur => _i5.getProperty(
        this,
        'shadowBlur',
      );
  /* #235
  source: 
    shadowBlur: number; */
  // Type InteropStaticType.number
  set shadowBlur(_i2.num value) {
    _i5.setProperty(
      this,
      'shadowBlur',
      value,
    );
  }

  /* #236
  source: 
    shadowColor: string; */
  _i2.String get shadowColor => _i5.getProperty(
        this,
        'shadowColor',
      );
  /* #236
  source: 
    shadowColor: string; */
  // Type InteropStaticType.string
  set shadowColor(_i2.String value) {
    _i5.setProperty(
      this,
      'shadowColor',
      value,
    );
  }

  /* #237
  source: 
    shadowOffsetX: number; */
  _i2.num get shadowOffsetX => _i5.getProperty(
        this,
        'shadowOffsetX',
      );
  /* #237
  source: 
    shadowOffsetX: number; */
  // Type InteropStaticType.number
  set shadowOffsetX(_i2.num value) {
    _i5.setProperty(
      this,
      'shadowOffsetX',
      value,
    );
  }

  /* #238
  source: 
    shadowOffsetY: number; */
  _i2.num get shadowOffsetY => _i5.getProperty(
        this,
        'shadowOffsetY',
      );
  /* #238
  source: 
    shadowOffsetY: number; */
  // Type InteropStaticType.number
  set shadowOffsetY(_i2.num value) {
    _i5.setProperty(
      this,
      'shadowOffsetY',
      value,
    );
  }

  /* #239
  source: 
    strokeStyle: string | CanvasGradient | CanvasPattern | SGradient; */
  _i2.Object get strokeStyle => _i5.getProperty(
        this,
        'strokeStyle',
      );
  /* #239
  source: 
    strokeStyle: string | CanvasGradient | CanvasPattern | SGradient; */
  // Type InteropUnion#119173218(parent: InteropGetter#59560348(name: strokeStyle))
  set strokeStyle(_i2.Object value) {
    _i5.setProperty(
      this,
      'strokeStyle',
      value,
    );
  }

  /* #240
  source: 
    textAlign: string; */
  _i2.String get textAlign => _i5.getProperty(
        this,
        'textAlign',
      );
  /* #240
  source: 
    textAlign: string; */
  // Type InteropStaticType.string
  set textAlign(_i2.String value) {
    _i5.setProperty(
      this,
      'textAlign',
      value,
    );
  }

  /* #241
  source: 
    imageSmoothingEnabled: boolean; */
  _i2.bool get imageSmoothingEnabled => _i5.getProperty(
        this,
        'imageSmoothingEnabled',
      );
  /* #241
  source: 
    imageSmoothingEnabled: boolean; */
  // Type InteropStaticType.boolean
  set imageSmoothingEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'imageSmoothingEnabled',
      value,
    );
  }

  /* #242
  source: 
    clipInsteadOfFill: boolean; */
  _i2.bool get clipInsteadOfFill => _i5.getProperty(
        this,
        'clipInsteadOfFill',
      );
  /* #242
  source: 
    clipInsteadOfFill: boolean; */
  // Type InteropStaticType.boolean
  set clipInsteadOfFill(_i2.bool value) {
    _i5.setProperty(
      this,
      'clipInsteadOfFill',
      value,
    );
  }

  /* #243
  source: 
    currentlyShadowed: boolean; */
  _i2.bool get currentlyShadowed => _i5.getProperty(
        this,
        'currentlyShadowed',
      );
  /* #243
  source: 
    currentlyShadowed: boolean; */
  // Type InteropStaticType.boolean
  set currentlyShadowed(_i2.bool value) {
    _i5.setProperty(
      this,
      'currentlyShadowed',
      value,
    );
  }

  /* #244
  source: 
    isTemporary: boolean; */
  _i2.bool get isTemporary => _i5.getProperty(
        this,
        'isTemporary',
      );
  /* #244
  source: 
    isTemporary: boolean; */
  // Type InteropStaticType.boolean
  set isTemporary(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTemporary',
      value,
    );
  }

  /* #245
  source: 
    filter: string; */
  _i2.String get filter => _i5.getProperty(
        this,
        'filter',
      );
  /* #245
  source: 
    filter: string; */
  // Type InteropStaticType.string
  set filter(_i2.String value) {
    _i5.setProperty(
      this,
      'filter',
      value,
    );
  }

  /* #246
  source: 
    cachedTransform: any; */
  _i2.dynamic get cachedTransform => _i5.getProperty(
        this,
        'cachedTransform',
      );
  /* #246
  source: 
    cachedTransform: any; */
  // Type InteropStaticType.dyn
  set cachedTransform(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'cachedTransform',
      value,
    );
  }

  void commitTransform() {
    _i5.callMethod(
      this,
      'commitTransform',
      [],
    );
  }

  void setImageSmoothingEnabled(_i2.bool smooth) {
    _i5.callMethod(
      this,
      'setImageSmoothingEnabled',
      [smooth],
    );
  }

  void arc(
    _i2.num x,
    _i2.num y,
    _i2.num radius,
    _i2.num startAngle,
    _i2.num endAngle,
    _i2.bool counterclockwise, [
    _i2.num? lx,
    _i2.num? ly,
  ]) {
    _i5.callMethod(
      this,
      'arc',
      [
        x,
        y,
        radius,
        startAngle,
        endAngle,
        counterclockwise,
        lx ?? _i4.undefined,
        ly ?? _i4.undefined,
      ],
    );
  }

  void beginPath() {
    _i5.callMethod(
      this,
      'beginPath',
      [],
    );
  }

  void endPath([_i2.num? pathIndex]) {
    _i5.callMethod(
      this,
      'endPath',
      [pathIndex ?? _i4.undefined],
    );
  }

  void bezierCurveTo(
    _i2.num a,
    _i2.num b,
    _i2.num c,
    _i2.num d,
    _i2.num e,
    _i2.num f,
  ) {
    _i5.callMethod(
      this,
      'bezierCurveTo',
      [
        a,
        b,
        c,
        d,
        e,
        f,
      ],
    );
  }

  void clearRect(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) {
    _i5.callMethod(
      this,
      'clearRect',
      [
        x,
        y,
        w,
        h,
      ],
    );
  }

  void clip() {
    _i5.callMethod(
      this,
      'clip',
      [],
    );
  }

  void closePath() {
    _i5.callMethod(
      this,
      'closePath',
      [],
    );
  }

  _i2.Object createLinearGradient(
    _i2.num aX0,
    _i2.num aY0,
    _i2.num aX1,
    _i2.num aY1,
  ) =>
      _i5.callMethod(
        this,
        'createLinearGradient',
        [
          aX0,
          aY0,
          aX1,
          aY1,
        ],
      );
  _i2.Object createPattern(
    _i2.Object image,
    _i2.String repetition,
  ) =>
      _i5.callMethod(
        this,
        'createPattern',
        [
          image,
          repetition,
        ],
      );
  _i2.Object createRadialGradient(
    _i2.num aX0,
    _i2.num aY0,
    _i2.num aR0,
    _i2.num aX1,
    _i2.num aY1,
    _i2.num aR1,
  ) =>
      _i5.callMethod(
        this,
        'createRadialGradient',
        [
          aX0,
          aY0,
          aR0,
          aX1,
          aY1,
          aR1,
        ],
      );
  void drawImage(
    _i2.Object src,
    _i2.num sx,
    _i2.num sy, [
    _i2.num? sw,
    _i2.num? sh,
    _i2.num? dx,
    _i2.num? dy,
    _i2.num? dw,
    _i2.num? dh,
  ]) {
    _i5.callMethod(
      this,
      'drawImage',
      [
        src,
        sx,
        sy,
        sw ?? _i4.undefined,
        sh ?? _i4.undefined,
        dx ?? _i4.undefined,
        dy ?? _i4.undefined,
        dw ?? _i4.undefined,
        dh ?? _i4.undefined,
      ],
    );
  }

  void fill([_i2.bool? fillRule]) {
    _i5.callMethod(
      this,
      'fill',
      [fillRule ?? _i4.undefined],
    );
  }

  void fillRect(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) {
    _i5.callMethod(
      this,
      'fillRect',
      [
        x,
        y,
        w,
        h,
      ],
    );
  }

  void fillBackground(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) {
    _i5.callMethod(
      this,
      'fillBackground',
      [
        x,
        y,
        w,
        h,
      ],
    );
  }

  void fillText(
    _i2.String str,
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'fillText',
      [
        str,
        x,
        y,
      ],
    );
  }

  _i4.ImageData getImageData(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'getImageData',
        [
          x,
          y,
          w,
          h,
        ],
      );
  void lineTo(
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'lineTo',
      [
        x,
        y,
      ],
    );
  }

  _i4.TextMetrics measureText(_i2.String text) => _i5.callMethod(
        this,
        'measureText',
        [text],
      );
  void moveTo(
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'moveTo',
      [
        x,
        y,
      ],
    );
  }

  void quadraticCurveTo(
    _i2.num a,
    _i2.num b,
    _i2.num c,
    _i2.num d,
  ) {
    _i5.callMethod(
      this,
      'quadraticCurveTo',
      [
        a,
        b,
        c,
        d,
      ],
    );
  }

  void rect(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) {
    _i5.callMethod(
      this,
      'rect',
      [
        x,
        y,
        w,
        h,
      ],
    );
  }

  void restore() {
    _i5.callMethod(
      this,
      'restore',
      [],
    );
  }

  void rotate(_i2.num angle) {
    _i5.callMethod(
      this,
      'rotate',
      [angle],
    );
  }

  void save() {
    _i5.callMethod(
      this,
      'save',
      [],
    );
  }

  void setTransform(
    _i2.num a,
    _i2.num b,
    _i2.num c,
    _i2.num d,
    _i2.num e,
    _i2.num f,
  ) {
    _i5.callMethod(
      this,
      'setTransform',
      [
        a,
        b,
        c,
        d,
        e,
        f,
      ],
    );
  }

  void scale(
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'scale',
      [
        x,
        y,
      ],
    );
  }

  void stroke() {
    _i5.callMethod(
      this,
      'stroke',
      [],
    );
  }

  void transform(
    _i2.num a,
    _i2.num b,
    _i2.num c,
    _i2.num d,
    _i2.num e,
    _i2.num f,
  ) {
    _i5.callMethod(
      this,
      'transform',
      [
        a,
        b,
        c,
        d,
        e,
        f,
      ],
    );
  }

  void translate(
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'translate',
      [
        x,
        y,
      ],
    );
  }

  void fillContext(
    _i3.BrushLike brush, [
    _i2.bool? fillRule,
  ]) {
    _i5.callMethod(
      this,
      'fillContext',
      [
        brush ?? _i4.undefined,
        fillRule ?? _i4.undefined,
      ],
    );
  }

  void strokeContext() {
    _i5.callMethod(
      this,
      'strokeContext',
      [],
    );
  }

  void shadowsSet(
    _i2.num x,
    _i2.num y,
    _i2.num blur,
  ) {
    _i5.callMethod(
      this,
      'shadowsSet',
      [
        x,
        y,
        blur,
      ],
    );
  }

  void shadowsOff() {
    _i5.callMethod(
      this,
      'shadowsOff',
      [],
    );
  }

  void shadowsOn() {
    _i5.callMethod(
      this,
      'shadowsOn',
      [],
    );
  }

  void enableDash(
    _i4.Array strokeDashArray,
    _i2.num strokeDashOffset,
  ) {
    _i5.callMethod(
      this,
      'enableDash',
      [
        strokeDashArray,
        strokeDashOffset,
      ],
    );
  }

  void disableDash() {
    _i5.callMethod(
      this,
      'disableDash',
      [],
    );
  }

  void clearContextCache(_i2.bool clearFont) {
    _i5.callMethod(
      this,
      'clearContextCache',
      [clearFont],
    );
  }

  void removePartFromView(_i3.GraphObject p) {
    _i5.callMethod(
      this,
      'removePartFromView',
      [p],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class List<T> implements _i3.Iterable<T> {
  factory List([_i2.Object? coll]) => _i5.callConstructor(
        _declaredList,
        [coll ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('List')
external _i2.Object _declaredList;

extension List$Typings<T> on List<T> {
  /* #601
  source: 
    /**
     * This read-only property is the length of the List.
     */
    get count(): number; */
  /// This read-only property is the length of the List.
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  /* #601
  source: 
    /**
     * This read-only property is the length of the List.
     */
    get count(): number; */
  // Type InteropStaticType.number
  set count(_i2.num value) {
    _i5.setProperty(
      this,
      'count',
      value,
    );
  }

  /* #605
  source: 
    /**
     * This read-only property is the length of the List.
     */
    get size(): number; */
  /// This read-only property is the length of the List.
  _i2.num get size => _i5.getProperty(
        this,
        'size',
      );
  /* #605
  source: 
    /**
     * This read-only property is the length of the List.
     */
    get size(): number; */
  // Type InteropStaticType.number
  set size(_i2.num value) {
    _i5.setProperty(
      this,
      'size',
      value,
    );
  }

  /* #609
  source: 
    /**
     * This read-only property is the length of the List, a synonym for the #count property.
     */
    get length(): number; */
  /// This read-only property is the length of the List, a synonym for the #count property.
  _i2.num get length => _i5.getProperty(
        this,
        'length',
      );
  /* #609
  source: 
    /**
     * This read-only property is the length of the List, a synonym for the #count property.
     */
    get length(): number; */
  // Type InteropStaticType.number
  set length(_i2.num value) {
    _i5.setProperty(
      this,
      'length',
      value,
    );
  }

  /* #622
  source: 
    /**
     * Gets an object that you can use for iterating over the List.
     * The key will be an integer from zero to the count-1.
     * The value will be the item at that index in the list.
     * Typical usage:
     * ```js
     *   var it = aList.iterator;
     *   while (it.next()) {
     *     . . . "index: " + it.key + " value: " + it.value . . .
     *   }
     * ```
     */
    get iterator(): Iterator<T>; */
  /// Gets an object that you can use for iterating over the List.
  /// The key will be an integer from zero to the count-1.
  /// The value will be the item at that index in the list.
  /// Typical usage:
  /// ```js
  ///   var it = aList.iterator;
  ///   while (it.next()) {
  ///     . . . "index: " + it.key + " value: " + it.value . . .
  ///   }
  /// ```
  _i3.Iterator<T> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #622
  source: 
    /**
     * Gets an object that you can use for iterating over the List.
     * The key will be an integer from zero to the count-1.
     * The value will be the item at that index in the list.
     * Typical usage:
     * ```js
     *   var it = aList.iterator;
     *   while (it.next()) {
     *     . . . "index: " + it.key + " value: " + it.value . . .
     *   }
     * ```
     */
    get iterator(): Iterator<T>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.Iterator<T> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  /* #636
  source: 
    /**
     * Gets an object that you can use for iterating over the List in backwards order.
     * The key will be an integer from count-1 to zero.
     * The value will be the item at that index in the list.
     * The list is not modified by traversing in reverse order.
     * Typical usage:
     * ```js
     *   var it = aList.iteratorBackwards;
     *   while (it.next()) {
     *     . . . 'key: ' + it.key + ' value: ' + it.value . . .
     *   }
     * ```
     */
    get iteratorBackwards(): Iterator<T>; */
  /// Gets an object that you can use for iterating over the List in backwards order.
  /// The key will be an integer from count-1 to zero.
  /// The value will be the item at that index in the list.
  /// The list is not modified by traversing in reverse order.
  /// Typical usage:
  /// ```js
  ///   var it = aList.iteratorBackwards;
  ///   while (it.next()) {
  ///     . . . 'key: ' + it.key + ' value: ' + it.value . . .
  ///   }
  /// ```
  _i3.Iterator<T> get iteratorBackwards => _i5.getProperty(
        this,
        'iteratorBackwards',
      );
  /* #636
  source: 
    /**
     * Gets an object that you can use for iterating over the List in backwards order.
     * The key will be an integer from count-1 to zero.
     * The value will be the item at that index in the list.
     * The list is not modified by traversing in reverse order.
     * Typical usage:
     * ```js
     *   var it = aList.iteratorBackwards;
     *   while (it.next()) {
     *     . . . 'key: ' + it.key + ' value: ' + it.value . . .
     *   }
     * ```
     */
    get iteratorBackwards(): Iterator<T>; */
  // Type Instance of 'InteropInterface'
  set iteratorBackwards(_i3.Iterator<T> value) {
    _i5.setProperty(
      this,
      'iteratorBackwards',
      value,
    );
  }

  _i2.String toString$() => _i5.callMethod(
        this,
        'toString',
        [],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),945337203,[Instance of 'InteropRef<InteropType>']*/ <T>
      add(T val) => _i5.callMethod(
            this,
            'add',
            [val],
          );
  void push(T val) {
    _i5.callMethod(
      this,
      'push',
      [val],
    );
  }

  _i3.List /*LIST InteropClass#847625641(name: List),48130252,[Instance of 'InteropRef<InteropType>']*/ <T>
      addAll(_i2.Object coll) => _i5.callMethod(
            this,
            'addAll',
            [coll],
          );
  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i2.bool contains(T val) => _i5.callMethod(
        this,
        'contains',
        [val],
      );
  _i2.bool has(T val) => _i5.callMethod(
        this,
        'has',
        [val],
      );
  _i2.num indexOf(T val) => _i5.callMethod(
        this,
        'indexOf',
        [val],
      );
  T elt(_i2.num i) => _i5.callMethod(
        this,
        'elt',
        [i],
      );
  T get(_i2.num i) => _i5.callMethod(
        this,
        'get',
        [i],
      );
  void setElt(
    _i2.num i,
    T val,
  ) {
    _i5.callMethod(
      this,
      'setElt',
      [
        i,
        val,
      ],
    );
  }

  void set(
    _i2.num i,
    T val,
  ) {
    _i5.callMethod(
      this,
      'set',
      [
        i,
        val,
      ],
    );
  }

  T? first() => _i5.callMethod(
        this,
        'first',
        [],
      );
  T? last() => _i5.callMethod(
        this,
        'last',
        [],
      );
  T? pop() => _i5.callMethod(
        this,
        'pop',
        [],
      );
  _i2.bool any(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'any',
        [_i5.allowInterop(pred)],
      );
  _i2.bool all(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'all',
        [_i5.allowInterop(pred)],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),87890465,[Instance of 'InteropRef<InteropType>']*/ <T>
      each(void Function(T) func) => _i5.callMethod(
            this,
            'each',
            [_i5.allowInterop(func)],
          );
  _i3.List /*LIST InteropClass#847625641(name: List),757360865,[Instance of 'InteropRef<InteropType>']*/ <S>
      map<S>(S Function(T) func) => _i5.callMethod(
            this,
            'map',
            [_i5.allowInterop(func)],
          );
  _i3.List /*LIST InteropClass#847625641(name: List),947346893,[Instance of 'InteropRef<InteropType>']*/ <T>
      filter(_i2.bool Function(T) pred) => _i5.callMethod(
            this,
            'filter',
            [_i5.allowInterop(pred)],
          );
  void insertAt(
    _i2.num i,
    T val,
  ) {
    _i5.callMethod(
      this,
      'insertAt',
      [
        i,
        val,
      ],
    );
  }

  _i2.bool remove(T val) => _i5.callMethod(
        this,
        'remove',
        [val],
      );
  _i2.bool delete(T val) => _i5.callMethod(
        this,
        'delete',
        [val],
      );
  void removeAt(_i2.num i) {
    _i5.callMethod(
      this,
      'removeAt',
      [i],
    );
  }

  _i3.List /*LIST InteropClass#847625641(name: List),443708804,[Instance of 'InteropRef<InteropType>']*/ <
      T> removeRange(
    _i2.num from,
    _i2.num to,
  ) =>
      _i5.callMethod(
        this,
        'removeRange',
        [
          from,
          to,
        ],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),6568733,[Instance of 'InteropRef<InteropType>']*/ <T>
      copy() => _i5.callMethod(
            this,
            'copy',
            [],
          );
  _i4.Array toArray() => _i5.callMethod(
        this,
        'toArray',
        [],
      );
  _i3.Set<T> toSet() => _i5.callMethod(
        this,
        'toSet',
        [],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),531005494,[Instance of 'InteropRef<InteropType>']*/ <
      T> sort(
          _i2.num Function(
            T,
            T,
          ) sortfunc) =>
      _i5.callMethod(
        this,
        'sort',
        [_i5.allowInterop(sortfunc)],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),124956493,[Instance of 'InteropRef<InteropType>']*/ <
      T> sortRange(
    _i2.num Function(
      T,
      T,
    ) sortfunc, [
    _i2.num? from,
    _i2.num? to,
  ]) =>
      _i5.callMethod(
        this,
        'sortRange',
        [
          _i5.allowInterop(sortfunc),
          from ?? _i4.undefined,
          to ?? _i4.undefined,
        ],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),739602517,[Instance of 'InteropRef<InteropType>']*/ <T>
      reverse() => _i5.callMethod(
            this,
            'reverse',
            [],
          );
}

@_i1.JS()
@_i1.staticInterop
class Set<T> implements _i3.Iterable<T> {
  factory Set([_i2.Object? coll]) => _i5.callConstructor(
        _declaredSet,
        [coll ?? _i4.undefined],
      );

  static void uniqueHash(_i2.Object obj) {
    _i5.callMethod(
      _declaredSet,
      'uniqueHash',
      [obj],
    );
  }

  static _i2.num hashIdUnique(_i2.Object obj) => _i5.callMethod(
        _declaredSet,
        'hashIdUnique',
        [obj],
      );
  static _i2.num? hashId(_i2.Object obj) => _i5.callMethod(
        _declaredSet,
        'hashId',
        [obj],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Set')
external _i2.Object _declaredSet;

extension Set$Typings<T> on Set<T> {
  /* #872
  source: 
    /**
     * This read-only property is the number of elements in the Set.
     */
    get count(): number; */
  /// This read-only property is the number of elements in the Set.
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  /* #872
  source: 
    /**
     * This read-only property is the number of elements in the Set.
     */
    get count(): number; */
  // Type InteropStaticType.number
  set count(_i2.num value) {
    _i5.setProperty(
      this,
      'count',
      value,
    );
  }

  /* #876
  source: 
    /**
     * This read-only property is the number of elements in the Set.
     */
    get size(): number; */
  /// This read-only property is the number of elements in the Set.
  _i2.num get size => _i5.getProperty(
        this,
        'size',
      );
  /* #876
  source: 
    /**
     * This read-only property is the number of elements in the Set.
     */
    get size(): number; */
  // Type InteropStaticType.number
  set size(_i2.num value) {
    _i5.setProperty(
      this,
      'size',
      value,
    );
  }

  /* #888
  source: 
    /**
     * Gets an object that you can use for iterating over the Set.
     * The value will be a member of the Set.
     * Typical usage:
     * ```js
     *   var it = aSet.iterator;
     *   while (it.next()) {
     *     . . . " value: " + it.value . . .
     *   }
     * ```
     */
    get iterator(): Iterator<T>; */
  /// Gets an object that you can use for iterating over the Set.
  /// The value will be a member of the Set.
  /// Typical usage:
  /// ```js
  ///   var it = aSet.iterator;
  ///   while (it.next()) {
  ///     . . . " value: " + it.value . . .
  ///   }
  /// ```
  _i3.Iterator<T> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #888
  source: 
    /**
     * Gets an object that you can use for iterating over the Set.
     * The value will be a member of the Set.
     * Typical usage:
     * ```js
     *   var it = aSet.iterator;
     *   while (it.next()) {
     *     . . . " value: " + it.value . . .
     *   }
     * ```
     */
    get iterator(): Iterator<T>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.Iterator<T> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  _i2.String toString$() => _i5.callMethod(
        this,
        'toString',
        [],
      );
  _i3.Set<T> add(T val) => _i5.callMethod(
        this,
        'add',
        [val],
      );
  _i3.Set<T> addAll(_i2.Object coll) => _i5.callMethod(
        this,
        'addAll',
        [coll],
      );
  _i2.bool contains(T val) => _i5.callMethod(
        this,
        'contains',
        [val],
      );
  _i2.bool has(T val) => _i5.callMethod(
        this,
        'has',
        [val],
      );
  _i2.bool containsAll(_i3.Iterable<T> coll) => _i5.callMethod(
        this,
        'containsAll',
        [coll],
      );
  _i2.bool containsAny(_i3.Iterable<T> coll) => _i5.callMethod(
        this,
        'containsAny',
        [coll],
      );
  T? first() => _i5.callMethod(
        this,
        'first',
        [],
      );
  _i2.bool any(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'any',
        [_i5.allowInterop(pred)],
      );
  _i2.bool all(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'all',
        [_i5.allowInterop(pred)],
      );
  _i3.Set<T> each(void Function(T) func) => _i5.callMethod(
        this,
        'each',
        [_i5.allowInterop(func)],
      );
  _i3.Set<S> map<S>(S Function(T) func) => _i5.callMethod(
        this,
        'map',
        [_i5.allowInterop(func)],
      );
  _i3.Set<T> filter(_i2.bool Function(T) pred) => _i5.callMethod(
        this,
        'filter',
        [_i5.allowInterop(pred)],
      );
  _i2.bool remove(T val) => _i5.callMethod(
        this,
        'remove',
        [val],
      );
  _i2.bool delete(T val) => _i5.callMethod(
        this,
        'delete',
        [val],
      );
  _i3.Set<T> removeAll(_i2.Object coll) => _i5.callMethod(
        this,
        'removeAll',
        [coll],
      );
  _i3.Set<T> retainAll(_i3.Iterable<T> coll) => _i5.callMethod(
        this,
        'retainAll',
        [coll],
      );
  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i3.Set<T> copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i4.Array toArray() => _i5.callMethod(
        this,
        'toArray',
        [],
      );
  _i3.List /*LIST InteropClass#847625641(name: List),216372994,[Instance of 'InteropRef<InteropType>']*/ <T>
      toList() => _i5.callMethod(
            this,
            'toList',
            [],
          );
}

@_i1.JS()
@_i1.staticInterop
class KeyValuePair<K, V> {
  factory KeyValuePair(
    K k,
    V v,
  ) =>
      _i5.callConstructor(
        _declaredKeyValuePair,
        [
          k,
          v,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('KeyValuePair')
external _i2.Object _declaredKeyValuePair;

extension KeyValuePair$Typings<K, V> on KeyValuePair<K, V> {
  /* #925
  source: 
    /**
     * Gets a key for a value in a Map.
     * @return {K} the key uniquely identifying a #value in a Map.
     */
    key: K; */
  /// Gets a key for a value in a Map.
  ///  @return {K} the key uniquely identifying a #value in a Map.
  K get key => _i5.getProperty(
        this,
        'key',
      );
  /* #925
  source: 
    /**
     * Gets a key for a value in a Map.
     * @return {K} the key uniquely identifying a #value in a Map.
     */
    key: K; */
  // Type InteropLocalType(K)
  set key(K value) {
    _i5.setProperty(
      this,
      'key',
      value,
    );
  }

  /* #930
  source: 
    /**
     * Gets a value in a Map.
     * @return {V} a value in a Map corresponding to a #key.
     */
    value: V; */
  /// Gets a value in a Map.
  ///  @return {V} a value in a Map corresponding to a #key.
  V get value => _i5.getProperty(
        this,
        'value',
      );
  /* #930
  source: 
    /**
     * Gets a value in a Map.
     * @return {V} a value in a Map corresponding to a #key.
     */
    value: V; */
  // Type InteropLocalType(V)
  set value(V value) {
    _i5.setProperty(
      this,
      'value',
      value,
    );
  }

  _i2.String toString$() => _i5.callMethod(
        this,
        'toString',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class IMapIterator<K, T> {}

extension IMapIterator$Typings<K, T> on IMapIterator<K, T> {
  /* #939
  source: 
    /** @hidden */
    iterator: IMapIterator<K, T>; */
  /// @hidden
  _i3.IMapIterator<K, T> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #939
  source: 
    /** @hidden */
    iterator: IMapIterator<K, T>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.IMapIterator<K, T> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  /* #959
  source: 
    /** @hidden */
    readonly key: K; */
  K get key => _i5.getProperty(
        this,
        'key',
      );
  /* #961
  source: 
    /** @hidden */
    readonly value: T; */
  T get value => _i5.getProperty(
        this,
        'value',
      );
  /* #963
  source: 
    /** @hidden */
    readonly count: number; */
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  _i2.bool next() => _i5.callMethod(
        this,
        'next',
        [],
      );
  _i2.bool hasNext() => _i5.callMethod(
        this,
        'hasNext',
        [],
      );
  _i3.KeyValuePair<K, T>? first() => _i5.callMethod(
        this,
        'first',
        [],
      );
  void reset() {
    _i5.callMethod(
      this,
      'reset',
      [],
    );
  }

  _i2.bool any(_i2.bool Function(_i3.KeyValuePair<K, T>) pred) =>
      _i5.callMethod(
        this,
        'any',
        [_i5.allowInterop(pred)],
      );
  _i2.bool all(_i2.bool Function(_i3.KeyValuePair<K, T>) pred) =>
      _i5.callMethod(
        this,
        'all',
        [_i5.allowInterop(pred)],
      );
  _i3.IMapIterator<K, T> each(void Function(_i3.KeyValuePair<K, T>) func) =>
      _i5.callMethod(
        this,
        'each',
        [_i5.allowInterop(func)],
      );
  _i3.Iterator<S> map<S>(S Function(_i3.KeyValuePair<K, T>) func) =>
      _i5.callMethod(
        this,
        'map',
        [_i5.allowInterop(func)],
      );
  _i3.Iterator<_i3.KeyValuePair<K, T>> filter(
          _i2.bool Function(_i3.KeyValuePair<K, T>) pred) =>
      _i5.callMethod(
        this,
        'filter',
        [_i5.allowInterop(pred)],
      );
}

@_i1.JS()
@_i1.staticInterop
class Map<K, V> {
  factory Map([_i2.Object? coll]) => _i5.callConstructor(
        _declaredMap,
        [coll ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Map')
external _i2.Object _declaredMap;

extension Map$Typings<K, V> on Map<K, V> {
  /* #1206
  source: 
    /**
     * This read-only property is the number of associations in the Map.
     */
    get count(): number; */
  /// This read-only property is the number of associations in the Map.
  _i2.num get count => _i5.getProperty(
        this,
        'count',
      );
  /* #1206
  source: 
    /**
     * This read-only property is the number of associations in the Map.
     */
    get count(): number; */
  // Type InteropStaticType.number
  set count(_i2.num value) {
    _i5.setProperty(
      this,
      'count',
      value,
    );
  }

  /* #1210
  source: 
    /**
     * This read-only property is the number of associations in the Map.
     */
    get size(): number; */
  /// This read-only property is the number of associations in the Map.
  _i2.num get size => _i5.getProperty(
        this,
        'size',
      );
  /* #1210
  source: 
    /**
     * This read-only property is the number of associations in the Map.
     */
    get size(): number; */
  // Type InteropStaticType.number
  set size(_i2.num value) {
    _i5.setProperty(
      this,
      'size',
      value,
    );
  }

  /* #1221
  source: 
    /**
     * Gets an object that you can use for iterating over the key-value pairs of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iterator;
     *   while (it.next()) {
     *     console.log("the key: " + it.key + " has value: " + it.value);
     *   }
     * ```
     */
    get iterator(): IMapIterator<K, V>; */
  /// Gets an object that you can use for iterating over the key-value pairs of a Map.
  /// Typical usage:
  /// ```js
  ///   var it = aMap.iterator;
  ///   while (it.next()) {
  ///     console.log("the key: " + it.key + " has value: " + it.value);
  ///   }
  /// ```
  _i3.IMapIterator<K, V> get iterator => _i5.getProperty(
        this,
        'iterator',
      );
  /* #1221
  source: 
    /**
     * Gets an object that you can use for iterating over the key-value pairs of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iterator;
     *   while (it.next()) {
     *     console.log("the key: " + it.key + " has value: " + it.value);
     *   }
     * ```
     */
    get iterator(): IMapIterator<K, V>; */
  // Type Instance of 'InteropInterface'
  set iterator(_i3.IMapIterator<K, V> value) {
    _i5.setProperty(
      this,
      'iterator',
      value,
    );
  }

  /* #1233
  source: 
    /**
     * Gets an object that you can use for iterating over the keys of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iteratorKeys;
     *   while (it.next()) {
     *     console.log("key: " + it.value);
     *   }
     * ```
     * @since 1.4
     */
    get iteratorKeys(): Iterator<K>; */
  /// Gets an object that you can use for iterating over the keys of a Map.
  /// Typical usage:
  /// ```js
  ///   var it = aMap.iteratorKeys;
  ///   while (it.next()) {
  ///     console.log("key: " + it.value);
  ///   }
  /// ```
  _i3.Iterator<K> get iteratorKeys => _i5.getProperty(
        this,
        'iteratorKeys',
      );
  /* #1233
  source: 
    /**
     * Gets an object that you can use for iterating over the keys of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iteratorKeys;
     *   while (it.next()) {
     *     console.log("key: " + it.value);
     *   }
     * ```
     * @since 1.4
     */
    get iteratorKeys(): Iterator<K>; */
  // Type Instance of 'InteropInterface'
  set iteratorKeys(_i3.Iterator<K> value) {
    _i5.setProperty(
      this,
      'iteratorKeys',
      value,
    );
  }

  /* #1245
  source: 
    /**
     * Gets an object that you can use for iterating over the values of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iteratorValues;
     *   while (it.next()) {
     *     console.log("value: " + it.value);
     *   }
     * ```
     * @since 1.4
     */
    get iteratorValues(): Iterator<V>; */
  /// Gets an object that you can use for iterating over the values of a Map.
  /// Typical usage:
  /// ```js
  ///   var it = aMap.iteratorValues;
  ///   while (it.next()) {
  ///     console.log("value: " + it.value);
  ///   }
  /// ```
  _i3.Iterator<V> get iteratorValues => _i5.getProperty(
        this,
        'iteratorValues',
      );
  /* #1245
  source: 
    /**
     * Gets an object that you can use for iterating over the values of a Map.
     * Typical usage:
     * ```js
     *   var it = aMap.iteratorValues;
     *   while (it.next()) {
     *     console.log("value: " + it.value);
     *   }
     * ```
     * @since 1.4
     */
    get iteratorValues(): Iterator<V>; */
  // Type Instance of 'InteropInterface'
  set iteratorValues(_i3.Iterator<V> value) {
    _i5.setProperty(
      this,
      'iteratorValues',
      value,
    );
  }

  _i2.String toString$() => _i5.callMethod(
        this,
        'toString',
        [],
      );
  _i3.Map<K, V> add(
    K key,
    V val,
  ) =>
      _i5.callMethod(
        this,
        'add',
        [
          key,
          val,
        ],
      );
  _i3.Map<K, V> set(
    K key,
    V val,
  ) =>
      _i5.callMethod(
        this,
        'set',
        [
          key,
          val,
        ],
      );
  _i3.Map<K, V> addAll(_i2.Object coll) => _i5.callMethod(
        this,
        'addAll',
        [coll],
      );
  _i3.KeyValuePair<K, V> first() => _i5.callMethod(
        this,
        'first',
        [],
      );
  _i2.bool any(_i2.bool Function(_i3.KeyValuePair<K, V>) pred) =>
      _i5.callMethod(
        this,
        'any',
        [_i5.allowInterop(pred)],
      );
  _i2.bool all(_i2.bool Function(_i3.KeyValuePair<K, V>) pred) =>
      _i5.callMethod(
        this,
        'all',
        [_i5.allowInterop(pred)],
      );
  _i3.Map<K, V> each(void Function(_i3.KeyValuePair<K, V>) func) =>
      _i5.callMethod(
        this,
        'each',
        [_i5.allowInterop(func)],
      );
  _i3.Map<K, S> map<S>(S Function(_i3.KeyValuePair<K, V>) func) =>
      _i5.callMethod(
        this,
        'map',
        [_i5.allowInterop(func)],
      );
  _i3.Map<K, V> filter(_i2.bool Function(_i3.KeyValuePair<K, V>) pred) =>
      _i5.callMethod(
        this,
        'filter',
        [_i5.allowInterop(pred)],
      );
  _i2.bool contains(K key) => _i5.callMethod(
        this,
        'contains',
        [key],
      );
  _i2.bool has(K key) => _i5.callMethod(
        this,
        'has',
        [key],
      );
  V? getValue(K key) => _i5.callMethod(
        this,
        'getValue',
        [key],
      );
  V? get(K key) => _i5.callMethod(
        this,
        'get',
        [key],
      );
  _i2.bool remove(K key) => _i5.callMethod(
        this,
        'remove',
        [key],
      );
  _i2.bool delete(K key) => _i5.callMethod(
        this,
        'delete',
        [key],
      );
  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i3.Map<K, V> copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i4.Array toArray() => _i5.callMethod(
        this,
        'toArray',
        [],
      );
  _i3.Set<K> toKeySet() => _i5.callMethod(
        this,
        'toKeySet',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Point {
  factory Point([
    _i2.num? x,
    _i2.num? y,
  ]) =>
      _i5.callConstructor(
        _declaredPoint,
        [
          x ?? _i4.undefined,
          y ?? _i4.undefined,
        ],
      );

  static _i3.Point parse(_i2.String str) => _i5.callMethod(
        _declaredPoint,
        'parse',
        [str],
      );
  static _i2.String stringify(_i3.Point val) => _i5.callMethod(
        _declaredPoint,
        'stringify',
        [val],
      );
  static _i2.num compareWithLineSegment(
    _i2.num a1x,
    _i2.num a1y,
    _i2.num a2x,
    _i2.num a2y,
    _i2.num px,
    _i2.num py,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'compareWithLineSegment',
        [
          a1x,
          a1y,
          a2x,
          a2y,
          px,
          py,
        ],
      );
  static _i2.bool intersectingLineSegments(
    _i2.num a1x,
    _i2.num a1y,
    _i2.num a2x,
    _i2.num a2y,
    _i2.num b1x,
    _i2.num b1y,
    _i2.num b2x,
    _i2.num b2y,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'intersectingLineSegments',
        [
          a1x,
          a1y,
          a2x,
          a2y,
          b1x,
          b1y,
          b2x,
          b2y,
        ],
      );
  static _i2.num distanceLineSegmentSquared(
    _i2.num px,
    _i2.num py,
    _i2.num ax,
    _i2.num ay,
    _i2.num bx,
    _i2.num by,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'distanceLineSegmentSquared',
        [
          px,
          py,
          ax,
          ay,
          bx,
          by,
        ],
      );
  static _i2.num distanceSquared(
    _i2.num px,
    _i2.num py,
    _i2.num qx,
    _i2.num qy,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'distanceSquared',
        [
          px,
          py,
          qx,
          qy,
        ],
      );
  static _i2.num direction(
    _i2.num px,
    _i2.num py,
    _i2.num qx,
    _i2.num qy,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'direction',
        [
          px,
          py,
          qx,
          qy,
        ],
      );
  static _i3.Point alloc() => _i5.callMethod(
        _declaredPoint,
        'alloc',
        [],
      );
  static _i3.Point allocAt(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        _declaredPoint,
        'allocAt',
        [
          x,
          y,
        ],
      );
  static void free(_i3.Point temp) {
    _i5.callMethod(
      _declaredPoint,
      'free',
      [temp],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Point')
external _i2.Object _declaredPoint;

extension Point$Typings on Point {
  /* #1561
  source: 
    /**
     * Gets or sets the x value of the Point.
     */
    get x(): number; */
  /// Gets or sets the x value of the Point.
  _i2.num get x => _i5.getProperty(
        this,
        'x',
      );
  /* #1561
  source: 
    /**
     * Gets or sets the x value of the Point.
     */
    get x(): number; */
  // Type InteropStaticType.number
  set x(_i2.num value) {
    _i5.setProperty(
      this,
      'x',
      value,
    );
  }

  /* #1566
  source: 
    /**
     * Gets or sets the y value of the Point.
     */
    get y(): number; */
  /// Gets or sets the y value of the Point.
  _i2.num get y => _i5.getProperty(
        this,
        'y',
      );
  /* #1566
  source: 
    /**
     * Gets or sets the y value of the Point.
     */
    get y(): number; */
  // Type InteropStaticType.number
  set y(_i2.num value) {
    _i5.setProperty(
      this,
      'y',
      value,
    );
  }

  _i3.Point setTo(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'setTo',
        [
          x,
          y,
        ],
      );
  _i3.Point set(_i3.Point p) => _i5.callMethod(
        this,
        'set',
        [p],
      );
  _i3.Point copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equals(_i3.Point p) => _i5.callMethod(
        this,
        'equals',
        [p],
      );
  _i2.bool equalTo(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'equalTo',
        [
          x,
          y,
        ],
      );
  _i2.bool equalsApprox(_i3.Point p) => _i5.callMethod(
        this,
        'equalsApprox',
        [p],
      );
  _i3.Point add(_i3.Point p) => _i5.callMethod(
        this,
        'add',
        [p],
      );
  _i3.Point subtract(_i3.Point p) => _i5.callMethod(
        this,
        'subtract',
        [p],
      );
  _i3.Point offset(
    _i2.num dx,
    _i2.num dy,
  ) =>
      _i5.callMethod(
        this,
        'offset',
        [
          dx,
          dy,
        ],
      );
  _i3.Point rotate(_i2.num angle) => _i5.callMethod(
        this,
        'rotate',
        [angle],
      );
  _i3.Point scale(
    _i2.num sx,
    _i2.num sy,
  ) =>
      _i5.callMethod(
        this,
        'scale',
        [
          sx,
          sy,
        ],
      );
  _i2.num distanceSquaredPoint(_i3.Point p) => _i5.callMethod(
        this,
        'distanceSquaredPoint',
        [p],
      );
  _i2.num distanceSquared(
    _i2.num px,
    _i2.num py,
  ) =>
      _i5.callMethod(
        this,
        'distanceSquared',
        [
          px,
          py,
        ],
      );
  _i3.Point normalize() => _i5.callMethod(
        this,
        'normalize',
        [],
      );
  _i2.num directionPoint(_i3.Point p) => _i5.callMethod(
        this,
        'directionPoint',
        [p],
      );
  _i2.num direction(
    _i2.num px,
    _i2.num py,
  ) =>
      _i5.callMethod(
        this,
        'direction',
        [
          px,
          py,
        ],
      );
  _i2.num compareWithLineSegmentPoint(
    _i3.Point p,
    _i3.Point q,
  ) =>
      _i5.callMethod(
        this,
        'compareWithLineSegmentPoint',
        [
          p,
          q,
        ],
      );
  _i3.Point projectOntoLineSegment(
    _i2.num px,
    _i2.num py,
    _i2.num qx,
    _i2.num qy,
  ) =>
      _i5.callMethod(
        this,
        'projectOntoLineSegment',
        [
          px,
          py,
          qx,
          qy,
        ],
      );
  _i3.Point projectOntoLineSegmentPoint(
    _i3.Point p,
    _i3.Point q,
  ) =>
      _i5.callMethod(
        this,
        'projectOntoLineSegmentPoint',
        [
          p,
          q,
        ],
      );
  _i3.Point snapToGrid(
    _i2.num originx,
    _i2.num originy,
    _i2.num cellwidth,
    _i2.num cellheight,
  ) =>
      _i5.callMethod(
        this,
        'snapToGrid',
        [
          originx,
          originy,
          cellwidth,
          cellheight,
        ],
      );
  _i3.Point snapToGridPoint(
    _i3.Point origin,
    _i3.Size cellsize,
  ) =>
      _i5.callMethod(
        this,
        'snapToGridPoint',
        [
          origin,
          cellsize,
        ],
      );
  _i3.Point setRectSpot(
    _i3.Rect r,
    _i3.Spot spot,
  ) =>
      _i5.callMethod(
        this,
        'setRectSpot',
        [
          r,
          spot,
        ],
      );
  _i3.Point setSpot(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
    _i3.Spot spot,
  ) =>
      _i5.callMethod(
        this,
        'setSpot',
        [
          x,
          y,
          w,
          h,
          spot,
        ],
      );
  _i2.bool isReal() => _i5.callMethod(
        this,
        'isReal',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Size {
  factory Size([
    _i2.num? w,
    _i2.num? h,
  ]) =>
      _i5.callConstructor(
        _declaredSize,
        [
          w ?? _i4.undefined,
          h ?? _i4.undefined,
        ],
      );

  static _i3.Size parse(_i2.String str) => _i5.callMethod(
        _declaredSize,
        'parse',
        [str],
      );
  static _i2.String stringify(_i3.Size val) => _i5.callMethod(
        _declaredSize,
        'stringify',
        [val],
      );
  static _i3.Size alloc() => _i5.callMethod(
        _declaredSize,
        'alloc',
        [],
      );
  static void free(_i3.Size temp) {
    _i5.callMethod(
      _declaredSize,
      'free',
      [temp],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Size')
external _i2.Object _declaredSize;

extension Size$Typings on Size {
  /* #1695
  source: 
    /**
     * Gets or sets the width value of the Size.
     * The value must not be negative.
     */
    get width(): number; */
  /// Gets or sets the width value of the Size.
  /// The value must not be negative.
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #1695
  source: 
    /**
     * Gets or sets the width value of the Size.
     * The value must not be negative.
     */
    get width(): number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #1701
  source: 
    /**
     * Gets or sets the height value of the Size.
     * The value must not be negative.
     */
    get height(): number; */
  /// Gets or sets the height value of the Size.
  /// The value must not be negative.
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #1701
  source: 
    /**
     * Gets or sets the height value of the Size.
     * The value must not be negative.
     */
    get height(): number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  _i3.Size setTo(
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'setTo',
        [
          w,
          h,
        ],
      );
  _i3.Size set(_i3.Size s) => _i5.callMethod(
        this,
        'set',
        [s],
      );
  _i3.Size copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equals(_i3.Size s) => _i5.callMethod(
        this,
        'equals',
        [s],
      );
  _i2.bool equalTo(
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'equalTo',
        [
          w,
          h,
        ],
      );
  _i2.bool equalsApprox(_i3.Size s) => _i5.callMethod(
        this,
        'equalsApprox',
        [s],
      );
  _i3.Size inflate(
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'inflate',
        [
          w,
          h,
        ],
      );
  _i2.bool isReal() => _i5.callMethod(
        this,
        'isReal',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Rect {
  factory Rect([
    _i2.Object? x,
    _i2.Object? y,
    _i2.num? w,
    _i2.num? h,
  ]) =>
      _i5.callConstructor(
        _declaredRect,
        [
          x ?? _i4.undefined,
          y ?? _i4.undefined,
          w ?? _i4.undefined,
          h ?? _i4.undefined,
        ],
      );

  static _i3.Rect parse(_i2.String str) => _i5.callMethod(
        _declaredRect,
        'parse',
        [str],
      );
  static _i2.String stringify(_i3.Rect val) => _i5.callMethod(
        _declaredRect,
        'stringify',
        [val],
      );
  static _i2.bool contains(
    _i2.num rx,
    _i2.num ry,
    _i2.num rw,
    _i2.num rh,
    _i2.num x,
    _i2.num y, [
    _i2.num? w,
    _i2.num? h,
  ]) =>
      _i5.callMethod(
        _declaredRect,
        'contains',
        [
          rx,
          ry,
          rw,
          rh,
          x,
          y,
          w ?? _i4.undefined,
          h ?? _i4.undefined,
        ],
      );
  static _i2.bool intersects(
    _i2.num rx,
    _i2.num ry,
    _i2.num rw,
    _i2.num rh,
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        _declaredRect,
        'intersects',
        [
          rx,
          ry,
          rw,
          rh,
          x,
          y,
          w,
          h,
        ],
      );
  static _i2.bool intersectsLineSegment(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
    _i2.num p1x,
    _i2.num p1y,
    _i2.num p2x,
    _i2.num p2y,
  ) =>
      _i5.callMethod(
        _declaredRect,
        'intersectsLineSegment',
        [
          x,
          y,
          w,
          h,
          p1x,
          p1y,
          p2x,
          p2y,
        ],
      );
  static _i3.Rect alloc() => _i5.callMethod(
        _declaredRect,
        'alloc',
        [],
      );
  static _i3.Rect allocAt(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        _declaredRect,
        'allocAt',
        [
          x,
          y,
          w,
          h,
        ],
      );
  static void free(_i3.Rect temp) {
    _i5.callMethod(
      _declaredRect,
      'free',
      [temp],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Rect')
external _i2.Object _declaredRect;

extension Rect$Typings on Rect {
  /* #2032
  source: 
    /**
     * Gets or sets the top-left x coordinate of the Rect.
     */
    get x(): number; */
  /// Gets or sets the top-left x coordinate of the Rect.
  _i2.num get x => _i5.getProperty(
        this,
        'x',
      );
  /* #2032
  source: 
    /**
     * Gets or sets the top-left x coordinate of the Rect.
     */
    get x(): number; */
  // Type InteropStaticType.number
  set x(_i2.num value) {
    _i5.setProperty(
      this,
      'x',
      value,
    );
  }

  /* #2037
  source: 
    /**
     * Gets or sets the top-left y coordinate of the Rect.
     */
    get y(): number; */
  /// Gets or sets the top-left y coordinate of the Rect.
  _i2.num get y => _i5.getProperty(
        this,
        'y',
      );
  /* #2037
  source: 
    /**
     * Gets or sets the top-left y coordinate of the Rect.
     */
    get y(): number; */
  // Type InteropStaticType.number
  set y(_i2.num value) {
    _i5.setProperty(
      this,
      'y',
      value,
    );
  }

  /* #2043
  source: 
    /**
     * Gets or sets the width of the Rect.
     * The value must not be negative.
     */
    get width(): number; */
  /// Gets or sets the width of the Rect.
  /// The value must not be negative.
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #2043
  source: 
    /**
     * Gets or sets the width of the Rect.
     * The value must not be negative.
     */
    get width(): number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #2049
  source: 
    /**
     * Gets or sets the height of the Rect.
     * The value must not be negative.
     */
    get height(): number; */
  /// Gets or sets the height of the Rect.
  /// The value must not be negative.
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #2049
  source: 
    /**
     * Gets or sets the height of the Rect.
     * The value must not be negative.
     */
    get height(): number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  /* #2055
  source: 
    /**
     * Gets or sets the leftmost value of the Rect.
     * This is the same as the X value.
     */
    get left(): number; */
  /// Gets or sets the leftmost value of the Rect.
  /// This is the same as the X value.
  _i2.num get left => _i5.getProperty(
        this,
        'left',
      );
  /* #2055
  source: 
    /**
     * Gets or sets the leftmost value of the Rect.
     * This is the same as the X value.
     */
    get left(): number; */
  // Type InteropStaticType.number
  set left(_i2.num value) {
    _i5.setProperty(
      this,
      'left',
      value,
    );
  }

  /* #2061
  source: 
    /**
     * Gets or sets the topmost value of the Rect.
     * This is the same as the Y value.
     */
    get top(): number; */
  /// Gets or sets the topmost value of the Rect.
  /// This is the same as the Y value.
  _i2.num get top => _i5.getProperty(
        this,
        'top',
      );
  /* #2061
  source: 
    /**
     * Gets or sets the topmost value of the Rect.
     * This is the same as the Y value.
     */
    get top(): number; */
  // Type InteropStaticType.number
  set top(_i2.num value) {
    _i5.setProperty(
      this,
      'top',
      value,
    );
  }

  /* #2067
  source: 
    /**
     * Gets or sets the x-axis value of the right of the Rect.
     * This is equal to the sum of the x value and the width.
     */
    get right(): number; */
  /// Gets or sets the x-axis value of the right of the Rect.
  /// This is equal to the sum of the x value and the width.
  _i2.num get right => _i5.getProperty(
        this,
        'right',
      );
  /* #2067
  source: 
    /**
     * Gets or sets the x-axis value of the right of the Rect.
     * This is equal to the sum of the x value and the width.
     */
    get right(): number; */
  // Type InteropStaticType.number
  set right(_i2.num value) {
    _i5.setProperty(
      this,
      'right',
      value,
    );
  }

  /* #2073
  source: 
    /**
     * Gets or sets the y-axis value of the bottom of the Rect.
     * This is equal to the sum of the y value and the height.
     */
    get bottom(): number; */
  /// Gets or sets the y-axis value of the bottom of the Rect.
  /// This is equal to the sum of the y value and the height.
  _i2.num get bottom => _i5.getProperty(
        this,
        'bottom',
      );
  /* #2073
  source: 
    /**
     * Gets or sets the y-axis value of the bottom of the Rect.
     * This is equal to the sum of the y value and the height.
     */
    get bottom(): number; */
  // Type InteropStaticType.number
  set bottom(_i2.num value) {
    _i5.setProperty(
      this,
      'bottom',
      value,
    );
  }

  /* #2078
  source: 
    /**
     * Gets or sets the x- and y-axis position of the Rect as a Point.
     */
    get position(): Point; */
  /// Gets or sets the x- and y-axis position of the Rect as a Point.
  _i3.Point get position => _i5.getProperty(
        this,
        'position',
      );
  /* #2078
  source: 
    /**
     * Gets or sets the x- and y-axis position of the Rect as a Point.
     */
    get position(): Point; */
  // Type Instance of 'InteropInterface'
  set position(_i3.Point value) {
    _i5.setProperty(
      this,
      'position',
      value,
    );
  }

  /* #2083
  source: 
    /**
     * Gets or sets the width and height of the Rect as a Size.
     */
    get size(): Size; */
  /// Gets or sets the width and height of the Rect as a Size.
  _i3.Size get size => _i5.getProperty(
        this,
        'size',
      );
  /* #2083
  source: 
    /**
     * Gets or sets the width and height of the Rect as a Size.
     */
    get size(): Size; */
  // Type Instance of 'InteropInterface'
  set size(_i3.Size value) {
    _i5.setProperty(
      this,
      'size',
      value,
    );
  }

  /* #2089
  source: 
    /**
     * Gets or sets the Point at the center of this Rect.
     * Setting this property just shifts the X and Y values.
     */
    get center(): Point; */
  /// Gets or sets the Point at the center of this Rect.
  /// Setting this property just shifts the X and Y values.
  _i3.Point get center => _i5.getProperty(
        this,
        'center',
      );
  /* #2089
  source: 
    /**
     * Gets or sets the Point at the center of this Rect.
     * Setting this property just shifts the X and Y values.
     */
    get center(): Point; */
  // Type Instance of 'InteropInterface'
  set center(_i3.Point value) {
    _i5.setProperty(
      this,
      'center',
      value,
    );
  }

  /* #2094
  source: 
    /**
     * Gets or sets the horizontal center X coordinate of the Rect.
     */
    get centerX(): number; */
  /// Gets or sets the horizontal center X coordinate of the Rect.
  _i2.num get centerX => _i5.getProperty(
        this,
        'centerX',
      );
  /* #2094
  source: 
    /**
     * Gets or sets the horizontal center X coordinate of the Rect.
     */
    get centerX(): number; */
  // Type InteropStaticType.number
  set centerX(_i2.num value) {
    _i5.setProperty(
      this,
      'centerX',
      value,
    );
  }

  /* #2099
  source: 
    /**
     * Gets or sets the vertical center Y coordinate of the Rect.
     */
    get centerY(): number; */
  /// Gets or sets the vertical center Y coordinate of the Rect.
  _i2.num get centerY => _i5.getProperty(
        this,
        'centerY',
      );
  /* #2099
  source: 
    /**
     * Gets or sets the vertical center Y coordinate of the Rect.
     */
    get centerY(): number; */
  // Type InteropStaticType.number
  set centerY(_i2.num value) {
    _i5.setProperty(
      this,
      'centerY',
      value,
    );
  }

  _i3.Rect setTo(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'setTo',
        [
          x,
          y,
          w,
          h,
        ],
      );
  _i3.Rect set(_i3.Rect r) => _i5.callMethod(
        this,
        'set',
        [r],
      );
  _i3.Rect setPoint(_i3.Point p) => _i5.callMethod(
        this,
        'setPoint',
        [p],
      );
  _i3.Rect setSize(_i3.Size s) => _i5.callMethod(
        this,
        'setSize',
        [s],
      );
  _i3.Rect copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equals(_i3.Rect r) => _i5.callMethod(
        this,
        'equals',
        [r],
      );
  _i2.bool equalTo(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'equalTo',
        [
          x,
          y,
          w,
          h,
        ],
      );
  _i2.bool equalsApprox(_i3.Rect r) => _i5.callMethod(
        this,
        'equalsApprox',
        [r],
      );
  _i2.bool containsPoint(_i3.Point p) => _i5.callMethod(
        this,
        'containsPoint',
        [p],
      );
  _i2.bool containsRect(_i3.Rect r) => _i5.callMethod(
        this,
        'containsRect',
        [r],
      );
  _i2.bool contains(
    _i2.num x,
    _i2.num y, [
    _i2.num? w,
    _i2.num? h,
  ]) =>
      _i5.callMethod(
        this,
        'contains',
        [
          x,
          y,
          w ?? _i4.undefined,
          h ?? _i4.undefined,
        ],
      );
  _i3.Rect offset(
    _i2.num dx,
    _i2.num dy,
  ) =>
      _i5.callMethod(
        this,
        'offset',
        [
          dx,
          dy,
        ],
      );
  _i3.Rect inflate(
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'inflate',
        [
          w,
          h,
        ],
      );
  _i3.Rect addMargin(_i3.Margin m) => _i5.callMethod(
        this,
        'addMargin',
        [m],
      );
  _i3.Rect subtractMargin(_i3.Margin m) => _i5.callMethod(
        this,
        'subtractMargin',
        [m],
      );
  _i3.Rect grow(
    _i2.num t,
    _i2.num r,
    _i2.num b,
    _i2.num l,
  ) =>
      _i5.callMethod(
        this,
        'grow',
        [
          t,
          r,
          b,
          l,
        ],
      );
  _i3.Rect intersectRect(_i3.Rect r) => _i5.callMethod(
        this,
        'intersectRect',
        [r],
      );
  _i3.Rect intersect(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'intersect',
        [
          x,
          y,
          w,
          h,
        ],
      );
  _i2.bool intersectsRect(_i3.Rect r) => _i5.callMethod(
        this,
        'intersectsRect',
        [r],
      );
  _i2.bool intersects(
    _i2.num x,
    _i2.num y,
    _i2.num w,
    _i2.num h,
  ) =>
      _i5.callMethod(
        this,
        'intersects',
        [
          x,
          y,
          w,
          h,
        ],
      );
  _i3.Rect unionPoint(_i3.Point p) => _i5.callMethod(
        this,
        'unionPoint',
        [p],
      );
  _i3.Rect unionRect(_i3.Rect r) => _i5.callMethod(
        this,
        'unionRect',
        [r],
      );
  _i3.Rect union(
    _i2.num x,
    _i2.num y, [
    _i2.num? w,
    _i2.num? h,
  ]) =>
      _i5.callMethod(
        this,
        'union',
        [
          x,
          y,
          w ?? _i4.undefined,
          h ?? _i4.undefined,
        ],
      );
  _i3.Rect setSpot(
    _i2.num x,
    _i2.num y,
    _i3.Spot spot,
  ) =>
      _i5.callMethod(
        this,
        'setSpot',
        [
          x,
          y,
          spot,
        ],
      );
  _i2.bool isReal() => _i5.callMethod(
        this,
        'isReal',
        [],
      );
  _i2.bool isEmpty() => _i5.callMethod(
        this,
        'isEmpty',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Margin {
  factory Margin([
    _i2.num? t,
    _i2.num? r,
    _i2.num? b,
    _i2.num? l,
  ]) =>
      _i5.callConstructor(
        _declaredMargin,
        [
          t ?? _i4.undefined,
          r ?? _i4.undefined,
          b ?? _i4.undefined,
          l ?? _i4.undefined,
        ],
      );

  static _i3.Margin parse(_i2.String str) => _i5.callMethod(
        _declaredMargin,
        'parse',
        [str],
      );
  static _i2.String stringify(_i3.Margin val) => _i5.callMethod(
        _declaredMargin,
        'stringify',
        [val],
      );
  static _i3.Margin alloc() => _i5.callMethod(
        _declaredMargin,
        'alloc',
        [],
      );
  static void free(_i3.Margin temp) {
    _i5.callMethod(
      _declaredMargin,
      'free',
      [temp],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Margin')
external _i2.Object _declaredMargin;

extension Margin$Typings on Margin {
  /* #2246
  source: 
    /**
     * Gets or sets the top value of this margin. Default is 0.
     */
    get top(): number; */
  /// Gets or sets the top value of this margin. Default is 0.
  _i2.num get top => _i5.getProperty(
        this,
        'top',
      );
  /* #2246
  source: 
    /**
     * Gets or sets the top value of this margin. Default is 0.
     */
    get top(): number; */
  // Type InteropStaticType.number
  set top(_i2.num value) {
    _i5.setProperty(
      this,
      'top',
      value,
    );
  }

  /* #2251
  source: 
    /**
     * Gets or sets the right value of this margin. Default is 0.
     */
    get right(): number; */
  /// Gets or sets the right value of this margin. Default is 0.
  _i2.num get right => _i5.getProperty(
        this,
        'right',
      );
  /* #2251
  source: 
    /**
     * Gets or sets the right value of this margin. Default is 0.
     */
    get right(): number; */
  // Type InteropStaticType.number
  set right(_i2.num value) {
    _i5.setProperty(
      this,
      'right',
      value,
    );
  }

  /* #2256
  source: 
    /**
     * Gets or sets the bottom value of this margin. Default is 0.
     */
    get bottom(): number; */
  /// Gets or sets the bottom value of this margin. Default is 0.
  _i2.num get bottom => _i5.getProperty(
        this,
        'bottom',
      );
  /* #2256
  source: 
    /**
     * Gets or sets the bottom value of this margin. Default is 0.
     */
    get bottom(): number; */
  // Type InteropStaticType.number
  set bottom(_i2.num value) {
    _i5.setProperty(
      this,
      'bottom',
      value,
    );
  }

  /* #2261
  source: 
    /**
     * Gets or sets the left value of this margin. Default is 0.
     */
    get left(): number; */
  /// Gets or sets the left value of this margin. Default is 0.
  _i2.num get left => _i5.getProperty(
        this,
        'left',
      );
  /* #2261
  source: 
    /**
     * Gets or sets the left value of this margin. Default is 0.
     */
    get left(): number; */
  // Type InteropStaticType.number
  set left(_i2.num value) {
    _i5.setProperty(
      this,
      'left',
      value,
    );
  }

  _i3.Margin setTo(
    _i2.num t,
    _i2.num r,
    _i2.num b,
    _i2.num l,
  ) =>
      _i5.callMethod(
        this,
        'setTo',
        [
          t,
          r,
          b,
          l,
        ],
      );
  _i3.Margin set(_i3.Margin m) => _i5.callMethod(
        this,
        'set',
        [m],
      );
  _i3.Margin copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equals(_i3.Margin m) => _i5.callMethod(
        this,
        'equals',
        [m],
      );
  _i2.bool equalTo(
    _i2.num t,
    _i2.num r,
    _i2.num b,
    _i2.num l,
  ) =>
      _i5.callMethod(
        this,
        'equalTo',
        [
          t,
          r,
          b,
          l,
        ],
      );
  _i2.bool equalsApprox(_i3.Margin m) => _i5.callMethod(
        this,
        'equalsApprox',
        [m],
      );
  _i2.bool isReal() => _i5.callMethod(
        this,
        'isReal',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Spot {
  factory Spot([
    _i2.num? x,
    _i2.num? y,
    _i2.num? offx,
    _i2.num? offy,
  ]) =>
      _i5.callConstructor(
        _declaredSpot,
        [
          x ?? _i4.undefined,
          y ?? _i4.undefined,
          offx ?? _i4.undefined,
          offy ?? _i4.undefined,
        ],
      );

  /* #2448
  source: 
    /**
     * Use this Spot value to indicate no particular spot --
     * code looking for a particular point on an element will need to do their
     * own calculations to determine the desired point depending on the
     * circumstances.
     * @constant
     */
    static None: Spot; */
  /// Use this Spot value to indicate no particular spot --
  /// code looking for a particular point on an element will need to do their
  /// own calculations to determine the desired point depending on the
  /// circumstances.
  static _i3.Spot get none => _i5.getProperty(
        _declaredSpot,
        'None',
      );
  /* #2448
  source: 
    /**
     * Use this Spot value to indicate no particular spot --
     * code looking for a particular point on an element will need to do their
     * own calculations to determine the desired point depending on the
     * circumstances.
     * @constant
     */
    static None: Spot; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'None',
      value,
    );
  }

  /* #2453
  source: 
    /**
     * Use this value to indicate that the real spot value is inherited from elsewhere.
     * @constant
     */
    static Default: Spot; */
  /// Use this value to indicate that the real spot value is inherited from elsewhere.
  static _i3.Spot get default$ => _i5.getProperty(
        _declaredSpot,
        'Default',
      );
  /* #2453
  source: 
    /**
     * Use this value to indicate that the real spot value is inherited from elsewhere.
     * @constant
     */
    static Default: Spot; */
  // Type Instance of 'InteropInterface'
  static set default$(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Default',
      value,
    );
  }

  /* #2458
  source: 
    /**
     * The specific point at the top-left corner of the bounding rectangle.
     * @constant
     */
    static TopLeft: Spot; */
  /// The specific point at the top-left corner of the bounding rectangle.
  static _i3.Spot get topLeft => _i5.getProperty(
        _declaredSpot,
        'TopLeft',
      );
  /* #2458
  source: 
    /**
     * The specific point at the top-left corner of the bounding rectangle.
     * @constant
     */
    static TopLeft: Spot; */
  // Type Instance of 'InteropInterface'
  static set topLeft(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopLeft',
      value,
    );
  }

  /* #2463
  source: 
    /**
     * The specific point at the center of the top side of the bounding rectangle.
     * @constant
     */
    static TopCenter: Spot; */
  /// The specific point at the center of the top side of the bounding rectangle.
  static _i3.Spot get topCenter => _i5.getProperty(
        _declaredSpot,
        'TopCenter',
      );
  /* #2463
  source: 
    /**
     * The specific point at the center of the top side of the bounding rectangle.
     * @constant
     */
    static TopCenter: Spot; */
  // Type Instance of 'InteropInterface'
  static set topCenter(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopCenter',
      value,
    );
  }

  /* #2468
  source: 
    /**
     * The specific point at the top-right corner of the bounding rectangle.
     * @constant
     */
    static TopRight: Spot; */
  /// The specific point at the top-right corner of the bounding rectangle.
  static _i3.Spot get topRight => _i5.getProperty(
        _declaredSpot,
        'TopRight',
      );
  /* #2468
  source: 
    /**
     * The specific point at the top-right corner of the bounding rectangle.
     * @constant
     */
    static TopRight: Spot; */
  // Type Instance of 'InteropInterface'
  static set topRight(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopRight',
      value,
    );
  }

  /* #2473
  source: 
    /**
     * The specific point at the middle of the left side of bounding rectangle.
     * @constant
     */
    static LeftCenter: Spot; */
  /// The specific point at the middle of the left side of bounding rectangle.
  static _i3.Spot get leftCenter => _i5.getProperty(
        _declaredSpot,
        'LeftCenter',
      );
  /* #2473
  source: 
    /**
     * The specific point at the middle of the left side of bounding rectangle.
     * @constant
     */
    static LeftCenter: Spot; */
  // Type Instance of 'InteropInterface'
  static set leftCenter(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'LeftCenter',
      value,
    );
  }

  /* #2478
  source: 
    /**
     * The specific point at the very center of the bounding rectangle.
     * @constant
     */
    static Center: Spot; */
  /// The specific point at the very center of the bounding rectangle.
  static _i3.Spot get center => _i5.getProperty(
        _declaredSpot,
        'Center',
      );
  /* #2478
  source: 
    /**
     * The specific point at the very center of the bounding rectangle.
     * @constant
     */
    static Center: Spot; */
  // Type Instance of 'InteropInterface'
  static set center(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Center',
      value,
    );
  }

  /* #2483
  source: 
    /**
     * The specific point at the middle of the right side of bounding rectangle.
     * @constant
     */
    static RightCenter: Spot; */
  /// The specific point at the middle of the right side of bounding rectangle.
  static _i3.Spot get rightCenter => _i5.getProperty(
        _declaredSpot,
        'RightCenter',
      );
  /* #2483
  source: 
    /**
     * The specific point at the middle of the right side of bounding rectangle.
     * @constant
     */
    static RightCenter: Spot; */
  // Type Instance of 'InteropInterface'
  static set rightCenter(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'RightCenter',
      value,
    );
  }

  /* #2488
  source: 
    /**
     * The specific point at the bottom-left corner of the bounding rectangle.
     * @constant
     */
    static BottomLeft: Spot; */
  /// The specific point at the bottom-left corner of the bounding rectangle.
  static _i3.Spot get bottomLeft => _i5.getProperty(
        _declaredSpot,
        'BottomLeft',
      );
  /* #2488
  source: 
    /**
     * The specific point at the bottom-left corner of the bounding rectangle.
     * @constant
     */
    static BottomLeft: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomLeft(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomLeft',
      value,
    );
  }

  /* #2493
  source: 
    /**
     * The specific point at the middle of the bottom side of bounding rectangle.
     * @constant
     */
    static BottomCenter: Spot; */
  /// The specific point at the middle of the bottom side of bounding rectangle.
  static _i3.Spot get bottomCenter => _i5.getProperty(
        _declaredSpot,
        'BottomCenter',
      );
  /* #2493
  source: 
    /**
     * The specific point at the middle of the bottom side of bounding rectangle.
     * @constant
     */
    static BottomCenter: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomCenter(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomCenter',
      value,
    );
  }

  /* #2498
  source: 
    /**
     * The specific point at the bottom-right corner of the bounding rectangle.
     * @constant
     */
    static BottomRight: Spot; */
  /// The specific point at the bottom-right corner of the bounding rectangle.
  static _i3.Spot get bottomRight => _i5.getProperty(
        _declaredSpot,
        'BottomRight',
      );
  /* #2498
  source: 
    /**
     * The specific point at the bottom-right corner of the bounding rectangle.
     * @constant
     */
    static BottomRight: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomRight(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomRight',
      value,
    );
  }

  /* #2503
  source: 
    /**
     * A synonym for Spot.TopCenter.
     * @constant
     */
    static MiddleTop: Spot; */
  /// A synonym for Spot.TopCenter.
  static _i3.Spot get middleTop => _i5.getProperty(
        _declaredSpot,
        'MiddleTop',
      );
  /* #2503
  source: 
    /**
     * A synonym for Spot.TopCenter.
     * @constant
     */
    static MiddleTop: Spot; */
  // Type Instance of 'InteropInterface'
  static set middleTop(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'MiddleTop',
      value,
    );
  }

  /* #2508
  source: 
    /**
     * A synonym for Spot.LeftCenter.
     * @constant
     */
    static MiddleLeft: Spot; */
  /// A synonym for Spot.LeftCenter.
  static _i3.Spot get middleLeft => _i5.getProperty(
        _declaredSpot,
        'MiddleLeft',
      );
  /* #2508
  source: 
    /**
     * A synonym for Spot.LeftCenter.
     * @constant
     */
    static MiddleLeft: Spot; */
  // Type Instance of 'InteropInterface'
  static set middleLeft(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'MiddleLeft',
      value,
    );
  }

  /* #2513
  source: 
    /**
     * A synonym for Spot.RightCenter.
     * @constant
     */
    static MiddleRight: Spot; */
  /// A synonym for Spot.RightCenter.
  static _i3.Spot get middleRight => _i5.getProperty(
        _declaredSpot,
        'MiddleRight',
      );
  /* #2513
  source: 
    /**
     * A synonym for Spot.RightCenter.
     * @constant
     */
    static MiddleRight: Spot; */
  // Type Instance of 'InteropInterface'
  static set middleRight(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'MiddleRight',
      value,
    );
  }

  /* #2518
  source: 
    /**
     * A synonym for Spot.BottomCenter.
     * @constant
     */
    static MiddleBottom: Spot; */
  /// A synonym for Spot.BottomCenter.
  static _i3.Spot get middleBottom => _i5.getProperty(
        _declaredSpot,
        'MiddleBottom',
      );
  /* #2518
  source: 
    /**
     * A synonym for Spot.BottomCenter.
     * @constant
     */
    static MiddleBottom: Spot; */
  // Type Instance of 'InteropInterface'
  static set middleBottom(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'MiddleBottom',
      value,
    );
  }

  /* #2523
  source: 
    /**
     * A synonym for Spot.TopCenter.
     * @constant
     */
    static Top: Spot; */
  /// A synonym for Spot.TopCenter.
  static _i3.Spot get top => _i5.getProperty(
        _declaredSpot,
        'Top',
      );
  /* #2523
  source: 
    /**
     * A synonym for Spot.TopCenter.
     * @constant
     */
    static Top: Spot; */
  // Type Instance of 'InteropInterface'
  static set top(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Top',
      value,
    );
  }

  /* #2528
  source: 
    /**
     * A synonym for Spot.LeftCenter.
     * @constant
     */
    static Left: Spot; */
  /// A synonym for Spot.LeftCenter.
  static _i3.Spot get left => _i5.getProperty(
        _declaredSpot,
        'Left',
      );
  /* #2528
  source: 
    /**
     * A synonym for Spot.LeftCenter.
     * @constant
     */
    static Left: Spot; */
  // Type Instance of 'InteropInterface'
  static set left(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Left',
      value,
    );
  }

  /* #2533
  source: 
    /**
     * A synonym for Spot.RightCenter.
     * @constant
     */
    static Right: Spot; */
  /// A synonym for Spot.RightCenter.
  static _i3.Spot get right => _i5.getProperty(
        _declaredSpot,
        'Right',
      );
  /* #2533
  source: 
    /**
     * A synonym for Spot.RightCenter.
     * @constant
     */
    static Right: Spot; */
  // Type Instance of 'InteropInterface'
  static set right(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Right',
      value,
    );
  }

  /* #2538
  source: 
    /**
     * A synonym for Spot.BottomCenter.
     * @constant
     */
    static Bottom: Spot; */
  /// A synonym for Spot.BottomCenter.
  static _i3.Spot get bottom => _i5.getProperty(
        _declaredSpot,
        'Bottom',
      );
  /* #2538
  source: 
    /**
     * A synonym for Spot.BottomCenter.
     * @constant
     */
    static Bottom: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottom(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'Bottom',
      value,
    );
  }

  /* #2543
  source: 
    /**
     * The set of points at the top side of the bounding rectangle.
     * @constant
     */
    static TopSide: Spot; */
  /// The set of points at the top side of the bounding rectangle.
  static _i3.Spot get topSide => _i5.getProperty(
        _declaredSpot,
        'TopSide',
      );
  /* #2543
  source: 
    /**
     * The set of points at the top side of the bounding rectangle.
     * @constant
     */
    static TopSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set topSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopSide',
      value,
    );
  }

  /* #2548
  source: 
    /**
     * The set of points at the left side of the bounding rectangle.
     * @constant
     */
    static LeftSide: Spot; */
  /// The set of points at the left side of the bounding rectangle.
  static _i3.Spot get leftSide => _i5.getProperty(
        _declaredSpot,
        'LeftSide',
      );
  /* #2548
  source: 
    /**
     * The set of points at the left side of the bounding rectangle.
     * @constant
     */
    static LeftSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set leftSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'LeftSide',
      value,
    );
  }

  /* #2553
  source: 
    /**
     * The set of points at the right side of the bounding rectangle.
     * @constant
     */
    static RightSide: Spot; */
  /// The set of points at the right side of the bounding rectangle.
  static _i3.Spot get rightSide => _i5.getProperty(
        _declaredSpot,
        'RightSide',
      );
  /* #2553
  source: 
    /**
     * The set of points at the right side of the bounding rectangle.
     * @constant
     */
    static RightSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set rightSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'RightSide',
      value,
    );
  }

  /* #2558
  source: 
    /**
     * The set of points at the bottom side of the bounding rectangle.
     * @constant
     */
    static BottomSide: Spot; */
  /// The set of points at the bottom side of the bounding rectangle.
  static _i3.Spot get bottomSide => _i5.getProperty(
        _declaredSpot,
        'BottomSide',
      );
  /* #2558
  source: 
    /**
     * The set of points at the bottom side of the bounding rectangle.
     * @constant
     */
    static BottomSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomSide',
      value,
    );
  }

  /* #2563
  source: 
    /**
     * The set of points at the top or bottom sides of the bounding rectangle.
     * @constant
     */
    static TopBottomSides: Spot; */
  /// The set of points at the top or bottom sides of the bounding rectangle.
  static _i3.Spot get topBottomSides => _i5.getProperty(
        _declaredSpot,
        'TopBottomSides',
      );
  /* #2563
  source: 
    /**
     * The set of points at the top or bottom sides of the bounding rectangle.
     * @constant
     */
    static TopBottomSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set topBottomSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopBottomSides',
      value,
    );
  }

  /* #2568
  source: 
    /**
     * The set of points at the left or right sides of the bounding rectangle.
     * @constant
     */
    static LeftRightSides: Spot; */
  /// The set of points at the left or right sides of the bounding rectangle.
  static _i3.Spot get leftRightSides => _i5.getProperty(
        _declaredSpot,
        'LeftRightSides',
      );
  /* #2568
  source: 
    /**
     * The set of points at the left or right sides of the bounding rectangle.
     * @constant
     */
    static LeftRightSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set leftRightSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'LeftRightSides',
      value,
    );
  }

  /* #2573
  source: 
    /**
     * The set of points at the top or left sides of the bounding rectangle.
     * @constant
     */
    static TopLeftSides: Spot; */
  /// The set of points at the top or left sides of the bounding rectangle.
  static _i3.Spot get topLeftSides => _i5.getProperty(
        _declaredSpot,
        'TopLeftSides',
      );
  /* #2573
  source: 
    /**
     * The set of points at the top or left sides of the bounding rectangle.
     * @constant
     */
    static TopLeftSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set topLeftSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopLeftSides',
      value,
    );
  }

  /* #2578
  source: 
    /**
     * The set of points at the top or right sides of the bounding rectangle.
     * @constant
     */
    static TopRightSides: Spot; */
  /// The set of points at the top or right sides of the bounding rectangle.
  static _i3.Spot get topRightSides => _i5.getProperty(
        _declaredSpot,
        'TopRightSides',
      );
  /* #2578
  source: 
    /**
     * The set of points at the top or right sides of the bounding rectangle.
     * @constant
     */
    static TopRightSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set topRightSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'TopRightSides',
      value,
    );
  }

  /* #2583
  source: 
    /**
     * The set of points at the left or bottom sides of the bounding rectangle.
     * @constant
     */
    static BottomLeftSides: Spot; */
  /// The set of points at the left or bottom sides of the bounding rectangle.
  static _i3.Spot get bottomLeftSides => _i5.getProperty(
        _declaredSpot,
        'BottomLeftSides',
      );
  /* #2583
  source: 
    /**
     * The set of points at the left or bottom sides of the bounding rectangle.
     * @constant
     */
    static BottomLeftSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomLeftSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomLeftSides',
      value,
    );
  }

  /* #2588
  source: 
    /**
     * The set of points at the right or bottom sides of the bounding rectangle.
     * @constant
     */
    static BottomRightSides: Spot; */
  /// The set of points at the right or bottom sides of the bounding rectangle.
  static _i3.Spot get bottomRightSides => _i5.getProperty(
        _declaredSpot,
        'BottomRightSides',
      );
  /* #2588
  source: 
    /**
     * The set of points at the right or bottom sides of the bounding rectangle.
     * @constant
     */
    static BottomRightSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set bottomRightSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'BottomRightSides',
      value,
    );
  }

  /* #2593
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except top side.
     * @constant
     */
    static NotTopSide: Spot; */
  /// The set of points on all sides of the bounding rectangle except top side.
  static _i3.Spot get notTopSide => _i5.getProperty(
        _declaredSpot,
        'NotTopSide',
      );
  /* #2593
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except top side.
     * @constant
     */
    static NotTopSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set notTopSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'NotTopSide',
      value,
    );
  }

  /* #2598
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except left side.
     * @constant
     */
    static NotLeftSide: Spot; */
  /// The set of points on all sides of the bounding rectangle except left side.
  static _i3.Spot get notLeftSide => _i5.getProperty(
        _declaredSpot,
        'NotLeftSide',
      );
  /* #2598
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except left side.
     * @constant
     */
    static NotLeftSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set notLeftSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'NotLeftSide',
      value,
    );
  }

  /* #2603
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except right side.
     * @constant
     */
    static NotRightSide: Spot; */
  /// The set of points on all sides of the bounding rectangle except right side.
  static _i3.Spot get notRightSide => _i5.getProperty(
        _declaredSpot,
        'NotRightSide',
      );
  /* #2603
  source: 
    /**
     * The set of points on all sides of the bounding rectangle except right side.
     * @constant
     */
    static NotRightSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set notRightSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'NotRightSide',
      value,
    );
  }

  /* #2608
  source: 
    /**
     * The set of points on all sides of bounding rectangle except bottom side.
     * @constant
     */
    static NotBottomSide: Spot; */
  /// The set of points on all sides of bounding rectangle except bottom side.
  static _i3.Spot get notBottomSide => _i5.getProperty(
        _declaredSpot,
        'NotBottomSide',
      );
  /* #2608
  source: 
    /**
     * The set of points on all sides of bounding rectangle except bottom side.
     * @constant
     */
    static NotBottomSide: Spot; */
  // Type Instance of 'InteropInterface'
  static set notBottomSide(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'NotBottomSide',
      value,
    );
  }

  /* #2613
  source: 
    /**
     * The set of points on all sides of the bounding rectangle.
     * @constant
     */
    static AllSides: Spot; */
  /// The set of points on all sides of the bounding rectangle.
  static _i3.Spot get allSides => _i5.getProperty(
        _declaredSpot,
        'AllSides',
      );
  /* #2613
  source: 
    /**
     * The set of points on all sides of the bounding rectangle.
     * @constant
     */
    static AllSides: Spot; */
  // Type Instance of 'InteropInterface'
  static set allSides(_i3.Spot value) {
    _i5.setProperty(
      _declaredSpot,
      'AllSides',
      value,
    );
  }

  static _i3.Spot parse(_i2.String str) => _i5.callMethod(
        _declaredSpot,
        'parse',
        [str],
      );
  static _i2.String stringify(_i3.Spot val) => _i5.callMethod(
        _declaredSpot,
        'stringify',
        [val],
      );
  static _i3.Spot alloc() => _i5.callMethod(
        _declaredSpot,
        'alloc',
        [],
      );
  static void free(_i3.Spot temp) {
    _i5.callMethod(
      _declaredSpot,
      'free',
      [temp],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Spot')
external _i2.Object _declaredSpot;

extension Spot$Typings on Spot {
  /* #2380
  source: 
    /**
     * Gets or sets the x value of the Spot, a fractional value between zero and one.
     *
     * The Spot(0,0) of a rectangle is at the top-left corner.
     * This value is commonly available as Spot.TopLeft.
     * The Spot(0.5,1) would be at the middle of the bottom side.
     * That value is commonly available as Spot.MiddleBottom.
     */
    get x(): number; */
  /// Gets or sets the x value of the Spot, a fractional value between zero and one.
  ///
  /// The Spot(0,0) of a rectangle is at the top-left corner.
  /// This value is commonly available as Spot.TopLeft.
  /// The Spot(0.5,1) would be at the middle of the bottom side.
  /// That value is commonly available as Spot.MiddleBottom.
  _i2.num get x => _i5.getProperty(
        this,
        'x',
      );
  /* #2380
  source: 
    /**
     * Gets or sets the x value of the Spot, a fractional value between zero and one.
     *
     * The Spot(0,0) of a rectangle is at the top-left corner.
     * This value is commonly available as Spot.TopLeft.
     * The Spot(0.5,1) would be at the middle of the bottom side.
     * That value is commonly available as Spot.MiddleBottom.
     */
    get x(): number; */
  // Type InteropStaticType.number
  set x(_i2.num value) {
    _i5.setProperty(
      this,
      'x',
      value,
    );
  }

  /* #2390
  source: 
    /**
     * Gets or sets the y value of the Spot, a fractional value between zero and one.
     *
     * The Spot(0,1) of a rectangle is at the bottom-left corner.
     * This value is commonly available as Spot.BottomLeft.
     * The Spot(1,0.5) would be at the middle of the right side.
     * That value is commonly available as Spot.MiddleRight.
     */
    get y(): number; */
  /// Gets or sets the y value of the Spot, a fractional value between zero and one.
  ///
  /// The Spot(0,1) of a rectangle is at the bottom-left corner.
  /// This value is commonly available as Spot.BottomLeft.
  /// The Spot(1,0.5) would be at the middle of the right side.
  /// That value is commonly available as Spot.MiddleRight.
  _i2.num get y => _i5.getProperty(
        this,
        'y',
      );
  /* #2390
  source: 
    /**
     * Gets or sets the y value of the Spot, a fractional value between zero and one.
     *
     * The Spot(0,1) of a rectangle is at the bottom-left corner.
     * This value is commonly available as Spot.BottomLeft.
     * The Spot(1,0.5) would be at the middle of the right side.
     * That value is commonly available as Spot.MiddleRight.
     */
    get y(): number; */
  // Type InteropStaticType.number
  set y(_i2.num value) {
    _i5.setProperty(
      this,
      'y',
      value,
    );
  }

  /* #2401
  source: 
    /**
     * Gets or sets the offsetX value of the Spot.
     * The value may be negative.
     * If this represents a side value instead of a specific spot, this value is meaningless.
     *
     * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
     * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
     * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
     */
    get offsetX(): number; */
  /// Gets or sets the offsetX value of the Spot.
  /// The value may be negative.
  /// If this represents a side value instead of a specific spot, this value is meaningless.
  ///
  /// A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
  /// A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
  /// A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
  _i2.num get offsetX => _i5.getProperty(
        this,
        'offsetX',
      );
  /* #2401
  source: 
    /**
     * Gets or sets the offsetX value of the Spot.
     * The value may be negative.
     * If this represents a side value instead of a specific spot, this value is meaningless.
     *
     * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
     * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
     * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
     */
    get offsetX(): number; */
  // Type InteropStaticType.number
  set offsetX(_i2.num value) {
    _i5.setProperty(
      this,
      'offsetX',
      value,
    );
  }

  /* #2412
  source: 
    /**
     * Gets or sets the offsetY value of the Spot.
     * The value may be negative.
     * If this represents a side value instead of a specific spot, this value is meaningless.
     *
     * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
     * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
     * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
     */
    get offsetY(): number; */
  /// Gets or sets the offsetY value of the Spot.
  /// The value may be negative.
  /// If this represents a side value instead of a specific spot, this value is meaningless.
  ///
  /// A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
  /// A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
  /// A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
  _i2.num get offsetY => _i5.getProperty(
        this,
        'offsetY',
      );
  /* #2412
  source: 
    /**
     * Gets or sets the offsetY value of the Spot.
     * The value may be negative.
     * If this represents a side value instead of a specific spot, this value is meaningless.
     *
     * A Spot(0,0,5,5) of a large rectangle is near the top-left corner, inside the rectangle.
     * A Spot(1,1,5,5) would be near the bottom-right corner, outside the rectangle.
     * A Spot(1,1,-5,-5) would also be near the bottom-right corner, but inside the rectangle.
     */
    get offsetY(): number; */
  // Type InteropStaticType.number
  set offsetY(_i2.num value) {
    _i5.setProperty(
      this,
      'offsetY',
      value,
    );
  }

  _i3.Spot setTo(
    _i2.num x,
    _i2.num y,
    _i2.num offx,
    _i2.num offy,
  ) =>
      _i5.callMethod(
        this,
        'setTo',
        [
          x,
          y,
          offx,
          offy,
        ],
      );
  _i3.Spot set(_i3.Spot s) => _i5.callMethod(
        this,
        'set',
        [s],
      );
  _i3.Spot copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equals(_i3.Spot spot) => _i5.callMethod(
        this,
        'equals',
        [spot],
      );
  _i3.Spot opposite() => _i5.callMethod(
        this,
        'opposite',
        [],
      );
  _i2.bool includesSide(_i3.Spot side) => _i5.callMethod(
        this,
        'includesSide',
        [side],
      );
  _i2.bool isSpot() => _i5.callMethod(
        this,
        'isSpot',
        [],
      );
  _i2.bool isNoSpot() => _i5.callMethod(
        this,
        'isNoSpot',
        [],
      );
  _i2.bool isSide() => _i5.callMethod(
        this,
        'isSide',
        [],
      );
  _i2.bool isNone() => _i5.callMethod(
        this,
        'isNone',
        [],
      );
  _i2.bool isDefault() => _i5.callMethod(
        this,
        'isDefault',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Geometry {
  factory Geometry([_i3.EnumValue? type]) => _i5.callConstructor(
        _declaredGeometry,
        [type ?? _i4.undefined],
      );

  /* #2668
  source: 
    /**
     * For drawing a simple straight line;
     * a value for Geometry#type.
     * The line goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Line: EnumValue; */
  /// For drawing a simple straight line;
  /// a value for Geometry#type.
  /// The line goes from the point
  /// (#startX, #startY) to the point (#endX, #endY).
  static _i3.EnumValue get line => _i5.getProperty(
        _declaredGeometry,
        'Line',
      );
  /* #2668
  source: 
    /**
     * For drawing a simple straight line;
     * a value for Geometry#type.
     * The line goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Line: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set line(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGeometry,
      'Line',
      value,
    );
  }

  /* #2676
  source: 
    /**
     * For drawing a rectangle;
     * a value for Geometry#type.
     * The rectangle goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Rectangle: EnumValue; */
  /// For drawing a rectangle;
  /// a value for Geometry#type.
  /// The rectangle goes from the point
  /// (#startX, #startY) to the point (#endX, #endY).
  static _i3.EnumValue get rectangle => _i5.getProperty(
        _declaredGeometry,
        'Rectangle',
      );
  /* #2676
  source: 
    /**
     * For drawing a rectangle;
     * a value for Geometry#type.
     * The rectangle goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Rectangle: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set rectangle(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGeometry,
      'Rectangle',
      value,
    );
  }

  /* #2684
  source: 
    /**
     * For drawing an ellipse fitting within a rectangle;
     * a value for Geometry#type.
     * The ellipse fits within the rectangle that goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Ellipse: EnumValue; */
  /// For drawing an ellipse fitting within a rectangle;
  /// a value for Geometry#type.
  /// The ellipse fits within the rectangle that goes from the point
  /// (#startX, #startY) to the point (#endX, #endY).
  static _i3.EnumValue get ellipse => _i5.getProperty(
        _declaredGeometry,
        'Ellipse',
      );
  /* #2684
  source: 
    /**
     * For drawing an ellipse fitting within a rectangle;
     * a value for Geometry#type.
     * The ellipse fits within the rectangle that goes from the point
     * (#startX, #startY) to the point (#endX, #endY).
     * @constant
     */
    static Ellipse: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set ellipse(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGeometry,
      'Ellipse',
      value,
    );
  }

  /* #2690
  source: 
    /**
     * For drawing a complex path made of a list of PathFigures;
     * a value for Geometry#type.
     * @constant
     */
    static Path: EnumValue; */
  /// For drawing a complex path made of a list of PathFigures;
  /// a value for Geometry#type.
  static _i3.EnumValue get path => _i5.getProperty(
        _declaredGeometry,
        'Path',
      );
  /* #2690
  source: 
    /**
     * For drawing a complex path made of a list of PathFigures;
     * a value for Geometry#type.
     * @constant
     */
    static Path: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set path(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGeometry,
      'Path',
      value,
    );
  }

  static _i2.String stringify(_i3.Geometry val) => _i5.callMethod(
        _declaredGeometry,
        'stringify',
        [val],
      );
  static _i2.String fillPath(_i2.String str) => _i5.callMethod(
        _declaredGeometry,
        'fillPath',
        [str],
      );
  static _i3.Geometry parse(
    _i2.String str, [
    _i2.bool? filled,
  ]) =>
      _i5.callMethod(
        _declaredGeometry,
        'parse',
        [
          str,
          filled ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Geometry')
external _i2.Object _declaredGeometry;

extension Geometry$Typings on Geometry {
  /* #2827
  source: 
    /**
     * (undocumented)
     * Flattened segments represents a series of points making up a Geometry.
     * The inner arrays consist of a sequence of PathSegment coordinates making up a PathFigure,
     * while the outer array represents the whole Geometry of these PathFigures.
     */
    get flattenedSegments(): Array<Array<number>>; */
  /// (undocumented)
  /// Flattened segments represents a series of points making up a Geometry.
  /// The inner arrays consist of a sequence of PathSegment coordinates making up a PathFigure,
  /// while the outer array represents the whole Geometry of these PathFigures.
  _i4.Array get flattenedSegments => _i5.getProperty(
        this,
        'flattenedSegments',
      );
  /* #2827
  source: 
    /**
     * (undocumented)
     * Flattened segments represents a series of points making up a Geometry.
     * The inner arrays consist of a sequence of PathSegment coordinates making up a PathFigure,
     * while the outer array represents the whole Geometry of these PathFigures.
     */
    get flattenedSegments(): Array<Array<number>>; */
  // Type Instance of 'ExternalInteropType'
  set flattenedSegments(_i4.Array value) {
    _i5.setProperty(
      this,
      'flattenedSegments',
      value,
    );
  }

  /* #2834
  source: 
    /**
     * (undocumented)
     * Flattened lengths represents a series of lengths of the paths making up a Geometry.
     * The inner arrays consist of a sequence of PathSegment lengths making up a PathFigure,
     * while the outer array represents the whole Geometry of these PathFigures.
     */
    get flattenedLengths(): Array<Array<number>>; */
  /// (undocumented)
  /// Flattened lengths represents a series of lengths of the paths making up a Geometry.
  /// The inner arrays consist of a sequence of PathSegment lengths making up a PathFigure,
  /// while the outer array represents the whole Geometry of these PathFigures.
  _i4.Array get flattenedLengths => _i5.getProperty(
        this,
        'flattenedLengths',
      );
  /* #2834
  source: 
    /**
     * (undocumented)
     * Flattened lengths represents a series of lengths of the paths making up a Geometry.
     * The inner arrays consist of a sequence of PathSegment lengths making up a PathFigure,
     * while the outer array represents the whole Geometry of these PathFigures.
     */
    get flattenedLengths(): Array<Array<number>>; */
  // Type Instance of 'ExternalInteropType'
  set flattenedLengths(_i4.Array value) {
    _i5.setProperty(
      this,
      'flattenedLengths',
      value,
    );
  }

  /* #2840
  source: 
    /**
     * (undocumented)
     * This read-only property returns the approximate length of the path.
     * This is the overall distance of all the PathSegments that make up the geometry.
     */
    get flattenedTotalLength(): number; */
  /// (undocumented)
  /// This read-only property returns the approximate length of the path.
  /// This is the overall distance of all the PathSegments that make up the geometry.
  _i2.num get flattenedTotalLength => _i5.getProperty(
        this,
        'flattenedTotalLength',
      );
  /* #2840
  source: 
    /**
     * (undocumented)
     * This read-only property returns the approximate length of the path.
     * This is the overall distance of all the PathSegments that make up the geometry.
     */
    get flattenedTotalLength(): number; */
  // Type InteropStaticType.number
  set flattenedTotalLength(_i2.num value) {
    _i5.setProperty(
      this,
      'flattenedTotalLength',
      value,
    );
  }

  /* #2847
  source: 
    /**
     * Gets or sets the type of the Geometry.
     * The default type is Geometry.Path.
     * Other permissible values are Geometry.Line, Geometry.Ellipse,
     * or Geometry.Rectangle.
     */
    get type(): EnumValue; */
  /// Gets or sets the type of the Geometry.
  /// The default type is Geometry.Path.
  /// Other permissible values are Geometry.Line, Geometry.Ellipse,
  /// or Geometry.Rectangle.
  _i3.EnumValue get type => _i5.getProperty(
        this,
        'type',
      );
  /* #2847
  source: 
    /**
     * Gets or sets the type of the Geometry.
     * The default type is Geometry.Path.
     * Other permissible values are Geometry.Line, Geometry.Ellipse,
     * or Geometry.Rectangle.
     */
    get type(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set type(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'type',
      value,
    );
  }

  /* #2854
  source: 
    /**
     * Gets or sets the starting X coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get startX(): number; */
  /// Gets or sets the starting X coordinate of the Geometry if it is of type
  /// Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
  /// The initial value is zero.
  _i2.num get startX => _i5.getProperty(
        this,
        'startX',
      );
  /* #2854
  source: 
    /**
     * Gets or sets the starting X coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get startX(): number; */
  // Type InteropStaticType.number
  set startX(_i2.num value) {
    _i5.setProperty(
      this,
      'startX',
      value,
    );
  }

  /* #2861
  source: 
    /**
     * Gets or sets the starting Y coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get startY(): number; */
  /// Gets or sets the starting Y coordinate of the Geometry if it is of type
  /// Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
  /// The initial value is zero.
  _i2.num get startY => _i5.getProperty(
        this,
        'startY',
      );
  /* #2861
  source: 
    /**
     * Gets or sets the starting Y coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get startY(): number; */
  // Type InteropStaticType.number
  set startY(_i2.num value) {
    _i5.setProperty(
      this,
      'startY',
      value,
    );
  }

  /* #2868
  source: 
    /**
     * Gets or sets the ending X coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get endX(): number; */
  /// Gets or sets the ending X coordinate of the Geometry if it is of type
  /// Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
  /// The initial value is zero.
  _i2.num get endX => _i5.getProperty(
        this,
        'endX',
      );
  /* #2868
  source: 
    /**
     * Gets or sets the ending X coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get endX(): number; */
  // Type InteropStaticType.number
  set endX(_i2.num value) {
    _i5.setProperty(
      this,
      'endX',
      value,
    );
  }

  /* #2875
  source: 
    /**
     * Gets or sets the ending Y coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get endY(): number; */
  /// Gets or sets the ending Y coordinate of the Geometry if it is of type
  /// Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
  /// The initial value is zero.
  _i2.num get endY => _i5.getProperty(
        this,
        'endY',
      );
  /* #2875
  source: 
    /**
     * Gets or sets the ending Y coordinate of the Geometry if it is of type
     * Geometry.Line|Line, Geometry.Rectangle|Rectangle, or Geometry.Ellipse|Ellipse.
     * The initial value is zero.
     */
    get endY(): number; */
  // Type InteropStaticType.number
  set endY(_i2.num value) {
    _i5.setProperty(
      this,
      'endY',
      value,
    );
  }

  /* #2882
  source: 
    /**
     * Gets or sets the List of PathFigures
     * that describes the content of the
     * path for Geometries of type Geometry.Path|Path.
     */
    get figures(): List<PathFigure>; */
  /// Gets or sets the List of PathFigures
  /// that describes the content of the
  /// path for Geometries of type Geometry.Path|Path.
  _i3.List /*LIST InteropClass#847625641(name: List),984173621,[Instance of 'InteropRef<InteropType>']*/ <_i3.PathFigure>
      get figures => _i5.getProperty(
            this,
            'figures',
          );
  /* #2882
  source: 
    /**
     * Gets or sets the List of PathFigures
     * that describes the content of the
     * path for Geometries of type Geometry.Path|Path.
     */
    get figures(): List<PathFigure>; */
  // Type Instance of 'InteropInterface'
  set figures(
      _i3.List /*LIST InteropClass#847625641(name: List),633050930,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.PathFigure>
          value) {
    _i5.setProperty(
      this,
      'figures',
      value,
    );
  }

  /* #2910
  source: 
    /**
     * Gets or sets the spot an "Auto" Panel will use for the top-left corner of any panel content
     * when the Shape#spot1 value is Spot.Default.
     * The default value is Spot.TopLeft, at the top-left point of the bounds of the Shape.
     */
    get spot1(): Spot; */
  /// Gets or sets the spot an "Auto" Panel will use for the top-left corner of any panel content
  /// when the Shape#spot1 value is Spot.Default.
  /// The default value is Spot.TopLeft, at the top-left point of the bounds of the Shape.
  _i3.Spot get spot1 => _i5.getProperty(
        this,
        'spot1',
      );
  /* #2910
  source: 
    /**
     * Gets or sets the spot an "Auto" Panel will use for the top-left corner of any panel content
     * when the Shape#spot1 value is Spot.Default.
     * The default value is Spot.TopLeft, at the top-left point of the bounds of the Shape.
     */
    get spot1(): Spot; */
  // Type Instance of 'InteropInterface'
  set spot1(_i3.Spot value) {
    _i5.setProperty(
      this,
      'spot1',
      value,
    );
  }

  /* #2917
  source: 
    /**
     * Gets or sets the spot an "Auto" Panel will use for the bottom-right corner of any panel content
     * when the Shape#spot2 value is Spot.Default.
     * The default value is Spot.BottomRight, at the bottom-right point of the bounds of the Shape.
     */
    get spot2(): Spot; */
  /// Gets or sets the spot an "Auto" Panel will use for the bottom-right corner of any panel content
  /// when the Shape#spot2 value is Spot.Default.
  /// The default value is Spot.BottomRight, at the bottom-right point of the bounds of the Shape.
  _i3.Spot get spot2 => _i5.getProperty(
        this,
        'spot2',
      );
  /* #2917
  source: 
    /**
     * Gets or sets the spot an "Auto" Panel will use for the bottom-right corner of any panel content
     * when the Shape#spot2 value is Spot.Default.
     * The default value is Spot.BottomRight, at the bottom-right point of the bounds of the Shape.
     */
    get spot2(): Spot; */
  // Type Instance of 'InteropInterface'
  set spot2(_i3.Spot value) {
    _i5.setProperty(
      this,
      'spot2',
      value,
    );
  }

  /* #2927
  source: 
    /**
     * Gets or sets the Shape#geometryStretch value the Shape should use by default
     * when the Shape#geometryStretch value is GraphObject.None.
     * The default value is GraphObject.Fill.
     * Some figure generators return a Geometry with this property set to GraphObject.Uniform,
     * in order to preserve its aspect ratio when used by a Shape that may have different sizes.
     * @since 1.5
     */
    get defaultStretch(): EnumValue; */
  /// Gets or sets the Shape#geometryStretch value the Shape should use by default
  /// when the Shape#geometryStretch value is GraphObject.None.
  /// The default value is GraphObject.Fill.
  /// Some figure generators return a Geometry with this property set to GraphObject.Uniform,
  /// in order to preserve its aspect ratio when used by a Shape that may have different sizes.
  _i3.EnumValue get defaultStretch => _i5.getProperty(
        this,
        'defaultStretch',
      );
  /* #2927
  source: 
    /**
     * Gets or sets the Shape#geometryStretch value the Shape should use by default
     * when the Shape#geometryStretch value is GraphObject.None.
     * The default value is GraphObject.Fill.
     * Some figure generators return a Geometry with this property set to GraphObject.Uniform,
     * in order to preserve its aspect ratio when used by a Shape that may have different sizes.
     * @since 1.5
     */
    get defaultStretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set defaultStretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'defaultStretch',
      value,
    );
  }

  /* #2933
  source: 
    /**
     * This read-only property returns a rectangle that contains all points within the Geometry.
     * The result will always contain the origin (0, 0).
     */
    get bounds(): Rect; */
  /// This read-only property returns a rectangle that contains all points within the Geometry.
  /// The result will always contain the origin (0, 0).
  _i3.Rect get bounds => _i5.getProperty(
        this,
        'bounds',
      );
  /* #2933
  source: 
    /**
     * This read-only property returns a rectangle that contains all points within the Geometry.
     * The result will always contain the origin (0, 0).
     */
    get bounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set bounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'bounds',
      value,
    );
  }

  _i3.Geometry copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equalsApprox(_i3.Geometry g) => _i5.callMethod(
        this,
        'equalsApprox',
        [g],
      );
  _i3.Rect computeBoundsWithoutOrigin() => _i5.callMethod(
        this,
        'computeBoundsWithoutOrigin',
        [],
      );
  _i3.Point normalize() => _i5.callMethod(
        this,
        'normalize',
        [],
      );
  _i3.Geometry offset(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'offset',
        [
          x,
          y,
        ],
      );
  _i3.Geometry scale(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'scale',
        [
          x,
          y,
        ],
      );
  _i3.Geometry rotate(
    _i2.num angle, [
    _i2.num? x,
    _i2.num? y,
  ]) =>
      _i5.callMethod(
        this,
        'rotate',
        [
          angle,
          x ?? _i4.undefined,
          y ?? _i4.undefined,
        ],
      );
  _i2.bool containsPoint(
    _i3.Point p, [
    _i2.num? sw,
  ]) =>
      _i5.callMethod(
        this,
        'containsPoint',
        [
          p,
          sw ?? _i4.undefined,
        ],
      );
  _i3.Point getPointAlongPath(
    _i2.num fraction, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'getPointAlongPath',
        [
          fraction,
          result ?? _i4.undefined,
        ],
      );
  _i2.num getAngleAlongPath(_i2.num fraction) => _i5.callMethod(
        this,
        'getAngleAlongPath',
        [fraction],
      );
  _i2.num getFractionForPoint(_i3.Point pt) => _i5.callMethod(
        this,
        'getFractionForPoint',
        [pt],
      );
  _i3.Geometry add(_i3.PathFigure figure) => _i5.callMethod(
        this,
        'add',
        [figure],
      );
  _i3.Geometry setSpots(
    _i2.num f1x,
    _i2.num f1y,
    _i2.num f2x,
    _i2.num f2y, [
    _i2.num? o1x,
    _i2.num? o1y,
    _i2.num? o2x,
    _i2.num? o2y,
  ]) =>
      _i5.callMethod(
        this,
        'setSpots',
        [
          f1x,
          f1y,
          f2x,
          f2y,
          o1x ?? _i4.undefined,
          o1y ?? _i4.undefined,
          o2x ?? _i4.undefined,
          o2y ?? _i4.undefined,
        ],
      );
}

@_i1.JS()
@_i1.staticInterop
class PathFigure {
  factory PathFigure([
    _i2.num? sx,
    _i2.num? sy,
    _i2.bool? filled,
    _i2.bool? shadowed,
    _i2.bool? isEvenOdd,
  ]) =>
      _i5.callConstructor(
        _declaredPathFigure,
        [
          sx ?? _i4.undefined,
          sy ?? _i4.undefined,
          filled ?? _i4.undefined,
          shadowed ?? _i4.undefined,
          isEvenOdd ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('PathFigure')
external _i2.Object _declaredPathFigure;

extension PathFigure$Typings on PathFigure {
  /* #2979
  source: 
    /**
     * Gets or sets whether this PathFigure is drawn filled.
     * The default value is true.
     */
    get isFilled(): boolean; */
  /// Gets or sets whether this PathFigure is drawn filled.
  /// The default value is true.
  _i2.bool get isFilled => _i5.getProperty(
        this,
        'isFilled',
      );
  /* #2979
  source: 
    /**
     * Gets or sets whether this PathFigure is drawn filled.
     * The default value is true.
     */
    get isFilled(): boolean; */
  // Type InteropStaticType.boolean
  set isFilled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isFilled',
      value,
    );
  }

  /* #2986
  source: 
    /**
     * Gets or sets whether this PathFigure will render a shadow if one is defined.
     * This is used for turning off shadows on specific subpaths.
     * The default value is true.
     */
    get isShadowed(): boolean; */
  /// Gets or sets whether this PathFigure will render a shadow if one is defined.
  /// This is used for turning off shadows on specific subpaths.
  /// The default value is true.
  _i2.bool get isShadowed => _i5.getProperty(
        this,
        'isShadowed',
      );
  /* #2986
  source: 
    /**
     * Gets or sets whether this PathFigure will render a shadow if one is defined.
     * This is used for turning off shadows on specific subpaths.
     * The default value is true.
     */
    get isShadowed(): boolean; */
  // Type InteropStaticType.boolean
  set isShadowed(_i2.bool value) {
    _i5.setProperty(
      this,
      'isShadowed',
      value,
    );
  }

  /* #2996
  source: 
    /**
     * Gets or sets whether this PathFigure will render and hit-test with the even-odd fill rule
     * or nonzero winding number fill rule (false).
     * The default value is false, using the nonzero winding number rule.
     *
     * In <a href="../../intro/geometry.html">Geometry Path Strings</a>, this is set by using "F0" instead of "F" at the beginning of a figure.
     * @since 2.3
     */
    get isEvenOdd(): boolean; */
  /// Gets or sets whether this PathFigure will render and hit-test with the even-odd fill rule
  /// or nonzero winding number fill rule (false).
  /// The default value is false, using the nonzero winding number rule.
  ///
  /// In <a href="../../intro/geometry.html">Geometry Path Strings</a>, this is set by using "F0" instead of "F" at the beginning of a figure.
  _i2.bool get isEvenOdd => _i5.getProperty(
        this,
        'isEvenOdd',
      );
  /* #2996
  source: 
    /**
     * Gets or sets whether this PathFigure will render and hit-test with the even-odd fill rule
     * or nonzero winding number fill rule (false).
     * The default value is false, using the nonzero winding number rule.
     *
     * In <a href="../../intro/geometry.html">Geometry Path Strings</a>, this is set by using "F0" instead of "F" at the beginning of a figure.
     * @since 2.3
     */
    get isEvenOdd(): boolean; */
  // Type InteropStaticType.boolean
  set isEvenOdd(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEvenOdd',
      value,
    );
  }

  /* #3002
  source: 
    /**
     * Gets or sets the starting point X coordinate of the PathFigure.
     * The default value is zero.
     */
    get startX(): number; */
  /// Gets or sets the starting point X coordinate of the PathFigure.
  /// The default value is zero.
  _i2.num get startX => _i5.getProperty(
        this,
        'startX',
      );
  /* #3002
  source: 
    /**
     * Gets or sets the starting point X coordinate of the PathFigure.
     * The default value is zero.
     */
    get startX(): number; */
  // Type InteropStaticType.number
  set startX(_i2.num value) {
    _i5.setProperty(
      this,
      'startX',
      value,
    );
  }

  /* #3008
  source: 
    /**
     * Gets or sets the starting point Y coordinate of the PathFigure.
     * The default value is zero.
     */
    get startY(): number; */
  /// Gets or sets the starting point Y coordinate of the PathFigure.
  /// The default value is zero.
  _i2.num get startY => _i5.getProperty(
        this,
        'startY',
      );
  /* #3008
  source: 
    /**
     * Gets or sets the starting point Y coordinate of the PathFigure.
     * The default value is zero.
     */
    get startY(): number; */
  // Type InteropStaticType.number
  set startY(_i2.num value) {
    _i5.setProperty(
      this,
      'startY',
      value,
    );
  }

  /* #3013
  source: 
    /**
     * Gets or sets the List of PathSegments that define this PathFigure.
     */
    get segments(): List<PathSegment>; */
  /// Gets or sets the List of PathSegments that define this PathFigure.
  _i3.List /*LIST InteropClass#847625641(name: List),776741256,[Instance of 'InteropRef<InteropType>']*/ <_i3.PathSegment>
      get segments => _i5.getProperty(
            this,
            'segments',
          );
  /* #3013
  source: 
    /**
     * Gets or sets the List of PathSegments that define this PathFigure.
     */
    get segments(): List<PathSegment>; */
  // Type Instance of 'InteropInterface'
  set segments(
      _i3.List /*LIST InteropClass#847625641(name: List),597300782,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.PathSegment>
          value) {
    _i5.setProperty(
      this,
      'segments',
      value,
    );
  }

  _i3.PathFigure copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equalsApprox(_i3.PathFigure f) => _i5.callMethod(
        this,
        'equalsApprox',
        [f],
      );
  _i3.PathFigure add(_i3.PathSegment segment) => _i5.callMethod(
        this,
        'add',
        [segment],
      );
}

@_i1.JS()
@_i1.staticInterop
class PathSegment {
  factory PathSegment([
    _i3.EnumValue? type,
    _i2.num? ex,
    _i2.num? ey,
    _i2.num? x1,
    _i2.num? y1,
    _i2.num? x2,
    _i2.Object? y2,
    _i2.bool? clockwise,
  ]) =>
      _i5.callConstructor(
        _declaredPathSegment,
        [
          type ?? _i4.undefined,
          ex ?? _i4.undefined,
          ey ?? _i4.undefined,
          x1 ?? _i4.undefined,
          y1 ?? _i4.undefined,
          x2 ?? _i4.undefined,
          y2 ?? _i4.undefined,
          clockwise ?? _i4.undefined,
        ],
      );

  /* #3120
  source: 
    /**
     * For beginning a new subpath, a value for PathSegment#type.
     * @constant
     */
    static Move: EnumValue; */
  /// For beginning a new subpath, a value for PathSegment#type.
  static _i3.EnumValue get move => _i5.getProperty(
        _declaredPathSegment,
        'Move',
      );
  /* #3120
  source: 
    /**
     * For beginning a new subpath, a value for PathSegment#type.
     * @constant
     */
    static Move: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set move(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'Move',
      value,
    );
  }

  /* #3125
  source: 
    /**
     * For drawing a straight line segment, a value for PathSegment#type.
     * @constant
     */
    static Line: EnumValue; */
  /// For drawing a straight line segment, a value for PathSegment#type.
  static _i3.EnumValue get line => _i5.getProperty(
        _declaredPathSegment,
        'Line',
      );
  /* #3125
  source: 
    /**
     * For drawing a straight line segment, a value for PathSegment#type.
     * @constant
     */
    static Line: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set line(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'Line',
      value,
    );
  }

  /* #3130
  source: 
    /**
     * For drawing a cubic bezier segment, a value for PathSegment#type.
     * @constant
     */
    static Bezier: EnumValue; */
  /// For drawing a cubic bezier segment, a value for PathSegment#type.
  static _i3.EnumValue get bezier => _i5.getProperty(
        _declaredPathSegment,
        'Bezier',
      );
  /* #3130
  source: 
    /**
     * For drawing a cubic bezier segment, a value for PathSegment#type.
     * @constant
     */
    static Bezier: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set bezier(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'Bezier',
      value,
    );
  }

  /* #3135
  source: 
    /**
     * For drawing a quadratic bezier segment, a value for PathSegment#type.
     * @constant
     */
    static QuadraticBezier: EnumValue; */
  /// For drawing a quadratic bezier segment, a value for PathSegment#type.
  static _i3.EnumValue get quadraticBezier => _i5.getProperty(
        _declaredPathSegment,
        'QuadraticBezier',
      );
  /* #3135
  source: 
    /**
     * For drawing a quadratic bezier segment, a value for PathSegment#type.
     * @constant
     */
    static QuadraticBezier: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set quadraticBezier(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'QuadraticBezier',
      value,
    );
  }

  /* #3140
  source: 
    /**
     * For drawing an arc segment, a value for PathSegment#type.
     * @constant
     */
    static Arc: EnumValue; */
  /// For drawing an arc segment, a value for PathSegment#type.
  static _i3.EnumValue get arc => _i5.getProperty(
        _declaredPathSegment,
        'Arc',
      );
  /* #3140
  source: 
    /**
     * For drawing an arc segment, a value for PathSegment#type.
     * @constant
     */
    static Arc: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set arc(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'Arc',
      value,
    );
  }

  /* #3148
  source: 
    /**
     * For drawing an SVG arc segment, a value for PathSegment#type.
     *
     * See: <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     * @constant
     * @since 1.1
     */
    static SvgArc: EnumValue; */
  /// For drawing an SVG arc segment, a value for PathSegment#type.
  ///
  /// See: <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
  static _i3.EnumValue get svgArc => _i5.getProperty(
        _declaredPathSegment,
        'SvgArc',
      );
  /* #3148
  source: 
    /**
     * For drawing an SVG arc segment, a value for PathSegment#type.
     *
     * See: <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     * @constant
     * @since 1.1
     */
    static SvgArc: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set svgArc(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredPathSegment,
      'SvgArc',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('PathSegment')
external _i2.Object _declaredPathSegment;

extension PathSegment$Typings on PathSegment {
  /* #3158
  source: 
    /**
     * Gets or sets whether the path is closed after this PathSegment.
     * Default value is false.
     */
    get isClosed(): boolean; */
  /// Gets or sets whether the path is closed after this PathSegment.
  /// Default value is false.
  _i2.bool get isClosed => _i5.getProperty(
        this,
        'isClosed',
      );
  /* #3158
  source: 
    /**
     * Gets or sets whether the path is closed after this PathSegment.
     * Default value is false.
     */
    get isClosed(): boolean; */
  // Type InteropStaticType.boolean
  set isClosed(_i2.bool value) {
    _i5.setProperty(
      this,
      'isClosed',
      value,
    );
  }

  /* #3167
  source: 
    /**
     * Gets or sets the type of the PathSegment.
     * The value must be one of the following:
     * PathSegment.Line, PathSegment.Bezier,
     * PathSegment.QuadraticBezier, PathSegment.Arc,
     * PathSegment.Move, PathSegment.Arc, and PathSegment.SvgArc.
     */
    get type(): EnumValue; */
  /// Gets or sets the type of the PathSegment.
  /// The value must be one of the following:
  /// PathSegment.Line, PathSegment.Bezier,
  /// PathSegment.QuadraticBezier, PathSegment.Arc,
  /// PathSegment.Move, PathSegment.Arc, and PathSegment.SvgArc.
  _i3.EnumValue get type => _i5.getProperty(
        this,
        'type',
      );
  /* #3167
  source: 
    /**
     * Gets or sets the type of the PathSegment.
     * The value must be one of the following:
     * PathSegment.Line, PathSegment.Bezier,
     * PathSegment.QuadraticBezier, PathSegment.Arc,
     * PathSegment.Move, PathSegment.Arc, and PathSegment.SvgArc.
     */
    get type(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set type(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'type',
      value,
    );
  }

  /* #3173
  source: 
    /**
     * Gets or sets the X coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
     * The default value is zero.
     */
    get endX(): number; */
  /// Gets or sets the X coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
  /// The default value is zero.
  _i2.num get endX => _i5.getProperty(
        this,
        'endX',
      );
  /* #3173
  source: 
    /**
     * Gets or sets the X coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
     * The default value is zero.
     */
    get endX(): number; */
  // Type InteropStaticType.number
  set endX(_i2.num value) {
    _i5.setProperty(
      this,
      'endX',
      value,
    );
  }

  /* #3179
  source: 
    /**
     * Gets or sets the Y coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
     * The default value is zero.
     */
    get endY(): number; */
  /// Gets or sets the Y coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
  /// The default value is zero.
  _i2.num get endY => _i5.getProperty(
        this,
        'endY',
      );
  /* #3179
  source: 
    /**
     * Gets or sets the Y coordinate of the end point for all types of PathSegment except PathSegment.Arc|Arc.
     * The default value is zero.
     */
    get endY(): number; */
  // Type InteropStaticType.number
  set endY(_i2.num value) {
    _i5.setProperty(
      this,
      'endY',
      value,
    );
  }

  /* #3185
  source: 
    /**
     * Gets or sets the X value of the first control point for a PathSegment
     * of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
     */
    get point1X(): number; */
  /// Gets or sets the X value of the first control point for a PathSegment
  /// of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
  _i2.num get point1X => _i5.getProperty(
        this,
        'point1X',
      );
  /* #3185
  source: 
    /**
     * Gets or sets the X value of the first control point for a PathSegment
     * of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
     */
    get point1X(): number; */
  // Type InteropStaticType.number
  set point1X(_i2.num value) {
    _i5.setProperty(
      this,
      'point1X',
      value,
    );
  }

  /* #3191
  source: 
    /**
     * Gets or sets the Y value of the first control point for a PathSegment
     * of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
     */
    get point1Y(): number; */
  /// Gets or sets the Y value of the first control point for a PathSegment
  /// of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
  _i2.num get point1Y => _i5.getProperty(
        this,
        'point1Y',
      );
  /* #3191
  source: 
    /**
     * Gets or sets the Y value of the first control point for a PathSegment
     * of type PathSegment.Bezier|Bezier or PathSegment.QuadraticBezier|QuadraticBezier.
     */
    get point1Y(): number; */
  // Type InteropStaticType.number
  set point1Y(_i2.num value) {
    _i5.setProperty(
      this,
      'point1Y',
      value,
    );
  }

  /* #3197
  source: 
    /**
     * Gets or sets the X value of the second control point for a PathSegment
     * of type cubic PathSegment.Bezier|Bezier.
     */
    get point2X(): number; */
  /// Gets or sets the X value of the second control point for a PathSegment
  /// of type cubic PathSegment.Bezier|Bezier.
  _i2.num get point2X => _i5.getProperty(
        this,
        'point2X',
      );
  /* #3197
  source: 
    /**
     * Gets or sets the X value of the second control point for a PathSegment
     * of type cubic PathSegment.Bezier|Bezier.
     */
    get point2X(): number; */
  // Type InteropStaticType.number
  set point2X(_i2.num value) {
    _i5.setProperty(
      this,
      'point2X',
      value,
    );
  }

  /* #3203
  source: 
    /**
     * Gets or sets the Y value of the second control point for a PathSegment
     * of type cubic PathSegment.Bezier|Bezier.
     */
    get point2Y(): number; */
  /// Gets or sets the Y value of the second control point for a PathSegment
  /// of type cubic PathSegment.Bezier|Bezier.
  _i2.num get point2Y => _i5.getProperty(
        this,
        'point2Y',
      );
  /* #3203
  source: 
    /**
     * Gets or sets the Y value of the second control point for a PathSegment
     * of type cubic PathSegment.Bezier|Bezier.
     */
    get point2Y(): number; */
  // Type InteropStaticType.number
  set point2Y(_i2.num value) {
    _i5.setProperty(
      this,
      'point2Y',
      value,
    );
  }

  /* #3208
  source: 
    /**
     * Gets or sets the center X value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
     */
    get centerX(): number; */
  /// Gets or sets the center X value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
  _i2.num get centerX => _i5.getProperty(
        this,
        'centerX',
      );
  /* #3208
  source: 
    /**
     * Gets or sets the center X value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
     */
    get centerX(): number; */
  // Type InteropStaticType.number
  set centerX(_i2.num value) {
    _i5.setProperty(
      this,
      'centerX',
      value,
    );
  }

  /* #3213
  source: 
    /**
     * Gets or sets the center Y value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
     */
    get centerY(): number; */
  /// Gets or sets the center Y value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
  _i2.num get centerY => _i5.getProperty(
        this,
        'centerY',
      );
  /* #3213
  source: 
    /**
     * Gets or sets the center Y value of the Arc for a PathSegment of type PathSegment.Arc|Arc.
     */
    get centerY(): number; */
  // Type InteropStaticType.number
  set centerY(_i2.num value) {
    _i5.setProperty(
      this,
      'centerY',
      value,
    );
  }

  /* #3219
  source: 
    /**
     * Gets or sets the X value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
     * Value must be a positive number.
     */
    get radiusX(): number; */
  /// Gets or sets the X value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
  /// Value must be a positive number.
  _i2.num get radiusX => _i5.getProperty(
        this,
        'radiusX',
      );
  /* #3219
  source: 
    /**
     * Gets or sets the X value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
     * Value must be a positive number.
     */
    get radiusX(): number; */
  // Type InteropStaticType.number
  set radiusX(_i2.num value) {
    _i5.setProperty(
      this,
      'radiusX',
      value,
    );
  }

  /* #3225
  source: 
    /**
     * Gets or sets the Y value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
     * Value must be a positive number.
     */
    get radiusY(): number; */
  /// Gets or sets the Y value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
  /// Value must be a positive number.
  _i2.num get radiusY => _i5.getProperty(
        this,
        'radiusY',
      );
  /* #3225
  source: 
    /**
     * Gets or sets the Y value of the radius for a PathSegment of type PathSegment.Arc|Arc or PathSegment.SvgArc|SvgArc.
     * Value must be a positive number.
     */
    get radiusY(): number; */
  // Type InteropStaticType.number
  set radiusY(_i2.num value) {
    _i5.setProperty(
      this,
      'radiusY',
      value,
    );
  }

  /* #3231
  source: 
    /**
     * Gets or sets the starting angle for a PathSegment of type PathSegment.Arc|Arc.
     * Value must within the range: (0 <= value < 360).
     */
    get startAngle(): number; */
  /// Gets or sets the starting angle for a PathSegment of type PathSegment.Arc|Arc.
  /// Value must within the range: (0 <= value < 360).
  _i2.num get startAngle => _i5.getProperty(
        this,
        'startAngle',
      );
  /* #3231
  source: 
    /**
     * Gets or sets the starting angle for a PathSegment of type PathSegment.Arc|Arc.
     * Value must within the range: (0 <= value < 360).
     */
    get startAngle(): number; */
  // Type InteropStaticType.number
  set startAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'startAngle',
      value,
    );
  }

  /* #3237
  source: 
    /**
     * Gets or sets the length of angle in degrees, or amount of arc to "sweep" for a PathSegment of type PathSegment.Arc|Arc.
     * Must be between -360 and 360, inclusive.
     */
    get sweepAngle(): number; */
  /// Gets or sets the length of angle in degrees, or amount of arc to "sweep" for a PathSegment of type PathSegment.Arc|Arc.
  /// Must be between -360 and 360, inclusive.
  _i2.num get sweepAngle => _i5.getProperty(
        this,
        'sweepAngle',
      );
  /* #3237
  source: 
    /**
     * Gets or sets the length of angle in degrees, or amount of arc to "sweep" for a PathSegment of type PathSegment.Arc|Arc.
     * Must be between -360 and 360, inclusive.
     */
    get sweepAngle(): number; */
  // Type InteropStaticType.number
  set sweepAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'sweepAngle',
      value,
    );
  }

  /* #3249
  source: 
    /**
     * Gets or sets the clockwise-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
     * The parameters allow for two potential ellipses and four potential arcs.
     * A clockwise-flag set to true will use one of the two possible positive-angle arcs,
     * and false will use one of the two negative-angle arcs. Which arc is chosen (small or large)
     * depends on the value of #isLargeArc.
     * For more information see the visual examples in the
     * <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     */
    get isClockwiseArc(): boolean; */
  /// Gets or sets the clockwise-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
  /// SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
  /// The parameters allow for two potential ellipses and four potential arcs.
  /// A clockwise-flag set to true will use one of the two possible positive-angle arcs,
  /// and false will use one of the two negative-angle arcs. Which arc is chosen (small or large)
  /// depends on the value of #isLargeArc.
  /// For more information see the visual examples in the
  /// <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
  _i2.bool get isClockwiseArc => _i5.getProperty(
        this,
        'isClockwiseArc',
      );
  /* #3249
  source: 
    /**
     * Gets or sets the clockwise-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
     * The parameters allow for two potential ellipses and four potential arcs.
     * A clockwise-flag set to true will use one of the two possible positive-angle arcs,
     * and false will use one of the two negative-angle arcs. Which arc is chosen (small or large)
     * depends on the value of #isLargeArc.
     * For more information see the visual examples in the
     * <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     */
    get isClockwiseArc(): boolean; */
  // Type InteropStaticType.boolean
  set isClockwiseArc(_i2.bool value) {
    _i5.setProperty(
      this,
      'isClockwiseArc',
      value,
    );
  }

  /* #3260
  source: 
    /**
     * Gets or sets the large-arc-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
     * The parameters allow for two potential ellipses and four potential arcs.
     * A large-arc-flag set to true will choose the larger of the two arc sweeps.
     * Which way the arc sweeps (positive angle or negative angle) depends on the value of #isClockwiseArc
     * For more information see the visual examples in the
     * <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     */
    get isLargeArc(): boolean; */
  /// Gets or sets the large-arc-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
  /// SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
  /// The parameters allow for two potential ellipses and four potential arcs.
  /// A large-arc-flag set to true will choose the larger of the two arc sweeps.
  /// Which way the arc sweeps (positive angle or negative angle) depends on the value of #isClockwiseArc
  /// For more information see the visual examples in the
  /// <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
  _i2.bool get isLargeArc => _i5.getProperty(
        this,
        'isLargeArc',
      );
  /* #3260
  source: 
    /**
     * Gets or sets the large-arc-flag for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * SVG Arcs specify a radius and an endpoint, and are always a portion of an ellipse.
     * The parameters allow for two potential ellipses and four potential arcs.
     * A large-arc-flag set to true will choose the larger of the two arc sweeps.
     * Which way the arc sweeps (positive angle or negative angle) depends on the value of #isClockwiseArc
     * For more information see the visual examples in the
     * <a href="https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands">SVG Arc specification (w3.org)</a>
     */
    get isLargeArc(): boolean; */
  // Type InteropStaticType.boolean
  set isLargeArc(_i2.bool value) {
    _i5.setProperty(
      this,
      'isLargeArc',
      value,
    );
  }

  /* #3268
  source: 
    /**
     * Gets or sets the X-axis rotation for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * X-axis rotation is used to rotate the ellipse that the arc is created from,
     * and must be between 0 and 360 degrees.
     * Default is 0.
     */
    get xAxisRotation(): number; */
  /// Gets or sets the X-axis rotation for a PathSegment of type PathSegment.SvgArc|SvgArc.
  /// X-axis rotation is used to rotate the ellipse that the arc is created from,
  /// and must be between 0 and 360 degrees.
  /// Default is 0.
  _i2.num get xAxisRotation => _i5.getProperty(
        this,
        'xAxisRotation',
      );
  /* #3268
  source: 
    /**
     * Gets or sets the X-axis rotation for a PathSegment of type PathSegment.SvgArc|SvgArc.
     * X-axis rotation is used to rotate the ellipse that the arc is created from,
     * and must be between 0 and 360 degrees.
     * Default is 0.
     */
    get xAxisRotation(): number; */
  // Type InteropStaticType.number
  set xAxisRotation(_i2.num value) {
    _i5.setProperty(
      this,
      'xAxisRotation',
      value,
    );
  }

  _i3.PathSegment copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.bool equalsApprox(_i3.PathSegment s) => _i5.callMethod(
        this,
        'equalsApprox',
        [s],
      );
  _i3.PathSegment close() => _i5.callMethod(
        this,
        'close',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class InputEvent {
  factory InputEvent() => _i5.callConstructor(
        _declaredInputEvent,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('InputEvent')
external _i2.Object _declaredInputEvent;

extension InputEvent$Typings on InputEvent {
  /* #3315
  source: 
    /**
     * Gets the source diagram associated with the event.
     */
    get diagram(): Diagram; */
  /// Gets the source diagram associated with the event.
  _i3.Diagram get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #3315
  source: 
    /**
     * Gets the source diagram associated with the event.
     */
    get diagram(): Diagram; */
  // Type Instance of 'InteropInterface'
  set diagram(_i3.Diagram value) {
    _i5.setProperty(
      this,
      'diagram',
      value,
    );
  }

  /* #3326
  source: 
    /**
     * Gets or sets the point at which this input event occurred.
     * The Point is in view coordinates within the viewport, not in document coordinates.
     * This should be valid for mouse events.
     * For keyboard events, this is the last available mouse point.
     * @see #documentPoint
     * @see Diagram#transformViewToDoc
     * @see Diagram#transformDocToView
     */
    get viewPoint(): Point; */
  /// Gets or sets the point at which this input event occurred.
  /// The Point is in view coordinates within the viewport, not in document coordinates.
  /// This should be valid for mouse events.
  /// For keyboard events, this is the last available mouse point.
  _i3.Point get viewPoint => _i5.getProperty(
        this,
        'viewPoint',
      );
  /* #3326
  source: 
    /**
     * Gets or sets the point at which this input event occurred.
     * The Point is in view coordinates within the viewport, not in document coordinates.
     * This should be valid for mouse events.
     * For keyboard events, this is the last available mouse point.
     * @see #documentPoint
     * @see Diagram#transformViewToDoc
     * @see Diagram#transformDocToView
     */
    get viewPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set viewPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'viewPoint',
      value,
    );
  }

  /* #3338
  source: 
    /**
     * Gets or sets the point at which this input event occurred, in document coordinates.
     * The Point is in document coordinates, the same as the GraphObject#position
     * for Parts in the diagram.
     * This should be valid for mouse events.
     * For keyboard events, this is the last available mouse point.
     * @see #viewPoint
     * @see Diagram#transformViewToDoc
     * @see Diagram#transformDocToView
     */
    get documentPoint(): Point; */
  /// Gets or sets the point at which this input event occurred, in document coordinates.
  /// The Point is in document coordinates, the same as the GraphObject#position
  /// for Parts in the diagram.
  /// This should be valid for mouse events.
  /// For keyboard events, this is the last available mouse point.
  _i3.Point get documentPoint => _i5.getProperty(
        this,
        'documentPoint',
      );
  /* #3338
  source: 
    /**
     * Gets or sets the point at which this input event occurred, in document coordinates.
     * The Point is in document coordinates, the same as the GraphObject#position
     * for Parts in the diagram.
     * This should be valid for mouse events.
     * For keyboard events, this is the last available mouse point.
     * @see #viewPoint
     * @see Diagram#transformViewToDoc
     * @see Diagram#transformDocToView
     */
    get documentPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set documentPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'documentPoint',
      value,
    );
  }

  /* #3348
  source: 
    /**
     * Gets or sets the modifier keys that were used with the mouse or keyboard event.
     * The number will be a combination of flags representing Control, Shift, Alt or Meta.
     * @see #control
     * @see #shift
     * @see #alt
     * @see #meta
     */
    get modifiers(): number; */
  /// Gets or sets the modifier keys that were used with the mouse or keyboard event.
  /// The number will be a combination of flags representing Control, Shift, Alt or Meta.
  _i2.num get modifiers => _i5.getProperty(
        this,
        'modifiers',
      );
  /* #3348
  source: 
    /**
     * Gets or sets the modifier keys that were used with the mouse or keyboard event.
     * The number will be a combination of flags representing Control, Shift, Alt or Meta.
     * @see #control
     * @see #shift
     * @see #alt
     * @see #meta
     */
    get modifiers(): number; */
  // Type InteropStaticType.number
  set modifiers(_i2.num value) {
    _i5.setProperty(
      this,
      'modifiers',
      value,
    );
  }

  /* #3378
  source: 
    /**
     * Gets or sets the numerical value representing the mouse button that caused this event.
     *
     * Only one mouse button can cause an event at a time,
     * but the set of all buttons currently pressed is kept in #buttons.
     *
     * This property describes nothing during a `mousemove` event,
     * since no button press causes the event. Instead, use the convenience properties
     * #left, #middle, or #right, or use the value
     * of #buttons to determine which mouse buttons are
     * held during `mousemove` events.
     *
     * Common values for this property:
     *   - 0: left mouse button
     *   - 1: middle mouse button
     *   - 2: right mouse button
     *
     * Other values are possible if the mouse has additional buttons.
     *
     * If there is no associated #event, setting this also
     * sets the #buttons flags to only this button.
     *
     * This property is valid if this is a mouse event.
     * @see #buttons
     * @see #left
     * @see #middle
     * @see #right
     */
    get button(): number; */
  /// Gets or sets the numerical value representing the mouse button that caused this event.
  ///
  /// Only one mouse button can cause an event at a time,
  /// but the set of all buttons currently pressed is kept in #buttons.
  ///
  /// This property describes nothing during a `mousemove` event,
  /// since no button press causes the event. Instead, use the convenience properties
  /// #left, #middle, or #right, or use the value
  /// of #buttons to determine which mouse buttons are
  /// held during `mousemove` events.
  ///
  /// Common values for this property:
  ///   - 0: left mouse button
  ///   - 1: middle mouse button
  ///   - 2: right mouse button
  ///
  /// Other values are possible if the mouse has additional buttons.
  ///
  /// If there is no associated #event, setting this also
  /// sets the #buttons flags to only this button.
  ///
  /// This property is valid if this is a mouse event.
  _i2.num get button => _i5.getProperty(
        this,
        'button',
      );
  /* #3378
  source: 
    /**
     * Gets or sets the numerical value representing the mouse button that caused this event.
     *
     * Only one mouse button can cause an event at a time,
     * but the set of all buttons currently pressed is kept in #buttons.
     *
     * This property describes nothing during a `mousemove` event,
     * since no button press causes the event. Instead, use the convenience properties
     * #left, #middle, or #right, or use the value
     * of #buttons to determine which mouse buttons are
     * held during `mousemove` events.
     *
     * Common values for this property:
     *   - 0: left mouse button
     *   - 1: middle mouse button
     *   - 2: right mouse button
     *
     * Other values are possible if the mouse has additional buttons.
     *
     * If there is no associated #event, setting this also
     * sets the #buttons flags to only this button.
     *
     * This property is valid if this is a mouse event.
     * @see #buttons
     * @see #left
     * @see #middle
     * @see #right
     */
    get button(): number; */
  // Type InteropStaticType.number
  set button(_i2.num value) {
    _i5.setProperty(
      this,
      'button',
      value,
    );
  }

  /* #3403
  source: 
    /**
     * Gets or sets the set of buttons that are currently being held down.
     * If this is a `mouseup` event, this set of buttons does not include
     * the button that was just released, which will be the value of #button.
     *
     * Common values for this property:
     *   - 0: not holding down any button
     *   - 1: left mouse button
     *   - 2: right mouse button
     *   - 3: both left and right mouse buttons
     *   - 4: middle mouse button
     *   - 5: middle and left mouse buttons
     *   - 6: middle and right mouse buttons
     *   - 7: all three common mouse buttons
     *
     * Other values are possible if the mouse has additional buttons.
     *
     * This property is valid if this is a mouse event.
     * @see #button
     * @see #left
     * @see #middle
     * @see #right
     */
    get buttons(): number; */
  /// Gets or sets the set of buttons that are currently being held down.
  /// If this is a `mouseup` event, this set of buttons does not include
  /// the button that was just released, which will be the value of #button.
  ///
  /// Common values for this property:
  ///   - 0: not holding down any button
  ///   - 1: left mouse button
  ///   - 2: right mouse button
  ///   - 3: both left and right mouse buttons
  ///   - 4: middle mouse button
  ///   - 5: middle and left mouse buttons
  ///   - 6: middle and right mouse buttons
  ///   - 7: all three common mouse buttons
  ///
  /// Other values are possible if the mouse has additional buttons.
  ///
  /// This property is valid if this is a mouse event.
  _i2.num get buttons => _i5.getProperty(
        this,
        'buttons',
      );
  /* #3403
  source: 
    /**
     * Gets or sets the set of buttons that are currently being held down.
     * If this is a `mouseup` event, this set of buttons does not include
     * the button that was just released, which will be the value of #button.
     *
     * Common values for this property:
     *   - 0: not holding down any button
     *   - 1: left mouse button
     *   - 2: right mouse button
     *   - 3: both left and right mouse buttons
     *   - 4: middle mouse button
     *   - 5: middle and left mouse buttons
     *   - 6: middle and right mouse buttons
     *   - 7: all three common mouse buttons
     *
     * Other values are possible if the mouse has additional buttons.
     *
     * This property is valid if this is a mouse event.
     * @see #button
     * @see #left
     * @see #middle
     * @see #right
     */
    get buttons(): number; */
  // Type InteropStaticType.number
  set buttons(_i2.num value) {
    _i5.setProperty(
      this,
      'buttons',
      value,
    );
  }

  /* #3409
  source: 
    /**
     * Gets or sets the key pressed or released as this event.
     * This property is valid if this is a keyboard event.
     */
    get key(): string; */
  /// Gets or sets the key pressed or released as this event.
  /// This property is valid if this is a keyboard event.
  _i2.String get key => _i5.getProperty(
        this,
        'key',
      );
  /* #3409
  source: 
    /**
     * Gets or sets the key pressed or released as this event.
     * This property is valid if this is a keyboard event.
     */
    get key(): string; */
  // Type InteropStaticType.string
  set key(_i2.String value) {
    _i5.setProperty(
      this,
      'key',
      value,
    );
  }

  /* #3416
  source: 
    /**
     * Gets or sets whether the InputEvent represents a mouse-down or a key-down event.
     * The default value is false.
     * @since 1.1
     */
    get down(): boolean; */
  /// Gets or sets whether the InputEvent represents a mouse-down or a key-down event.
  /// The default value is false.
  _i2.bool get down => _i5.getProperty(
        this,
        'down',
      );
  /* #3416
  source: 
    /**
     * Gets or sets whether the InputEvent represents a mouse-down or a key-down event.
     * The default value is false.
     * @since 1.1
     */
    get down(): boolean; */
  // Type InteropStaticType.boolean
  set down(_i2.bool value) {
    _i5.setProperty(
      this,
      'down',
      value,
    );
  }

  /* #3423
  source: 
    /**
     * Gets or sets whether the InputEvent represents a mouse-up or a key-up event.
     * The default value is false.
     * @since 1.1
     */
    get up(): boolean; */
  /// Gets or sets whether the InputEvent represents a mouse-up or a key-up event.
  /// The default value is false.
  _i2.bool get up => _i5.getProperty(
        this,
        'up',
      );
  /* #3423
  source: 
    /**
     * Gets or sets whether the InputEvent represents a mouse-up or a key-up event.
     * The default value is false.
     * @since 1.1
     */
    get up(): boolean; */
  // Type InteropStaticType.boolean
  set up(_i2.bool value) {
    _i5.setProperty(
      this,
      'up',
      value,
    );
  }

  /* #3430
  source: 
    /**
     * Gets or sets whether this event represents a click or a double-click.
     * It is zero if not a click; one if a single-click; two if a double-click.
     * This property is valid if this is a mouse event.
     */
    get clickCount(): number; */
  /// Gets or sets whether this event represents a click or a double-click.
  /// It is zero if not a click; one if a single-click; two if a double-click.
  /// This property is valid if this is a mouse event.
  _i2.num get clickCount => _i5.getProperty(
        this,
        'clickCount',
      );
  /* #3430
  source: 
    /**
     * Gets or sets whether this event represents a click or a double-click.
     * It is zero if not a click; one if a single-click; two if a double-click.
     * This property is valid if this is a mouse event.
     */
    get clickCount(): number; */
  // Type InteropStaticType.number
  set clickCount(_i2.num value) {
    _i5.setProperty(
      this,
      'clickCount',
      value,
    );
  }

  /* #3437
  source: 
    /**
     * Gets or sets the amount of change associated with a mouse-wheel rotation.
     * It is an abstract number, either positive or negative.
     * This property is valid if this is a mouse-wheel event.
     */
    get delta(): number; */
  /// Gets or sets the amount of change associated with a mouse-wheel rotation.
  /// It is an abstract number, either positive or negative.
  /// This property is valid if this is a mouse-wheel event.
  _i2.num get delta => _i5.getProperty(
        this,
        'delta',
      );
  /* #3437
  source: 
    /**
     * Gets or sets the amount of change associated with a mouse-wheel rotation.
     * It is an abstract number, either positive or negative.
     * This property is valid if this is a mouse-wheel event.
     */
    get delta(): number; */
  // Type InteropStaticType.number
  set delta(_i2.num value) {
    _i5.setProperty(
      this,
      'delta',
      value,
    );
  }

  /* #3444
  source: 
    /**
     * This property is true when the InputEvent is caused by a touch event that registered more than one touch.
     * @see #isTouchEvent
     * @since 1.5
     */
    get isMultiTouch(): boolean; */
  /// This property is true when the InputEvent is caused by a touch event that registered more than one touch.
  _i2.bool get isMultiTouch => _i5.getProperty(
        this,
        'isMultiTouch',
      );
  /* #3444
  source: 
    /**
     * This property is true when the InputEvent is caused by a touch event that registered more than one touch.
     * @see #isTouchEvent
     * @since 1.5
     */
    get isMultiTouch(): boolean; */
  // Type InteropStaticType.boolean
  set isMultiTouch(_i2.bool value) {
    _i5.setProperty(
      this,
      'isMultiTouch',
      value,
    );
  }

  /* #3453
  source: 
    /**
     * Gets or sets whether an InputEvent that applies to a GraphObject and bubbles
     * up the chain of containing Panels is stopped from continuing up the chain.
     *
     * Some event handlers may set this to true to avoid getting any behavior from the containing Panels.
     * The default value is false.
     */
    get handled(): boolean; */
  /// Gets or sets whether an InputEvent that applies to a GraphObject and bubbles
  /// up the chain of containing Panels is stopped from continuing up the chain.
  ///
  /// Some event handlers may set this to true to avoid getting any behavior from the containing Panels.
  /// The default value is false.
  _i2.bool get handled => _i5.getProperty(
        this,
        'handled',
      );
  /* #3453
  source: 
    /**
     * Gets or sets whether an InputEvent that applies to a GraphObject and bubbles
     * up the chain of containing Panels is stopped from continuing up the chain.
     *
     * Some event handlers may set this to true to avoid getting any behavior from the containing Panels.
     * The default value is false.
     */
    get handled(): boolean; */
  // Type InteropStaticType.boolean
  set handled(_i2.bool value) {
    _i5.setProperty(
      this,
      'handled',
      value,
    );
  }

  /* #3467
  source: 
    /**
     * Gets or sets whether the underlying #event is prevented from bubbling up
     * the hierarchy of HTML elements outside of the Diagram and whether any default action is canceled.
     * Setting this is uncommon, but may be needed in some CommandHandler overrides in order to
     * pass along events, such as keystrokes, to parent elements of the Diagram.
     *
     * Some event handlers may set this to true if the event should continue beyond the diagram's DIV
     * and result in any default behaviors by the user-agent.
     * The default value is false.
     * @since 2.2
     * @see #handled
     */
    get bubbles(): boolean; */
  /// Gets or sets whether the underlying #event is prevented from bubbling up
  /// the hierarchy of HTML elements outside of the Diagram and whether any default action is canceled.
  /// Setting this is uncommon, but may be needed in some CommandHandler overrides in order to
  /// pass along events, such as keystrokes, to parent elements of the Diagram.
  ///
  /// Some event handlers may set this to true if the event should continue beyond the diagram's DIV
  /// and result in any default behaviors by the user-agent.
  /// The default value is false.
  _i2.bool get bubbles => _i5.getProperty(
        this,
        'bubbles',
      );
  /* #3467
  source: 
    /**
     * Gets or sets whether the underlying #event is prevented from bubbling up
     * the hierarchy of HTML elements outside of the Diagram and whether any default action is canceled.
     * Setting this is uncommon, but may be needed in some CommandHandler overrides in order to
     * pass along events, such as keystrokes, to parent elements of the Diagram.
     *
     * Some event handlers may set this to true if the event should continue beyond the diagram's DIV
     * and result in any default behaviors by the user-agent.
     * The default value is false.
     * @since 2.2
     * @see #handled
     */
    get bubbles(): boolean; */
  // Type InteropStaticType.boolean
  set bubbles(_i2.bool value) {
    _i5.setProperty(
      this,
      'bubbles',
      value,
    );
  }

  /* #3474
  source: 
    /**
     * Gets or sets the platform's user-agent-supplied event for this event.
     * It may be null if no underlying event exists.
     * @see #timestamp
     */
    get event(): Event | null; */
  /// Gets or sets the platform's user-agent-supplied event for this event.
  /// It may be null if no underlying event exists.
  _i4.Event? get event => _i5.getProperty(
        this,
        'event',
      );
  /* #3474
  source: 
    /**
     * Gets or sets the platform's user-agent-supplied event for this event.
     * It may be null if no underlying event exists.
     * @see #timestamp
     */
    get event(): Event | null; */
  // Type InteropUnion#207854424(parent: InteropGetter#206094612(name: event))
  set event(_i4.Event? value) {
    _i5.setProperty(
      this,
      'event',
      value ?? _i4.undefined,
    );
  }

  /* #3481
  source: 
    /**
     * This read-only property is true when the InputEvent is caused by a touch event.
     * @see #isMultiTouch
     * @since 1.5
     */
    get isTouchEvent(): boolean; */
  /// This read-only property is true when the InputEvent is caused by a touch event.
  _i2.bool get isTouchEvent => _i5.getProperty(
        this,
        'isTouchEvent',
      );
  /* #3481
  source: 
    /**
     * This read-only property is true when the InputEvent is caused by a touch event.
     * @see #isMultiTouch
     * @since 1.5
     */
    get isTouchEvent(): boolean; */
  // Type InteropStaticType.boolean
  set isTouchEvent(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTouchEvent',
      value,
    );
  }

  /* #3485
  source: 
    /**
     * Gets or sets the time at which the event occurred, in milliseconds.
     */
    get timestamp(): number; */
  /// Gets or sets the time at which the event occurred, in milliseconds.
  _i2.num get timestamp => _i5.getProperty(
        this,
        'timestamp',
      );
  /* #3485
  source: 
    /**
     * Gets or sets the time at which the event occurred, in milliseconds.
     */
    get timestamp(): number; */
  // Type InteropStaticType.number
  set timestamp(_i2.num value) {
    _i5.setProperty(
      this,
      'timestamp',
      value,
    );
  }

  /* #3490
  source: 
    /**
     * Gets or sets the diagram associated with the canvas that the event is currently targeting.
     */
    get targetDiagram(): Diagram | null; */
  /// Gets or sets the diagram associated with the canvas that the event is currently targeting.
  _i3.Diagram? get targetDiagram => _i5.getProperty(
        this,
        'targetDiagram',
      );
  /* #3490
  source: 
    /**
     * Gets or sets the diagram associated with the canvas that the event is currently targeting.
     */
    get targetDiagram(): Diagram | null; */
  // Type InteropUnion#659278362(parent: InteropGetter#805329640(name: targetDiagram))
  set targetDiagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'targetDiagram',
      value ?? _i4.undefined,
    );
  }

  /* #3499
  source: 
    /**
     * Gets or sets the GraphObject that is at the current mouse point, if any.
     *
     * For those events that are bubbled up the chain of parent Panels,
     * this property provides access to the original GraphObject where the input event occurred.
     * @see #handled
     */
    get targetObject(): GraphObject | null; */
  /// Gets or sets the GraphObject that is at the current mouse point, if any.
  ///
  /// For those events that are bubbled up the chain of parent Panels,
  /// this property provides access to the original GraphObject where the input event occurred.
  _i3.GraphObject? get targetObject => _i5.getProperty(
        this,
        'targetObject',
      );
  /* #3499
  source: 
    /**
     * Gets or sets the GraphObject that is at the current mouse point, if any.
     *
     * For those events that are bubbled up the chain of parent Panels,
     * this property provides access to the original GraphObject where the input event occurred.
     * @see #handled
     */
    get targetObject(): GraphObject | null; */
  // Type InteropUnion#166703980(parent: InteropGetter#523316111(name: targetObject))
  set targetObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'targetObject',
      value ?? _i4.undefined,
    );
  }

  /* #3509
  source: 
    /**
     * Gets or sets whether the control key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #shift
     * @see #alt
     * @see #meta
     */
    get control(): boolean; */
  /// Gets or sets whether the control key is being held down.
  /// This is true if the key was pressed at the time of the event.
  _i2.bool get control => _i5.getProperty(
        this,
        'control',
      );
  /* #3509
  source: 
    /**
     * Gets or sets whether the control key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #shift
     * @see #alt
     * @see #meta
     */
    get control(): boolean; */
  // Type InteropStaticType.boolean
  set control(_i2.bool value) {
    _i5.setProperty(
      this,
      'control',
      value,
    );
  }

  /* #3519
  source: 
    /**
     * Gets or sets whether the shift key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #alt
     * @see #meta
     */
    get shift(): boolean; */
  /// Gets or sets whether the shift key is being held down.
  /// This is true if the key was pressed at the time of the event.
  _i2.bool get shift => _i5.getProperty(
        this,
        'shift',
      );
  /* #3519
  source: 
    /**
     * Gets or sets whether the shift key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #alt
     * @see #meta
     */
    get shift(): boolean; */
  // Type InteropStaticType.boolean
  set shift(_i2.bool value) {
    _i5.setProperty(
      this,
      'shift',
      value,
    );
  }

  /* #3529
  source: 
    /**
     * Gets or sets whether the alt key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #shift
     * @see #meta
     */
    get alt(): boolean; */
  /// Gets or sets whether the alt key is being held down.
  /// This is true if the key was pressed at the time of the event.
  _i2.bool get alt => _i5.getProperty(
        this,
        'alt',
      );
  /* #3529
  source: 
    /**
     * Gets or sets whether the alt key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #shift
     * @see #meta
     */
    get alt(): boolean; */
  // Type InteropStaticType.boolean
  set alt(_i2.bool value) {
    _i5.setProperty(
      this,
      'alt',
      value,
    );
  }

  /* #3539
  source: 
    /**
     * Gets or sets whether the meta key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #shift
     * @see #alt
     */
    get meta(): boolean; */
  /// Gets or sets whether the meta key is being held down.
  /// This is true if the key was pressed at the time of the event.
  _i2.bool get meta => _i5.getProperty(
        this,
        'meta',
      );
  /* #3539
  source: 
    /**
     * Gets or sets whether the meta key is being held down.
     * This is true if the key was pressed at the time of the event.
     * @see #modifiers
     * @see #control
     * @see #shift
     * @see #alt
     */
    get meta(): boolean; */
  // Type InteropStaticType.boolean
  set meta(_i2.bool value) {
    _i5.setProperty(
      this,
      'meta',
      value,
    );
  }

  /* #3553
  source: 
    /**
     * Gets or sets whether the logical left mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     *
     * If this InputEvent has a #event of type `MouseEvent` with `e.type` of "mouseup" or "mousedown",
     * this property uses the value of #button. Otherwise, it uses the value of #buttons.
     *
     * When setting, this sets the value of #buttons.
     * @see #button
     * @see #middle
     * @see #right
     */
    get left(): boolean; */
  /// Gets or sets whether the logical left mouse button is being held down.
  /// This is true if the button was pressed at the time of the event.
  ///
  /// If this InputEvent has a #event of type `MouseEvent` with `e.type` of "mouseup" or "mousedown",
  /// this property uses the value of #button. Otherwise, it uses the value of #buttons.
  ///
  /// When setting, this sets the value of #buttons.
  _i2.bool get left => _i5.getProperty(
        this,
        'left',
      );
  /* #3553
  source: 
    /**
     * Gets or sets whether the logical left mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     *
     * If this InputEvent has a #event of type `MouseEvent` with `e.type` of "mouseup" or "mousedown",
     * this property uses the value of #button. Otherwise, it uses the value of #buttons.
     *
     * When setting, this sets the value of #buttons.
     * @see #button
     * @see #middle
     * @see #right
     */
    get left(): boolean; */
  // Type InteropStaticType.boolean
  set left(_i2.bool value) {
    _i5.setProperty(
      this,
      'left',
      value,
    );
  }

  /* #3562
  source: 
    /**
     * Gets or sets whether the logical right mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     * @see #button
     * @see #left
     * @see #middle
     */
    get right(): boolean; */
  /// Gets or sets whether the logical right mouse button is being held down.
  /// This is true if the button was pressed at the time of the event.
  _i2.bool get right => _i5.getProperty(
        this,
        'right',
      );
  /* #3562
  source: 
    /**
     * Gets or sets whether the logical right mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     * @see #button
     * @see #left
     * @see #middle
     */
    get right(): boolean; */
  // Type InteropStaticType.boolean
  set right(_i2.bool value) {
    _i5.setProperty(
      this,
      'right',
      value,
    );
  }

  /* #3571
  source: 
    /**
     * Gets or sets whether the logical middle mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     * @see #button
     * @see #left
     * @see #right
     */
    get middle(): boolean; */
  /// Gets or sets whether the logical middle mouse button is being held down.
  /// This is true if the button was pressed at the time of the event.
  _i2.bool get middle => _i5.getProperty(
        this,
        'middle',
      );
  /* #3571
  source: 
    /**
     * Gets or sets whether the logical middle mouse button is being held down.
     * This is true if the button was pressed at the time of the event.
     * @see #button
     * @see #left
     * @see #right
     */
    get middle(): boolean; */
  // Type InteropStaticType.boolean
  set middle(_i2.bool value) {
    _i5.setProperty(
      this,
      'middle',
      value,
    );
  }

  _i3.InputEvent copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class DiagramEvent {
  factory DiagramEvent() => _i5.callConstructor(
        _declaredDiagramEvent,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('DiagramEvent')
external _i2.Object _declaredDiagramEvent;

extension DiagramEvent$Typings on DiagramEvent {
  /* #3735
  source: 
    /**
     * Gets the diagram associated with the event.
     */
    get diagram(): Diagram; */
  /// Gets the diagram associated with the event.
  _i3.Diagram get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #3735
  source: 
    /**
     * Gets the diagram associated with the event.
     */
    get diagram(): Diagram; */
  // Type Instance of 'InteropInterface'
  set diagram(_i3.Diagram value) {
    _i5.setProperty(
      this,
      'diagram',
      value,
    );
  }

  /* #3742
  source: 
    /**
     * Gets or sets the name of the kind of diagram event that this represents.
     * This property should always be set to one of the recognized list of names,
     * as listed in the documentation for DiagramEvent.
     */
    get name(): string; */
  /// Gets or sets the name of the kind of diagram event that this represents.
  /// This property should always be set to one of the recognized list of names,
  /// as listed in the documentation for DiagramEvent.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #3742
  source: 
    /**
     * Gets or sets the name of the kind of diagram event that this represents.
     * This property should always be set to one of the recognized list of names,
     * as listed in the documentation for DiagramEvent.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #3748
  source: 
    /**
     * Gets or sets an optional object that is the subject of the diagram event.
     * This property defaults to null.
     */
    get subject(): any; */
  /// Gets or sets an optional object that is the subject of the diagram event.
  /// This property defaults to null.
  _i2.dynamic get subject => _i5.getProperty(
        this,
        'subject',
      );
  /* #3748
  source: 
    /**
     * Gets or sets an optional object that is the subject of the diagram event.
     * This property defaults to null.
     */
    get subject(): any; */
  // Type InteropStaticType.dyn
  set subject(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'subject',
      value,
    );
  }

  /* #3754
  source: 
    /**
     * Gets or sets an optional object that describes the change to the subject of the diagram event.
     * This property defaults to null.
     */
    get parameter(): any; */
  /// Gets or sets an optional object that describes the change to the subject of the diagram event.
  /// This property defaults to null.
  _i2.dynamic get parameter => _i5.getProperty(
        this,
        'parameter',
      );
  /* #3754
  source: 
    /**
     * Gets or sets an optional object that describes the change to the subject of the diagram event.
     * This property defaults to null.
     */
    get parameter(): any; */
  // Type InteropStaticType.dyn
  set parameter(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'parameter',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class DiagramEventsInterface {
  external factory DiagramEventsInterface._({
    _i2.dynamic animationStarting,
    _i2.dynamic animationFinished,
    _i2.dynamic backgroundSingleClicked,
    _i2.dynamic backgroundDoubleClicked,
    _i2.dynamic backgroundContextClicked,
    _i2.dynamic changingSelection,
    _i2.dynamic changedSelection,
    _i2.dynamic clipboardChanged,
    _i2.dynamic clipboardPasted,
    _i2.dynamic documentBoundsChanged,
    _i2.dynamic externalObjectsDropped,
    _i2.dynamic gainedFocus,
    _i2.dynamic initialLayoutCompleted,
    _i2.dynamic layoutCompleted,
    _i2.dynamic linkDrawn,
    _i2.dynamic linkRelinked,
    _i2.dynamic linkReshaped,
    _i2.dynamic lostFocus,
    _i2.dynamic modified,
    _i2.dynamic objectSingleClicked,
    _i2.dynamic objectDoubleClicked,
    _i2.dynamic objectContextClicked,
    _i2.dynamic partCreated,
    _i2.dynamic partResized,
    _i2.dynamic partRotated,
    _i2.dynamic selectionMoved,
    _i2.dynamic selectionCopied,
    _i2.dynamic selectionDeleted,
    _i2.dynamic selectionDeleting,
    _i2.dynamic selectionGrouped,
    _i2.dynamic selectionUngrouped,
    _i2.dynamic subGraphCollapsed,
    _i2.dynamic subGraphExpanded,
    _i2.dynamic textEdited,
    _i2.dynamic treeCollapsed,
    _i2.dynamic treeExpanded,
    _i2.dynamic viewportBoundsChanged,
  });

  factory DiagramEventsInterface({
    _i3.DiagramEventHandler? animationStarting,
    _i3.DiagramEventHandler? animationFinished,
    _i3.DiagramEventHandler? backgroundSingleClicked,
    _i3.DiagramEventHandler? backgroundDoubleClicked,
    _i3.DiagramEventHandler? backgroundContextClicked,
    _i3.DiagramEventHandler? changingSelection,
    _i3.DiagramEventHandler? changedSelection,
    _i3.DiagramEventHandler? clipboardChanged,
    _i3.DiagramEventHandler? clipboardPasted,
    _i3.DiagramEventHandler? documentBoundsChanged,
    _i3.DiagramEventHandler? externalObjectsDropped,
    _i3.DiagramEventHandler? gainedFocus,
    _i3.DiagramEventHandler? initialLayoutCompleted,
    _i3.DiagramEventHandler? layoutCompleted,
    _i3.DiagramEventHandler? linkDrawn,
    _i3.DiagramEventHandler? linkRelinked,
    _i3.DiagramEventHandler? linkReshaped,
    _i3.DiagramEventHandler? lostFocus,
    _i3.DiagramEventHandler? modified,
    _i3.DiagramEventHandler? objectSingleClicked,
    _i3.DiagramEventHandler? objectDoubleClicked,
    _i3.DiagramEventHandler? objectContextClicked,
    _i3.DiagramEventHandler? partCreated,
    _i3.DiagramEventHandler? partResized,
    _i3.DiagramEventHandler? partRotated,
    _i3.DiagramEventHandler? selectionMoved,
    _i3.DiagramEventHandler? selectionCopied,
    _i3.DiagramEventHandler? selectionDeleted,
    _i3.DiagramEventHandler? selectionDeleting,
    _i3.DiagramEventHandler? selectionGrouped,
    _i3.DiagramEventHandler? selectionUngrouped,
    _i3.DiagramEventHandler? subGraphCollapsed,
    _i3.DiagramEventHandler? subGraphExpanded,
    _i3.DiagramEventHandler? textEdited,
    _i3.DiagramEventHandler? treeCollapsed,
    _i3.DiagramEventHandler? treeExpanded,
    _i3.DiagramEventHandler? viewportBoundsChanged,
  }) =>
      DiagramEventsInterface._(
        animationStarting: animationStarting == null
            ? _i4.undefined
            : _i5.allowInterop(animationStarting),
        animationFinished: animationFinished == null
            ? _i4.undefined
            : _i5.allowInterop(animationFinished),
        backgroundSingleClicked: backgroundSingleClicked == null
            ? _i4.undefined
            : _i5.allowInterop(backgroundSingleClicked),
        backgroundDoubleClicked: backgroundDoubleClicked == null
            ? _i4.undefined
            : _i5.allowInterop(backgroundDoubleClicked),
        backgroundContextClicked: backgroundContextClicked == null
            ? _i4.undefined
            : _i5.allowInterop(backgroundContextClicked),
        changingSelection: changingSelection == null
            ? _i4.undefined
            : _i5.allowInterop(changingSelection),
        changedSelection: changedSelection == null
            ? _i4.undefined
            : _i5.allowInterop(changedSelection),
        clipboardChanged: clipboardChanged == null
            ? _i4.undefined
            : _i5.allowInterop(clipboardChanged),
        clipboardPasted: clipboardPasted == null
            ? _i4.undefined
            : _i5.allowInterop(clipboardPasted),
        documentBoundsChanged: documentBoundsChanged == null
            ? _i4.undefined
            : _i5.allowInterop(documentBoundsChanged),
        externalObjectsDropped: externalObjectsDropped == null
            ? _i4.undefined
            : _i5.allowInterop(externalObjectsDropped),
        gainedFocus:
            gainedFocus == null ? _i4.undefined : _i5.allowInterop(gainedFocus),
        initialLayoutCompleted: initialLayoutCompleted == null
            ? _i4.undefined
            : _i5.allowInterop(initialLayoutCompleted),
        layoutCompleted: layoutCompleted == null
            ? _i4.undefined
            : _i5.allowInterop(layoutCompleted),
        linkDrawn:
            linkDrawn == null ? _i4.undefined : _i5.allowInterop(linkDrawn),
        linkRelinked: linkRelinked == null
            ? _i4.undefined
            : _i5.allowInterop(linkRelinked),
        linkReshaped: linkReshaped == null
            ? _i4.undefined
            : _i5.allowInterop(linkReshaped),
        lostFocus:
            lostFocus == null ? _i4.undefined : _i5.allowInterop(lostFocus),
        modified: modified == null ? _i4.undefined : _i5.allowInterop(modified),
        objectSingleClicked: objectSingleClicked == null
            ? _i4.undefined
            : _i5.allowInterop(objectSingleClicked),
        objectDoubleClicked: objectDoubleClicked == null
            ? _i4.undefined
            : _i5.allowInterop(objectDoubleClicked),
        objectContextClicked: objectContextClicked == null
            ? _i4.undefined
            : _i5.allowInterop(objectContextClicked),
        partCreated:
            partCreated == null ? _i4.undefined : _i5.allowInterop(partCreated),
        partResized:
            partResized == null ? _i4.undefined : _i5.allowInterop(partResized),
        partRotated:
            partRotated == null ? _i4.undefined : _i5.allowInterop(partRotated),
        selectionMoved: selectionMoved == null
            ? _i4.undefined
            : _i5.allowInterop(selectionMoved),
        selectionCopied: selectionCopied == null
            ? _i4.undefined
            : _i5.allowInterop(selectionCopied),
        selectionDeleted: selectionDeleted == null
            ? _i4.undefined
            : _i5.allowInterop(selectionDeleted),
        selectionDeleting: selectionDeleting == null
            ? _i4.undefined
            : _i5.allowInterop(selectionDeleting),
        selectionGrouped: selectionGrouped == null
            ? _i4.undefined
            : _i5.allowInterop(selectionGrouped),
        selectionUngrouped: selectionUngrouped == null
            ? _i4.undefined
            : _i5.allowInterop(selectionUngrouped),
        subGraphCollapsed: subGraphCollapsed == null
            ? _i4.undefined
            : _i5.allowInterop(subGraphCollapsed),
        subGraphExpanded: subGraphExpanded == null
            ? _i4.undefined
            : _i5.allowInterop(subGraphExpanded),
        textEdited:
            textEdited == null ? _i4.undefined : _i5.allowInterop(textEdited),
        treeCollapsed: treeCollapsed == null
            ? _i4.undefined
            : _i5.allowInterop(treeCollapsed),
        treeExpanded: treeExpanded == null
            ? _i4.undefined
            : _i5.allowInterop(treeExpanded),
        viewportBoundsChanged: viewportBoundsChanged == null
            ? _i4.undefined
            : _i5.allowInterop(viewportBoundsChanged),
      );
}

extension DiagramEventsInterface$Typings on DiagramEventsInterface {
  /* #3769
  source: 
    AnimationStarting?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get animationStarting => _i5.getProperty(
        this,
        'AnimationStarting',
      );
  /* #3769
  source: 
    AnimationStarting?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set animationStarting(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'AnimationStarting',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3770
  source: 
    AnimationFinished?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get animationFinished => _i5.getProperty(
        this,
        'AnimationFinished',
      );
  /* #3770
  source: 
    AnimationFinished?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set animationFinished(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'AnimationFinished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3771
  source: 
    BackgroundSingleClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get backgroundSingleClicked => _i5.getProperty(
        this,
        'BackgroundSingleClicked',
      );
  /* #3771
  source: 
    BackgroundSingleClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set backgroundSingleClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'BackgroundSingleClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3772
  source: 
    BackgroundDoubleClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get backgroundDoubleClicked => _i5.getProperty(
        this,
        'BackgroundDoubleClicked',
      );
  /* #3772
  source: 
    BackgroundDoubleClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set backgroundDoubleClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'BackgroundDoubleClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3773
  source: 
    BackgroundContextClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get backgroundContextClicked => _i5.getProperty(
        this,
        'BackgroundContextClicked',
      );
  /* #3773
  source: 
    BackgroundContextClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set backgroundContextClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'BackgroundContextClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3774
  source: 
    ChangingSelection?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get changingSelection => _i5.getProperty(
        this,
        'ChangingSelection',
      );
  /* #3774
  source: 
    ChangingSelection?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set changingSelection(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ChangingSelection',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3775
  source: 
    ChangedSelection?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get changedSelection => _i5.getProperty(
        this,
        'ChangedSelection',
      );
  /* #3775
  source: 
    ChangedSelection?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set changedSelection(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ChangedSelection',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3776
  source: 
    ClipboardChanged?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get clipboardChanged => _i5.getProperty(
        this,
        'ClipboardChanged',
      );
  /* #3776
  source: 
    ClipboardChanged?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set clipboardChanged(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ClipboardChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3777
  source: 
    ClipboardPasted?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get clipboardPasted => _i5.getProperty(
        this,
        'ClipboardPasted',
      );
  /* #3777
  source: 
    ClipboardPasted?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set clipboardPasted(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ClipboardPasted',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3778
  source: 
    DocumentBoundsChanged?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get documentBoundsChanged => _i5.getProperty(
        this,
        'DocumentBoundsChanged',
      );
  /* #3778
  source: 
    DocumentBoundsChanged?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set documentBoundsChanged(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'DocumentBoundsChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3779
  source: 
    ExternalObjectsDropped?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get externalObjectsDropped => _i5.getProperty(
        this,
        'ExternalObjectsDropped',
      );
  /* #3779
  source: 
    ExternalObjectsDropped?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set externalObjectsDropped(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ExternalObjectsDropped',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3780
  source: 
    GainedFocus?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get gainedFocus => _i5.getProperty(
        this,
        'GainedFocus',
      );
  /* #3780
  source: 
    GainedFocus?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set gainedFocus(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'GainedFocus',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3781
  source: 
    InitialLayoutCompleted?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get initialLayoutCompleted => _i5.getProperty(
        this,
        'InitialLayoutCompleted',
      );
  /* #3781
  source: 
    InitialLayoutCompleted?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set initialLayoutCompleted(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'InitialLayoutCompleted',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3782
  source: 
    LayoutCompleted?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get layoutCompleted => _i5.getProperty(
        this,
        'LayoutCompleted',
      );
  /* #3782
  source: 
    LayoutCompleted?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set layoutCompleted(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'LayoutCompleted',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3783
  source: 
    LinkDrawn?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get linkDrawn => _i5.getProperty(
        this,
        'LinkDrawn',
      );
  /* #3783
  source: 
    LinkDrawn?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set linkDrawn(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'LinkDrawn',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3784
  source: 
    LinkRelinked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get linkRelinked => _i5.getProperty(
        this,
        'LinkRelinked',
      );
  /* #3784
  source: 
    LinkRelinked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set linkRelinked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'LinkRelinked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3785
  source: 
    LinkReshaped?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get linkReshaped => _i5.getProperty(
        this,
        'LinkReshaped',
      );
  /* #3785
  source: 
    LinkReshaped?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set linkReshaped(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'LinkReshaped',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3786
  source: 
    LostFocus?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get lostFocus => _i5.getProperty(
        this,
        'LostFocus',
      );
  /* #3786
  source: 
    LostFocus?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set lostFocus(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'LostFocus',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3787
  source: 
    Modified?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get modified => _i5.getProperty(
        this,
        'Modified',
      );
  /* #3787
  source: 
    Modified?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set modified(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'Modified',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3788
  source: 
    ObjectSingleClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get objectSingleClicked => _i5.getProperty(
        this,
        'ObjectSingleClicked',
      );
  /* #3788
  source: 
    ObjectSingleClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set objectSingleClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ObjectSingleClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3789
  source: 
    ObjectDoubleClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get objectDoubleClicked => _i5.getProperty(
        this,
        'ObjectDoubleClicked',
      );
  /* #3789
  source: 
    ObjectDoubleClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set objectDoubleClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ObjectDoubleClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3790
  source: 
    ObjectContextClicked?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get objectContextClicked => _i5.getProperty(
        this,
        'ObjectContextClicked',
      );
  /* #3790
  source: 
    ObjectContextClicked?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set objectContextClicked(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ObjectContextClicked',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3791
  source: 
    PartCreated?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get partCreated => _i5.getProperty(
        this,
        'PartCreated',
      );
  /* #3791
  source: 
    PartCreated?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set partCreated(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'PartCreated',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3792
  source: 
    PartResized?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get partResized => _i5.getProperty(
        this,
        'PartResized',
      );
  /* #3792
  source: 
    PartResized?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set partResized(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'PartResized',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3793
  source: 
    PartRotated?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get partRotated => _i5.getProperty(
        this,
        'PartRotated',
      );
  /* #3793
  source: 
    PartRotated?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set partRotated(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'PartRotated',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3794
  source: 
    SelectionMoved?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionMoved => _i5.getProperty(
        this,
        'SelectionMoved',
      );
  /* #3794
  source: 
    SelectionMoved?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionMoved(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionMoved',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3795
  source: 
    SelectionCopied?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionCopied => _i5.getProperty(
        this,
        'SelectionCopied',
      );
  /* #3795
  source: 
    SelectionCopied?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionCopied(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionCopied',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3796
  source: 
    SelectionDeleted?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionDeleted => _i5.getProperty(
        this,
        'SelectionDeleted',
      );
  /* #3796
  source: 
    SelectionDeleted?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionDeleted(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionDeleted',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3797
  source: 
    SelectionDeleting?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionDeleting => _i5.getProperty(
        this,
        'SelectionDeleting',
      );
  /* #3797
  source: 
    SelectionDeleting?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionDeleting(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionDeleting',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3798
  source: 
    SelectionGrouped?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionGrouped => _i5.getProperty(
        this,
        'SelectionGrouped',
      );
  /* #3798
  source: 
    SelectionGrouped?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionGrouped(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionGrouped',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3799
  source: 
    SelectionUngrouped?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get selectionUngrouped => _i5.getProperty(
        this,
        'SelectionUngrouped',
      );
  /* #3799
  source: 
    SelectionUngrouped?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set selectionUngrouped(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SelectionUngrouped',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3800
  source: 
    SubGraphCollapsed?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get subGraphCollapsed => _i5.getProperty(
        this,
        'SubGraphCollapsed',
      );
  /* #3800
  source: 
    SubGraphCollapsed?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set subGraphCollapsed(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SubGraphCollapsed',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3801
  source: 
    SubGraphExpanded?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get subGraphExpanded => _i5.getProperty(
        this,
        'SubGraphExpanded',
      );
  /* #3801
  source: 
    SubGraphExpanded?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set subGraphExpanded(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'SubGraphExpanded',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3802
  source: 
    TextEdited?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get textEdited => _i5.getProperty(
        this,
        'TextEdited',
      );
  /* #3802
  source: 
    TextEdited?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set textEdited(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'TextEdited',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3803
  source: 
    TreeCollapsed?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get treeCollapsed => _i5.getProperty(
        this,
        'TreeCollapsed',
      );
  /* #3803
  source: 
    TreeCollapsed?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set treeCollapsed(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'TreeCollapsed',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3804
  source: 
    TreeExpanded?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get treeExpanded => _i5.getProperty(
        this,
        'TreeExpanded',
      );
  /* #3804
  source: 
    TreeExpanded?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set treeExpanded(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'TreeExpanded',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #3805
  source: 
    ViewportBoundsChanged?: DiagramEventHandler; */
  _i3.DiagramEventHandler? get viewportBoundsChanged => _i5.getProperty(
        this,
        'ViewportBoundsChanged',
      );
  /* #3805
  source: 
    ViewportBoundsChanged?: DiagramEventHandler; */
  // Type InteropTypedef#253355606(name: DiagramEventHandler)
  set viewportBoundsChanged(_i3.DiagramEventHandler? value) {
    _i5.setProperty(
      this,
      'ViewportBoundsChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ChangedEvent {
  factory ChangedEvent() => _i5.callConstructor(
        _declaredChangedEvent,
        [],
      );

  /* #3912
  source: 
    /**
     * For informational events, such as transactions and undo/redo operations,
     * and used as the value for ChangedEvent#change.
     * The ChangedEvent#object refers to the Transaction affected, if any.
     * The ChangedEvent#propertyName distinguishes the different transaction or undo or redo stages.
     * The ChangedEvent#oldValue may provide the transaction name, if available, as given to UndoManager#commitTransaction.
     * @constant
     */
    static Transaction: EnumValue; */
  /// For informational events, such as transactions and undo/redo operations,
  /// and used as the value for ChangedEvent#change.
  /// The ChangedEvent#object refers to the Transaction affected, if any.
  /// The ChangedEvent#propertyName distinguishes the different transaction or undo or redo stages.
  /// The ChangedEvent#oldValue may provide the transaction name, if available, as given to UndoManager#commitTransaction.
  static _i3.EnumValue get transaction => _i5.getProperty(
        _declaredChangedEvent,
        'Transaction',
      );
  /* #3912
  source: 
    /**
     * For informational events, such as transactions and undo/redo operations,
     * and used as the value for ChangedEvent#change.
     * The ChangedEvent#object refers to the Transaction affected, if any.
     * The ChangedEvent#propertyName distinguishes the different transaction or undo or redo stages.
     * The ChangedEvent#oldValue may provide the transaction name, if available, as given to UndoManager#commitTransaction.
     * @constant
     */
    static Transaction: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set transaction(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredChangedEvent,
      'Transaction',
      value,
    );
  }

  /* #3923
  source: 
    /**
     * For simple property changes,
     * and used as the value for ChangedEvent#change.
     * The name of the property is given by ChangedEvent#propertyName.
     * The modified object is given by ChangedEvent#object.
     * Use the ChangedEvent#oldValue and ChangedEvent#newValue properties for the previous and next property values.
     *
     * For model changes, the ChangedEvent#modelChange may be non-empty, indicating a structural change to the model.
     * @constant
     */
    static Property: EnumValue; */
  /// For simple property changes,
  /// and used as the value for ChangedEvent#change.
  /// The name of the property is given by ChangedEvent#propertyName.
  /// The modified object is given by ChangedEvent#object.
  /// Use the ChangedEvent#oldValue and ChangedEvent#newValue properties for the previous and next property values.
  ///
  /// For model changes, the ChangedEvent#modelChange may be non-empty, indicating a structural change to the model.
  static _i3.EnumValue get property => _i5.getProperty(
        _declaredChangedEvent,
        'Property',
      );
  /* #3923
  source: 
    /**
     * For simple property changes,
     * and used as the value for ChangedEvent#change.
     * The name of the property is given by ChangedEvent#propertyName.
     * The modified object is given by ChangedEvent#object.
     * Use the ChangedEvent#oldValue and ChangedEvent#newValue properties for the previous and next property values.
     *
     * For model changes, the ChangedEvent#modelChange may be non-empty, indicating a structural change to the model.
     * @constant
     */
    static Property: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set property(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredChangedEvent,
      'Property',
      value,
    );
  }

  /* #3933
  source: 
    /**
     * For inserting into collections,
     * and used as the value for ChangedEvent#change.
     * The modified object is given by ChangedEvent#object.
     * Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
     * Use the ChangedEvent#newValue property to indicate the value that was inserted.
     * Use the optional ChangedEvent#newParam property to indicate where or how, such as an array index or dictionary key.
     * @constant
     */
    static Insert: EnumValue; */
  /// For inserting into collections,
  /// and used as the value for ChangedEvent#change.
  /// The modified object is given by ChangedEvent#object.
  /// Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
  /// Use the ChangedEvent#newValue property to indicate the value that was inserted.
  /// Use the optional ChangedEvent#newParam property to indicate where or how, such as an array index or dictionary key.
  static _i3.EnumValue get insert => _i5.getProperty(
        _declaredChangedEvent,
        'Insert',
      );
  /* #3933
  source: 
    /**
     * For inserting into collections,
     * and used as the value for ChangedEvent#change.
     * The modified object is given by ChangedEvent#object.
     * Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
     * Use the ChangedEvent#newValue property to indicate the value that was inserted.
     * Use the optional ChangedEvent#newParam property to indicate where or how, such as an array index or dictionary key.
     * @constant
     */
    static Insert: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set insert(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredChangedEvent,
      'Insert',
      value,
    );
  }

  /* #3943
  source: 
    /**
     * For removing from collections,
     * and used as the value for ChangedEvent#change.
     * The modified object is given by ChangedEvent#object.
     * Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
     * Use the ChangedEvent#oldValue property to indicate the value that was removed.
     * Use the optional ChangedEvent#oldParam property to indicate where or how, such as an array index or dictionary key.
     * @constant
     */
    static Remove: EnumValue; */
  /// For removing from collections,
  /// and used as the value for ChangedEvent#change.
  /// The modified object is given by ChangedEvent#object.
  /// Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
  /// Use the ChangedEvent#oldValue property to indicate the value that was removed.
  /// Use the optional ChangedEvent#oldParam property to indicate where or how, such as an array index or dictionary key.
  static _i3.EnumValue get remove => _i5.getProperty(
        _declaredChangedEvent,
        'Remove',
      );
  /* #3943
  source: 
    /**
     * For removing from collections,
     * and used as the value for ChangedEvent#change.
     * The modified object is given by ChangedEvent#object.
     * Use the optional ChangedEvent#propertyName to distinguish between different collections on the object.
     * Use the ChangedEvent#oldValue property to indicate the value that was removed.
     * Use the optional ChangedEvent#oldParam property to indicate where or how, such as an array index or dictionary key.
     * @constant
     */
    static Remove: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set remove(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredChangedEvent,
      'Remove',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('ChangedEvent')
external _i2.Object _declaredChangedEvent;

extension ChangedEvent$Typings on ChangedEvent {
  /* #3994
  source: 
    /**
     * Gets or sets the Model or TreeModel or GraphLinksModel that was modified.
     * When this property is non-null, the #diagram property will be null.
     * However this property and the #diagram property may both be null simultaneously,
     * when no particular model or diagram applies.
     */
    get model(): Model | null; */
  /// Gets or sets the Model or TreeModel or GraphLinksModel that was modified.
  /// When this property is non-null, the #diagram property will be null.
  /// However this property and the #diagram property may both be null simultaneously,
  /// when no particular model or diagram applies.
  _i3.Model? get model => _i5.getProperty(
        this,
        'model',
      );
  /* #3994
  source: 
    /**
     * Gets or sets the Model or TreeModel or GraphLinksModel that was modified.
     * When this property is non-null, the #diagram property will be null.
     * However this property and the #diagram property may both be null simultaneously,
     * when no particular model or diagram applies.
     */
    get model(): Model | null; */
  // Type InteropUnion#1070634688(parent: InteropGetter#113405966(name: model))
  set model(_i3.Model? value) {
    _i5.setProperty(
      this,
      'model',
      value ?? _i4.undefined,
    );
  }

  /* #4002
  source: 
    /**
     * Gets or sets the Diagram that was modified.
     * When this property is non-null, the #model property will be null.
     * However this property and the #model property may both be null simultaneously,
     * when no particular model or diagram applies.
     */
    get diagram(): Diagram | null; */
  /// Gets or sets the Diagram that was modified.
  /// When this property is non-null, the #model property will be null.
  /// However this property and the #model property may both be null simultaneously,
  /// when no particular model or diagram applies.
  _i3.Diagram? get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #4002
  source: 
    /**
     * Gets or sets the Diagram that was modified.
     * When this property is non-null, the #model property will be null.
     * However this property and the #model property may both be null simultaneously,
     * when no particular model or diagram applies.
     */
    get diagram(): Diagram | null; */
  // Type InteropUnion#853201526(parent: InteropGetter#275683063(name: diagram))
  set diagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'diagram',
      value ?? _i4.undefined,
    );
  }

  /* #4010
  source: 
    /**
     * Gets or sets the nature of change that occurred.
     * The default is ChangedEvent.Property.
     * Other values are ChangedEvent.Insert, ChangedEvent.Remove,
     * and ChangedEvent.Transaction.
     */
    get change(): EnumValue; */
  /// Gets or sets the nature of change that occurred.
  /// The default is ChangedEvent.Property.
  /// Other values are ChangedEvent.Insert, ChangedEvent.Remove,
  /// and ChangedEvent.Transaction.
  _i3.EnumValue get change => _i5.getProperty(
        this,
        'change',
      );
  /* #4010
  source: 
    /**
     * Gets or sets the nature of change that occurred.
     * The default is ChangedEvent.Property.
     * Other values are ChangedEvent.Insert, ChangedEvent.Remove,
     * and ChangedEvent.Transaction.
     */
    get change(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set change(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'change',
      value,
    );
  }

  /* #4021
  source: 
    /**
     * Gets or sets the name of the model change, reflecting a change to
     * model data in addition to a change to the model itself.
     *
     * The default is an empty string, which indicates that this is just
     * a regular change to some object's state, probably its property.
     * For a list of possible model change names, see the documentation for ChangedEvent.
     * The names are compared in a case-sensitive manner.
     */
    get modelChange(): string; */
  /// Gets or sets the name of the model change, reflecting a change to
  /// model data in addition to a change to the model itself.
  ///
  /// The default is an empty string, which indicates that this is just
  /// a regular change to some object's state, probably its property.
  /// For a list of possible model change names, see the documentation for ChangedEvent.
  /// The names are compared in a case-sensitive manner.
  _i2.String get modelChange => _i5.getProperty(
        this,
        'modelChange',
      );
  /* #4021
  source: 
    /**
     * Gets or sets the name of the model change, reflecting a change to
     * model data in addition to a change to the model itself.
     *
     * The default is an empty string, which indicates that this is just
     * a regular change to some object's state, probably its property.
     * For a list of possible model change names, see the documentation for ChangedEvent.
     * The names are compared in a case-sensitive manner.
     */
    get modelChange(): string; */
  // Type InteropStaticType.string
  set modelChange(_i2.String value) {
    _i5.setProperty(
      this,
      'modelChange',
      value,
    );
  }

  /* #4032
  source: 
    /**
     * Gets or sets the name of the property change.
     * The default is an empty string, which is not a valid property name.
     * This property can be useful even when the type of change is
     * not ChangedEvent.Property, because it can help identify
     * the collection in the #object that was modified
     * (for ChangedEvent.Insert or ChangedEvent.Remove)
     * or the stage of the current transaction (for ChangedEvent.Transaction).
     */
    get propertyName(): string | ((a: ObjectData, b: any) => any); */
  /// Gets or sets the name of the property change.
  /// The default is an empty string, which is not a valid property name.
  /// This property can be useful even when the type of change is
  /// not ChangedEvent.Property, because it can help identify
  /// the collection in the #object that was modified
  /// (for ChangedEvent.Insert or ChangedEvent.Remove)
  /// or the stage of the current transaction (for ChangedEvent.Transaction).
  _i2.Object get propertyName => _i5.getProperty(
        this,
        'propertyName',
      );
  /* #4032
  source: 
    /**
     * Gets or sets the name of the property change.
     * The default is an empty string, which is not a valid property name.
     * This property can be useful even when the type of change is
     * not ChangedEvent.Property, because it can help identify
     * the collection in the #object that was modified
     * (for ChangedEvent.Insert or ChangedEvent.Remove)
     * or the stage of the current transaction (for ChangedEvent.Transaction).
     */
    get propertyName(): string | ((a: ObjectData, b: any) => any); */
  // Type InteropUnion#39408788(parent: InteropGetter#834248505(name: propertyName))
  set propertyName(_i2.Object value) {
    _i5.setProperty(
      this,
      'propertyName',
      value,
    );
  }

  /* #4044
  source: 
    /**
     * This read-only property is true when this ChangedEvent is of type ChangedEvent.Transaction and represents the end of a transactional change.
     * It is implemented as:
     * ```js
     * return (this.change === ChangedEvent.Transaction &&
     *         (this.propertyName === "CommittedTransaction" ||
     *          this.propertyName === "FinishedUndo" ||
     *          this.propertyName === "FinishedRedo"));
     * ```
     */
    get isTransactionFinished(): boolean; */
  /// This read-only property is true when this ChangedEvent is of type ChangedEvent.Transaction and represents the end of a transactional change.
  /// It is implemented as:
  /// ```js
  /// return (this.change === ChangedEvent.Transaction &&
  ///         (this.propertyName === "CommittedTransaction" ||
  ///          this.propertyName === "FinishedUndo" ||
  ///          this.propertyName === "FinishedRedo"));
  /// ```
  _i2.bool get isTransactionFinished => _i5.getProperty(
        this,
        'isTransactionFinished',
      );
  /* #4044
  source: 
    /**
     * This read-only property is true when this ChangedEvent is of type ChangedEvent.Transaction and represents the end of a transactional change.
     * It is implemented as:
     * ```js
     * return (this.change === ChangedEvent.Transaction &&
     *         (this.propertyName === "CommittedTransaction" ||
     *          this.propertyName === "FinishedUndo" ||
     *          this.propertyName === "FinishedRedo"));
     * ```
     */
    get isTransactionFinished(): boolean; */
  // Type InteropStaticType.boolean
  set isTransactionFinished(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTransactionFinished',
      value,
    );
  }

  /* #4051
  source: 
    /**
     * Gets or sets the Object that was modified.
     * The default is null.
     *
     * For ChangedEvent.Transaction changes, this may be the Transaction.
     */
    get object(): ObjectData | null; */
  /// Gets or sets the Object that was modified.
  /// The default is null.
  ///
  /// For ChangedEvent.Transaction changes, this may be the Transaction.
  _i2.Object? get object => _i5.getProperty(
        this,
        'object',
      );
  /* #4051
  source: 
    /**
     * Gets or sets the Object that was modified.
     * The default is null.
     *
     * For ChangedEvent.Transaction changes, this may be the Transaction.
     */
    get object(): ObjectData | null; */
  // Type InteropUnion#202123629(parent: InteropGetter#875502647(name: object))
  set object(_i2.Object? value) {
    _i5.setProperty(
      this,
      'object',
      value ?? _i4.undefined,
    );
  }

  /* #4057
  source: 
    /**
     * Gets or sets the previous or old value that the property had.
     * The default is null.
     */
    get oldValue(): any; */
  /// Gets or sets the previous or old value that the property had.
  /// The default is null.
  _i2.dynamic get oldValue => _i5.getProperty(
        this,
        'oldValue',
      );
  /* #4057
  source: 
    /**
     * Gets or sets the previous or old value that the property had.
     * The default is null.
     */
    get oldValue(): any; */
  // Type InteropStaticType.dyn
  set oldValue(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'oldValue',
      value,
    );
  }

  /* #4066
  source: 
    /**
     * Gets or sets an optional value associated with the old value.
     * Most properties do not require any parameter to describe the change.
     * This is typically a value that helps distinguish the old value, such as an index into an array.
     * It is null if it is not used.
     * The default is null.
     */
    get oldParam(): any; */
  /// Gets or sets an optional value associated with the old value.
  /// Most properties do not require any parameter to describe the change.
  /// This is typically a value that helps distinguish the old value, such as an index into an array.
  /// It is null if it is not used.
  /// The default is null.
  _i2.dynamic get oldParam => _i5.getProperty(
        this,
        'oldParam',
      );
  /* #4066
  source: 
    /**
     * Gets or sets an optional value associated with the old value.
     * Most properties do not require any parameter to describe the change.
     * This is typically a value that helps distinguish the old value, such as an index into an array.
     * It is null if it is not used.
     * The default is null.
     */
    get oldParam(): any; */
  // Type InteropStaticType.dyn
  set oldParam(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'oldParam',
      value,
    );
  }

  /* #4072
  source: 
    /**
     * Gets or sets the next or current value that the property has.
     * The default is null.
     */
    get newValue(): any; */
  /// Gets or sets the next or current value that the property has.
  /// The default is null.
  _i2.dynamic get newValue => _i5.getProperty(
        this,
        'newValue',
      );
  /* #4072
  source: 
    /**
     * Gets or sets the next or current value that the property has.
     * The default is null.
     */
    get newValue(): any; */
  // Type InteropStaticType.dyn
  set newValue(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'newValue',
      value,
    );
  }

  /* #4081
  source: 
    /**
     * Gets or sets an optional value associated with the new value.
     * Most properties do not require any parameter to describe the change.
     * This is typically a value that helps distinguish the new value, such as an index into an array.
     * It is null if it is not used.
     * The default is null.
     */
    get newParam(): any; */
  /// Gets or sets an optional value associated with the new value.
  /// Most properties do not require any parameter to describe the change.
  /// This is typically a value that helps distinguish the new value, such as an index into an array.
  /// It is null if it is not used.
  /// The default is null.
  _i2.dynamic get newParam => _i5.getProperty(
        this,
        'newParam',
      );
  /* #4081
  source: 
    /**
     * Gets or sets an optional value associated with the new value.
     * Most properties do not require any parameter to describe the change.
     * This is typically a value that helps distinguish the new value, such as an index into an array.
     * It is null if it is not used.
     * The default is null.
     */
    get newParam(): any; */
  // Type InteropStaticType.dyn
  set newParam(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'newParam',
      value,
    );
  }

  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i3.ChangedEvent copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i2.dynamic getValue(_i2.bool undo) => _i5.callMethod(
        this,
        'getValue',
        [undo],
      );
  _i2.dynamic getParam(_i2.bool undo) => _i5.callMethod(
        this,
        'getParam',
        [undo],
      );
  _i2.bool canUndo() => _i5.callMethod(
        this,
        'canUndo',
        [],
      );
  void undo() {
    _i5.callMethod(
      this,
      'undo',
      [],
    );
  }

  _i2.bool canRedo() => _i5.callMethod(
        this,
        'canRedo',
        [],
      );
  void redo() {
    _i5.callMethod(
      this,
      'redo',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Transaction {
  factory Transaction() => _i5.callConstructor(
        _declaredTransaction,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Transaction')
external _i2.Object _declaredTransaction;

extension Transaction$Typings on Transaction {
  /* #4160
  source: 
    /**
     * This read-only property returns the list of ChangedEvents.
     * The changes are stored in order of occurrence.
     *
     * You should not modify this list.
     */
    get changes(): List<ChangedEvent>; */
  /// This read-only property returns the list of ChangedEvents.
  /// The changes are stored in order of occurrence.
  ///
  /// You should not modify this list.
  _i3.List /*LIST InteropClass#847625641(name: List),330668975,[Instance of 'InteropRef<InteropType>']*/ <_i3.ChangedEvent>
      get changes => _i5.getProperty(
            this,
            'changes',
          );
  /* #4160
  source: 
    /**
     * This read-only property returns the list of ChangedEvents.
     * The changes are stored in order of occurrence.
     *
     * You should not modify this list.
     */
    get changes(): List<ChangedEvent>; */
  // Type Instance of 'InteropInterface'
  set changes(
      _i3.List /*LIST InteropClass#847625641(name: List),920850035,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.ChangedEvent>
          value) {
    _i5.setProperty(
      this,
      'changes',
      value,
    );
  }

  /* #4165
  source: 
    /**
     * Gets or sets the transaction name for this collection of changes.
     * This is set by a top-level call to UndoManager#commitTransaction.
     */
    get name(): string; */
  /// Gets or sets the transaction name for this collection of changes.
  /// This is set by a top-level call to UndoManager#commitTransaction.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #4165
  source: 
    /**
     * Gets or sets the transaction name for this collection of changes.
     * This is set by a top-level call to UndoManager#commitTransaction.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #4172
  source: 
    /**
     * Gets or sets whether we can add more ChangedEvents to this list of changes.
     * This is initially false.
     * It is set to true by UndoManager#commitTransaction and UndoManager#rollbackTransaction.
     */
    get isComplete(): boolean; */
  /// Gets or sets whether we can add more ChangedEvents to this list of changes.
  /// This is initially false.
  /// It is set to true by UndoManager#commitTransaction and UndoManager#rollbackTransaction.
  _i2.bool get isComplete => _i5.getProperty(
        this,
        'isComplete',
      );
  /* #4172
  source: 
    /**
     * Gets or sets whether we can add more ChangedEvents to this list of changes.
     * This is initially false.
     * It is set to true by UndoManager#commitTransaction and UndoManager#rollbackTransaction.
     */
    get isComplete(): boolean; */
  // Type InteropStaticType.boolean
  set isComplete(_i2.bool value) {
    _i5.setProperty(
      this,
      'isComplete',
      value,
    );
  }

  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i2.bool canUndo() => _i5.callMethod(
        this,
        'canUndo',
        [],
      );
  void undo() {
    _i5.callMethod(
      this,
      'undo',
      [],
    );
  }

  _i2.bool canRedo() => _i5.callMethod(
        this,
        'canRedo',
        [],
      );
  void redo() {
    _i5.callMethod(
      this,
      'redo',
      [],
    );
  }

  void optimize() {
    _i5.callMethod(
      this,
      'optimize',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class UndoManager {
  factory UndoManager() => _i5.callConstructor(
        _declaredUndoManager,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('UndoManager')
external _i2.Object _declaredUndoManager;

extension UndoManager$Typings on UndoManager {
  /* #4417
  source: 
    /**
     * This read-only property returns an iterator for all of the Models that this UndoManager is handling.
     * @see #addModel
     * @see #removeModel
     */
    get models(): Iterator<Model>; */
  /// This read-only property returns an iterator for all of the Models that this UndoManager is handling.
  _i3.Iterator<_i3.Model> get models => _i5.getProperty(
        this,
        'models',
      );
  /* #4417
  source: 
    /**
     * This read-only property returns an iterator for all of the Models that this UndoManager is handling.
     * @see #addModel
     * @see #removeModel
     */
    get models(): Iterator<Model>; */
  // Type Instance of 'InteropInterface'
  set models(_i3.Iterator<_i3.Model> value) {
    _i5.setProperty(
      this,
      'models',
      value,
    );
  }

  /* #4426
  source: 
    /**
     * Gets or sets whether this UndoManager records any changes.
     * The default value is false -- you need to set this to true if
     * you want the user to be able to undo or redo.
     *
     * You can temporarily turn off recording by setting Diagram#skipsUndoManager
     * and Model#skipsUndoManager to true.
     */
    get isEnabled(): boolean; */
  /// Gets or sets whether this UndoManager records any changes.
  /// The default value is false -- you need to set this to true if
  /// you want the user to be able to undo or redo.
  ///
  /// You can temporarily turn off recording by setting Diagram#skipsUndoManager
  /// and Model#skipsUndoManager to true.
  _i2.bool get isEnabled => _i5.getProperty(
        this,
        'isEnabled',
      );
  /* #4426
  source: 
    /**
     * Gets or sets whether this UndoManager records any changes.
     * The default value is false -- you need to set this to true if
     * you want the user to be able to undo or redo.
     *
     * You can temporarily turn off recording by setting Diagram#skipsUndoManager
     * and Model#skipsUndoManager to true.
     */
    get isEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEnabled',
      value,
    );
  }

  /* #4433
  source: 
    /**
     * This read-only property returns the Transaction in the #history to be undone next.
     * The value may be null if the UndoManager is not ready to perform an undo.
     * @see #transactionToRedo
     */
    get transactionToUndo(): Transaction | null; */
  /// This read-only property returns the Transaction in the #history to be undone next.
  /// The value may be null if the UndoManager is not ready to perform an undo.
  _i3.Transaction? get transactionToUndo => _i5.getProperty(
        this,
        'transactionToUndo',
      );
  /* #4433
  source: 
    /**
     * This read-only property returns the Transaction in the #history to be undone next.
     * The value may be null if the UndoManager is not ready to perform an undo.
     * @see #transactionToRedo
     */
    get transactionToUndo(): Transaction | null; */
  // Type InteropUnion#731442573(parent: InteropGetter#143790439(name: transactionToUndo))
  set transactionToUndo(_i3.Transaction? value) {
    _i5.setProperty(
      this,
      'transactionToUndo',
      value ?? _i4.undefined,
    );
  }

  /* #4439
  source: 
    /**
     * This read-only property returns the Transaction in the #history to be redone next.
     * The value may be null if the UndoManager is not ready to perform a redo.
     * @see #transactionToUndo
     */
    get transactionToRedo(): Transaction | null; */
  /// This read-only property returns the Transaction in the #history to be redone next.
  /// The value may be null if the UndoManager is not ready to perform a redo.
  _i3.Transaction? get transactionToRedo => _i5.getProperty(
        this,
        'transactionToRedo',
      );
  /* #4439
  source: 
    /**
     * This read-only property returns the Transaction in the #history to be redone next.
     * The value may be null if the UndoManager is not ready to perform a redo.
     * @see #transactionToUndo
     */
    get transactionToRedo(): Transaction | null; */
  // Type InteropUnion#1012668661(parent: InteropGetter#1002645242(name: transactionToRedo))
  set transactionToRedo(_i3.Transaction? value) {
    _i5.setProperty(
      this,
      'transactionToRedo',
      value ?? _i4.undefined,
    );
  }

  /* #4443
  source: 
    /**
     * This read-only property is true during a call to #undo or #redo.
     */
    get isUndoingRedoing(): boolean; */
  /// This read-only property is true during a call to #undo or #redo.
  _i2.bool get isUndoingRedoing => _i5.getProperty(
        this,
        'isUndoingRedoing',
      );
  /* #4443
  source: 
    /**
     * This read-only property is true during a call to #undo or #redo.
     */
    get isUndoingRedoing(): boolean; */
  // Type InteropStaticType.boolean
  set isUndoingRedoing(_i2.bool value) {
    _i5.setProperty(
      this,
      'isUndoingRedoing',
      value,
    );
  }

  /* #4450
  source: 
    /**
     * This read-only property returns the whole history, a list of all of the Transactions,
     * each representing a transaction with some number of ChangedEvents.
     *
     * You should not modify this List.
     */
    get history(): List<Transaction>; */
  /// This read-only property returns the whole history, a list of all of the Transactions,
  /// each representing a transaction with some number of ChangedEvents.
  ///
  /// You should not modify this List.
  _i3.List /*LIST InteropClass#847625641(name: List),696561512,[Instance of 'InteropRef<InteropType>']*/ <_i3.Transaction>
      get history => _i5.getProperty(
            this,
            'history',
          );
  /* #4450
  source: 
    /**
     * This read-only property returns the whole history, a list of all of the Transactions,
     * each representing a transaction with some number of ChangedEvents.
     *
     * You should not modify this List.
     */
    get history(): List<Transaction>; */
  // Type Instance of 'InteropInterface'
  set history(
      _i3.List /*LIST InteropClass#847625641(name: List),83893042,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Transaction>
          value) {
    _i5.setProperty(
      this,
      'history',
      value,
    );
  }

  /* #4468
  source: 
    /**
     * Gets or sets the maximum number of transactions that this undo manager will remember.
     * When a transaction is committed and the number exceeds this value,
     * the UndoManager will discard the oldest transaction(s) in order to meet this limit.
     * The initial value is 999.
     * Any new value must be an integer.
     * A negative value is treated as if there were no limit.
     * A zero value will not remember any Transactions in the #history,
     * but will allow commits and rollbacks to occur normally,
     * including raising "Transaction" type ChangedEvents.
     *
     * This property is useful in helping limit the memory consumption of typical applications.
     * But this does not limit the number of ChangedEvents that are recorded,
     * because there may be an unlimited number of those within each Transaction.
     * Decreasing this value will not necessarily remove any existing Transactions
     * if there currently exist more in #history than the new value permits.
     */
    get maxHistoryLength(): number; */
  /// Gets or sets the maximum number of transactions that this undo manager will remember.
  /// When a transaction is committed and the number exceeds this value,
  /// the UndoManager will discard the oldest transaction(s) in order to meet this limit.
  /// The initial value is 999.
  /// Any new value must be an integer.
  /// A negative value is treated as if there were no limit.
  /// A zero value will not remember any Transactions in the #history,
  /// but will allow commits and rollbacks to occur normally,
  /// including raising "Transaction" type ChangedEvents.
  ///
  /// This property is useful in helping limit the memory consumption of typical applications.
  /// But this does not limit the number of ChangedEvents that are recorded,
  /// because there may be an unlimited number of those within each Transaction.
  /// Decreasing this value will not necessarily remove any existing Transactions
  /// if there currently exist more in #history than the new value permits.
  _i2.num get maxHistoryLength => _i5.getProperty(
        this,
        'maxHistoryLength',
      );
  /* #4468
  source: 
    /**
     * Gets or sets the maximum number of transactions that this undo manager will remember.
     * When a transaction is committed and the number exceeds this value,
     * the UndoManager will discard the oldest transaction(s) in order to meet this limit.
     * The initial value is 999.
     * Any new value must be an integer.
     * A negative value is treated as if there were no limit.
     * A zero value will not remember any Transactions in the #history,
     * but will allow commits and rollbacks to occur normally,
     * including raising "Transaction" type ChangedEvents.
     *
     * This property is useful in helping limit the memory consumption of typical applications.
     * But this does not limit the number of ChangedEvents that are recorded,
     * because there may be an unlimited number of those within each Transaction.
     * Decreasing this value will not necessarily remove any existing Transactions
     * if there currently exist more in #history than the new value permits.
     */
    get maxHistoryLength(): number; */
  // Type InteropStaticType.number
  set maxHistoryLength(_i2.num value) {
    _i5.setProperty(
      this,
      'maxHistoryLength',
      value,
    );
  }

  /* #4474
  source: 
    /**
     * This read-only property returns the index into #history for the current undoable Transaction.
     * The value is -1 if there is no undoable Transaction to be undone.
     */
    get historyIndex(): number; */
  /// This read-only property returns the index into #history for the current undoable Transaction.
  /// The value is -1 if there is no undoable Transaction to be undone.
  _i2.num get historyIndex => _i5.getProperty(
        this,
        'historyIndex',
      );
  /* #4474
  source: 
    /**
     * This read-only property returns the index into #history for the current undoable Transaction.
     * The value is -1 if there is no undoable Transaction to be undone.
     */
    get historyIndex(): number; */
  // Type InteropStaticType.number
  set historyIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'historyIndex',
      value,
    );
  }

  /* #4482
  source: 
    /**
     * This read-only property returns the current Transaction for recording additional model change events.
     * This is initialized and augmented by #handleChanged
     * before it is added to #history by a top-level call
     * to #commitTransaction.
     * The value will be null between transactions.
     */
    get currentTransaction(): Transaction | null; */
  /// This read-only property returns the current Transaction for recording additional model change events.
  /// This is initialized and augmented by #handleChanged
  /// before it is added to #history by a top-level call
  /// to #commitTransaction.
  /// The value will be null between transactions.
  _i3.Transaction? get currentTransaction => _i5.getProperty(
        this,
        'currentTransaction',
      );
  /* #4482
  source: 
    /**
     * This read-only property returns the current Transaction for recording additional model change events.
     * This is initialized and augmented by #handleChanged
     * before it is added to #history by a top-level call
     * to #commitTransaction.
     * The value will be null between transactions.
     */
    get currentTransaction(): Transaction | null; */
  // Type InteropUnion#176521688(parent: InteropGetter#810557719(name: currentTransaction))
  set currentTransaction(_i3.Transaction? value) {
    _i5.setProperty(
      this,
      'currentTransaction',
      value ?? _i4.undefined,
    );
  }

  /* #4493
  source: 
    /**
     * This read-only property returns the current transaction level.
     * The value is zero when there is no ongoing transaction.
     * The initial value is zero.
     * #startTransaction will increment this value;
     * #commitTransaction or #rollbackTransaction will decrement it.
     * When this value is greater than zero, #canUndo
     * and #canRedo will be false, because
     * additional logically related model change events may occur.
     */
    get transactionLevel(): number; */
  /// This read-only property returns the current transaction level.
  /// The value is zero when there is no ongoing transaction.
  /// The initial value is zero.
  /// #startTransaction will increment this value;
  /// #commitTransaction or #rollbackTransaction will decrement it.
  /// When this value is greater than zero, #canUndo
  /// and #canRedo will be false, because
  /// additional logically related model change events may occur.
  _i2.num get transactionLevel => _i5.getProperty(
        this,
        'transactionLevel',
      );
  /* #4493
  source: 
    /**
     * This read-only property returns the current transaction level.
     * The value is zero when there is no ongoing transaction.
     * The initial value is zero.
     * #startTransaction will increment this value;
     * #commitTransaction or #rollbackTransaction will decrement it.
     * When this value is greater than zero, #canUndo
     * and #canRedo will be false, because
     * additional logically related model change events may occur.
     */
    get transactionLevel(): number; */
  // Type InteropStaticType.number
  set transactionLevel(_i2.num value) {
    _i5.setProperty(
      this,
      'transactionLevel',
      value,
    );
  }

  /* #4501
  source: 
    /**
     * This read-only property is true after the first call to #startTransaction
     * and before a corresponding call to #commitTransaction or #rollbackTransaction.
     *
     * During a transaction #canUndo and #canRedo will be false.
     * #currentTransaction may be non-null if any ChangedEvents were recorded.
     */
    get isInTransaction(): boolean; */
  /// This read-only property is true after the first call to #startTransaction
  /// and before a corresponding call to #commitTransaction or #rollbackTransaction.
  ///
  /// During a transaction #canUndo and #canRedo will be false.
  /// #currentTransaction may be non-null if any ChangedEvents were recorded.
  _i2.bool get isInTransaction => _i5.getProperty(
        this,
        'isInTransaction',
      );
  /* #4501
  source: 
    /**
     * This read-only property is true after the first call to #startTransaction
     * and before a corresponding call to #commitTransaction or #rollbackTransaction.
     *
     * During a transaction #canUndo and #canRedo will be false.
     * #currentTransaction may be non-null if any ChangedEvents were recorded.
     */
    get isInTransaction(): boolean; */
  // Type InteropStaticType.boolean
  set isInTransaction(_i2.bool value) {
    _i5.setProperty(
      this,
      'isInTransaction',
      value,
    );
  }

  /* #4511
  source: 
    /**
     * This read-only property returns a stack of ongoing transaction names.
     * The outermost transaction name will be the first item in the list.
     * The last one will be the name of the most recent (nested) call
     * to #startTransaction.
     *
     * You should not modify this List.
     */
    get nestedTransactionNames(): List<string>; */
  /// This read-only property returns a stack of ongoing transaction names.
  /// The outermost transaction name will be the first item in the list.
  /// The last one will be the name of the most recent (nested) call
  /// to #startTransaction.
  ///
  /// You should not modify this List.
  _i3.List /*LIST InteropClass#847625641(name: List),871931907,[Instance of 'InteropRef<InteropType>']*/ <_i2.String>
      get nestedTransactionNames => _i5.getProperty(
            this,
            'nestedTransactionNames',
          );
  /* #4511
  source: 
    /**
     * This read-only property returns a stack of ongoing transaction names.
     * The outermost transaction name will be the first item in the list.
     * The last one will be the name of the most recent (nested) call
     * to #startTransaction.
     *
     * You should not modify this List.
     */
    get nestedTransactionNames(): List<string>; */
  // Type Instance of 'InteropInterface'
  set nestedTransactionNames(
      _i3.List /*LIST InteropClass#847625641(name: List),969157865,[Instance of 'InteropRef<InteropType>']*/ <
              _i2.String>
          value) {
    _i5.setProperty(
      this,
      'nestedTransactionNames',
      value,
    );
  }

  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  void copyProperties(_i3.UndoManager old) {
    _i5.callMethod(
      this,
      'copyProperties',
      [old],
    );
  }

  void addModel(_i3.Model model) {
    _i5.callMethod(
      this,
      'addModel',
      [model],
    );
  }

  void removeModel(_i3.Model model) {
    _i5.callMethod(
      this,
      'removeModel',
      [model],
    );
  }

  _i2.bool startTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'startTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool commitTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'commitTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool rollbackTransaction() => _i5.callMethod(
        this,
        'rollbackTransaction',
        [],
      );
  _i2.bool canUndo() => _i5.callMethod(
        this,
        'canUndo',
        [],
      );
  void undo() {
    _i5.callMethod(
      this,
      'undo',
      [],
    );
  }

  _i2.bool canRedo() => _i5.callMethod(
        this,
        'canRedo',
        [],
      );
  void redo() {
    _i5.callMethod(
      this,
      'redo',
      [],
    );
  }

  void handleChanged(_i3.ChangedEvent e) {
    _i5.callMethod(
      this,
      'handleChanged',
      [e],
    );
  }

  _i2.bool skipsEvent(_i3.ChangedEvent e) => _i5.callMethod(
        this,
        'skipsEvent',
        [e],
      );
}

@_i1.JS()
@_i1.staticInterop
class Tool {
  factory Tool() => _i5.callConstructor(
        _declaredTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Tool')
external _i2.Object _declaredTool;

extension Tool$Typings on Tool {
  /* #4584
  source: 
    /**
     * This read-only property returns the Diagram that owns this tool and
     * for which this tool is handling input events.
     */
    get diagram(): Diagram; */
  /// This read-only property returns the Diagram that owns this tool and
  /// for which this tool is handling input events.
  _i3.Diagram get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #4584
  source: 
    /**
     * This read-only property returns the Diagram that owns this tool and
     * for which this tool is handling input events.
     */
    get diagram(): Diagram; */
  // Type Instance of 'InteropInterface'
  set diagram(_i3.Diagram value) {
    _i5.setProperty(
      this,
      'diagram',
      value,
    );
  }

  /* #5063
  source: 
    /**
     * Gets or sets the name of this tool.
     * The default name is an empty string,
     * but the constructor for each instance of a subclass of Tool will initialize it appropriately.
     * For example, the name of the DragSelectingTool is "DragSelecting".
     *
     * This name is sometimes used by tools that use Adornments as the Part#category for their Adornments.
     * It is also sometimes used by tools that conduct transactions as the transaction name.
     */
    get name(): string; */
  /// Gets or sets the name of this tool.
  /// The default name is an empty string,
  /// but the constructor for each instance of a subclass of Tool will initialize it appropriately.
  /// For example, the name of the DragSelectingTool is "DragSelecting".
  ///
  /// This name is sometimes used by tools that use Adornments as the Part#category for their Adornments.
  /// It is also sometimes used by tools that conduct transactions as the transaction name.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #5063
  source: 
    /**
     * Gets or sets the name of this tool.
     * The default name is an empty string,
     * but the constructor for each instance of a subclass of Tool will initialize it appropriately.
     * For example, the name of the DragSelectingTool is "DragSelecting".
     *
     * This name is sometimes used by tools that use Adornments as the Part#category for their Adornments.
     * It is also sometimes used by tools that conduct transactions as the transaction name.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #5077
  source: 
    /**
     * Gets or sets whether this tool can be started by a mouse event.
     *
     * Set this to false to prevent #canStart from returning true.
     * Setting this property to false should prevent this tool from being used in a mode-less fashion
     * by the ToolManager with a mouse down/move/up event.
     * However, even when this property is false, this tool can still be used in a modal fashion:
     * it can still be started by explicitly setting the
     * Diagram#currentTool property to this tool.
     *
     * The default value is true.
     */
    get isEnabled(): boolean; */
  /// Gets or sets whether this tool can be started by a mouse event.
  ///
  /// Set this to false to prevent #canStart from returning true.
  /// Setting this property to false should prevent this tool from being used in a mode-less fashion
  /// by the ToolManager with a mouse down/move/up event.
  /// However, even when this property is false, this tool can still be used in a modal fashion:
  /// it can still be started by explicitly setting the
  /// Diagram#currentTool property to this tool.
  ///
  /// The default value is true.
  _i2.bool get isEnabled => _i5.getProperty(
        this,
        'isEnabled',
      );
  /* #5077
  source: 
    /**
     * Gets or sets whether this tool can be started by a mouse event.
     *
     * Set this to false to prevent #canStart from returning true.
     * Setting this property to false should prevent this tool from being used in a mode-less fashion
     * by the ToolManager with a mouse down/move/up event.
     * However, even when this property is false, this tool can still be used in a modal fashion:
     * it can still be started by explicitly setting the
     * Diagram#currentTool property to this tool.
     *
     * The default value is true.
     */
    get isEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEnabled',
      value,
    );
  }

  /* #5092
  source: 
    /**
     * Gets or sets whether this tool is started and is actively doing something.
     *
     * You can set this to true after your tool is started (i.e. when it is the
     * Diagram#currentTool and #doStart
     * had been called), but when it is not yet in a state
     * that it is actually "doing" something, because it is waiting for the right
     * circumstances.  This is typically only important when the tool is used in
     * a modal fashion.
     *
     * The default value is false.
     * This is normally set by #doActivate and #doDeactivate.
     */
    get isActive(): boolean; */
  /// Gets or sets whether this tool is started and is actively doing something.
  ///
  /// You can set this to true after your tool is started (i.e. when it is the
  /// Diagram#currentTool and #doStart
  /// had been called), but when it is not yet in a state
  /// that it is actually "doing" something, because it is waiting for the right
  /// circumstances.  This is typically only important when the tool is used in
  /// a modal fashion.
  ///
  /// The default value is false.
  /// This is normally set by #doActivate and #doDeactivate.
  _i2.bool get isActive => _i5.getProperty(
        this,
        'isActive',
      );
  /* #5092
  source: 
    /**
     * Gets or sets whether this tool is started and is actively doing something.
     *
     * You can set this to true after your tool is started (i.e. when it is the
     * Diagram#currentTool and #doStart
     * had been called), but when it is not yet in a state
     * that it is actually "doing" something, because it is waiting for the right
     * circumstances.  This is typically only important when the tool is used in
     * a modal fashion.
     *
     * The default value is false.
     * This is normally set by #doActivate and #doDeactivate.
     */
    get isActive(): boolean; */
  // Type InteropStaticType.boolean
  set isActive(_i2.bool value) {
    _i5.setProperty(
      this,
      'isActive',
      value,
    );
  }

  /* #5113
  source: 
    /**
     * Gets or sets the name of the transaction to be committed by #stopTransaction
     *
     * If null, the transaction will be rolled back.
     *
     * If this is non-null at the time of a call to #stopTransaction,
     * it calls Diagram#commitTransaction with this transaction name;
     * if this is null at that time, it calls Diagram#rollbackTransaction.
     *
     * The default value is null; #startTransaction will also set this to null.
     * Because a value of null when #stopTransaction is called will rollback the transaction,
     * it is important that your code sets this property to a non-null value when it thinks it has succeeded.
     *
     * This property exists so that no matter what execution path occurs to end the usage of a tool,
     * any ongoing transaction can be properly committed or rolled-back.
     * Many tools call #startTransaction and #stopTransaction; thus they set this property
     * for their transaction to be committed.
     * #doCancel also sets this property to null.
     */
    get transactionResult(): string | null; */
  /// Gets or sets the name of the transaction to be committed by #stopTransaction
  ///
  /// If null, the transaction will be rolled back.
  ///
  /// If this is non-null at the time of a call to #stopTransaction,
  /// it calls Diagram#commitTransaction with this transaction name;
  /// if this is null at that time, it calls Diagram#rollbackTransaction.
  ///
  /// The default value is null; #startTransaction will also set this to null.
  /// Because a value of null when #stopTransaction is called will rollback the transaction,
  /// it is important that your code sets this property to a non-null value when it thinks it has succeeded.
  ///
  /// This property exists so that no matter what execution path occurs to end the usage of a tool,
  /// any ongoing transaction can be properly committed or rolled-back.
  /// Many tools call #startTransaction and #stopTransaction; thus they set this property
  /// for their transaction to be committed.
  /// #doCancel also sets this property to null.
  _i2.String? get transactionResult => _i5.getProperty(
        this,
        'transactionResult',
      );
  /* #5113
  source: 
    /**
     * Gets or sets the name of the transaction to be committed by #stopTransaction
     *
     * If null, the transaction will be rolled back.
     *
     * If this is non-null at the time of a call to #stopTransaction,
     * it calls Diagram#commitTransaction with this transaction name;
     * if this is null at that time, it calls Diagram#rollbackTransaction.
     *
     * The default value is null; #startTransaction will also set this to null.
     * Because a value of null when #stopTransaction is called will rollback the transaction,
     * it is important that your code sets this property to a non-null value when it thinks it has succeeded.
     *
     * This property exists so that no matter what execution path occurs to end the usage of a tool,
     * any ongoing transaction can be properly committed or rolled-back.
     * Many tools call #startTransaction and #stopTransaction; thus they set this property
     * for their transaction to be committed.
     * #doCancel also sets this property to null.
     */
    get transactionResult(): string | null; */
  // Type InteropUnion#950208169(parent: InteropGetter#1015841189(name: transactionResult))
  set transactionResult(_i2.String? value) {
    _i5.setProperty(
      this,
      'transactionResult',
      value ?? _i4.undefined,
    );
  }

  void updateAdornments(_i3.Part part) {
    _i5.callMethod(
      this,
      'updateAdornments',
      [part],
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doStart() {
    _i5.callMethod(
      this,
      'doStart',
      [],
    );
  }

  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  void doStop() {
    _i5.callMethod(
      this,
      'doStop',
      [],
    );
  }

  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void stopTool() {
    _i5.callMethod(
      this,
      'stopTool',
      [],
    );
  }

  void doMouseDown() {
    _i5.callMethod(
      this,
      'doMouseDown',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void doMouseWheel() {
    _i5.callMethod(
      this,
      'doMouseWheel',
      [],
    );
  }

  _i2.bool canStartMultiTouch() => _i5.callMethod(
        this,
        'canStartMultiTouch',
        [],
      );
  void standardPinchZoomStart() {
    _i5.callMethod(
      this,
      'standardPinchZoomStart',
      [],
    );
  }

  void standardPinchZoomMove() {
    _i5.callMethod(
      this,
      'standardPinchZoomMove',
      [],
    );
  }

  void doKeyDown() {
    _i5.callMethod(
      this,
      'doKeyDown',
      [],
    );
  }

  void doKeyUp() {
    _i5.callMethod(
      this,
      'doKeyUp',
      [],
    );
  }

  _i2.bool startTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'startTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool stopTransaction() => _i5.callMethod(
        this,
        'stopTransaction',
        [],
      );
  void standardMouseSelect() {
    _i5.callMethod(
      this,
      'standardMouseSelect',
      [],
    );
  }

  _i2.bool standardMouseClick<T extends _i3.GraphObject>([
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
  ]) =>
      _i5.callMethod(
        this,
        'standardMouseClick',
        [
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
        ],
      );
  void standardMouseOver() {
    _i5.callMethod(
      this,
      'standardMouseOver',
      [],
    );
  }

  void standardMouseWheel() {
    _i5.callMethod(
      this,
      'standardMouseWheel',
      [],
    );
  }

  void standardWaitAfter(
    _i2.num delay, [
    _i3.InputEvent? event,
  ]) {
    _i5.callMethod(
      this,
      'standardWaitAfter',
      [
        delay,
        event ?? _i4.undefined,
      ],
    );
  }

  void cancelWaitAfter() {
    _i5.callMethod(
      this,
      'cancelWaitAfter',
      [],
    );
  }

  void doWaitAfter(_i3.InputEvent event) {
    _i5.callMethod(
      this,
      'doWaitAfter',
      [event],
    );
  }

  _i3.GraphObject? findToolHandleAt(
    _i3.Point p,
    _i2.String category,
  ) =>
      _i5.callMethod(
        this,
        'findToolHandleAt',
        [
          p,
          category,
        ],
      );
  _i2.bool isBeyondDragSize([
    _i3.Point? first,
    _i3.Point? last,
  ]) =>
      _i5.callMethod(
        this,
        'isBeyondDragSize',
        [
          first ?? _i4.undefined,
          last ?? _i4.undefined,
        ],
      );
}

@_i1.JS()
@_i1.staticInterop
class ToolManager implements _i3.Tool {
  factory ToolManager() => _i5.callConstructor(
        _declaredToolManager,
        [],
      );

  /* #5172
  source: 
    /**
     * This default value for #mouseWheelBehavior indicates that mouse wheel events scroll the diagram.
     * @constant
     */
    static WheelScroll: EnumValue; */
  /// This default value for #mouseWheelBehavior indicates that mouse wheel events scroll the diagram.
  static _i3.EnumValue get wheelScroll => _i5.getProperty(
        _declaredToolManager,
        'WheelScroll',
      );
  /* #5172
  source: 
    /**
     * This default value for #mouseWheelBehavior indicates that mouse wheel events scroll the diagram.
     * @constant
     */
    static WheelScroll: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wheelScroll(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'WheelScroll',
      value,
    );
  }

  /* #5177
  source: 
    /**
     * This value for #mouseWheelBehavior indicates that the mouse wheel events change the scale of the diagram.
     * @constant
     */
    static WheelZoom: EnumValue; */
  /// This value for #mouseWheelBehavior indicates that the mouse wheel events change the scale of the diagram.
  static _i3.EnumValue get wheelZoom => _i5.getProperty(
        _declaredToolManager,
        'WheelZoom',
      );
  /* #5177
  source: 
    /**
     * This value for #mouseWheelBehavior indicates that the mouse wheel events change the scale of the diagram.
     * @constant
     */
    static WheelZoom: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wheelZoom(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'WheelZoom',
      value,
    );
  }

  /* #5184
  source: 
    /**
     * This value for #mouseWheelBehavior indicates that the mouse wheel events are ignored,
     * although scrolling or zooming by other means may still be allowed.
     * @constant
     * @since 1.2
     */
    static WheelNone: EnumValue; */
  /// This value for #mouseWheelBehavior indicates that the mouse wheel events are ignored,
  /// although scrolling or zooming by other means may still be allowed.
  static _i3.EnumValue get wheelNone => _i5.getProperty(
        _declaredToolManager,
        'WheelNone',
      );
  /* #5184
  source: 
    /**
     * This value for #mouseWheelBehavior indicates that the mouse wheel events are ignored,
     * although scrolling or zooming by other means may still be allowed.
     * @constant
     * @since 1.2
     */
    static WheelNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wheelNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'WheelNone',
      value,
    );
  }

  /* #5191
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to zoom the Diagram.
     * @constant
     * @since 1.5
     */
    static GestureZoom: EnumValue; */
  /// This value for #gestureBehavior indicates that the pointer/touch pinch gestures
  /// on the canvas intend to zoom the Diagram.
  static _i3.EnumValue get gestureZoom => _i5.getProperty(
        _declaredToolManager,
        'GestureZoom',
      );
  /* #5191
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to zoom the Diagram.
     * @constant
     * @since 1.5
     */
    static GestureZoom: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set gestureZoom(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'GestureZoom',
      value,
    );
  }

  /* #5198
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to have no effect on the Diagram, but also no effect on the page.
     * @constant
     * @since 1.5
     */
    static GestureCancel: EnumValue; */
  /// This value for #gestureBehavior indicates that the pointer/touch pinch gestures
  /// on the canvas intend to have no effect on the Diagram, but also no effect on the page.
  static _i3.EnumValue get gestureCancel => _i5.getProperty(
        _declaredToolManager,
        'GestureCancel',
      );
  /* #5198
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to have no effect on the Diagram, but also no effect on the page.
     * @constant
     * @since 1.5
     */
    static GestureCancel: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set gestureCancel(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'GestureCancel',
      value,
    );
  }

  /* #5206
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to have no effect on the Diagram, but will not be prevented,
     * and may bubble up the page to have other effects (such as zooming the page).
     * @constant
     * @since 1.5
     */
    static GestureNone: EnumValue; */
  /// This value for #gestureBehavior indicates that the pointer/touch pinch gestures
  /// on the canvas intend to have no effect on the Diagram, but will not be prevented,
  /// and may bubble up the page to have other effects (such as zooming the page).
  static _i3.EnumValue get gestureNone => _i5.getProperty(
        _declaredToolManager,
        'GestureNone',
      );
  /* #5206
  source: 
    /**
     * This value for #gestureBehavior indicates that the pointer/touch pinch gestures
     * on the canvas intend to have no effect on the Diagram, but will not be prevented,
     * and may bubble up the page to have other effects (such as zooming the page).
     * @constant
     * @since 1.5
     */
    static GestureNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set gestureNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredToolManager,
      'GestureNone',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('ToolManager')
external _i2.Object _declaredToolManager;

extension ToolManager$Typings on ToolManager {
  /* #5213
  source: 
    /**
     * Gets or sets the ToolManager's mouse wheel behavior. Allowed values are ToolManager.WheelScroll and
     * ToolManager.WheelZoom and ToolManager.WheelNone.
     *
     * The default value is ToolManager.WheelScroll.
     */
    get mouseWheelBehavior(): EnumValue; */
  /// Gets or sets the ToolManager's mouse wheel behavior. Allowed values are ToolManager.WheelScroll and
  /// ToolManager.WheelZoom and ToolManager.WheelNone.
  ///
  /// The default value is ToolManager.WheelScroll.
  _i3.EnumValue get mouseWheelBehavior => _i5.getProperty(
        this,
        'mouseWheelBehavior',
      );
  /* #5213
  source: 
    /**
     * Gets or sets the ToolManager's mouse wheel behavior. Allowed values are ToolManager.WheelScroll and
     * ToolManager.WheelZoom and ToolManager.WheelNone.
     *
     * The default value is ToolManager.WheelScroll.
     */
    get mouseWheelBehavior(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set mouseWheelBehavior(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'mouseWheelBehavior',
      value,
    );
  }

  /* #5228
  source: 
    /**
     * Gets or sets the ToolManager's touch pinching behavior.
     * Allowed values are ToolManager.GestureZoom and
     * ToolManager.GestureCancel and ToolManager.GestureNone.
     * The default value is ToolManager.GestureZoom.
     *
     * If you want to control whether a single finger touch movement
     * causes a pan (i.e. scroll) of the diagram's contents or scrolls the page,
     * consider either disabling the PanningTool by setting its property
     * Tool#isEnabled to false or by setting PanningTool#bubbles to true.
     *
     * @since 1.5
     */
    get gestureBehavior(): EnumValue; */
  /// Gets or sets the ToolManager's touch pinching behavior.
  /// Allowed values are ToolManager.GestureZoom and
  /// ToolManager.GestureCancel and ToolManager.GestureNone.
  /// The default value is ToolManager.GestureZoom.
  ///
  /// If you want to control whether a single finger touch movement
  /// causes a pan (i.e. scroll) of the diagram's contents or scrolls the page,
  /// consider either disabling the PanningTool by setting its property
  /// Tool#isEnabled to false or by setting PanningTool#bubbles to true.
  _i3.EnumValue get gestureBehavior => _i5.getProperty(
        this,
        'gestureBehavior',
      );
  /* #5228
  source: 
    /**
     * Gets or sets the ToolManager's touch pinching behavior.
     * Allowed values are ToolManager.GestureZoom and
     * ToolManager.GestureCancel and ToolManager.GestureNone.
     * The default value is ToolManager.GestureZoom.
     *
     * If you want to control whether a single finger touch movement
     * causes a pan (i.e. scroll) of the diagram's contents or scrolls the page,
     * consider either disabling the PanningTool by setting its property
     * Tool#isEnabled to false or by setting PanningTool#bubbles to true.
     *
     * @since 1.5
     */
    get gestureBehavior(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set gestureBehavior(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'gestureBehavior',
      value,
    );
  }

  /* #5379
  source: 
    /**
     * This read-only property returns the currently showing tooltip, or null if there is none.
     */
    get currentToolTip(): Adornment | HTMLInfo | null; */
  /// This read-only property returns the currently showing tooltip, or null if there is none.
  _i2.dynamic get currentToolTip => _i5.getProperty(
        this,
        'currentToolTip',
      );
  /* #5379
  source: 
    /**
     * This read-only property returns the currently showing tooltip, or null if there is none.
     */
    get currentToolTip(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#191972019(parent: InteropGetter#346371409(name: currentToolTip))
  set currentToolTip(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'currentToolTip',
      value ?? _i4.undefined,
    );
  }

  /* #5472
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger press event.
     * When the ToolManager handles a mouse-down or touch-down event in #doMouseDown,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #actionTool, an ActionTool
     *   - #relinkingTool, a RelinkingTool
     *   - #linkReshapingTool, a LinkReshapingTool
     *   - #rotatingTool, a RotatingTool
     *   - #resizingTool, a ResizingTool
     */
    get mouseDownTools(): List<Tool>; */
  /// This read-only property returns the list of Tools that might be started upon a mouse or finger press event.
  /// When the ToolManager handles a mouse-down or touch-down event in #doMouseDown,
  /// it searches this list in order, starting the first tool for which
  /// Tool#canStart returns true.
  ///
  /// This list may be modified, but it must not be modified while any tool
  /// is handling events.
  ///
  /// #initializeStandardTools installs the following tools, in order:
  ///   - #actionTool, an ActionTool
  ///   - #relinkingTool, a RelinkingTool
  ///   - #linkReshapingTool, a LinkReshapingTool
  ///   - #rotatingTool, a RotatingTool
  ///   - #resizingTool, a ResizingTool
  _i3.List /*LIST InteropClass#847625641(name: List),404776270,[Instance of 'InteropRef<InteropType>']*/ <_i3.Tool>
      get mouseDownTools => _i5.getProperty(
            this,
            'mouseDownTools',
          );
  /* #5472
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger press event.
     * When the ToolManager handles a mouse-down or touch-down event in #doMouseDown,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #actionTool, an ActionTool
     *   - #relinkingTool, a RelinkingTool
     *   - #linkReshapingTool, a LinkReshapingTool
     *   - #rotatingTool, a RotatingTool
     *   - #resizingTool, a ResizingTool
     */
    get mouseDownTools(): List<Tool>; */
  // Type Instance of 'InteropInterface'
  set mouseDownTools(
      _i3.List /*LIST InteropClass#847625641(name: List),702674798,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Tool>
          value) {
    _i5.setProperty(
      this,
      'mouseDownTools',
      value,
    );
  }

  /* #5488
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger move event.
     * When the ToolManager handles a mouse-move or touch-move event in #doMouseMove,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #linkingTool, a LinkingTool
     *   - #draggingTool, a DraggingTool
     *   - #dragSelectingTool, a DragSelectingTool
     *   - #panningTool, a PanningTool
     */
    get mouseMoveTools(): List<Tool>; */
  /// This read-only property returns the list of Tools that might be started upon a mouse or finger move event.
  /// When the ToolManager handles a mouse-move or touch-move event in #doMouseMove,
  /// it searches this list in order, starting the first tool for which
  /// Tool#canStart returns true.
  ///
  /// This list may be modified, but it must not be modified while any tool
  /// is handling events.
  ///
  /// #initializeStandardTools installs the following tools, in order:
  ///   - #linkingTool, a LinkingTool
  ///   - #draggingTool, a DraggingTool
  ///   - #dragSelectingTool, a DragSelectingTool
  ///   - #panningTool, a PanningTool
  _i3.List /*LIST InteropClass#847625641(name: List),738505273,[Instance of 'InteropRef<InteropType>']*/ <_i3.Tool>
      get mouseMoveTools => _i5.getProperty(
            this,
            'mouseMoveTools',
          );
  /* #5488
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger move event.
     * When the ToolManager handles a mouse-move or touch-move event in #doMouseMove,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #linkingTool, a LinkingTool
     *   - #draggingTool, a DraggingTool
     *   - #dragSelectingTool, a DragSelectingTool
     *   - #panningTool, a PanningTool
     */
    get mouseMoveTools(): List<Tool>; */
  // Type Instance of 'InteropInterface'
  set mouseMoveTools(
      _i3.List /*LIST InteropClass#847625641(name: List),624228728,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Tool>
          value) {
    _i5.setProperty(
      this,
      'mouseMoveTools',
      value,
    );
  }

  /* #5504
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger up event.
     * When the ToolManager handles a mouse-up or touch-up event in #doMouseUp,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #contextMenuTool, a ContextMenuTool
     *   - #textEditingTool, a TextEditingTool
     *   - #clickCreatingTool, a ClickCreatingTool
     *   - #clickSelectingTool, a ClickSelectingTool
     */
    get mouseUpTools(): List<Tool>; */
  /// This read-only property returns the list of Tools that might be started upon a mouse or finger up event.
  /// When the ToolManager handles a mouse-up or touch-up event in #doMouseUp,
  /// it searches this list in order, starting the first tool for which
  /// Tool#canStart returns true.
  ///
  /// This list may be modified, but it must not be modified while any tool
  /// is handling events.
  ///
  /// #initializeStandardTools installs the following tools, in order:
  ///   - #contextMenuTool, a ContextMenuTool
  ///   - #textEditingTool, a TextEditingTool
  ///   - #clickCreatingTool, a ClickCreatingTool
  ///   - #clickSelectingTool, a ClickSelectingTool
  _i3.List /*LIST InteropClass#847625641(name: List),672094417,[Instance of 'InteropRef<InteropType>']*/ <_i3.Tool>
      get mouseUpTools => _i5.getProperty(
            this,
            'mouseUpTools',
          );
  /* #5504
  source: 
    /**
     * This read-only property returns the list of Tools that might be started upon a mouse or finger up event.
     * When the ToolManager handles a mouse-up or touch-up event in #doMouseUp,
     * it searches this list in order, starting the first tool for which
     * Tool#canStart returns true.
     *
     * This list may be modified, but it must not be modified while any tool
     * is handling events.
     *
     * #initializeStandardTools installs the following tools, in order:
     *   - #contextMenuTool, a ContextMenuTool
     *   - #textEditingTool, a TextEditingTool
     *   - #clickCreatingTool, a ClickCreatingTool
     *   - #clickSelectingTool, a ClickSelectingTool
     */
    get mouseUpTools(): List<Tool>; */
  // Type Instance of 'InteropInterface'
  set mouseUpTools(
      _i3.List /*LIST InteropClass#847625641(name: List),198607458,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Tool>
          value) {
    _i5.setProperty(
      this,
      'mouseUpTools',
      value,
    );
  }

  /* #5512
  source: 
    /**
     * Gets or sets the time between when the mouse stops moving and a hover event,
     * in milliseconds. This value affects the delay before GraphObject#toolTips are shown.
     * The default value is 850 milliseconds.
     *
     * Set #toolTipDuration to control how long a tooltip will remain visible.
     */
    get hoverDelay(): number; */
  /// Gets or sets the time between when the mouse stops moving and a hover event,
  /// in milliseconds. This value affects the delay before GraphObject#toolTips are shown.
  /// The default value is 850 milliseconds.
  ///
  /// Set #toolTipDuration to control how long a tooltip will remain visible.
  _i2.num get hoverDelay => _i5.getProperty(
        this,
        'hoverDelay',
      );
  /* #5512
  source: 
    /**
     * Gets or sets the time between when the mouse stops moving and a hover event,
     * in milliseconds. This value affects the delay before GraphObject#toolTips are shown.
     * The default value is 850 milliseconds.
     *
     * Set #toolTipDuration to control how long a tooltip will remain visible.
     */
    get hoverDelay(): number; */
  // Type InteropStaticType.number
  set hoverDelay(_i2.num value) {
    _i5.setProperty(
      this,
      'hoverDelay',
      value,
    );
  }

  /* #5519
  source: 
    /**
     * Gets or sets the time between when the mouse stops moving and a hold event,
     * in milliseconds.
     * The default value is 850 milliseconds.
     */
    get holdDelay(): number; */
  /// Gets or sets the time between when the mouse stops moving and a hold event,
  /// in milliseconds.
  /// The default value is 850 milliseconds.
  _i2.num get holdDelay => _i5.getProperty(
        this,
        'holdDelay',
      );
  /* #5519
  source: 
    /**
     * Gets or sets the time between when the mouse stops moving and a hold event,
     * in milliseconds.
     * The default value is 850 milliseconds.
     */
    get holdDelay(): number; */
  // Type InteropStaticType.number
  set holdDelay(_i2.num value) {
    _i5.setProperty(
      this,
      'holdDelay',
      value,
    );
  }

  /* #5527
  source: 
    /**
     * Gets or sets the distance in view coordinates within which a mouse down-and-up is considered a click and beyond which a mouse movement is considered a drag.
     * The default value is 2 pixels horizontally and vertically for mouse events, and increases by 6 pixels for touch events.
     * This value is used by Tool#isBeyondDragSize.
     * @since 1.2
     */
    get dragSize(): Size; */
  /// Gets or sets the distance in view coordinates within which a mouse down-and-up is considered a click and beyond which a mouse movement is considered a drag.
  /// The default value is 2 pixels horizontally and vertically for mouse events, and increases by 6 pixels for touch events.
  /// This value is used by Tool#isBeyondDragSize.
  _i3.Size get dragSize => _i5.getProperty(
        this,
        'dragSize',
      );
  /* #5527
  source: 
    /**
     * Gets or sets the distance in view coordinates within which a mouse down-and-up is considered a click and beyond which a mouse movement is considered a drag.
     * The default value is 2 pixels horizontally and vertically for mouse events, and increases by 6 pixels for touch events.
     * This value is used by Tool#isBeyondDragSize.
     * @since 1.2
     */
    get dragSize(): Size; */
  // Type Instance of 'InteropInterface'
  set dragSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'dragSize',
      value,
    );
  }

  /* #5537
  source: 
    /**
     * Gets or sets how long a tool tip is visible.
     * The default value is 5000 milliseconds.
     *
     * This is used by #showToolTip to determine how long to wait before calling #hideToolTip.
     *
     * Set #hoverDelay to control how long the mouse should stay stationary before it shows a tooltip.
     */
    get toolTipDuration(): number; */
  /// Gets or sets how long a tool tip is visible.
  /// The default value is 5000 milliseconds.
  ///
  /// This is used by #showToolTip to determine how long to wait before calling #hideToolTip.
  ///
  /// Set #hoverDelay to control how long the mouse should stay stationary before it shows a tooltip.
  _i2.num get toolTipDuration => _i5.getProperty(
        this,
        'toolTipDuration',
      );
  /* #5537
  source: 
    /**
     * Gets or sets how long a tool tip is visible.
     * The default value is 5000 milliseconds.
     *
     * This is used by #showToolTip to determine how long to wait before calling #hideToolTip.
     *
     * Set #hoverDelay to control how long the mouse should stay stationary before it shows a tooltip.
     */
    get toolTipDuration(): number; */
  // Type InteropStaticType.number
  set toolTipDuration(_i2.num value) {
    _i5.setProperty(
      this,
      'toolTipDuration',
      value,
    );
  }

  /* #5544
  source: 
    /**
     * Gets or sets the mode-less ActionTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get actionTool(): ActionTool; */
  /// Gets or sets the mode-less ActionTool, normally one of the #mouseDownTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.ActionTool get actionTool => _i5.getProperty(
        this,
        'actionTool',
      );
  /* #5544
  source: 
    /**
     * Gets or sets the mode-less ActionTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get actionTool(): ActionTool; */
  // Type Instance of 'InteropInterface'
  set actionTool(_i3.ActionTool value) {
    _i5.setProperty(
      this,
      'actionTool',
      value,
    );
  }

  /* #5551
  source: 
    /**
     * Gets or sets the mode-less RelinkingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get relinkingTool(): RelinkingTool; */
  /// Gets or sets the mode-less RelinkingTool, normally one of the #mouseDownTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.RelinkingTool get relinkingTool => _i5.getProperty(
        this,
        'relinkingTool',
      );
  /* #5551
  source: 
    /**
     * Gets or sets the mode-less RelinkingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get relinkingTool(): RelinkingTool; */
  // Type Instance of 'InteropInterface'
  set relinkingTool(_i3.RelinkingTool value) {
    _i5.setProperty(
      this,
      'relinkingTool',
      value,
    );
  }

  /* #5558
  source: 
    /**
     * Gets or sets the mode-less LinkReshapingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get linkReshapingTool(): LinkReshapingTool; */
  /// Gets or sets the mode-less LinkReshapingTool, normally one of the #mouseDownTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.LinkReshapingTool get linkReshapingTool => _i5.getProperty(
        this,
        'linkReshapingTool',
      );
  /* #5558
  source: 
    /**
     * Gets or sets the mode-less LinkReshapingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get linkReshapingTool(): LinkReshapingTool; */
  // Type Instance of 'InteropInterface'
  set linkReshapingTool(_i3.LinkReshapingTool value) {
    _i5.setProperty(
      this,
      'linkReshapingTool',
      value,
    );
  }

  /* #5565
  source: 
    /**
     * Gets or sets the mode-less ResizingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get resizingTool(): ResizingTool; */
  /// Gets or sets the mode-less ResizingTool, normally one of the #mouseDownTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.ResizingTool get resizingTool => _i5.getProperty(
        this,
        'resizingTool',
      );
  /* #5565
  source: 
    /**
     * Gets or sets the mode-less ResizingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get resizingTool(): ResizingTool; */
  // Type Instance of 'InteropInterface'
  set resizingTool(_i3.ResizingTool value) {
    _i5.setProperty(
      this,
      'resizingTool',
      value,
    );
  }

  /* #5572
  source: 
    /**
     * Gets or sets the mode-less RotatingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get rotatingTool(): RotatingTool; */
  /// Gets or sets the mode-less RotatingTool, normally one of the #mouseDownTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.RotatingTool get rotatingTool => _i5.getProperty(
        this,
        'rotatingTool',
      );
  /* #5572
  source: 
    /**
     * Gets or sets the mode-less RotatingTool, normally one of the #mouseDownTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get rotatingTool(): RotatingTool; */
  // Type Instance of 'InteropInterface'
  set rotatingTool(_i3.RotatingTool value) {
    _i5.setProperty(
      this,
      'rotatingTool',
      value,
    );
  }

  /* #5579
  source: 
    /**
     * Gets or sets the mode-less LinkingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get linkingTool(): LinkingTool; */
  /// Gets or sets the mode-less LinkingTool, normally one of the #mouseMoveTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.LinkingTool get linkingTool => _i5.getProperty(
        this,
        'linkingTool',
      );
  /* #5579
  source: 
    /**
     * Gets or sets the mode-less LinkingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get linkingTool(): LinkingTool; */
  // Type Instance of 'InteropInterface'
  set linkingTool(_i3.LinkingTool value) {
    _i5.setProperty(
      this,
      'linkingTool',
      value,
    );
  }

  /* #5586
  source: 
    /**
     * Gets or sets the mode-less DraggingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get draggingTool(): DraggingTool; */
  /// Gets or sets the mode-less DraggingTool, normally one of the #mouseMoveTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.DraggingTool get draggingTool => _i5.getProperty(
        this,
        'draggingTool',
      );
  /* #5586
  source: 
    /**
     * Gets or sets the mode-less DraggingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get draggingTool(): DraggingTool; */
  // Type Instance of 'InteropInterface'
  set draggingTool(_i3.DraggingTool value) {
    _i5.setProperty(
      this,
      'draggingTool',
      value,
    );
  }

  /* #5593
  source: 
    /**
     * Gets or sets the mode-less DragSelectingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get dragSelectingTool(): DragSelectingTool; */
  /// Gets or sets the mode-less DragSelectingTool, normally one of the #mouseMoveTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.DragSelectingTool get dragSelectingTool => _i5.getProperty(
        this,
        'dragSelectingTool',
      );
  /* #5593
  source: 
    /**
     * Gets or sets the mode-less DragSelectingTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get dragSelectingTool(): DragSelectingTool; */
  // Type Instance of 'InteropInterface'
  set dragSelectingTool(_i3.DragSelectingTool value) {
    _i5.setProperty(
      this,
      'dragSelectingTool',
      value,
    );
  }

  /* #5600
  source: 
    /**
     * Gets or sets the mode-less PanningTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get panningTool(): PanningTool; */
  /// Gets or sets the mode-less PanningTool, normally one of the #mouseMoveTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.PanningTool get panningTool => _i5.getProperty(
        this,
        'panningTool',
      );
  /* #5600
  source: 
    /**
     * Gets or sets the mode-less PanningTool, normally one of the #mouseMoveTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get panningTool(): PanningTool; */
  // Type Instance of 'InteropInterface'
  set panningTool(_i3.PanningTool value) {
    _i5.setProperty(
      this,
      'panningTool',
      value,
    );
  }

  /* #5607
  source: 
    /**
     * Gets or sets the mode-less ContextMenuTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get contextMenuTool(): ContextMenuTool; */
  /// Gets or sets the mode-less ContextMenuTool, normally one of the #mouseUpTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.ContextMenuTool get contextMenuTool => _i5.getProperty(
        this,
        'contextMenuTool',
      );
  /* #5607
  source: 
    /**
     * Gets or sets the mode-less ContextMenuTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get contextMenuTool(): ContextMenuTool; */
  // Type Instance of 'InteropInterface'
  set contextMenuTool(_i3.ContextMenuTool value) {
    _i5.setProperty(
      this,
      'contextMenuTool',
      value,
    );
  }

  /* #5614
  source: 
    /**
     * Gets or sets the mode-less TextEditingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get textEditingTool(): TextEditingTool; */
  /// Gets or sets the mode-less TextEditingTool, normally one of the #mouseUpTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.TextEditingTool get textEditingTool => _i5.getProperty(
        this,
        'textEditingTool',
      );
  /* #5614
  source: 
    /**
     * Gets or sets the mode-less TextEditingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get textEditingTool(): TextEditingTool; */
  // Type Instance of 'InteropInterface'
  set textEditingTool(_i3.TextEditingTool value) {
    _i5.setProperty(
      this,
      'textEditingTool',
      value,
    );
  }

  /* #5621
  source: 
    /**
     * Gets or sets the mode-less ClickCreatingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get clickCreatingTool(): ClickCreatingTool; */
  /// Gets or sets the mode-less ClickCreatingTool, normally one of the #mouseUpTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.ClickCreatingTool get clickCreatingTool => _i5.getProperty(
        this,
        'clickCreatingTool',
      );
  /* #5621
  source: 
    /**
     * Gets or sets the mode-less ClickCreatingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get clickCreatingTool(): ClickCreatingTool; */
  // Type Instance of 'InteropInterface'
  set clickCreatingTool(_i3.ClickCreatingTool value) {
    _i5.setProperty(
      this,
      'clickCreatingTool',
      value,
    );
  }

  /* #5628
  source: 
    /**
     * Gets or sets the mode-less ClickSelectingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get clickSelectingTool(): ClickSelectingTool; */
  /// Gets or sets the mode-less ClickSelectingTool, normally one of the #mouseUpTools.
  ///
  /// You can disable this tool by setting its Tool#isEnabled property to false.
  _i3.ClickSelectingTool get clickSelectingTool => _i5.getProperty(
        this,
        'clickSelectingTool',
      );
  /* #5628
  source: 
    /**
     * Gets or sets the mode-less ClickSelectingTool, normally one of the #mouseUpTools.
     *
     * You can disable this tool by setting its Tool#isEnabled property to false.
     */
    get clickSelectingTool(): ClickSelectingTool; */
  // Type Instance of 'InteropInterface'
  set clickSelectingTool(_i3.ClickSelectingTool value) {
    _i5.setProperty(
      this,
      'clickSelectingTool',
      value,
    );
  }

  void initializeStandardTools() {
    _i5.callMethod(
      this,
      'initializeStandardTools',
      [],
    );
  }

  void doMouseDown() {
    _i5.callMethod(
      this,
      'doMouseDown',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doWaitAfter(_i3.InputEvent event) {
    _i5.callMethod(
      this,
      'doWaitAfter',
      [event],
    );
  }

  void doMouseHover() {
    _i5.callMethod(
      this,
      'doMouseHover',
      [],
    );
  }

  void doToolTip() {
    _i5.callMethod(
      this,
      'doToolTip',
      [],
    );
  }

  void showToolTip(
    _i2.Object tooltip,
    _i3.GraphObject obj,
  ) {
    _i5.callMethod(
      this,
      'showToolTip',
      [
        tooltip,
        obj,
      ],
    );
  }

  void positionToolTip(
    _i3.Adornment tooltip,
    _i3.GraphObject obj,
  ) {
    _i5.callMethod(
      this,
      'positionToolTip',
      [
        tooltip,
        obj,
      ],
    );
  }

  void hideToolTip() {
    _i5.callMethod(
      this,
      'hideToolTip',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void doMouseWheel() {
    _i5.callMethod(
      this,
      'doMouseWheel',
      [],
    );
  }

  void doKeyDown() {
    _i5.callMethod(
      this,
      'doKeyDown',
      [],
    );
  }

  void doKeyUp() {
    _i5.callMethod(
      this,
      'doKeyUp',
      [],
    );
  }

  _i3.Tool? findTool(_i2.String name) => _i5.callMethod(
        this,
        'findTool',
        [name],
      );
  _i3.Tool? replaceTool(
    _i2.String name,
    _i3.Tool newtool,
  ) =>
      _i5.callMethod(
        this,
        'replaceTool',
        [
          name,
          newtool,
        ],
      );
  void replaceStandardTool(
    _i2.String name,
    _i3.Tool newtool,
    _i3.List /*LIST InteropClass#847625641(name: List),245470836,[Instance of 'InteropRef<InteropType>']*/ <
            _i3.Tool>
        list,
  ) {
    _i5.callMethod(
      this,
      'replaceStandardTool',
      [
        name,
        newtool,
        list,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class DraggingTool implements _i3.Tool {
  factory DraggingTool() => _i5.callConstructor(
        _declaredDraggingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('DraggingTool')
external _i2.Object _declaredDraggingTool;

extension DraggingTool$Typings on DraggingTool {
  /* #5754
  source: 
    /**
     * Gets or sets whether for any internal copying operation is permitted by control-drag-and-drop.
     * This property affects the behavior of #mayCopy,
     * but does not affect whether copied objects may be dropped into this diagram from a different diagram.
     *
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 1.4
     */
    get isCopyEnabled(): boolean; */
  /// Gets or sets whether for any internal copying operation is permitted by control-drag-and-drop.
  /// This property affects the behavior of #mayCopy,
  /// but does not affect whether copied objects may be dropped into this diagram from a different diagram.
  ///
  /// The default value is true.
  /// Setting this property does not raise any events.
  _i2.bool get isCopyEnabled => _i5.getProperty(
        this,
        'isCopyEnabled',
      );
  /* #5754
  source: 
    /**
     * Gets or sets whether for any internal copying operation is permitted by control-drag-and-drop.
     * This property affects the behavior of #mayCopy,
     * but does not affect whether copied objects may be dropped into this diagram from a different diagram.
     *
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 1.4
     */
    get isCopyEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isCopyEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isCopyEnabled',
      value,
    );
  }

  /* #5765
  source: 
    /**
     * Gets or sets whether for a copying operation the extended selection
     * is copied or only the selected parts.
     * The default value is true.
     * Setting this property does not raise any events.
     *
     * The CommandHandler#copiesConnectedLinks property serves a similar role for the CommandHandler#copySelection command,
     * when the user types control-C to copy the currently selected parts.
     */
    get copiesEffectiveCollection(): boolean; */
  /// Gets or sets whether for a copying operation the extended selection
  /// is copied or only the selected parts.
  /// The default value is true.
  /// Setting this property does not raise any events.
  ///
  /// The CommandHandler#copiesConnectedLinks property serves a similar role for the CommandHandler#copySelection command,
  /// when the user types control-C to copy the currently selected parts.
  _i2.bool get copiesEffectiveCollection => _i5.getProperty(
        this,
        'copiesEffectiveCollection',
      );
  /* #5765
  source: 
    /**
     * Gets or sets whether for a copying operation the extended selection
     * is copied or only the selected parts.
     * The default value is true.
     * Setting this property does not raise any events.
     *
     * The CommandHandler#copiesConnectedLinks property serves a similar role for the CommandHandler#copySelection command,
     * when the user types control-C to copy the currently selected parts.
     */
    get copiesEffectiveCollection(): boolean; */
  // Type InteropStaticType.boolean
  set copiesEffectiveCollection(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesEffectiveCollection',
      value,
    );
  }

  /* #5784
  source: 
    /**
     * Gets or sets the DraggingTool's DraggingOptions instance, which controls several dragging properties.
     *
     * Several DraggingTool properties are just convenience properties:
     *   - #isGridSnapEnabled
     *   - #isGridSnapRealtime
     *   - #gridSnapCellSize
     *   - #gridSnapCellSpot
     *   - #gridSnapOrigin
     *   - #dragsLink
     *   - #dragsTree
     *
     * Setting any of these properties really sets the corresponding dragOptions property.
     *
     * Setting this property does not raise any events.
     * @since 2.0
     */
    get dragOptions(): DraggingOptions; */
  /// Gets or sets the DraggingTool's DraggingOptions instance, which controls several dragging properties.
  ///
  /// Several DraggingTool properties are just convenience properties:
  ///   - #isGridSnapEnabled
  ///   - #isGridSnapRealtime
  ///   - #gridSnapCellSize
  ///   - #gridSnapCellSpot
  ///   - #gridSnapOrigin
  ///   - #dragsLink
  ///   - #dragsTree
  ///
  /// Setting any of these properties really sets the corresponding dragOptions property.
  ///
  /// Setting this property does not raise any events.
  _i3.DraggingOptions get dragOptions => _i5.getProperty(
        this,
        'dragOptions',
      );
  /* #5784
  source: 
    /**
     * Gets or sets the DraggingTool's DraggingOptions instance, which controls several dragging properties.
     *
     * Several DraggingTool properties are just convenience properties:
     *   - #isGridSnapEnabled
     *   - #isGridSnapRealtime
     *   - #gridSnapCellSize
     *   - #gridSnapCellSpot
     *   - #gridSnapOrigin
     *   - #dragsLink
     *   - #dragsTree
     *
     * Setting any of these properties really sets the corresponding dragOptions property.
     *
     * Setting this property does not raise any events.
     * @since 2.0
     */
    get dragOptions(): DraggingOptions; */
  // Type Instance of 'InteropInterface'
  set dragOptions(_i3.DraggingOptions value) {
    _i5.setProperty(
      this,
      'dragOptions',
      value,
    );
  }

  /* #5799
  source: 
    /**
     * Gets or sets whether the DraggingTool snaps objects to grid points.
     * Whether the snapping movement of the dragged parts occurs during the drag or only upon a drop
     * is determined by the value of #isGridSnapRealtime.
     *
     * This property does not affect dragging disconnected links,
     * but those links to respect the Part#dragComputation, which can be used to snap them.
     *
     * By default this property is false.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get isGridSnapEnabled(): boolean; */
  /// Gets or sets whether the DraggingTool snaps objects to grid points.
  /// Whether the snapping movement of the dragged parts occurs during the drag or only upon a drop
  /// is determined by the value of #isGridSnapRealtime.
  ///
  /// This property does not affect dragging disconnected links,
  /// but those links to respect the Part#dragComputation, which can be used to snap them.
  ///
  /// By default this property is false.
  /// Setting this property does not raise any events.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i2.bool get isGridSnapEnabled => _i5.getProperty(
        this,
        'isGridSnapEnabled',
      );
  /* #5799
  source: 
    /**
     * Gets or sets whether the DraggingTool snaps objects to grid points.
     * Whether the snapping movement of the dragged parts occurs during the drag or only upon a drop
     * is determined by the value of #isGridSnapRealtime.
     *
     * This property does not affect dragging disconnected links,
     * but those links to respect the Part#dragComputation, which can be used to snap them.
     *
     * By default this property is false.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get isGridSnapEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapEnabled',
      value,
    );
  }

  /* #5807
  source: 
    /**
     * Gets or sets whether link routing takes some short-cuts during dragging.
     * When false Links whose routing is AvoidsNodes are not routed to avoid Nodes, in order to improve dragging performance.
     * The default value is true.
     * @since 1.4
     */
    get isComplexRoutingRealtime(): boolean; */
  /// Gets or sets whether link routing takes some short-cuts during dragging.
  /// When false Links whose routing is AvoidsNodes are not routed to avoid Nodes, in order to improve dragging performance.
  /// The default value is true.
  _i2.bool get isComplexRoutingRealtime => _i5.getProperty(
        this,
        'isComplexRoutingRealtime',
      );
  /* #5807
  source: 
    /**
     * Gets or sets whether link routing takes some short-cuts during dragging.
     * When false Links whose routing is AvoidsNodes are not routed to avoid Nodes, in order to improve dragging performance.
     * The default value is true.
     * @since 1.4
     */
    get isComplexRoutingRealtime(): boolean; */
  // Type InteropStaticType.boolean
  set isComplexRoutingRealtime(_i2.bool value) {
    _i5.setProperty(
      this,
      'isComplexRoutingRealtime',
      value,
    );
  }

  /* #5818
  source: 
    /**
     * Gets or sets whether the DraggingTool snaps objects to grid points during the drag.
     * This property is ignored unless #isGridSnapEnabled is true.
     * By default this property is true; when false parts are only snapped to grid locations upon the drop (i.e. mouse-up).
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     * @since 1.1
     */
    get isGridSnapRealtime(): boolean; */
  /// Gets or sets whether the DraggingTool snaps objects to grid points during the drag.
  /// This property is ignored unless #isGridSnapEnabled is true.
  /// By default this property is true; when false parts are only snapped to grid locations upon the drop (i.e. mouse-up).
  /// Setting this property does not raise any events.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i2.bool get isGridSnapRealtime => _i5.getProperty(
        this,
        'isGridSnapRealtime',
      );
  /* #5818
  source: 
    /**
     * Gets or sets whether the DraggingTool snaps objects to grid points during the drag.
     * This property is ignored unless #isGridSnapEnabled is true.
     * By default this property is true; when false parts are only snapped to grid locations upon the drop (i.e. mouse-up).
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     * @since 1.1
     */
    get isGridSnapRealtime(): boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapRealtime(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapRealtime',
      value,
    );
  }

  /* #5828
  source: 
    /**
     * Gets or sets the size of the grid cell used when snapping during a drag
     * if the value of #isGridSnapEnabled is true.
     * By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapCellSize(): Size; */
  /// Gets or sets the size of the grid cell used when snapping during a drag
  /// if the value of #isGridSnapEnabled is true.
  /// By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
  /// Setting this property does not raise any events.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i3.Size get gridSnapCellSize => _i5.getProperty(
        this,
        'gridSnapCellSize',
      );
  /* #5828
  source: 
    /**
     * Gets or sets the size of the grid cell used when snapping during a drag
     * if the value of #isGridSnapEnabled is true.
     * By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapCellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set gridSnapCellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'gridSnapCellSize',
      value,
    );
  }

  /* #5839
  source: 
    /**
     * Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
     * if the value of #isGridSnapEnabled is true.
     * By default this property is Spot.TopLeft:
     * node locations will snap exactly to the grid point.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapCellSpot(): Spot; */
  /// Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
  /// if the value of #isGridSnapEnabled is true.
  /// By default this property is Spot.TopLeft:
  /// node locations will snap exactly to the grid point.
  /// Setting this property does not raise any events.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i3.Spot get gridSnapCellSpot => _i5.getProperty(
        this,
        'gridSnapCellSpot',
      );
  /* #5839
  source: 
    /**
     * Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
     * if the value of #isGridSnapEnabled is true.
     * By default this property is Spot.TopLeft:
     * node locations will snap exactly to the grid point.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapCellSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set gridSnapCellSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'gridSnapCellSpot',
      value,
    );
  }

  /* #5850
  source: 
    /**
     * Gets or sets the snapping grid's origin point, in document coordinates,
     * if the value of #isGridSnapEnabled is true.
     * By default this property is the Point(NaN, NaN),
     * which causes this tool to use the Panel#gridOrigin value from the Diagram#grid.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapOrigin(): Point; */
  /// Gets or sets the snapping grid's origin point, in document coordinates,
  /// if the value of #isGridSnapEnabled is true.
  /// By default this property is the Point(NaN, NaN),
  /// which causes this tool to use the Panel#gridOrigin value from the Diagram#grid.
  /// Setting this property does not raise any events.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i3.Point get gridSnapOrigin => _i5.getProperty(
        this,
        'gridSnapOrigin',
      );
  /* #5850
  source: 
    /**
     * Gets or sets the snapping grid's origin point, in document coordinates,
     * if the value of #isGridSnapEnabled is true.
     * By default this property is the Point(NaN, NaN),
     * which causes this tool to use the Panel#gridOrigin value from the Diagram#grid.
     * Setting this property does not raise any events.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get gridSnapOrigin(): Point; */
  // Type Instance of 'InteropInterface'
  set gridSnapOrigin(_i3.Point value) {
    _i5.setProperty(
      this,
      'gridSnapOrigin',
      value,
    );
  }

  /* #5865
  source: 
    /**
     * Gets or sets whether the user can drag a single Link,
     * disconnecting it from its connected nodes and possibly connecting it
     * to valid ports when the link is dropped.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * In order to avoid too many cases of having both ends of a dragged Link connect to the same node (if allowed),
     * it is commonplace to decrease the LinkingBaseTool#portGravity to a smaller value such as 10 or 20.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     * @since 1.3
     */
    get dragsLink(): boolean; */
  /// Gets or sets whether the user can drag a single Link,
  /// disconnecting it from its connected nodes and possibly connecting it
  /// to valid ports when the link is dropped.
  /// The default value is false.
  /// Setting this property does not raise any events.
  ///
  /// In order to avoid too many cases of having both ends of a dragged Link connect to the same node (if allowed),
  /// it is commonplace to decrease the LinkingBaseTool#portGravity to a smaller value such as 10 or 20.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i2.bool get dragsLink => _i5.getProperty(
        this,
        'dragsLink',
      );
  /* #5865
  source: 
    /**
     * Gets or sets whether the user can drag a single Link,
     * disconnecting it from its connected nodes and possibly connecting it
     * to valid ports when the link is dropped.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * In order to avoid too many cases of having both ends of a dragged Link connect to the same node (if allowed),
     * it is commonplace to decrease the LinkingBaseTool#portGravity to a smaller value such as 10 or 20.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     * @since 1.3
     */
    get dragsLink(): boolean; */
  // Type InteropStaticType.boolean
  set dragsLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsLink',
      value,
    );
  }

  /* #5878
  source: 
    /**
     * Gets or sets whether moving or copying a node also includes all of the
     * node's tree children and their descendants, along with the links to those additional nodes.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * The CommandHandler#copiesTree property serves a similar role for the CommandHandler#copySelection command,
     * when the user types control-C to copy the currently selected parts.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get dragsTree(): boolean; */
  /// Gets or sets whether moving or copying a node also includes all of the
  /// node's tree children and their descendants, along with the links to those additional nodes.
  /// The default value is false.
  /// Setting this property does not raise any events.
  ///
  /// The CommandHandler#copiesTree property serves a similar role for the CommandHandler#copySelection command,
  /// when the user types control-C to copy the currently selected parts.
  ///
  /// This property is a convenience getter/setter, and sets a value on #dragOptions.
  _i2.bool get dragsTree => _i5.getProperty(
        this,
        'dragsTree',
      );
  /* #5878
  source: 
    /**
     * Gets or sets whether moving or copying a node also includes all of the
     * node's tree children and their descendants, along with the links to those additional nodes.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * The CommandHandler#copiesTree property serves a similar role for the CommandHandler#copySelection command,
     * when the user types control-C to copy the currently selected parts.
     *
     * This property is a convenience getter/setter, and sets a value on #dragOptions.
     */
    get dragsTree(): boolean; */
  // Type InteropStaticType.boolean
  set dragsTree(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsTree',
      value,
    );
  }

  /* #5886
  source: 
    /**
     * The cursor to show when a drop is allowed and will result in a copy.
     * This defaults to 'copy'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get copyCursor(): string; */
  /// The cursor to show when a drop is allowed and will result in a copy.
  /// This defaults to 'copy'.
  /// Read more about cursors at Diagram#currentCursor
  _i2.String get copyCursor => _i5.getProperty(
        this,
        'copyCursor',
      );
  /* #5886
  source: 
    /**
     * The cursor to show when a drop is allowed and will result in a copy.
     * This defaults to 'copy'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get copyCursor(): string; */
  // Type InteropStaticType.string
  set copyCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'copyCursor',
      value,
    );
  }

  /* #5894
  source: 
    /**
     * The cursor to show when a drop is allowed and will result in a move.
     * This defaults to the empty string, which refers to the Diagram#defaultCursor.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get moveCursor(): string; */
  /// The cursor to show when a drop is allowed and will result in a move.
  /// This defaults to the empty string, which refers to the Diagram#defaultCursor.
  /// Read more about cursors at Diagram#currentCursor
  _i2.String get moveCursor => _i5.getProperty(
        this,
        'moveCursor',
      );
  /* #5894
  source: 
    /**
     * The cursor to show when a drop is allowed and will result in a move.
     * This defaults to the empty string, which refers to the Diagram#defaultCursor.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get moveCursor(): string; */
  // Type InteropStaticType.string
  set moveCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'moveCursor',
      value,
    );
  }

  /* #5902
  source: 
    /**
     * The cursor to show when a drop is not allowed.
     * This defaults to 'no-drop'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get nodropCursor(): string; */
  /// The cursor to show when a drop is not allowed.
  /// This defaults to 'no-drop'.
  /// Read more about cursors at Diagram#currentCursor
  _i2.String get nodropCursor => _i5.getProperty(
        this,
        'nodropCursor',
      );
  /* #5902
  source: 
    /**
     * The cursor to show when a drop is not allowed.
     * This defaults to 'no-drop'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get nodropCursor(): string; */
  // Type InteropStaticType.string
  set nodropCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'nodropCursor',
      value,
    );
  }

  /* #5908
  source: 
    /**
     * Gets the Part found at the mouse point.
     * This is normally set by a call to #standardMouseSelect.
     */
    get currentPart(): Part | null; */
  /// Gets the Part found at the mouse point.
  /// This is normally set by a call to #standardMouseSelect.
  _i3.Part? get currentPart => _i5.getProperty(
        this,
        'currentPart',
      );
  /* #5908
  source: 
    /**
     * Gets the Part found at the mouse point.
     * This is normally set by a call to #standardMouseSelect.
     */
    get currentPart(): Part | null; */
  // Type InteropUnion#217853456(parent: InteropGetter#143491557(name: currentPart))
  set currentPart(_i3.Part? value) {
    _i5.setProperty(
      this,
      'currentPart',
      value ?? _i4.undefined,
    );
  }

  /* #5918
  source: 
    /**
     * Gets the collection of Parts that this tool has copied.
     * The value is a Map mapping Parts to DraggingInfo Objects
     * that have a "point" property remembering the original location of that Part.
     * The value is null when moving instead of copying.
     *
     * #draggedParts provides the map of Parts that are being moved and from which this collection was copied.
     */
    get copiedParts(): Map<Part, DraggingInfo> | null; */
  /// Gets the collection of Parts that this tool has copied.
  /// The value is a Map mapping Parts to DraggingInfo Objects
  /// that have a "point" property remembering the original location of that Part.
  /// The value is null when moving instead of copying.
  ///
  /// #draggedParts provides the map of Parts that are being moved and from which this collection was copied.
  _i3.Map<_i3.Part, _i3.DraggingInfo>? get copiedParts => _i5.getProperty(
        this,
        'copiedParts',
      );
  /* #5918
  source: 
    /**
     * Gets the collection of Parts that this tool has copied.
     * The value is a Map mapping Parts to DraggingInfo Objects
     * that have a "point" property remembering the original location of that Part.
     * The value is null when moving instead of copying.
     *
     * #draggedParts provides the map of Parts that are being moved and from which this collection was copied.
     */
    get copiedParts(): Map<Part, DraggingInfo> | null; */
  // Type InteropUnion#156392581(parent: InteropGetter#386320288(name: copiedParts))
  set copiedParts(_i3.Map<_i3.Part, _i3.DraggingInfo>? value) {
    _i5.setProperty(
      this,
      'copiedParts',
      value ?? _i4.undefined,
    );
  }

  /* #5927
  source: 
    /**
     * Gets the collection of Parts being moved.
     * The value is a Map mapping Parts to DraggingInfo Objects
     * that have a "point" property remembering the original location of that Part.
     *
     * #copiedParts provides the map of Parts that have been copied during a copying operation, if any.
     */
    get draggedParts(): Map<Part, DraggingInfo> | null; */
  /// Gets the collection of Parts being moved.
  /// The value is a Map mapping Parts to DraggingInfo Objects
  /// that have a "point" property remembering the original location of that Part.
  ///
  /// #copiedParts provides the map of Parts that have been copied during a copying operation, if any.
  _i3.Map<_i3.Part, _i3.DraggingInfo>? get draggedParts => _i5.getProperty(
        this,
        'draggedParts',
      );
  /* #5927
  source: 
    /**
     * Gets the collection of Parts being moved.
     * The value is a Map mapping Parts to DraggingInfo Objects
     * that have a "point" property remembering the original location of that Part.
     *
     * #copiedParts provides the map of Parts that have been copied during a copying operation, if any.
     */
    get draggedParts(): Map<Part, DraggingInfo> | null; */
  // Type InteropUnion#21111439(parent: InteropGetter#1072994565(name: draggedParts))
  set draggedParts(_i3.Map<_i3.Part, _i3.DraggingInfo>? value) {
    _i5.setProperty(
      this,
      'draggedParts',
      value ?? _i4.undefined,
    );
  }

  /* #5934
  source: 
    /**
     * (undocumented)
     * This read-only property returns a Set that holds all of the Parts that are currently being dragged for either copying or moving.
     * @return {Set.<Part>} Returns the Map#toKeySet of either #copiedParts or #draggedParts, or else an empty Set.
     */
    get draggingParts(): Set<Part>; */
  /// (undocumented)
  /// This read-only property returns a Set that holds all of the Parts that are currently being dragged for either copying or moving.
  _i3.Set<_i3.Part> get draggingParts => _i5.getProperty(
        this,
        'draggingParts',
      );
  /* #5934
  source: 
    /**
     * (undocumented)
     * This read-only property returns a Set that holds all of the Parts that are currently being dragged for either copying or moving.
     * @return {Set.<Part>} Returns the Map#toKeySet of either #copiedParts or #draggedParts, or else an empty Set.
     */
    get draggingParts(): Set<Part>; */
  // Type Instance of 'InteropInterface'
  set draggingParts(_i3.Set<_i3.Part> value) {
    _i5.setProperty(
      this,
      'draggingParts',
      value,
    );
  }

  /* #5944
  source: 
    /**
     * Gets or sets the mouse point from which parts start to move.
     * The value is a Point in document coordinates.
     * This property is normally set to the diagram's mouse-down point in #doActivate,
     * but may be set to a different point if parts are being copied from a different control.
     * Setting this property does not raise any events.
     */
    get startPoint(): Point; */
  /// Gets or sets the mouse point from which parts start to move.
  /// The value is a Point in document coordinates.
  /// This property is normally set to the diagram's mouse-down point in #doActivate,
  /// but may be set to a different point if parts are being copied from a different control.
  /// Setting this property does not raise any events.
  _i3.Point get startPoint => _i5.getProperty(
        this,
        'startPoint',
      );
  /* #5944
  source: 
    /**
     * Gets or sets the mouse point from which parts start to move.
     * The value is a Point in document coordinates.
     * This property is normally set to the diagram's mouse-down point in #doActivate,
     * but may be set to a different point if parts are being copied from a different control.
     * Setting this property does not raise any events.
     */
    get startPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set startPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'startPoint',
      value,
    );
  }

  /* #5952
  source: 
    /**
     * On touch gestures only, this property gets or sets the time in milliseconds
     * for which the mouse must be stationary before this tool can be started.
     * The default value is 100 milliseconds.
     * Setting this property does not raise any events.
     */
    get delay(): number; */
  /// On touch gestures only, this property gets or sets the time in milliseconds
  /// for which the mouse must be stationary before this tool can be started.
  /// The default value is 100 milliseconds.
  /// Setting this property does not raise any events.
  _i2.num get delay => _i5.getProperty(
        this,
        'delay',
      );
  /* #5952
  source: 
    /**
     * On touch gestures only, this property gets or sets the time in milliseconds
     * for which the mouse must be stationary before this tool can be started.
     * The default value is 100 milliseconds.
     * Setting this property does not raise any events.
     */
    get delay(): number; */
  // Type InteropStaticType.number
  set delay(_i2.num value) {
    _i5.setProperty(
      this,
      'delay',
      value,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  _i3.Part? findDraggablePart() => _i5.callMethod(
        this,
        'findDraggablePart',
        [],
      );
  void standardMouseSelect() {
    _i5.callMethod(
      this,
      'standardMouseSelect',
      [],
    );
  }

  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  _i3.Map<_i3.Part, _i3.DraggingInfo> computeEffectiveCollection(
    _i3.Iterable<_i3.Part> parts,
    _i3.DraggingOptions options,
  ) =>
      _i5.callMethod(
        this,
        'computeEffectiveCollection',
        [
          parts,
          options,
        ],
      );
  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  _i2.bool stopTransaction() => _i5.callMethod(
        this,
        'stopTransaction',
        [],
      );
  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void doKeyDown() {
    _i5.callMethod(
      this,
      'doKeyDown',
      [],
    );
  }

  void doKeyUp() {
    _i5.callMethod(
      this,
      'doKeyUp',
      [],
    );
  }

  void moveParts(
    _i3.Map<_i3.Part, _i3.DraggingInfo> parts,
    _i3.Point offset, [
    _i2.bool? check,
  ]) {
    _i5.callMethod(
      this,
      'moveParts',
      [
        parts,
        offset,
        check ?? _i4.undefined,
      ],
    );
  }

  _i3.GraphObject? findDragOverObject(_i3.Point pt) => _i5.callMethod(
        this,
        'findDragOverObject',
        [pt],
      );
  void doDragOver(
    _i3.Point pt, [
    _i3.GraphObject? obj,
  ]) {
    _i5.callMethod(
      this,
      'doDragOver',
      [
        pt,
        obj ?? _i4.undefined,
      ],
    );
  }

  void doDropOnto(
    _i3.Point pt, [
    _i3.GraphObject? obj,
  ]) {
    _i5.callMethod(
      this,
      'doDropOnto',
      [
        pt,
        obj ?? _i4.undefined,
      ],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  _i2.bool simulatedMouseMove(
    _i2.dynamic e,
    _i3.Point modelpt, [
    _i3.Diagram? overdiag,
  ]) =>
      _i5.callMethod(
        this,
        'simulatedMouseMove',
        [
          e ?? _i4.undefined,
          modelpt,
          overdiag ?? _i4.undefined,
        ],
      );
  _i2.bool simulatedMouseUp(
    _i2.dynamic e,
    _i3.Point modelpt, [
    _i3.Diagram? curdiag,
  ]) =>
      _i5.callMethod(
        this,
        'simulatedMouseUp',
        [
          e ?? _i4.undefined,
          modelpt,
          curdiag ?? _i4.undefined,
        ],
      );
  _i2.bool mayCopy() => _i5.callMethod(
        this,
        'mayCopy',
        [],
      );
  _i2.bool mayMove() => _i5.callMethod(
        this,
        'mayMove',
        [],
      );
  _i3.Point computeMove(
    _i3.Part n,
    _i3.Point newloc, [
    _i3.Map<_i3.Part, _i3.DraggingInfo>? draggedparts,
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'computeMove',
        [
          n,
          newloc,
          draggedparts ?? _i4.undefined,
          result ?? _i4.undefined,
        ],
      );
}

@_i1.JS()
@_i1.staticInterop
class LinkingBaseTool implements _i3.Tool {
  factory LinkingBaseTool() => _i5.callConstructor(
        _declaredLinkingBaseTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LinkingBaseTool')
external _i2.Object _declaredLinkingBaseTool;

extension LinkingBaseTool$Typings on LinkingBaseTool {
  /* #6209
  source: 
    /**
     * Gets or sets the distance at which link snapping occurs.
     * The default value is 100.0.
     * The value must be non-negative.
     * Setting this property does not raise any events.
     */
    get portGravity(): number; */
  /// Gets or sets the distance at which link snapping occurs.
  /// The default value is 100.0.
  /// The value must be non-negative.
  /// Setting this property does not raise any events.
  _i2.num get portGravity => _i5.getProperty(
        this,
        'portGravity',
      );
  /* #6209
  source: 
    /**
     * Gets or sets the distance at which link snapping occurs.
     * The default value is 100.0.
     * The value must be non-negative.
     * Setting this property does not raise any events.
     */
    get portGravity(): number; */
  // Type InteropStaticType.number
  set portGravity(_i2.num value) {
    _i5.setProperty(
      this,
      'portGravity',
      value,
    );
  }

  /* #6218
  source: 
    /**
     * Gets or sets whether it is valid to have partly or completely unconnected links.
     *
     * The default value is false -- the user cannot draw or reconnect a link to "nowhere".
     * Setting this property does not raise any events.
     * @since 1.3
     */
    get isUnconnectedLinkValid(): boolean; */
  /// Gets or sets whether it is valid to have partly or completely unconnected links.
  ///
  /// The default value is false -- the user cannot draw or reconnect a link to "nowhere".
  /// Setting this property does not raise any events.
  _i2.bool get isUnconnectedLinkValid => _i5.getProperty(
        this,
        'isUnconnectedLinkValid',
      );
  /* #6218
  source: 
    /**
     * Gets or sets whether it is valid to have partly or completely unconnected links.
     *
     * The default value is false -- the user cannot draw or reconnect a link to "nowhere".
     * Setting this property does not raise any events.
     * @since 1.3
     */
    get isUnconnectedLinkValid(): boolean; */
  // Type InteropStaticType.boolean
  set isUnconnectedLinkValid(_i2.bool value) {
    _i5.setProperty(
      this,
      'isUnconnectedLinkValid',
      value,
    );
  }

  /* #6226
  source: 
    /**
     * Gets or sets the cursor used during the linking or relinking operation.
     * This defaults to 'pointer'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get linkingCursor(): string; */
  /// Gets or sets the cursor used during the linking or relinking operation.
  /// This defaults to 'pointer'.
  /// Read more about cursors at Diagram#currentCursor
  _i2.String get linkingCursor => _i5.getProperty(
        this,
        'linkingCursor',
      );
  /* #6226
  source: 
    /**
     * Gets or sets the cursor used during the linking or relinking operation.
     * This defaults to 'pointer'.
     * Read more about cursors at Diagram#currentCursor
     * @since 2.2
     */
    get linkingCursor(): string; */
  // Type InteropStaticType.string
  set linkingCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'linkingCursor',
      value,
    );
  }

  /* #6232
  source: 
    /**
     * Gets or sets the temporary Link that is shown while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryLink(): Link; */
  /// Gets or sets the temporary Link that is shown while the user is drawing or reconnecting a link.
  /// Setting this property does not raise any events.
  _i3.Link get temporaryLink => _i5.getProperty(
        this,
        'temporaryLink',
      );
  /* #6232
  source: 
    /**
     * Gets or sets the temporary Link that is shown while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryLink(): Link; */
  // Type Instance of 'InteropInterface'
  set temporaryLink(_i3.Link value) {
    _i5.setProperty(
      this,
      'temporaryLink',
      value,
    );
  }

  /* #6239
  source: 
    /**
     * Gets or sets the temporary Node at the "from" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryFromNode(): Node; */
  /// Gets or sets the temporary Node at the "from" end of the #temporaryLink
  /// while the user is drawing or reconnecting a link.
  /// Setting this property does not raise any events.
  _i3.Node get temporaryFromNode => _i5.getProperty(
        this,
        'temporaryFromNode',
      );
  /* #6239
  source: 
    /**
     * Gets or sets the temporary Node at the "from" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryFromNode(): Node; */
  // Type Instance of 'InteropInterface'
  set temporaryFromNode(_i3.Node value) {
    _i5.setProperty(
      this,
      'temporaryFromNode',
      value,
    );
  }

  /* #6246
  source: 
    /**
     * Gets or sets the GraphObject that is the port at the "from" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryFromPort(): GraphObject; */
  /// Gets or sets the GraphObject that is the port at the "from" end of the #temporaryLink
  /// while the user is drawing or reconnecting a link.
  /// Setting this property does not raise any events.
  _i3.GraphObject get temporaryFromPort => _i5.getProperty(
        this,
        'temporaryFromPort',
      );
  /* #6246
  source: 
    /**
     * Gets or sets the GraphObject that is the port at the "from" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryFromPort(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set temporaryFromPort(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'temporaryFromPort',
      value,
    );
  }

  /* #6253
  source: 
    /**
     * Gets or sets the temporary Node at the "to" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryToNode(): Node; */
  /// Gets or sets the temporary Node at the "to" end of the #temporaryLink
  /// while the user is drawing or reconnecting a link.
  /// Setting this property does not raise any events.
  _i3.Node get temporaryToNode => _i5.getProperty(
        this,
        'temporaryToNode',
      );
  /* #6253
  source: 
    /**
     * Gets or sets the temporary Node at the "to" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryToNode(): Node; */
  // Type Instance of 'InteropInterface'
  set temporaryToNode(_i3.Node value) {
    _i5.setProperty(
      this,
      'temporaryToNode',
      value,
    );
  }

  /* #6260
  source: 
    /**
     * Gets or sets the GraphObject that is the port at the "to" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryToPort(): GraphObject; */
  /// Gets or sets the GraphObject that is the port at the "to" end of the #temporaryLink
  /// while the user is drawing or reconnecting a link.
  /// Setting this property does not raise any events.
  _i3.GraphObject get temporaryToPort => _i5.getProperty(
        this,
        'temporaryToPort',
      );
  /* #6260
  source: 
    /**
     * Gets or sets the GraphObject that is the port at the "to" end of the #temporaryLink
     * while the user is drawing or reconnecting a link.
     * Setting this property does not raise any events.
     */
    get temporaryToPort(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set temporaryToPort(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'temporaryToPort',
      value,
    );
  }

  /* #6266
  source: 
    /**
     * Gets or sets the original Link being reconnected by the RelinkingTool.
     * Setting this property does not raise any events.
     */
    get originalLink(): Link | null; */
  /// Gets or sets the original Link being reconnected by the RelinkingTool.
  /// Setting this property does not raise any events.
  _i3.Link? get originalLink => _i5.getProperty(
        this,
        'originalLink',
      );
  /* #6266
  source: 
    /**
     * Gets or sets the original Link being reconnected by the RelinkingTool.
     * Setting this property does not raise any events.
     */
    get originalLink(): Link | null; */
  // Type InteropUnion#775504653(parent: InteropGetter#62060221(name: originalLink))
  set originalLink(_i3.Link? value) {
    _i5.setProperty(
      this,
      'originalLink',
      value ?? _i4.undefined,
    );
  }

  /* #6273
  source: 
    /**
     * Gets or sets the original Node from which the new link is being drawn
     * or from which the #originalLink was connected when being relinked.
     * Setting this property does not raise any events.
     */
    get originalFromNode(): Node | null; */
  /// Gets or sets the original Node from which the new link is being drawn
  /// or from which the #originalLink was connected when being relinked.
  /// Setting this property does not raise any events.
  _i3.Node? get originalFromNode => _i5.getProperty(
        this,
        'originalFromNode',
      );
  /* #6273
  source: 
    /**
     * Gets or sets the original Node from which the new link is being drawn
     * or from which the #originalLink was connected when being relinked.
     * Setting this property does not raise any events.
     */
    get originalFromNode(): Node | null; */
  // Type InteropUnion#73968607(parent: InteropGetter#634969977(name: originalFromNode))
  set originalFromNode(_i3.Node? value) {
    _i5.setProperty(
      this,
      'originalFromNode',
      value ?? _i4.undefined,
    );
  }

  /* #6279
  source: 
    /**
     * Gets or sets the GraphObject that is the port in the #originalFromNode.
     * Setting this property does not raise any events.
     */
    get originalFromPort(): GraphObject | null; */
  /// Gets or sets the GraphObject that is the port in the #originalFromNode.
  /// Setting this property does not raise any events.
  _i3.GraphObject? get originalFromPort => _i5.getProperty(
        this,
        'originalFromPort',
      );
  /* #6279
  source: 
    /**
     * Gets or sets the GraphObject that is the port in the #originalFromNode.
     * Setting this property does not raise any events.
     */
    get originalFromPort(): GraphObject | null; */
  // Type InteropUnion#711542235(parent: InteropGetter#392019221(name: originalFromPort))
  set originalFromPort(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'originalFromPort',
      value ?? _i4.undefined,
    );
  }

  /* #6286
  source: 
    /**
     * Gets or sets the original Node to which the new link is being drawn
     * or to which the #originalLink was connected when being relinked.
     * Setting this property does not raise any events.
     */
    get originalToNode(): Node | null; */
  /// Gets or sets the original Node to which the new link is being drawn
  /// or to which the #originalLink was connected when being relinked.
  /// Setting this property does not raise any events.
  _i3.Node? get originalToNode => _i5.getProperty(
        this,
        'originalToNode',
      );
  /* #6286
  source: 
    /**
     * Gets or sets the original Node to which the new link is being drawn
     * or to which the #originalLink was connected when being relinked.
     * Setting this property does not raise any events.
     */
    get originalToNode(): Node | null; */
  // Type InteropUnion#450673965(parent: InteropGetter#15511627(name: originalToNode))
  set originalToNode(_i3.Node? value) {
    _i5.setProperty(
      this,
      'originalToNode',
      value ?? _i4.undefined,
    );
  }

  /* #6292
  source: 
    /**
     * Gets or sets the GraphObject that is the port in the #originalToNode.
     * Setting this property does not raise any events.
     */
    get originalToPort(): GraphObject | null; */
  /// Gets or sets the GraphObject that is the port in the #originalToNode.
  /// Setting this property does not raise any events.
  _i3.GraphObject? get originalToPort => _i5.getProperty(
        this,
        'originalToPort',
      );
  /* #6292
  source: 
    /**
     * Gets or sets the GraphObject that is the port in the #originalToNode.
     * Setting this property does not raise any events.
     */
    get originalToPort(): GraphObject | null; */
  // Type InteropUnion#308302038(parent: InteropGetter#728466391(name: originalToPort))
  set originalToPort(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'originalToPort',
      value ?? _i4.undefined,
    );
  }

  /* #6298
  source: 
    /**
     * Gets whether the linking operation is in the forwards direction,
     * connecting from the "From" port to the "To" port.
     */
    get isForwards(): boolean; */
  /// Gets whether the linking operation is in the forwards direction,
  /// connecting from the "From" port to the "To" port.
  _i2.bool get isForwards => _i5.getProperty(
        this,
        'isForwards',
      );
  /* #6298
  source: 
    /**
     * Gets whether the linking operation is in the forwards direction,
     * connecting from the "From" port to the "To" port.
     */
    get isForwards(): boolean; */
  // Type InteropStaticType.boolean
  set isForwards(_i2.bool value) {
    _i5.setProperty(
      this,
      'isForwards',
      value,
    );
  }

  /* #6309
  source: 
    /**
     * Gets or sets a proposed GraphObject port for connecting a link.
     * Whether this is a "to" port or a "from" port depends on the direction
     * (#isForwards) in which the link is being drawn or reconnected.
     *
     * This is set when the mouse is being dragged and when a mouse-up event occurs
     * with the result of a call to #findTargetPort.
     * Setting this property does not raise any events.
     */
    get targetPort(): GraphObject | null; */
  /// Gets or sets a proposed GraphObject port for connecting a link.
  /// Whether this is a "to" port or a "from" port depends on the direction
  /// (#isForwards) in which the link is being drawn or reconnected.
  ///
  /// This is set when the mouse is being dragged and when a mouse-up event occurs
  /// with the result of a call to #findTargetPort.
  /// Setting this property does not raise any events.
  _i3.GraphObject? get targetPort => _i5.getProperty(
        this,
        'targetPort',
      );
  /* #6309
  source: 
    /**
     * Gets or sets a proposed GraphObject port for connecting a link.
     * Whether this is a "to" port or a "from" port depends on the direction
     * (#isForwards) in which the link is being drawn or reconnected.
     *
     * This is set when the mouse is being dragged and when a mouse-up event occurs
     * with the result of a call to #findTargetPort.
     * Setting this property does not raise any events.
     */
    get targetPort(): GraphObject | null; */
  // Type InteropUnion#277567641(parent: InteropGetter#17906999(name: targetPort))
  set targetPort(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'targetPort',
      value ?? _i4.undefined,
    );
  }

  /* #6503
  source: 
    /**
     * Gets or sets a predicate that determines whether or not a new link between two ports would be valid.
     * This predicate is called in addition to the normal link checking performed by #isValidLink
     * and any Node#linkValidation predicates on the "from" and "to" nodes.
     * When relinking, the Link being considered for reconnection is passed as the fifth argument.
     * The default predicate is null, which is equivalent to simply returning true.
     * <p class="boxread">
     * For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get linkValidation(): ((fromNode: Node, fromPort: GraphObject, toNode: Node, toPort: GraphObject, link: Link) => boolean) | null; */
  /// Gets or sets a predicate that determines whether or not a new link between two ports would be valid.
  /// This predicate is called in addition to the normal link checking performed by #isValidLink
  /// and any Node#linkValidation predicates on the "from" and "to" nodes.
  /// When relinking, the Link being considered for reconnection is passed as the fifth argument.
  /// The default predicate is null, which is equivalent to simply returning true.
  /// <p class="boxread">
  /// For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
  ///
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i3.Node,
    _i3.GraphObject,
    _i3.Node,
    _i3.GraphObject,
    _i3.Link,
  )? get linkValidation => _i5.getProperty(
        this,
        'linkValidation',
      );
  /* #6503
  source: 
    /**
     * Gets or sets a predicate that determines whether or not a new link between two ports would be valid.
     * This predicate is called in addition to the normal link checking performed by #isValidLink
     * and any Node#linkValidation predicates on the "from" and "to" nodes.
     * When relinking, the Link being considered for reconnection is passed as the fifth argument.
     * The default predicate is null, which is equivalent to simply returning true.
     * <p class="boxread">
     * For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get linkValidation(): ((fromNode: Node, fromPort: GraphObject, toNode: Node, toPort: GraphObject, link: Link) => boolean) | null; */
  // Type InteropUnion#687690906(parent: InteropGetter#780096305(name: linkValidation))
  set linkValidation(
      _i2.bool Function(
        _i3.Node,
        _i3.GraphObject,
        _i3.Node,
        _i3.GraphObject,
        _i3.Link,
      )? value) {
    _i5.setProperty(
      this,
      'linkValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #6522
  source: 
    /**
     * Gets or sets a function that is called as the tool targets the nearest valid port.
     * The first two arguments specify the port by providing the Node that it is in
     * and the GraphObject that is the actual port object.
     * The next two arguments are the temporary port that has been moved and styled to be like the valid port.
     * These values will be either the #temporaryToNode and #temporaryToPort
     * or the #temporaryFromNode and #temporaryFromPort, depending on
     * which end of the temporary link is being updated.
     * The fifth argument is true if the target port represents a potential "to" end of a link;
     * it is false if it is for the "from" end of a link.
     *
     * When there is no valid port within the #portGravity, the first two arguments are null.
     *
     * The function, if supplied, must not add or remove any links or nodes or port objects,
     * nor may it change the validity of any potential link connection.
     * @since 1.2
     */
    get portTargeted(): ((node: Node | null, port: GraphObject | null, tempNode: Node, tempPort: GraphObject, toEnd: boolean) => void) | null; */
  /// Gets or sets a function that is called as the tool targets the nearest valid port.
  /// The first two arguments specify the port by providing the Node that it is in
  /// and the GraphObject that is the actual port object.
  /// The next two arguments are the temporary port that has been moved and styled to be like the valid port.
  /// These values will be either the #temporaryToNode and #temporaryToPort
  /// or the #temporaryFromNode and #temporaryFromPort, depending on
  /// which end of the temporary link is being updated.
  /// The fifth argument is true if the target port represents a potential "to" end of a link;
  /// it is false if it is for the "from" end of a link.
  ///
  /// When there is no valid port within the #portGravity, the first two arguments are null.
  ///
  /// The function, if supplied, must not add or remove any links or nodes or port objects,
  /// nor may it change the validity of any potential link connection.
  void Function(
    _i3.Node?,
    _i3.GraphObject?,
    _i3.Node,
    _i3.GraphObject,
    _i2.bool,
  )? get portTargeted => _i5.getProperty(
        this,
        'portTargeted',
      );
  /* #6522
  source: 
    /**
     * Gets or sets a function that is called as the tool targets the nearest valid port.
     * The first two arguments specify the port by providing the Node that it is in
     * and the GraphObject that is the actual port object.
     * The next two arguments are the temporary port that has been moved and styled to be like the valid port.
     * These values will be either the #temporaryToNode and #temporaryToPort
     * or the #temporaryFromNode and #temporaryFromPort, depending on
     * which end of the temporary link is being updated.
     * The fifth argument is true if the target port represents a potential "to" end of a link;
     * it is false if it is for the "from" end of a link.
     *
     * When there is no valid port within the #portGravity, the first two arguments are null.
     *
     * The function, if supplied, must not add or remove any links or nodes or port objects,
     * nor may it change the validity of any potential link connection.
     * @since 1.2
     */
    get portTargeted(): ((node: Node | null, port: GraphObject | null, tempNode: Node, tempPort: GraphObject, toEnd: boolean) => void) | null; */
  // Type InteropUnion#551711214(parent: InteropGetter#123935266(name: portTargeted))
  set portTargeted(
      void Function(
        _i3.Node?,
        _i3.GraphObject?,
        _i3.Node,
        _i3.GraphObject,
        _i2.bool,
      )? value) {
    _i5.setProperty(
      this,
      'portTargeted',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  void copyPortProperties(
    _i3.Node? realnode,
    _i3.GraphObject? realport,
    _i3.Node tempnode,
    _i3.GraphObject tempport,
    _i2.bool toend,
  ) {
    _i5.callMethod(
      this,
      'copyPortProperties',
      [
        realnode ?? _i4.undefined,
        realport ?? _i4.undefined,
        tempnode,
        tempport,
        toend,
      ],
    );
  }

  void setNoTargetPortProperties(
    _i3.Node tempnode,
    _i3.GraphObject tempport,
    _i2.bool toend,
  ) {
    _i5.callMethod(
      this,
      'setNoTargetPortProperties',
      [
        tempnode,
        tempport,
        toend,
      ],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  _i3.GraphObject? findTargetPort(_i2.bool toend) => _i5.callMethod(
        this,
        'findTargetPort',
        [toend],
      );
  _i2.bool isValidFrom([
    _i3.Node? fromnode,
    _i3.GraphObject? fromport,
  ]) =>
      _i5.callMethod(
        this,
        'isValidFrom',
        [
          fromnode ?? _i4.undefined,
          fromport ?? _i4.undefined,
        ],
      );
  _i2.bool isValidTo([
    _i3.Node? tonode,
    _i3.GraphObject? toport,
  ]) =>
      _i5.callMethod(
        this,
        'isValidTo',
        [
          tonode ?? _i4.undefined,
          toport ?? _i4.undefined,
        ],
      );
  _i2.bool isInSameNode([
    _i3.GraphObject? fromport,
    _i3.GraphObject? toport,
  ]) =>
      _i5.callMethod(
        this,
        'isInSameNode',
        [
          fromport ?? _i4.undefined,
          toport ?? _i4.undefined,
        ],
      );
  _i2.bool isLinked([
    _i3.GraphObject? fromport,
    _i3.GraphObject? toport,
  ]) =>
      _i5.callMethod(
        this,
        'isLinked',
        [
          fromport ?? _i4.undefined,
          toport ?? _i4.undefined,
        ],
      );
  _i2.bool isValidLink([
    _i3.Node? fromnode,
    _i3.GraphObject? fromport,
    _i3.Node? tonode,
    _i3.GraphObject? toport,
  ]) =>
      _i5.callMethod(
        this,
        'isValidLink',
        [
          fromnode ?? _i4.undefined,
          fromport ?? _i4.undefined,
          tonode ?? _i4.undefined,
          toport ?? _i4.undefined,
        ],
      );
  _i2.bool isValidCycle([
    _i3.Node? from,
    _i3.Node? to,
    _i3.Link? ignore,
  ]) =>
      _i5.callMethod(
        this,
        'isValidCycle',
        [
          from ?? _i4.undefined,
          to ?? _i4.undefined,
          ignore ?? _i4.undefined,
        ],
      );
}

@_i1.JS()
@_i1.staticInterop
class LinkingTool implements _i3.LinkingBaseTool {
  factory LinkingTool() => _i5.callConstructor(
        _declaredLinkingTool,
        [],
      );

  /* #6572
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links in either direction.
     * @constant
     */
    static Either: EnumValue; */
  /// This value for LinkingTool#direction indicates that users may draw new links in either direction.
  static _i3.EnumValue get either => _i5.getProperty(
        _declaredLinkingTool,
        'Either',
      );
  /* #6572
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links in either direction.
     * @constant
     */
    static Either: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set either(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkingTool,
      'Either',
      value,
    );
  }

  /* #6578
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links forwards only
     * (i.e. from "from" node to "to" node).
     * @constant
     */
    static ForwardsOnly: EnumValue; */
  /// This value for LinkingTool#direction indicates that users may draw new links forwards only
  /// (i.e. from "from" node to "to" node).
  static _i3.EnumValue get forwardsOnly => _i5.getProperty(
        _declaredLinkingTool,
        'ForwardsOnly',
      );
  /* #6578
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links forwards only
     * (i.e. from "from" node to "to" node).
     * @constant
     */
    static ForwardsOnly: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set forwardsOnly(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkingTool,
      'ForwardsOnly',
      value,
    );
  }

  /* #6584
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links backwards only
     * (i.e. from "to" node to "from" node).
     * @constant
     */
    static BackwardsOnly: EnumValue; */
  /// This value for LinkingTool#direction indicates that users may draw new links backwards only
  /// (i.e. from "to" node to "from" node).
  static _i3.EnumValue get backwardsOnly => _i5.getProperty(
        _declaredLinkingTool,
        'BackwardsOnly',
      );
  /* #6584
  source: 
    /**
     * This value for LinkingTool#direction indicates that users may draw new links backwards only
     * (i.e. from "to" node to "from" node).
     * @constant
     */
    static BackwardsOnly: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set backwardsOnly(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkingTool,
      'BackwardsOnly',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('LinkingTool')
external _i2.Object _declaredLinkingTool;

extension LinkingTool$Typings on LinkingTool {
  /* #6602
  source: 
    /**
     * Gets or sets a data object that is copied by #insertLink
     * and added to the GraphLinksModel when creating a new Link.
     * The default value is an empty Object, which will be copied.
     * The value must be an Object for the linking operation to succeed.
     * A null value will cause #insertLink to fail.
     *
     * The copied link data's GraphLinksModel#linkFromKeyProperty
     * and GraphLinksModel#linkToKeyProperty properties are set to
     * the corresponding node's data's key values.
     * If the ports have GraphObject#portId values that are not null,
     * the link data's GraphLinksModel#linkFromPortIdProperty
     * and GraphLinksModel#linkToPortIdProperty properties are also set.
     *
     * Setting this property does not raise any events.
     * This property is ignored if the Diagram#model is not a GraphLinksModel.
     */
    get archetypeLinkData(): ObjectData | null; */
  /// Gets or sets a data object that is copied by #insertLink
  /// and added to the GraphLinksModel when creating a new Link.
  /// The default value is an empty Object, which will be copied.
  /// The value must be an Object for the linking operation to succeed.
  /// A null value will cause #insertLink to fail.
  ///
  /// The copied link data's GraphLinksModel#linkFromKeyProperty
  /// and GraphLinksModel#linkToKeyProperty properties are set to
  /// the corresponding node's data's key values.
  /// If the ports have GraphObject#portId values that are not null,
  /// the link data's GraphLinksModel#linkFromPortIdProperty
  /// and GraphLinksModel#linkToPortIdProperty properties are also set.
  ///
  /// Setting this property does not raise any events.
  /// This property is ignored if the Diagram#model is not a GraphLinksModel.
  _i2.Object? get archetypeLinkData => _i5.getProperty(
        this,
        'archetypeLinkData',
      );
  /* #6602
  source: 
    /**
     * Gets or sets a data object that is copied by #insertLink
     * and added to the GraphLinksModel when creating a new Link.
     * The default value is an empty Object, which will be copied.
     * The value must be an Object for the linking operation to succeed.
     * A null value will cause #insertLink to fail.
     *
     * The copied link data's GraphLinksModel#linkFromKeyProperty
     * and GraphLinksModel#linkToKeyProperty properties are set to
     * the corresponding node's data's key values.
     * If the ports have GraphObject#portId values that are not null,
     * the link data's GraphLinksModel#linkFromPortIdProperty
     * and GraphLinksModel#linkToPortIdProperty properties are also set.
     *
     * Setting this property does not raise any events.
     * This property is ignored if the Diagram#model is not a GraphLinksModel.
     */
    get archetypeLinkData(): ObjectData | null; */
  // Type InteropUnion#932064196(parent: InteropGetter#969053776(name: archetypeLinkData))
  set archetypeLinkData(_i2.Object? value) {
    _i5.setProperty(
      this,
      'archetypeLinkData',
      value ?? _i4.undefined,
    );
  }

  /* #6617
  source: 
    /**
     * Gets or sets an optional node data object representing a link label, that is copied by #insertLink
     * and added to the GraphLinksModel when creating a new Link.
     *
     * The default value is null, which causes no such label node data to be added to the model
     * along with the new link data.
     *
     * #insertLink calls GraphLinksModel#addLabelKeyForLinkData
     * to associate the label node data with the link data.
     *
     * Setting this property does not raise any events.
     * This property is ignored if the Diagram#model is not a GraphLinksModel.
     */
    get archetypeLabelNodeData(): ObjectData | null; */
  /// Gets or sets an optional node data object representing a link label, that is copied by #insertLink
  /// and added to the GraphLinksModel when creating a new Link.
  ///
  /// The default value is null, which causes no such label node data to be added to the model
  /// along with the new link data.
  ///
  /// #insertLink calls GraphLinksModel#addLabelKeyForLinkData
  /// to associate the label node data with the link data.
  ///
  /// Setting this property does not raise any events.
  /// This property is ignored if the Diagram#model is not a GraphLinksModel.
  _i2.Object? get archetypeLabelNodeData => _i5.getProperty(
        this,
        'archetypeLabelNodeData',
      );
  /* #6617
  source: 
    /**
     * Gets or sets an optional node data object representing a link label, that is copied by #insertLink
     * and added to the GraphLinksModel when creating a new Link.
     *
     * The default value is null, which causes no such label node data to be added to the model
     * along with the new link data.
     *
     * #insertLink calls GraphLinksModel#addLabelKeyForLinkData
     * to associate the label node data with the link data.
     *
     * Setting this property does not raise any events.
     * This property is ignored if the Diagram#model is not a GraphLinksModel.
     */
    get archetypeLabelNodeData(): ObjectData | null; */
  // Type InteropUnion#939072434(parent: InteropGetter#889818486(name: archetypeLabelNodeData))
  set archetypeLabelNodeData(_i2.Object? value) {
    _i5.setProperty(
      this,
      'archetypeLabelNodeData',
      value ?? _i4.undefined,
    );
  }

  /* #6625
  source: 
    /**
     * Gets or sets the direction in which new links may be drawn.
     * Possible values are LinkingTool.ForwardsOnly, LinkingTool.BackwardsOnly, or LinkingTool.Either.
     * This defaults to LinkingTool.Either.
     * Setting this property does not raise any events.
     */
    get direction(): EnumValue; */
  /// Gets or sets the direction in which new links may be drawn.
  /// Possible values are LinkingTool.ForwardsOnly, LinkingTool.BackwardsOnly, or LinkingTool.Either.
  /// This defaults to LinkingTool.Either.
  /// Setting this property does not raise any events.
  _i3.EnumValue get direction => _i5.getProperty(
        this,
        'direction',
      );
  /* #6625
  source: 
    /**
     * Gets or sets the direction in which new links may be drawn.
     * Possible values are LinkingTool.ForwardsOnly, LinkingTool.BackwardsOnly, or LinkingTool.Either.
     * This defaults to LinkingTool.Either.
     * Setting this property does not raise any events.
     */
    get direction(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set direction(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'direction',
      value,
    );
  }

  /* #6644
  source: 
    /**
     * Gets or sets the GraphObject at which #findLinkablePort should start its search.
     * The default value is null.
     * Setting this property does not raise any events.
     *
     * If you want to explicitly start a new user mouse-gesture to draw a new link
     * from a given GraphObject that may be a "port" object or may be within
     * the visual tree of a "port" object, set this property to that object
     * to let #findLinkablePort find the real "port" object.
     * Then start and activate this tool:
     * ```js
     *   var tool = myDiagram.toolManager.linkingTool;
     *   tool.startObject = ...;
     *   myDiagram.currentTool = tool;
     *   tool.doActivate();
     * ```
     */
    get startObject(): GraphObject | null; */
  /// Gets or sets the GraphObject at which #findLinkablePort should start its search.
  /// The default value is null.
  /// Setting this property does not raise any events.
  ///
  /// If you want to explicitly start a new user mouse-gesture to draw a new link
  /// from a given GraphObject that may be a "port" object or may be within
  /// the visual tree of a "port" object, set this property to that object
  /// to let #findLinkablePort find the real "port" object.
  /// Then start and activate this tool:
  /// ```js
  ///   var tool = myDiagram.toolManager.linkingTool;
  ///   tool.startObject = ...;
  ///   myDiagram.currentTool = tool;
  ///   tool.doActivate();
  /// ```
  _i3.GraphObject? get startObject => _i5.getProperty(
        this,
        'startObject',
      );
  /* #6644
  source: 
    /**
     * Gets or sets the GraphObject at which #findLinkablePort should start its search.
     * The default value is null.
     * Setting this property does not raise any events.
     *
     * If you want to explicitly start a new user mouse-gesture to draw a new link
     * from a given GraphObject that may be a "port" object or may be within
     * the visual tree of a "port" object, set this property to that object
     * to let #findLinkablePort find the real "port" object.
     * Then start and activate this tool:
     * ```js
     *   var tool = myDiagram.toolManager.linkingTool;
     *   tool.startObject = ...;
     *   myDiagram.currentTool = tool;
     *   tool.doActivate();
     * ```
     */
    get startObject(): GraphObject | null; */
  // Type InteropUnion#630726599(parent: InteropGetter#519439890(name: startObject))
  set startObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'startObject',
      value ?? _i4.undefined,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  _i3.GraphObject? findLinkablePort() => _i5.callMethod(
        this,
        'findLinkablePort',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  _i3.Link? insertLink([
    _i3.Node? fromnode,
    _i3.GraphObject? fromport,
    _i3.Node? tonode,
    _i3.GraphObject? toport,
  ]) =>
      _i5.callMethod(
        this,
        'insertLink',
        [
          fromnode ?? _i4.undefined,
          fromport ?? _i4.undefined,
          tonode ?? _i4.undefined,
          toport ?? _i4.undefined,
        ],
      );
  void doNoLink([
    _i3.Node? fromnode,
    _i3.GraphObject? fromport,
    _i3.Node? tonode,
    _i3.GraphObject? toport,
  ]) {
    _i5.callMethod(
      this,
      'doNoLink',
      [
        fromnode ?? _i4.undefined,
        fromport ?? _i4.undefined,
        tonode ?? _i4.undefined,
        toport ?? _i4.undefined,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class RelinkingTool implements _i3.LinkingBaseTool {
  factory RelinkingTool() => _i5.callConstructor(
        _declaredRelinkingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('RelinkingTool')
external _i2.Object _declaredRelinkingTool;

extension RelinkingTool$Typings on RelinkingTool {
  /* #6829
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
     * at the "from" end of the link.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger green triangles:
     * ```js
     * myDiagram.toolManager.relinkingTool.toHandleArchetype =
     *   $(go.Shape, "Triangle",
     *     { width: 10, height: 10, fill: "limegreen", segmentIndex: 0 });
     * ```
     * @see #toHandleArchetype
     */
    get fromHandleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
  /// at the "from" end of the link.
  /// By default this is a Shape that is a small blue diamond.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handle to be larger green triangles:
  /// ```js
  /// myDiagram.toolManager.relinkingTool.toHandleArchetype =
  ///   $(go.Shape, "Triangle",
  ///     { width: 10, height: 10, fill: "limegreen", segmentIndex: 0 });
  /// ```
  _i3.GraphObject? get fromHandleArchetype => _i5.getProperty(
        this,
        'fromHandleArchetype',
      );
  /* #6829
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
     * at the "from" end of the link.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger green triangles:
     * ```js
     * myDiagram.toolManager.relinkingTool.toHandleArchetype =
     *   $(go.Shape, "Triangle",
     *     { width: 10, height: 10, fill: "limegreen", segmentIndex: 0 });
     * ```
     * @see #toHandleArchetype
     */
    get fromHandleArchetype(): GraphObject | null; */
  // Type InteropUnion#468302610(parent: InteropGetter#12655392(name: fromHandleArchetype))
  set fromHandleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'fromHandleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #6845
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
     * at the "to" end of the link.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger orange triangles:
     * ```js
     *   myDiagram.toolManager.relinkingTool.toHandleArchetype =
     *   $(go.Shape, "Triangle",
     *     { width: 10, height: 10, fill: "orange", segmentIndex: -1 });
     * ```
     * @see #fromHandleArchetype
     */
    get toHandleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
  /// at the "to" end of the link.
  /// By default this is a Shape that is a small blue diamond.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handle to be larger orange triangles:
  /// ```js
  ///   myDiagram.toolManager.relinkingTool.toHandleArchetype =
  ///   $(go.Shape, "Triangle",
  ///     { width: 10, height: 10, fill: "orange", segmentIndex: -1 });
  /// ```
  _i3.GraphObject? get toHandleArchetype => _i5.getProperty(
        this,
        'toHandleArchetype',
      );
  /* #6845
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a relinking handle for the selected link path
     * at the "to" end of the link.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger orange triangles:
     * ```js
     *   myDiagram.toolManager.relinkingTool.toHandleArchetype =
     *   $(go.Shape, "Triangle",
     *     { width: 10, height: 10, fill: "orange", segmentIndex: -1 });
     * ```
     * @see #fromHandleArchetype
     */
    get toHandleArchetype(): GraphObject | null; */
  // Type InteropUnion#990789144(parent: InteropGetter#65992164(name: toHandleArchetype))
  set toHandleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'toHandleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #6855
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "RelinkFrom" or "RelinkTo".
     * Its Adornment#adornedPart is the same as the #originalLink.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  /// Returns the GraphObject that is the tool handle being dragged by the user.
  /// This will be contained by an Adornment whose category is "RelinkFrom" or "RelinkTo".
  /// Its Adornment#adornedPart is the same as the #originalLink.
  ///
  /// This property is also settable, but should only be set either within an override of #doActivate
  /// or prior to calling #doActivate.
  _i3.GraphObject? get handle => _i5.getProperty(
        this,
        'handle',
      );
  /* #6855
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "RelinkFrom" or "RelinkTo".
     * Its Adornment#adornedPart is the same as the #originalLink.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  // Type InteropUnion#1671015(parent: InteropGetter#78571503(name: handle))
  set handle(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handle',
      value ?? _i4.undefined,
    );
  }

  void updateAdornments(_i3.Part part) {
    _i5.callMethod(
      this,
      'updateAdornments',
      [part],
    );
  }

  _i3.Adornment? makeAdornment(
    _i3.GraphObject selelt,
    _i2.bool toend,
  ) =>
      _i5.callMethod(
        this,
        'makeAdornment',
        [
          selelt,
          toend,
        ],
      );
  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void copyLinkProperties(
    _i3.Link? reallink,
    _i3.Link templink,
  ) {
    _i5.callMethod(
      this,
      'copyLinkProperties',
      [
        reallink ?? _i4.undefined,
        templink,
      ],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  _i2.bool reconnectLink(
    _i3.Link existinglink,
    _i3.Node? newnode,
    _i3.GraphObject? newport,
    _i2.bool toend,
  ) =>
      _i5.callMethod(
        this,
        'reconnectLink',
        [
          existinglink,
          newnode ?? _i4.undefined,
          newport ?? _i4.undefined,
          toend,
        ],
      );
  void doNoRelink(
    _i3.Link existinglink,
    _i2.bool toend,
  ) {
    _i5.callMethod(
      this,
      'doNoRelink',
      [
        existinglink,
        toend,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class LinkReshapingTool implements _i3.Tool {
  factory LinkReshapingTool() => _i5.callConstructor(
        _declaredLinkReshapingTool,
        [],
      );

  /* #6989
  source: 
    /**
     * Disallow dragging.
     * @constant
     */
    static None: EnumValue; */
  /// Disallow dragging.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredLinkReshapingTool,
        'None',
      );
  /* #6989
  source: 
    /**
     * Disallow dragging.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkReshapingTool,
      'None',
      value,
    );
  }

  /* #6994
  source: 
    /**
     * Allow only horizontal (left-and-right) dragging.
     * @constant
     */
    static Horizontal: EnumValue; */
  /// Allow only horizontal (left-and-right) dragging.
  static _i3.EnumValue get horizontal => _i5.getProperty(
        _declaredLinkReshapingTool,
        'Horizontal',
      );
  /* #6994
  source: 
    /**
     * Allow only horizontal (left-and-right) dragging.
     * @constant
     */
    static Horizontal: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set horizontal(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkReshapingTool,
      'Horizontal',
      value,
    );
  }

  /* #6999
  source: 
    /**
     * Allow only vertical (up-and-down) dragging.
     * @constant
     */
    static Vertical: EnumValue; */
  /// Allow only vertical (up-and-down) dragging.
  static _i3.EnumValue get vertical => _i5.getProperty(
        _declaredLinkReshapingTool,
        'Vertical',
      );
  /* #6999
  source: 
    /**
     * Allow only vertical (up-and-down) dragging.
     * @constant
     */
    static Vertical: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set vertical(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkReshapingTool,
      'Vertical',
      value,
    );
  }

  /* #7004
  source: 
    /**
     * Allow dragging in any direction.
     * @constant
     */
    static All: EnumValue; */
  /// Allow dragging in any direction.
  static _i3.EnumValue get all => _i5.getProperty(
        _declaredLinkReshapingTool,
        'All',
      );
  /* #7004
  source: 
    /**
     * Allow dragging in any direction.
     * @constant
     */
    static All: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set all(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLinkReshapingTool,
      'All',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('LinkReshapingTool')
external _i2.Object _declaredLinkReshapingTool;

extension LinkReshapingTool$Typings on LinkReshapingTool {
  /* #7060
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a reshape handle at each movable point in the selected link's route.
     * By default this is a Shape that is a small blue rectangle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handles to be larger yellow circles:
     * ```js
     *   myDiagram.toolManager.linkReshapingTool.handleArchetype =
     *     $(go.Shape, "Circle",
     *       { width: 10, height: 10, fill: "yellow" });
     * ```
     * @see #midHandleArchetype
     */
    get handleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a reshape handle at each movable point in the selected link's route.
  /// By default this is a Shape that is a small blue rectangle.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handles to be larger yellow circles:
  /// ```js
  ///   myDiagram.toolManager.linkReshapingTool.handleArchetype =
  ///     $(go.Shape, "Circle",
  ///       { width: 10, height: 10, fill: "yellow" });
  /// ```
  _i3.GraphObject? get handleArchetype => _i5.getProperty(
        this,
        'handleArchetype',
      );
  /* #7060
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a reshape handle at each movable point in the selected link's route.
     * By default this is a Shape that is a small blue rectangle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handles to be larger yellow circles:
     * ```js
     *   myDiagram.toolManager.linkReshapingTool.handleArchetype =
     *     $(go.Shape, "Circle",
     *       { width: 10, height: 10, fill: "yellow" });
     * ```
     * @see #midHandleArchetype
     */
    get handleArchetype(): GraphObject | null; */
  // Type InteropUnion#267504315(parent: InteropGetter#724888754(name: handleArchetype))
  set handleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #7086
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a resegment handle at each mid-point in the selected Link's route.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger cyan triangles:
     * ```js
     *   myDiagram.toolManager.linkReshapingTool.midHandleArchetype =
     *     $(go.Shape, "Triangle", { width: 10, height: 10, fill: "cyan" });
     * ```
     * @see #handleArchetype
     * @since 1.2
     */
    get midHandleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a resegment handle at each mid-point in the selected Link's route.
  /// By default this is a Shape that is a small blue diamond.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handle to be larger cyan triangles:
  /// ```js
  ///   myDiagram.toolManager.linkReshapingTool.midHandleArchetype =
  ///     $(go.Shape, "Triangle", { width: 10, height: 10, fill: "cyan" });
  /// ```
  _i3.GraphObject? get midHandleArchetype => _i5.getProperty(
        this,
        'midHandleArchetype',
      );
  /* #7086
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a resegment handle at each mid-point in the selected Link's route.
     * By default this is a Shape that is a small blue diamond.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger cyan triangles:
     * ```js
     *   myDiagram.toolManager.linkReshapingTool.midHandleArchetype =
     *     $(go.Shape, "Triangle", { width: 10, height: 10, fill: "cyan" });
     * ```
     * @see #handleArchetype
     * @since 1.2
     */
    get midHandleArchetype(): GraphObject | null; */
  // Type InteropUnion#333246366(parent: InteropGetter#643448119(name: midHandleArchetype))
  set midHandleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'midHandleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #7094
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "LinkReshaping".
     * Its Adornment#adornedPart is the same as the #adornedLink.
     * This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
     */
    get handle(): GraphObject | null; */
  /// Returns the GraphObject that is the tool handle being dragged by the user.
  /// This will be contained by an Adornment whose category is "LinkReshaping".
  /// Its Adornment#adornedPart is the same as the #adornedLink.
  /// This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
  _i3.GraphObject? get handle => _i5.getProperty(
        this,
        'handle',
      );
  /* #7094
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "LinkReshaping".
     * Its Adornment#adornedPart is the same as the #adornedLink.
     * This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
     */
    get handle(): GraphObject | null; */
  // Type InteropUnion#922217250(parent: InteropGetter#761480054(name: handle))
  set handle(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handle',
      value ?? _i4.undefined,
    );
  }

  /* #7099
  source: 
    /**
     * This read-only property returns the Link that is being routed manually.
     */
    get adornedLink(): Link | null; */
  /// This read-only property returns the Link that is being routed manually.
  _i3.Link? get adornedLink => _i5.getProperty(
        this,
        'adornedLink',
      );
  /* #7099
  source: 
    /**
     * This read-only property returns the Link that is being routed manually.
     */
    get adornedLink(): Link | null; */
  // Type InteropUnion#764470620(parent: InteropGetter#792621887(name: adornedLink))
  set adornedLink(_i3.Link? value) {
    _i5.setProperty(
      this,
      'adornedLink',
      value ?? _i4.undefined,
    );
  }

  /* #7188
  source: 
    /**
     * This read-only property returns the Point that was the original location of the handle that is being dragged to reshape the Link.
     * @since 1.1
     */
    get originalPoint(): Point; */
  /// This read-only property returns the Point that was the original location of the handle that is being dragged to reshape the Link.
  _i3.Point get originalPoint => _i5.getProperty(
        this,
        'originalPoint',
      );
  /* #7188
  source: 
    /**
     * This read-only property returns the Point that was the original location of the handle that is being dragged to reshape the Link.
     * @since 1.1
     */
    get originalPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set originalPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'originalPoint',
      value,
    );
  }

  /* #7194
  source: 
    /**
     * This read-only property returns the List of Points that was the original route of the Link that is being reshaped.
     * This List should not be modified; its value is indeterminate until a reshaping has been activated.
     * @since 1.1
     */
    get originalPoints(): List<Point>; */
  /// This read-only property returns the List of Points that was the original route of the Link that is being reshaped.
  /// This List should not be modified; its value is indeterminate until a reshaping has been activated.
  _i3.List /*LIST InteropClass#847625641(name: List),253702025,[Instance of 'InteropRef<InteropType>']*/ <_i3.Point>
      get originalPoints => _i5.getProperty(
            this,
            'originalPoints',
          );
  /* #7194
  source: 
    /**
     * This read-only property returns the List of Points that was the original route of the Link that is being reshaped.
     * This List should not be modified; its value is indeterminate until a reshaping has been activated.
     * @since 1.1
     */
    get originalPoints(): List<Point>; */
  // Type Instance of 'InteropInterface'
  set originalPoints(
      _i3.List /*LIST InteropClass#847625641(name: List),151066934,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Point>
          value) {
    _i5.setProperty(
      this,
      'originalPoints',
      value,
    );
  }

  _i3.EnumValue getReshapingBehavior(_i3.GraphObject obj) => _i5.callMethod(
        this,
        'getReshapingBehavior',
        [obj],
      );
  void setReshapingBehavior(
    _i3.GraphObject obj,
    _i3.EnumValue behavior,
  ) {
    _i5.callMethod(
      this,
      'setReshapingBehavior',
      [
        obj,
        behavior,
      ],
    );
  }

  void updateAdornments(_i3.Part part) {
    _i5.callMethod(
      this,
      'updateAdornments',
      [part],
    );
  }

  _i3.Adornment? makeAdornment(_i3.GraphObject pathshape) => _i5.callMethod(
        this,
        'makeAdornment',
        [pathshape],
      );
  _i3.GraphObject? makeHandle(
    _i3.GraphObject pathshape,
    _i2.num idx,
  ) =>
      _i5.callMethod(
        this,
        'makeHandle',
        [
          pathshape,
          idx,
        ],
      );
  _i3.GraphObject? makeResegmentHandle(
    _i3.GraphObject pathshape,
    _i2.num idx,
  ) =>
      _i5.callMethod(
        this,
        'makeResegmentHandle',
        [
          pathshape,
          idx,
        ],
      );
  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  _i2.bool stopTransaction() => _i5.callMethod(
        this,
        'stopTransaction',
        [],
      );
  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  _i3.Point getResegmentingPoint() => _i5.callMethod(
        this,
        'getResegmentingPoint',
        [],
      );
  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void reshape(_i3.Point newPoint) {
    _i5.callMethod(
      this,
      'reshape',
      [newPoint],
    );
  }

  _i3.Point computeReshape(_i3.Point p) => _i5.callMethod(
        this,
        'computeReshape',
        [p],
      );
}

@_i1.JS()
@_i1.staticInterop
class ResizingTool implements _i3.Tool {
  factory ResizingTool() => _i5.callConstructor(
        _declaredResizingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ResizingTool')
external _i2.Object _declaredResizingTool;

extension ResizingTool$Typings on ResizingTool {
  /* #7319
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a resizing handle for the selected part.
     * By default this is a Shape that is a small blue rectangle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger yellow circles:
     * ```js
     *   myDiagram.toolManager.resizingTool.handleArchetype =
     *     $(go.Shape, "Circle",
     *       { width: 10, height: 10, fill: "yellow" });
     * ```
     *
     * This property is ignored when a custom resizing Adornment is specified as the Part#resizeAdornmentTemplate.
     * That property is normally null, in which case this tool will automatically construct Adornments
     * holding eight copies of this handle archetype, each with a GraphObject#alignment being one of the
     * standard eight Spots.
     */
    get handleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a resizing handle for the selected part.
  /// By default this is a Shape that is a small blue rectangle.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handle to be larger yellow circles:
  /// ```js
  ///   myDiagram.toolManager.resizingTool.handleArchetype =
  ///     $(go.Shape, "Circle",
  ///       { width: 10, height: 10, fill: "yellow" });
  /// ```
  ///
  /// This property is ignored when a custom resizing Adornment is specified as the Part#resizeAdornmentTemplate.
  /// That property is normally null, in which case this tool will automatically construct Adornments
  /// holding eight copies of this handle archetype, each with a GraphObject#alignment being one of the
  /// standard eight Spots.
  _i3.GraphObject? get handleArchetype => _i5.getProperty(
        this,
        'handleArchetype',
      );
  /* #7319
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a resizing handle for the selected part.
     * By default this is a Shape that is a small blue rectangle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be larger yellow circles:
     * ```js
     *   myDiagram.toolManager.resizingTool.handleArchetype =
     *     $(go.Shape, "Circle",
     *       { width: 10, height: 10, fill: "yellow" });
     * ```
     *
     * This property is ignored when a custom resizing Adornment is specified as the Part#resizeAdornmentTemplate.
     * That property is normally null, in which case this tool will automatically construct Adornments
     * holding eight copies of this handle archetype, each with a GraphObject#alignment being one of the
     * standard eight Spots.
     */
    get handleArchetype(): GraphObject | null; */
  // Type InteropUnion#248224399(parent: InteropGetter#724921875(name: handleArchetype))
  set handleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #7330
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "ResizingTool".
     * Its Adornment#adornedObject is the same as the #adornedObject.
     * This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  /// Returns the GraphObject that is the tool handle being dragged by the user.
  /// This will be contained by an Adornment whose category is "ResizingTool".
  /// Its Adornment#adornedObject is the same as the #adornedObject.
  /// This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
  ///
  /// This property is also settable, but should only be set either within an override of #doActivate
  /// or prior to calling #doActivate.
  _i3.GraphObject? get handle => _i5.getProperty(
        this,
        'handle',
      );
  /* #7330
  source: 
    /**
     * Returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "ResizingTool".
     * Its Adornment#adornedObject is the same as the #adornedObject.
     * This is normally set by #doActivate, remembering the result of the call to Tool#findToolHandleAt.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  // Type InteropUnion#1068727189(parent: InteropGetter#702485446(name: handle))
  set handle(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handle',
      value ?? _i4.undefined,
    );
  }

  /* #7339
  source: 
    /**
     * Gets the GraphObject that is being resized.
     * This may be the same object as the selected Part or it may be contained within that Part.
     *
     * This property is also settable, but should only be set when overriding functions
     * in ResizingTool, and not during normal operation.
     */
    get adornedObject(): GraphObject | null; */
  /// Gets the GraphObject that is being resized.
  /// This may be the same object as the selected Part or it may be contained within that Part.
  ///
  /// This property is also settable, but should only be set when overriding functions
  /// in ResizingTool, and not during normal operation.
  _i3.GraphObject? get adornedObject => _i5.getProperty(
        this,
        'adornedObject',
      );
  /* #7339
  source: 
    /**
     * Gets the GraphObject that is being resized.
     * This may be the same object as the selected Part or it may be contained within that Part.
     *
     * This property is also settable, but should only be set when overriding functions
     * in ResizingTool, and not during normal operation.
     */
    get adornedObject(): GraphObject | null; */
  // Type InteropUnion#4880751(parent: InteropGetter#940608838(name: adornedObject))
  set adornedObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'adornedObject',
      value ?? _i4.undefined,
    );
  }

  /* #7503
  source: 
    /**
     * Gets or sets the minimum size to which the user can resize.
     * The effective minimum size is the maximum of this value and the GraphObject#minSize,
     * independently in each direction.
     *
     * The default value is `go.Size(1, 1)`.
     * Any new value must be of type Size; `NaN` width or height values are treated as zero.
     * Setting this property does not raise any events.
     */
    get minSize(): Size; */
  /// Gets or sets the minimum size to which the user can resize.
  /// The effective minimum size is the maximum of this value and the GraphObject#minSize,
  /// independently in each direction.
  ///
  /// The default value is `go.Size(1, 1)`.
  /// Any new value must be of type Size; `NaN` width or height values are treated as zero.
  /// Setting this property does not raise any events.
  _i3.Size get minSize => _i5.getProperty(
        this,
        'minSize',
      );
  /* #7503
  source: 
    /**
     * Gets or sets the minimum size to which the user can resize.
     * The effective minimum size is the maximum of this value and the GraphObject#minSize,
     * independently in each direction.
     *
     * The default value is `go.Size(1, 1)`.
     * Any new value must be of type Size; `NaN` width or height values are treated as zero.
     * Setting this property does not raise any events.
     */
    get minSize(): Size; */
  // Type Instance of 'InteropInterface'
  set minSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'minSize',
      value,
    );
  }

  /* #7514
  source: 
    /**
     * Gets or sets the maximum size to which the user can resize.
     * The effective maximum size is the minimum of this value and the GraphObject#maxSize,
     * independently in each direction.
     *
     * The default value is `go.Size(9999, 9999)`.
     * Any new value must be of type Size; `NaN` width or height values are treated as Infinity.
     * Setting this property does not raise any events.
     */
    get maxSize(): Size; */
  /// Gets or sets the maximum size to which the user can resize.
  /// The effective maximum size is the minimum of this value and the GraphObject#maxSize,
  /// independently in each direction.
  ///
  /// The default value is `go.Size(9999, 9999)`.
  /// Any new value must be of type Size; `NaN` width or height values are treated as Infinity.
  /// Setting this property does not raise any events.
  _i3.Size get maxSize => _i5.getProperty(
        this,
        'maxSize',
      );
  /* #7514
  source: 
    /**
     * Gets or sets the maximum size to which the user can resize.
     * The effective maximum size is the minimum of this value and the GraphObject#maxSize,
     * independently in each direction.
     *
     * The default value is `go.Size(9999, 9999)`.
     * Any new value must be of type Size; `NaN` width or height values are treated as Infinity.
     * Setting this property does not raise any events.
     */
    get maxSize(): Size; */
  // Type Instance of 'InteropInterface'
  set maxSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'maxSize',
      value,
    );
  }

  /* #7526
  source: 
    /**
     * Gets or sets the width and height multiples with which the user must resize.
     * The effective cell size is computed by first looking at the Adornment#adornedPart's Part#resizeCellSize.
     * If either or both of its width and height are `NaN`, it will use this property, `cellSize`.
     * If either or both of this property's width and height are `NaN`, it will
     * consider the Diagram#grid's Panel#gridCellSize.
     *
     * The default value is `go.Size(NaN, NaN)`.
     * Setting this property does not raise any events.
     */
    get cellSize(): Size; */
  /// Gets or sets the width and height multiples with which the user must resize.
  /// The effective cell size is computed by first looking at the Adornment#adornedPart's Part#resizeCellSize.
  /// If either or both of its width and height are `NaN`, it will use this property, `cellSize`.
  /// If either or both of this property's width and height are `NaN`, it will
  /// consider the Diagram#grid's Panel#gridCellSize.
  ///
  /// The default value is `go.Size(NaN, NaN)`.
  /// Setting this property does not raise any events.
  _i3.Size get cellSize => _i5.getProperty(
        this,
        'cellSize',
      );
  /* #7526
  source: 
    /**
     * Gets or sets the width and height multiples with which the user must resize.
     * The effective cell size is computed by first looking at the Adornment#adornedPart's Part#resizeCellSize.
     * If either or both of its width and height are `NaN`, it will use this property, `cellSize`.
     * If either or both of this property's width and height are `NaN`, it will
     * consider the Diagram#grid's Panel#gridCellSize.
     *
     * The default value is `go.Size(NaN, NaN)`.
     * Setting this property does not raise any events.
     */
    get cellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set cellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'cellSize',
      value,
    );
  }

  /* #7533
  source: 
    /**
     * Gets or sets whether the ResizingTool snaps object sizes to the diagram's background grid during the resize.
     * By default this property is false.
     * Setting this property does not raise any events.
     */
    get isGridSnapEnabled(): boolean; */
  /// Gets or sets whether the ResizingTool snaps object sizes to the diagram's background grid during the resize.
  /// By default this property is false.
  /// Setting this property does not raise any events.
  _i2.bool get isGridSnapEnabled => _i5.getProperty(
        this,
        'isGridSnapEnabled',
      );
  /* #7533
  source: 
    /**
     * Gets or sets whether the ResizingTool snaps object sizes to the diagram's background grid during the resize.
     * By default this property is false.
     * Setting this property does not raise any events.
     */
    get isGridSnapEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapEnabled',
      value,
    );
  }

  /* #7541
  source: 
    /**
     * Gets or sets whether the ResizingTool moves the member Parts of a Group that has no Group#placeholder.
     * By default this property is true.
     * Setting this property does not raise any events.
     * @since 2.1.26
     */
    get dragsMembers(): boolean; */
  /// Gets or sets whether the ResizingTool moves the member Parts of a Group that has no Group#placeholder.
  /// By default this property is true.
  /// Setting this property does not raise any events.
  _i2.bool get dragsMembers => _i5.getProperty(
        this,
        'dragsMembers',
      );
  /* #7541
  source: 
    /**
     * Gets or sets whether the ResizingTool moves the member Parts of a Group that has no Group#placeholder.
     * By default this property is true.
     * Setting this property does not raise any events.
     * @since 2.1.26
     */
    get dragsMembers(): boolean; */
  // Type InteropStaticType.boolean
  set dragsMembers(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsMembers',
      value,
    );
  }

  /* #7548
  source: 
    /**
     * Gets the Point opposite to the chosen, dragged handle of the "Resizing" Adornment.
     * This property has no meaning until after #doActivate has been called.
     * @since 2.2
     */
    get oppositePoint(): Point; */
  /// Gets the Point opposite to the chosen, dragged handle of the "Resizing" Adornment.
  /// This property has no meaning until after #doActivate has been called.
  _i3.Point get oppositePoint => _i5.getProperty(
        this,
        'oppositePoint',
      );
  /* #7548
  source: 
    /**
     * Gets the Point opposite to the chosen, dragged handle of the "Resizing" Adornment.
     * This property has no meaning until after #doActivate has been called.
     * @since 2.2
     */
    get oppositePoint(): Point; */
  // Type Instance of 'InteropInterface'
  set oppositePoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'oppositePoint',
      value,
    );
  }

  /* #7555
  source: 
    /**
     * This read-only property returns the Size that was the original value of the GraphObject#desiredSize
     * of the element that is being resized.
     * @since 1.1
     */
    get originalDesiredSize(): Size; */
  /// This read-only property returns the Size that was the original value of the GraphObject#desiredSize
  /// of the element that is being resized.
  _i3.Size get originalDesiredSize => _i5.getProperty(
        this,
        'originalDesiredSize',
      );
  /* #7555
  source: 
    /**
     * This read-only property returns the Size that was the original value of the GraphObject#desiredSize
     * of the element that is being resized.
     * @since 1.1
     */
    get originalDesiredSize(): Size; */
  // Type Instance of 'InteropInterface'
  set originalDesiredSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'originalDesiredSize',
      value,
    );
  }

  /* #7561
  source: 
    /**
     * This read-only property returns the Point that was the original value of the Part#location
     * of the Part that is being resized.
     * @since 1.1
     */
    get originalLocation(): Point; */
  /// This read-only property returns the Point that was the original value of the Part#location
  /// of the Part that is being resized.
  _i3.Point get originalLocation => _i5.getProperty(
        this,
        'originalLocation',
      );
  /* #7561
  source: 
    /**
     * This read-only property returns the Point that was the original value of the Part#location
     * of the Part that is being resized.
     * @since 1.1
     */
    get originalLocation(): Point; */
  // Type Instance of 'InteropInterface'
  set originalLocation(_i3.Point value) {
    _i5.setProperty(
      this,
      'originalLocation',
      value,
    );
  }

  void updateAdornments(_i3.Part part) {
    _i5.callMethod(
      this,
      'updateAdornments',
      [part],
    );
  }

  _i3.Adornment? makeAdornment(_i3.GraphObject resizeObj) => _i5.callMethod(
        this,
        'makeAdornment',
        [resizeObj],
      );
  void updateResizeHandles(
    _i3.GraphObject elt,
    _i2.num angle,
  ) {
    _i5.callMethod(
      this,
      'updateResizeHandles',
      [
        elt,
        angle,
      ],
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  _i2.bool stopTransaction() => _i5.callMethod(
        this,
        'stopTransaction',
        [],
      );
  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void resize(_i3.Rect newr) {
    _i5.callMethod(
      this,
      'resize',
      [newr],
    );
  }

  _i3.Rect computeResize(
    _i3.Point newPoint,
    _i3.Spot spot,
    _i3.Size min,
    _i3.Size max,
    _i3.Size cell,
    _i2.bool reshape,
  ) =>
      _i5.callMethod(
        this,
        'computeResize',
        [
          newPoint,
          spot,
          min,
          max,
          cell,
          reshape,
        ],
      );
  _i2.bool computeReshape() => _i5.callMethod(
        this,
        'computeReshape',
        [],
      );
  _i3.Size computeMinSize() => _i5.callMethod(
        this,
        'computeMinSize',
        [],
      );
  _i3.Size computeMaxSize() => _i5.callMethod(
        this,
        'computeMaxSize',
        [],
      );
  _i3.Size computeCellSize() => _i5.callMethod(
        this,
        'computeCellSize',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class RotatingTool implements _i3.Tool {
  factory RotatingTool() => _i5.callConstructor(
        _declaredRotatingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('RotatingTool')
external _i2.Object _declaredRotatingTool;

extension RotatingTool$Typings on RotatingTool {
  /* #7654
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a rotation handle for the selected part.
     * By default this is a Shape that is a small yellow circle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be green "X":
     * ```js
     *   myDiagram.toolManager.rotatingTool.handleArchetype =
     *     $(go.Shape, "XLine",
     *       { width: 8, height: 8, stroke: "green", fill: "transparent" });
     * ```
     *
     * This property is ignored when a custom rotating Adornment is specified as the Part#rotateAdornmentTemplate.
     */
    get handleArchetype(): GraphObject | null; */
  /// Gets or sets a small GraphObject that is copied as a rotation handle for the selected part.
  /// By default this is a Shape that is a small yellow circle.
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the default handle to be green "X":
  /// ```js
  ///   myDiagram.toolManager.rotatingTool.handleArchetype =
  ///     $(go.Shape, "XLine",
  ///       { width: 8, height: 8, stroke: "green", fill: "transparent" });
  /// ```
  ///
  /// This property is ignored when a custom rotating Adornment is specified as the Part#rotateAdornmentTemplate.
  _i3.GraphObject? get handleArchetype => _i5.getProperty(
        this,
        'handleArchetype',
      );
  /* #7654
  source: 
    /**
     * Gets or sets a small GraphObject that is copied as a rotation handle for the selected part.
     * By default this is a Shape that is a small yellow circle.
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the default handle to be green "X":
     * ```js
     *   myDiagram.toolManager.rotatingTool.handleArchetype =
     *     $(go.Shape, "XLine",
     *       { width: 8, height: 8, stroke: "green", fill: "transparent" });
     * ```
     *
     * This property is ignored when a custom rotating Adornment is specified as the Part#rotateAdornmentTemplate.
     */
    get handleArchetype(): GraphObject | null; */
  // Type InteropUnion#160923827(parent: InteropGetter#492680924(name: handleArchetype))
  set handleArchetype(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handleArchetype',
      value ?? _i4.undefined,
    );
  }

  /* #7664
  source: 
    /**
     * This read-only property returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "RotatingTool".
     * Its Adornment#adornedObject is the same as the #adornedObject.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  /// This read-only property returns the GraphObject that is the tool handle being dragged by the user.
  /// This will be contained by an Adornment whose category is "RotatingTool".
  /// Its Adornment#adornedObject is the same as the #adornedObject.
  ///
  /// This property is also settable, but should only be set either within an override of #doActivate
  /// or prior to calling #doActivate.
  _i3.GraphObject? get handle => _i5.getProperty(
        this,
        'handle',
      );
  /* #7664
  source: 
    /**
     * This read-only property returns the GraphObject that is the tool handle being dragged by the user.
     * This will be contained by an Adornment whose category is "RotatingTool".
     * Its Adornment#adornedObject is the same as the #adornedObject.
     *
     * This property is also settable, but should only be set either within an override of #doActivate
     * or prior to calling #doActivate.
     */
    get handle(): GraphObject | null; */
  // Type InteropUnion#16059862(parent: InteropGetter#438964330(name: handle))
  set handle(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'handle',
      value ?? _i4.undefined,
    );
  }

  /* #7673
  source: 
    /**
     * Gets the GraphObject that is being rotated.
     * This may be the same object as the selected Part or it may be contained within that Part.
     *
     * This property is also settable, but should only be set when overriding functions
     * in RotatingTool, and not during normal operation.
     */
    get adornedObject(): GraphObject | null; */
  /// Gets the GraphObject that is being rotated.
  /// This may be the same object as the selected Part or it may be contained within that Part.
  ///
  /// This property is also settable, but should only be set when overriding functions
  /// in RotatingTool, and not during normal operation.
  _i3.GraphObject? get adornedObject => _i5.getProperty(
        this,
        'adornedObject',
      );
  /* #7673
  source: 
    /**
     * Gets the GraphObject that is being rotated.
     * This may be the same object as the selected Part or it may be contained within that Part.
     *
     * This property is also settable, but should only be set when overriding functions
     * in RotatingTool, and not during normal operation.
     */
    get adornedObject(): GraphObject | null; */
  // Type InteropUnion#745895693(parent: InteropGetter#50344215(name: adornedObject))
  set adornedObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'adornedObject',
      value ?? _i4.undefined,
    );
  }

  /* #7773
  source: 
    /**
     * Gets or sets the preferred angles for the selected object.
     *
     * The default value is 45 degrees, meaning that angles that are multiples
     * of 45 degrees are automatically preferred, if the actual angle is
     * close to that multiple.
     * The closeness is determined by the #snapAngleEpsilon property.
     * A value of zero for #snapAngleMultiple results in no snapping at all.
     * Setting this property does not raise any events.
     */
    get snapAngleMultiple(): number; */
  /// Gets or sets the preferred angles for the selected object.
  ///
  /// The default value is 45 degrees, meaning that angles that are multiples
  /// of 45 degrees are automatically preferred, if the actual angle is
  /// close to that multiple.
  /// The closeness is determined by the #snapAngleEpsilon property.
  /// A value of zero for #snapAngleMultiple results in no snapping at all.
  /// Setting this property does not raise any events.
  _i2.num get snapAngleMultiple => _i5.getProperty(
        this,
        'snapAngleMultiple',
      );
  /* #7773
  source: 
    /**
     * Gets or sets the preferred angles for the selected object.
     *
     * The default value is 45 degrees, meaning that angles that are multiples
     * of 45 degrees are automatically preferred, if the actual angle is
     * close to that multiple.
     * The closeness is determined by the #snapAngleEpsilon property.
     * A value of zero for #snapAngleMultiple results in no snapping at all.
     * Setting this property does not raise any events.
     */
    get snapAngleMultiple(): number; */
  // Type InteropStaticType.number
  set snapAngleMultiple(_i2.num value) {
    _i5.setProperty(
      this,
      'snapAngleMultiple',
      value,
    );
  }

  /* #7786
  source: 
    /**
     * Gets or sets the the closeness to a desired angle at which the angle is "snapped to".
     *
     * The default value is 2 degrees, meaning that any angle within 2 degrees
     * of a multiple of the #snapAngleMultiple automatically
     * snaps to that multiple.
     * Values are limited to half of the #snapAngleMultiple;
     * such values restrict user selected angles only to exact multiples of
     * #snapAngleMultiple -- no other angles between them.
     * Setting this property does not raise any events.
     */
    get snapAngleEpsilon(): number; */
  /// Gets or sets the the closeness to a desired angle at which the angle is "snapped to".
  ///
  /// The default value is 2 degrees, meaning that any angle within 2 degrees
  /// of a multiple of the #snapAngleMultiple automatically
  /// snaps to that multiple.
  /// Values are limited to half of the #snapAngleMultiple;
  /// such values restrict user selected angles only to exact multiples of
  /// #snapAngleMultiple -- no other angles between them.
  /// Setting this property does not raise any events.
  _i2.num get snapAngleEpsilon => _i5.getProperty(
        this,
        'snapAngleEpsilon',
      );
  /* #7786
  source: 
    /**
     * Gets or sets the the closeness to a desired angle at which the angle is "snapped to".
     *
     * The default value is 2 degrees, meaning that any angle within 2 degrees
     * of a multiple of the #snapAngleMultiple automatically
     * snaps to that multiple.
     * Values are limited to half of the #snapAngleMultiple;
     * such values restrict user selected angles only to exact multiples of
     * #snapAngleMultiple -- no other angles between them.
     * Setting this property does not raise any events.
     */
    get snapAngleEpsilon(): number; */
  // Type InteropStaticType.number
  set snapAngleEpsilon(_i2.num value) {
    _i5.setProperty(
      this,
      'snapAngleEpsilon',
      value,
    );
  }

  /* #7794
  source: 
    /**
     * This read-only property returns the angle that was the original value of the GraphObject#angle
     * of the GraphObject that is being rotated.
     * The value is invalid when this tool is not active.
     * @since 1.1
     */
    get originalAngle(): number; */
  /// This read-only property returns the angle that was the original value of the GraphObject#angle
  /// of the GraphObject that is being rotated.
  /// The value is invalid when this tool is not active.
  _i2.num get originalAngle => _i5.getProperty(
        this,
        'originalAngle',
      );
  /* #7794
  source: 
    /**
     * This read-only property returns the angle that was the original value of the GraphObject#angle
     * of the GraphObject that is being rotated.
     * The value is invalid when this tool is not active.
     * @since 1.1
     */
    get originalAngle(): number; */
  // Type InteropStaticType.number
  set originalAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'originalAngle',
      value,
    );
  }

  /* #7801
  source: 
    /**
     * Gets or sets the Point at which the axis of the rotation should be.
     * #doActivate saves here the value returned by the call to #computeRotationPoint.
     * The value is invalid when this tool is not active.
     * @since 2.0
     */
    get rotationPoint(): Point; */
  /// Gets or sets the Point at which the axis of the rotation should be.
  /// #doActivate saves here the value returned by the call to #computeRotationPoint.
  /// The value is invalid when this tool is not active.
  _i3.Point get rotationPoint => _i5.getProperty(
        this,
        'rotationPoint',
      );
  /* #7801
  source: 
    /**
     * Gets or sets the Point at which the axis of the rotation should be.
     * #doActivate saves here the value returned by the call to #computeRotationPoint.
     * The value is invalid when this tool is not active.
     * @since 2.0
     */
    get rotationPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set rotationPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'rotationPoint',
      value,
    );
  }

  /* #7813
  source: 
    /**
     * Gets or sets the spot to locate the Adornment for the rotation handle when it does not have a Placeholder.
     * This assumes the Adornment's location will be at the center of the rotation handle.
     *
     * By default this is zero degrees, which locates the Adornment
     * so that it is placed to the right of an un-rotated object.
     * You can set this to a multiple of 90 degrees to position the rotation handle differently
     * with respect to the #rotationPoint.
     * @since 2.0
     */
    get handleAngle(): number; */
  /// Gets or sets the spot to locate the Adornment for the rotation handle when it does not have a Placeholder.
  /// This assumes the Adornment's location will be at the center of the rotation handle.
  ///
  /// By default this is zero degrees, which locates the Adornment
  /// so that it is placed to the right of an un-rotated object.
  /// You can set this to a multiple of 90 degrees to position the rotation handle differently
  /// with respect to the #rotationPoint.
  _i2.num get handleAngle => _i5.getProperty(
        this,
        'handleAngle',
      );
  /* #7813
  source: 
    /**
     * Gets or sets the spot to locate the Adornment for the rotation handle when it does not have a Placeholder.
     * This assumes the Adornment's location will be at the center of the rotation handle.
     *
     * By default this is zero degrees, which locates the Adornment
     * so that it is placed to the right of an un-rotated object.
     * You can set this to a multiple of 90 degrees to position the rotation handle differently
     * with respect to the #rotationPoint.
     * @since 2.0
     */
    get handleAngle(): number; */
  // Type InteropStaticType.number
  set handleAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'handleAngle',
      value,
    );
  }

  /* #7823
  source: 
    /**
     * Gets or sets the spot to locate the Adornment at a particular distance from the #adornedObject.
     * This assumes the Adornment's location will be at the center of the rotation handle.
     *
     * By default this is 50, which locates the Adornment
     * so that it is placed to the right of an un-rotated object.
     * @since 2.0
     */
    get handleDistance(): number; */
  /// Gets or sets the spot to locate the Adornment at a particular distance from the #adornedObject.
  /// This assumes the Adornment's location will be at the center of the rotation handle.
  ///
  /// By default this is 50, which locates the Adornment
  /// so that it is placed to the right of an un-rotated object.
  _i2.num get handleDistance => _i5.getProperty(
        this,
        'handleDistance',
      );
  /* #7823
  source: 
    /**
     * Gets or sets the spot to locate the Adornment at a particular distance from the #adornedObject.
     * This assumes the Adornment's location will be at the center of the rotation handle.
     *
     * By default this is 50, which locates the Adornment
     * so that it is placed to the right of an un-rotated object.
     * @since 2.0
     */
    get handleDistance(): number; */
  // Type InteropStaticType.number
  set handleDistance(_i2.num value) {
    _i5.setProperty(
      this,
      'handleDistance',
      value,
    );
  }

  void updateAdornments(_i3.Part part) {
    _i5.callMethod(
      this,
      'updateAdornments',
      [part],
    );
  }

  _i3.Adornment? makeAdornment(_i3.GraphObject rotateObj) => _i5.callMethod(
        this,
        'makeAdornment',
        [rotateObj],
      );
  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  _i3.Point computeRotationPoint(_i3.GraphObject obj) => _i5.callMethod(
        this,
        'computeRotationPoint',
        [obj],
      );
  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  _i2.bool stopTransaction() => _i5.callMethod(
        this,
        'stopTransaction',
        [],
      );
  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void rotate(_i2.num newangle) {
    _i5.callMethod(
      this,
      'rotate',
      [newangle],
    );
  }

  _i2.num computeRotate(_i3.Point newPoint) => _i5.callMethod(
        this,
        'computeRotate',
        [newPoint],
      );
}

@_i1.JS()
@_i1.staticInterop
class ClickSelectingTool implements _i3.Tool {
  factory ClickSelectingTool() => _i5.callConstructor(
        _declaredClickSelectingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ClickSelectingTool')
external _i2.Object _declaredClickSelectingTool;

extension ClickSelectingTool$Typings on ClickSelectingTool {
  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ActionTool implements _i3.Tool {
  factory ActionTool() => _i5.callConstructor(
        _declaredActionTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ActionTool')
external _i2.Object _declaredActionTool;

extension ActionTool$Typings on ActionTool {
  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doMouseDown() {
    _i5.callMethod(
      this,
      'doMouseDown',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ClickCreatingTool implements _i3.Tool {
  factory ClickCreatingTool() => _i5.callConstructor(
        _declaredClickCreatingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ClickCreatingTool')
external _i2.Object _declaredClickCreatingTool;

extension ClickCreatingTool$Typings on ClickCreatingTool {
  /* #8005
  source: 
    /**
     * Gets or sets a data object that will be copied and added to the diagram's model each time this tool executes.
     * The default value is null.
     * The value must be non-null for this tool to be able to run.
     * Setting this property does not raise any events.
     */
    get archetypeNodeData(): ObjectData | null; */
  /// Gets or sets a data object that will be copied and added to the diagram's model each time this tool executes.
  /// The default value is null.
  /// The value must be non-null for this tool to be able to run.
  /// Setting this property does not raise any events.
  _i2.Object? get archetypeNodeData => _i5.getProperty(
        this,
        'archetypeNodeData',
      );
  /* #8005
  source: 
    /**
     * Gets or sets a data object that will be copied and added to the diagram's model each time this tool executes.
     * The default value is null.
     * The value must be non-null for this tool to be able to run.
     * Setting this property does not raise any events.
     */
    get archetypeNodeData(): ObjectData | null; */
  // Type InteropUnion#138319572(parent: InteropGetter#408149754(name: archetypeNodeData))
  set archetypeNodeData(_i2.Object? value) {
    _i5.setProperty(
      this,
      'archetypeNodeData',
      value ?? _i4.undefined,
    );
  }

  /* #8013
  source: 
    /**
     * Gets or sets whether a double click rather than a single-click is required
     * to insert a new Part at the mouse-up point.
     * The default value is true -- only a double-click will cause a node to be created.
     * Setting this property does not raise any events.
     */
    get isDoubleClick(): boolean; */
  /// Gets or sets whether a double click rather than a single-click is required
  /// to insert a new Part at the mouse-up point.
  /// The default value is true -- only a double-click will cause a node to be created.
  /// Setting this property does not raise any events.
  _i2.bool get isDoubleClick => _i5.getProperty(
        this,
        'isDoubleClick',
      );
  /* #8013
  source: 
    /**
     * Gets or sets whether a double click rather than a single-click is required
     * to insert a new Part at the mouse-up point.
     * The default value is true -- only a double-click will cause a node to be created.
     * Setting this property does not raise any events.
     */
    get isDoubleClick(): boolean; */
  // Type InteropStaticType.boolean
  set isDoubleClick(_i2.bool value) {
    _i5.setProperty(
      this,
      'isDoubleClick',
      value,
    );
  }

  /* #8022
  source: 
    /**
     * Gets or sets whether the ClickCreatingTool snaps object sizes to the diagram's background grid during creation.
     * By default this property is false.
     * Setting this property does not raise any events.
     *
     * @since 2.0
     */
    get isGridSnapEnabled(): boolean; */
  /// Gets or sets whether the ClickCreatingTool snaps object sizes to the diagram's background grid during creation.
  /// By default this property is false.
  /// Setting this property does not raise any events.
  _i2.bool get isGridSnapEnabled => _i5.getProperty(
        this,
        'isGridSnapEnabled',
      );
  /* #8022
  source: 
    /**
     * Gets or sets whether the ClickCreatingTool snaps object sizes to the diagram's background grid during creation.
     * By default this property is false.
     * Setting this property does not raise any events.
     *
     * @since 2.0
     */
    get isGridSnapEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapEnabled',
      value,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  _i3.Part? insertPart(_i3.Point loc) => _i5.callMethod(
        this,
        'insertPart',
        [loc],
      );
}

@_i1.JS()
@_i1.staticInterop
class DragSelectingTool implements _i3.Tool {
  factory DragSelectingTool() => _i5.callConstructor(
        _declaredDragSelectingTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('DragSelectingTool')
external _i2.Object _declaredDragSelectingTool;

extension DragSelectingTool$Typings on DragSelectingTool {
  /* #8137
  source: 
    /**
     * Gets or sets the time in milliseconds for which the mouse must be stationary
     * before this tool can be started.
     * The default value is 175 milliseconds.
     * Setting this property does not raise any events.
     */
    get delay(): number; */
  /// Gets or sets the time in milliseconds for which the mouse must be stationary
  /// before this tool can be started.
  /// The default value is 175 milliseconds.
  /// Setting this property does not raise any events.
  _i2.num get delay => _i5.getProperty(
        this,
        'delay',
      );
  /* #8137
  source: 
    /**
     * Gets or sets the time in milliseconds for which the mouse must be stationary
     * before this tool can be started.
     * The default value is 175 milliseconds.
     * Setting this property does not raise any events.
     */
    get delay(): number; */
  // Type InteropStaticType.number
  set delay(_i2.num value) {
    _i5.setProperty(
      this,
      'delay',
      value,
    );
  }

  /* #8145
  source: 
    /**
     * Gets or sets whether a selectable Part may be only partly
     * or must be completely enclosed by the rectangle given to #selectInRect.
     * The default value is false: parts must be completely inside the rectangle.
     * Setting this property does not raise any events.
     */
    get isPartialInclusion(): boolean; */
  /// Gets or sets whether a selectable Part may be only partly
  /// or must be completely enclosed by the rectangle given to #selectInRect.
  /// The default value is false: parts must be completely inside the rectangle.
  /// Setting this property does not raise any events.
  _i2.bool get isPartialInclusion => _i5.getProperty(
        this,
        'isPartialInclusion',
      );
  /* #8145
  source: 
    /**
     * Gets or sets whether a selectable Part may be only partly
     * or must be completely enclosed by the rectangle given to #selectInRect.
     * The default value is false: parts must be completely inside the rectangle.
     * Setting this property does not raise any events.
     */
    get isPartialInclusion(): boolean; */
  // Type InteropStaticType.boolean
  set isPartialInclusion(_i2.bool value) {
    _i5.setProperty(
      this,
      'isPartialInclusion',
      value,
    );
  }

  /* #8168
  source: 
    /**
     * Gets or sets the Part used as the "rubber-band selection box"
     * that is stretched to follow the mouse, as feedback for what area will
     * be passed to #selectInRect upon a mouse-up.
     *
     * Initially this is a Part containing only a simple magenta rectangular Shape.
     * The object to be resized during dragging should be named "SHAPE".
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the selection box to be a thicker bright green rectangle:
     * ```js
     *   myDiagram.toolManager.dragSelectingTool.box =
     *     $(go.Part,
     *       { layerName: "Tool", selectable: false },
     *       $(go.Shape,
     *         { name: "SHAPE", fill: null, stroke: "chartreuse", strokeWidth: 3 }));
     * ```
     * Note that the Part should be put into a Layer that Layer#isTemporary.
     *
     * Modifying this property while this tool Tool#isActive might have no effect.
     */
    get box(): Part | null; */
  /// Gets or sets the Part used as the "rubber-band selection box"
  /// that is stretched to follow the mouse, as feedback for what area will
  /// be passed to #selectInRect upon a mouse-up.
  ///
  /// Initially this is a Part containing only a simple magenta rectangular Shape.
  /// The object to be resized during dragging should be named "SHAPE".
  /// Setting this property does not raise any events.
  ///
  /// Here is an example of changing the selection box to be a thicker bright green rectangle:
  /// ```js
  ///   myDiagram.toolManager.dragSelectingTool.box =
  ///     $(go.Part,
  ///       { layerName: "Tool", selectable: false },
  ///       $(go.Shape,
  ///         { name: "SHAPE", fill: null, stroke: "chartreuse", strokeWidth: 3 }));
  /// ```
  /// Note that the Part should be put into a Layer that Layer#isTemporary.
  ///
  /// Modifying this property while this tool Tool#isActive might have no effect.
  _i3.Part? get box => _i5.getProperty(
        this,
        'box',
      );
  /* #8168
  source: 
    /**
     * Gets or sets the Part used as the "rubber-band selection box"
     * that is stretched to follow the mouse, as feedback for what area will
     * be passed to #selectInRect upon a mouse-up.
     *
     * Initially this is a Part containing only a simple magenta rectangular Shape.
     * The object to be resized during dragging should be named "SHAPE".
     * Setting this property does not raise any events.
     *
     * Here is an example of changing the selection box to be a thicker bright green rectangle:
     * ```js
     *   myDiagram.toolManager.dragSelectingTool.box =
     *     $(go.Part,
     *       { layerName: "Tool", selectable: false },
     *       $(go.Shape,
     *         { name: "SHAPE", fill: null, stroke: "chartreuse", strokeWidth: 3 }));
     * ```
     * Note that the Part should be put into a Layer that Layer#isTemporary.
     *
     * Modifying this property while this tool Tool#isActive might have no effect.
     */
    get box(): Part | null; */
  // Type InteropUnion#216851336(parent: InteropGetter#340777095(name: box))
  set box(_i3.Part? value) {
    _i5.setProperty(
      this,
      'box',
      value ?? _i4.undefined,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  _i3.Rect computeBoxBounds() => _i5.callMethod(
        this,
        'computeBoxBounds',
        [],
      );
  void selectInRect(_i3.Rect r) {
    _i5.callMethod(
      this,
      'selectInRect',
      [r],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class PanningTool implements _i3.Tool {
  factory PanningTool() => _i5.callConstructor(
        _declaredPanningTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('PanningTool')
external _i2.Object _declaredPanningTool;

extension PanningTool$Typings on PanningTool {
  /* #8237
  source: 
    /**
     * Gets or sets whether panning actions will allow
     * events to bubble **instead** of panning in the diagram.
     *
     * Set this to true to allow mobile devices to scroll the page with panning gestures on the diagram.
     * Otherwise, the panning events will be captured and used to pan inside of the diagram.
     *
     * The default value is false.
     */
    get bubbles(): boolean; */
  /// Gets or sets whether panning actions will allow
  /// events to bubble **instead** of panning in the diagram.
  ///
  /// Set this to true to allow mobile devices to scroll the page with panning gestures on the diagram.
  /// Otherwise, the panning events will be captured and used to pan inside of the diagram.
  ///
  /// The default value is false.
  _i2.bool get bubbles => _i5.getProperty(
        this,
        'bubbles',
      );
  /* #8237
  source: 
    /**
     * Gets or sets whether panning actions will allow
     * events to bubble **instead** of panning in the diagram.
     *
     * Set this to true to allow mobile devices to scroll the page with panning gestures on the diagram.
     * Otherwise, the panning events will be captured and used to pan inside of the diagram.
     *
     * The default value is false.
     */
    get bubbles(): boolean; */
  // Type InteropStaticType.boolean
  set bubbles(_i2.bool value) {
    _i5.setProperty(
      this,
      'bubbles',
      value,
    );
  }

  /* #8243
  source: 
    /**
     * This read-only property returns the Point that was the original value of Diagram#position when the panning operation started.
     * @since 1.1
     */
    get originalPosition(): Point; */
  /// This read-only property returns the Point that was the original value of Diagram#position when the panning operation started.
  _i3.Point get originalPosition => _i5.getProperty(
        this,
        'originalPosition',
      );
  /* #8243
  source: 
    /**
     * This read-only property returns the Point that was the original value of Diagram#position when the panning operation started.
     * @since 1.1
     */
    get originalPosition(): Point; */
  // Type Instance of 'InteropInterface'
  set originalPosition(_i3.Point value) {
    _i5.setProperty(
      this,
      'originalPosition',
      value,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class HTMLInfo {
  factory HTMLInfo() => _i5.callConstructor(
        _declaredHTMLInfo,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('HTMLInfo')
external _i2.Object _declaredHTMLInfo;

extension HTMLInfo$Typings on HTMLInfo {
  /* #8332
  source: 
    /**
     * Gets or sets the primary HTML Element that represents this HTMLInfo.
     * In a context menu, this would be the outermost HTML element, the one which typically
     * shows and hides. If this is set and #hide is not, HTMLInfo will automatically execute:
     * ```js
     *   tool.mainElement.style.display = "none";
     * ```
     *
     * when #hide would typically be called.
     *
     * This is set only for convenience; the default value for this property is null.
     * @see #hide
     */
    get mainElement(): HTMLElement | null; */
  /// Gets or sets the primary HTML Element that represents this HTMLInfo.
  /// In a context menu, this would be the outermost HTML element, the one which typically
  /// shows and hides. If this is set and #hide is not, HTMLInfo will automatically execute:
  /// ```js
  ///   tool.mainElement.style.display = "none";
  /// ```
  ///
  /// when #hide would typically be called.
  ///
  /// This is set only for convenience; the default value for this property is null.
  _i4.HTMLElement? get mainElement => _i5.getProperty(
        this,
        'mainElement',
      );
  /* #8332
  source: 
    /**
     * Gets or sets the primary HTML Element that represents this HTMLInfo.
     * In a context menu, this would be the outermost HTML element, the one which typically
     * shows and hides. If this is set and #hide is not, HTMLInfo will automatically execute:
     * ```js
     *   tool.mainElement.style.display = "none";
     * ```
     *
     * when #hide would typically be called.
     *
     * This is set only for convenience; the default value for this property is null.
     * @see #hide
     */
    get mainElement(): HTMLElement | null; */
  // Type InteropUnion#621400057(parent: InteropGetter#673749524(name: mainElement))
  set mainElement(_i4.HTMLElement? value) {
    _i5.setProperty(
      this,
      'mainElement',
      value ?? _i4.undefined,
    );
  }

  /* #8350
  source: 
    /**
     * Gets or sets the function to call when an HTMLInfo is to be shown,
     * such as when used as the GraphObject#contextMenu or Diagram#toolTip or TextBlock#textEditor.
     *
     * If this is called by:
     *   - ContextMenuTool#showContextMenu, the first argument is the GraphObject for which the context menu is being shown, or null for the diagram background.
     *   - ToolManager#showToolTip, the first argument is the GraphObject for which the tooltip is being shown, or null for the diagram background.
     *   - TextEditingTool#doActivate, the first argument is the TextBlock for which the text editor is being shown.
     *
     * If you need access to any bound data for the first argument, if it is non-null, you can get it via:
     * `obj.part.data`
     * and then you can look at any of the properties you have put on that data.
     *
     * When used as a context menu, typically shown elements, such as buttons, should call
     * `diagram.currentTool.stopTool();` when their action is completed.
     */
    get show(): ((a: GraphObject, b: Diagram, c: Tool) => void) | null; */
  /// Gets or sets the function to call when an HTMLInfo is to be shown,
  /// such as when used as the GraphObject#contextMenu or Diagram#toolTip or TextBlock#textEditor.
  ///
  /// If this is called by:
  ///   - ContextMenuTool#showContextMenu, the first argument is the GraphObject for which the context menu is being shown, or null for the diagram background.
  ///   - ToolManager#showToolTip, the first argument is the GraphObject for which the tooltip is being shown, or null for the diagram background.
  ///   - TextEditingTool#doActivate, the first argument is the TextBlock for which the text editor is being shown.
  ///
  /// If you need access to any bound data for the first argument, if it is non-null, you can get it via:
  /// `obj.part.data`
  /// and then you can look at any of the properties you have put on that data.
  ///
  /// When used as a context menu, typically shown elements, such as buttons, should call
  /// `diagram.currentTool.stopTool();` when their action is completed.
  void Function(
    _i3.GraphObject,
    _i3.Diagram,
    _i3.Tool,
  )? get show => _i5.getProperty(
        this,
        'show',
      );
  /* #8350
  source: 
    /**
     * Gets or sets the function to call when an HTMLInfo is to be shown,
     * such as when used as the GraphObject#contextMenu or Diagram#toolTip or TextBlock#textEditor.
     *
     * If this is called by:
     *   - ContextMenuTool#showContextMenu, the first argument is the GraphObject for which the context menu is being shown, or null for the diagram background.
     *   - ToolManager#showToolTip, the first argument is the GraphObject for which the tooltip is being shown, or null for the diagram background.
     *   - TextEditingTool#doActivate, the first argument is the TextBlock for which the text editor is being shown.
     *
     * If you need access to any bound data for the first argument, if it is non-null, you can get it via:
     * `obj.part.data`
     * and then you can look at any of the properties you have put on that data.
     *
     * When used as a context menu, typically shown elements, such as buttons, should call
     * `diagram.currentTool.stopTool();` when their action is completed.
     */
    get show(): ((a: GraphObject, b: Diagram, c: Tool) => void) | null; */
  // Type InteropUnion#361568228(parent: InteropGetter#554872154(name: show))
  set show(
      void Function(
        _i3.GraphObject,
        _i3.Diagram,
        _i3.Tool,
      )? value) {
    _i5.setProperty(
      this,
      'show',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #8366
  source: 
    /**
     * Gets or sets the function to call when an HTMLInfo is to be hidden.
     * The function should "hide" the HTMLInfo, either by removing any traces of it or otherwise
     * returning the page state to one where the HTMLInfo content is no longer considered active.
     *
     * Setting this is not strictly necessary, if no action is to be taken when hiding the HTMLInfo.
     *
     * If this is called by:
     *   - ContextMenuTool#hideContextMenu, the second argument is the ContextMenuTool.
     *   - ToolManager#hideToolTip, the second argument is the ToolManager.
     *   - TextEditingTool#doDeactivate, the second argument is the TextEditingTool.
     *
     * @see #mainElement
     */
    get hide(): ((a: Diagram, b: Tool) => void) | null; */
  /// Gets or sets the function to call when an HTMLInfo is to be hidden.
  /// The function should "hide" the HTMLInfo, either by removing any traces of it or otherwise
  /// returning the page state to one where the HTMLInfo content is no longer considered active.
  ///
  /// Setting this is not strictly necessary, if no action is to be taken when hiding the HTMLInfo.
  ///
  /// If this is called by:
  ///   - ContextMenuTool#hideContextMenu, the second argument is the ContextMenuTool.
  ///   - ToolManager#hideToolTip, the second argument is the ToolManager.
  ///   - TextEditingTool#doDeactivate, the second argument is the TextEditingTool.
  void Function(
    _i3.Diagram,
    _i3.Tool,
  )? get hide => _i5.getProperty(
        this,
        'hide',
      );
  /* #8366
  source: 
    /**
     * Gets or sets the function to call when an HTMLInfo is to be hidden.
     * The function should "hide" the HTMLInfo, either by removing any traces of it or otherwise
     * returning the page state to one where the HTMLInfo content is no longer considered active.
     *
     * Setting this is not strictly necessary, if no action is to be taken when hiding the HTMLInfo.
     *
     * If this is called by:
     *   - ContextMenuTool#hideContextMenu, the second argument is the ContextMenuTool.
     *   - ToolManager#hideToolTip, the second argument is the ToolManager.
     *   - TextEditingTool#doDeactivate, the second argument is the TextEditingTool.
     *
     * @see #mainElement
     */
    get hide(): ((a: Diagram, b: Tool) => void) | null; */
  // Type InteropUnion#400903068(parent: InteropGetter#633014883(name: hide))
  set hide(
      void Function(
        _i3.Diagram,
        _i3.Tool,
      )? value) {
    _i5.setProperty(
      this,
      'hide',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #8374
  source: 
    /**
     * Gets or sets a function that returns the primary value associated with this HTMLInfo,
     * such as the string value of a text editor, which would be solicited by the TextEditingTool.
     *
     * This typically returns a string.
     */
    get valueFunction(): (() => any) | null; */
  /// Gets or sets a function that returns the primary value associated with this HTMLInfo,
  /// such as the string value of a text editor, which would be solicited by the TextEditingTool.
  ///
  /// This typically returns a string.
  _i2.dynamic Function()? get valueFunction => _i5.getProperty(
        this,
        'valueFunction',
      );
  /* #8374
  source: 
    /**
     * Gets or sets a function that returns the primary value associated with this HTMLInfo,
     * such as the string value of a text editor, which would be solicited by the TextEditingTool.
     *
     * This typically returns a string.
     */
    get valueFunction(): (() => any) | null; */
  // Type InteropUnion#540638261(parent: InteropGetter#320026348(name: valueFunction))
  set valueFunction(_i2.dynamic Function()? value) {
    _i5.setProperty(
      this,
      'valueFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ContextMenuTool implements _i3.Tool {
  factory ContextMenuTool() => _i5.callConstructor(
        _declaredContextMenuTool,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ContextMenuTool')
external _i2.Object _declaredContextMenuTool;

extension ContextMenuTool$Typings on ContextMenuTool {
  /* #8559
  source: 
    /**
     * Gets or sets the currently showing context menu, or null if there is none.
     * This is typically only set in #showContextMenu and not by the user.
     * It is also typically set to null in #hideContextMenu.
     */
    get currentContextMenu(): Adornment | HTMLInfo | null; */
  /// Gets or sets the currently showing context menu, or null if there is none.
  /// This is typically only set in #showContextMenu and not by the user.
  /// It is also typically set to null in #hideContextMenu.
  _i2.dynamic get currentContextMenu => _i5.getProperty(
        this,
        'currentContextMenu',
      );
  /* #8559
  source: 
    /**
     * Gets or sets the currently showing context menu, or null if there is none.
     * This is typically only set in #showContextMenu and not by the user.
     * It is also typically set to null in #hideContextMenu.
     */
    get currentContextMenu(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#5907117(parent: InteropGetter#336893660(name: currentContextMenu))
  set currentContextMenu(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'currentContextMenu',
      value ?? _i4.undefined,
    );
  }

  /* #8570
  source: 
    /**
     * Gets or sets the HTMLInfo or Adornment that acts as the default touch context menu.
     * On touch devices, this context menu will appear even there is no context menu defined.
     *
     * You can disable this functionality by setting this property to null.
     *
     * By default shows a set of HTML elements acting as a context menu.
     * @since 1.7
     */
    get defaultTouchContextMenu(): Adornment | HTMLInfo | null; */
  /// Gets or sets the HTMLInfo or Adornment that acts as the default touch context menu.
  /// On touch devices, this context menu will appear even there is no context menu defined.
  ///
  /// You can disable this functionality by setting this property to null.
  ///
  /// By default shows a set of HTML elements acting as a context menu.
  _i2.dynamic get defaultTouchContextMenu => _i5.getProperty(
        this,
        'defaultTouchContextMenu',
      );
  /* #8570
  source: 
    /**
     * Gets or sets the HTMLInfo or Adornment that acts as the default touch context menu.
     * On touch devices, this context menu will appear even there is no context menu defined.
     *
     * You can disable this functionality by setting this property to null.
     *
     * By default shows a set of HTML elements acting as a context menu.
     * @since 1.7
     */
    get defaultTouchContextMenu(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#230852549(parent: InteropGetter#715310990(name: defaultTouchContextMenu))
  set defaultTouchContextMenu(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'defaultTouchContextMenu',
      value ?? _i4.undefined,
    );
  }

  /* #8579
  source: 
    /**
     * Gets or sets the GraphObject found at the mouse point that has a context menu.
     * This property remembers the result returned by #findObjectWithContextMenu if it is a GraphObject.
     * This value is passed to #showContextMenu as the second argument.
     * The value will be null if the context menu is for the diagram rather than for a particular GraphObject.
     * @since 1.4
     */
    get currentObject(): GraphObject | null; */
  /// Gets or sets the GraphObject found at the mouse point that has a context menu.
  /// This property remembers the result returned by #findObjectWithContextMenu if it is a GraphObject.
  /// This value is passed to #showContextMenu as the second argument.
  /// The value will be null if the context menu is for the diagram rather than for a particular GraphObject.
  _i3.GraphObject? get currentObject => _i5.getProperty(
        this,
        'currentObject',
      );
  /* #8579
  source: 
    /**
     * Gets or sets the GraphObject found at the mouse point that has a context menu.
     * This property remembers the result returned by #findObjectWithContextMenu if it is a GraphObject.
     * This value is passed to #showContextMenu as the second argument.
     * The value will be null if the context menu is for the diagram rather than for a particular GraphObject.
     * @since 1.4
     */
    get currentObject(): GraphObject | null; */
  // Type InteropUnion#198247717(parent: InteropGetter#504505215(name: currentObject))
  set currentObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'currentObject',
      value ?? _i4.undefined,
    );
  }

  /* #8584
  source: 
    /**
     * This read-only property returns the original mouse-down point in document coordinates.
     */
    get mouseDownPoint(): Point; */
  /// This read-only property returns the original mouse-down point in document coordinates.
  _i3.Point get mouseDownPoint => _i5.getProperty(
        this,
        'mouseDownPoint',
      );
  /* #8584
  source: 
    /**
     * This read-only property returns the original mouse-down point in document coordinates.
     */
    get mouseDownPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set mouseDownPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'mouseDownPoint',
      value,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  _i2.dynamic findObjectWithContextMenu([_i2.Object? obj]) => _i5.callMethod(
        this,
        'findObjectWithContextMenu',
        [obj ?? _i4.undefined],
      );
  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doMouseDown() {
    _i5.callMethod(
      this,
      'doMouseDown',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void doMouseMove() {
    _i5.callMethod(
      this,
      'doMouseMove',
      [],
    );
  }

  void showContextMenu(
    _i2.Object contextmenu, [
    _i3.GraphObject? obj,
  ]) {
    _i5.callMethod(
      this,
      'showContextMenu',
      [
        contextmenu,
        obj ?? _i4.undefined,
      ],
    );
  }

  void positionContextMenu(
    _i3.Adornment contextmenu, [
    _i3.GraphObject? obj,
  ]) {
    _i5.callMethod(
      this,
      'positionContextMenu',
      [
        contextmenu,
        obj ?? _i4.undefined,
      ],
    );
  }

  void hideContextMenu() {
    _i5.callMethod(
      this,
      'hideContextMenu',
      [],
    );
  }

  void showDefaultContextMenu() {
    _i5.callMethod(
      this,
      'showDefaultContextMenu',
      [],
    );
  }

  void hideDefaultContextMenu() {
    _i5.callMethod(
      this,
      'hideDefaultContextMenu',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class TextEditingTool implements _i3.Tool {
  factory TextEditingTool() => _i5.callConstructor(
        _declaredTextEditingTool,
        [],
      );

  /* #8633
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the text editing control has lost focus.
     * @constant
     */
    static LostFocus: EnumValue; */
  /// A possible value for TextEditingTool#acceptText, the text editing control has lost focus.
  static _i3.EnumValue get lostFocus => _i5.getProperty(
        _declaredTextEditingTool,
        'LostFocus',
      );
  /* #8633
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the text editing control has lost focus.
     * @constant
     */
    static LostFocus: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set lostFocus(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'LostFocus',
      value,
    );
  }

  /* #8638
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has clicked somewhere else in the diagram.
     * @constant
     */
    static MouseDown: EnumValue; */
  /// A possible value for TextEditingTool#acceptText, the user has clicked somewhere else in the diagram.
  static _i3.EnumValue get mouseDown => _i5.getProperty(
        _declaredTextEditingTool,
        'MouseDown',
      );
  /* #8638
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has clicked somewhere else in the diagram.
     * @constant
     */
    static MouseDown: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set mouseDown(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'MouseDown',
      value,
    );
  }

  /* #8643
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has typed TAB.
     * @constant
     */
    static Tab: EnumValue; */
  /// A possible value for TextEditingTool#acceptText, the user has typed TAB.
  static _i3.EnumValue get tab => _i5.getProperty(
        _declaredTextEditingTool,
        'Tab',
      );
  /* #8643
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has typed TAB.
     * @constant
     */
    static Tab: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set tab(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'Tab',
      value,
    );
  }

  /* #8648
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has typed ENTER.
     * @constant
     */
    static Enter: EnumValue; */
  /// A possible value for TextEditingTool#acceptText, the user has typed ENTER.
  static _i3.EnumValue get enter => _i5.getProperty(
        _declaredTextEditingTool,
        'Enter',
      );
  /* #8648
  source: 
    /**
     * A possible value for TextEditingTool#acceptText, the user has typed ENTER.
     * @constant
     */
    static Enter: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set enter(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'Enter',
      value,
    );
  }

  /* #8655
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A single click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing.
     * @constant
     */
    static SingleClick: EnumValue; */
  /// A possible value for TextEditingTool#starting,
  /// A single click on a TextBlock with TextBlock#editable property set to true
  /// will start in-place editing.
  static _i3.EnumValue get singleClick => _i5.getProperty(
        _declaredTextEditingTool,
        'SingleClick',
      );
  /* #8655
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A single click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing.
     * @constant
     */
    static SingleClick: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set singleClick(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'SingleClick',
      value,
    );
  }

  /* #8662
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A single click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing, but only if the Part that the TextBlock is in is already selected.
     * @constant
     */
    static SingleClickSelected: EnumValue; */
  /// A possible value for TextEditingTool#starting,
  /// A single click on a TextBlock with TextBlock#editable property set to true
  /// will start in-place editing, but only if the Part that the TextBlock is in is already selected.
  static _i3.EnumValue get singleClickSelected => _i5.getProperty(
        _declaredTextEditingTool,
        'SingleClickSelected',
      );
  /* #8662
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A single click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing, but only if the Part that the TextBlock is in is already selected.
     * @constant
     */
    static SingleClickSelected: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set singleClickSelected(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'SingleClickSelected',
      value,
    );
  }

  /* #8669
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A double click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing.
     * @constant
     */
    static DoubleClick: EnumValue; */
  /// A possible value for TextEditingTool#starting,
  /// A double click on a TextBlock with TextBlock#editable property set to true
  /// will start in-place editing.
  static _i3.EnumValue get doubleClick => _i5.getProperty(
        _declaredTextEditingTool,
        'DoubleClick',
      );
  /* #8669
  source: 
    /**
     * A possible value for TextEditingTool#starting,
     * A double click on a TextBlock with TextBlock#editable property set to true
     * will start in-place editing.
     * @constant
     */
    static DoubleClick: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set doubleClick(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'DoubleClick',
      value,
    );
  }

  /* #8675
  source: 
    /**
     * A possible value for #state,
     * this is the starting value before the tool is activated.
     * @constant
     */
    static StateNone: EnumValue; */
  /// A possible value for #state,
  /// this is the starting value before the tool is activated.
  static _i3.EnumValue get stateNone => _i5.getProperty(
        _declaredTextEditingTool,
        'StateNone',
      );
  /* #8675
  source: 
    /**
     * A possible value for #state,
     * this is the starting value before the tool is activated.
     * @constant
     */
    static StateNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateNone',
      value,
    );
  }

  /* #8681
  source: 
    /**
     * A possible value for #state,
     * TextEditingTool#doActivate sets the value of #state to this.
     * @constant
     */
    static StateActive: EnumValue; */
  /// A possible value for #state,
  /// TextEditingTool#doActivate sets the value of #state to this.
  static _i3.EnumValue get stateActive => _i5.getProperty(
        _declaredTextEditingTool,
        'StateActive',
      );
  /* #8681
  source: 
    /**
     * A possible value for #state,
     * TextEditingTool#doActivate sets the value of #state to this.
     * @constant
     */
    static StateActive: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateActive(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateActive',
      value,
    );
  }

  /* #8687
  source: 
    /**
     * A possible value for #state,
     * The default text editor receiving focus sets the value of #state to this.
     * @constant
     */
    static StateEditing: EnumValue; */
  /// A possible value for #state,
  /// The default text editor receiving focus sets the value of #state to this.
  static _i3.EnumValue get stateEditing => _i5.getProperty(
        _declaredTextEditingTool,
        'StateEditing',
      );
  /* #8687
  source: 
    /**
     * A possible value for #state,
     * The default text editor receiving focus sets the value of #state to this.
     * @constant
     */
    static StateEditing: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateEditing(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateEditing',
      value,
    );
  }

  /* #8693
  source: 
    /**
     * A possible value for #state,
     * TextEditingTool.acceptText sets the value of #state to this.
     * @constant
     */
    static StateValidating: EnumValue; */
  /// A possible value for #state,
  /// TextEditingTool.acceptText sets the value of #state to this.
  static _i3.EnumValue get stateValidating => _i5.getProperty(
        _declaredTextEditingTool,
        'StateValidating',
      );
  /* #8693
  source: 
    /**
     * A possible value for #state,
     * TextEditingTool.acceptText sets the value of #state to this.
     * @constant
     */
    static StateValidating: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateValidating(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateValidating',
      value,
    );
  }

  /* #8699
  source: 
    /**
     * A possible value for #state,
     * If validation fails, TextEditingTool.acceptText sets the value of #state to this.
     * @constant
     */
    static StateInvalid: EnumValue; */
  /// A possible value for #state,
  /// If validation fails, TextEditingTool.acceptText sets the value of #state to this.
  static _i3.EnumValue get stateInvalid => _i5.getProperty(
        _declaredTextEditingTool,
        'StateInvalid',
      );
  /* #8699
  source: 
    /**
     * A possible value for #state,
     * If validation fails, TextEditingTool.acceptText sets the value of #state to this.
     * @constant
     */
    static StateInvalid: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateInvalid(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateInvalid',
      value,
    );
  }

  /* #8705
  source: 
    /**
     * A possible value for #state,
     * Once accepted and the tool begins the "TextEditing" transaction, the value of #state is set to this.
     * @constant
     */
    static StateValidated: EnumValue; */
  /// A possible value for #state,
  /// Once accepted and the tool begins the "TextEditing" transaction, the value of #state is set to this.
  static _i3.EnumValue get stateValidated => _i5.getProperty(
        _declaredTextEditingTool,
        'StateValidated',
      );
  /* #8705
  source: 
    /**
     * A possible value for #state,
     * Once accepted and the tool begins the "TextEditing" transaction, the value of #state is set to this.
     * @constant
     */
    static StateValidated: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stateValidated(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextEditingTool,
      'StateValidated',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('TextEditingTool')
external _i2.Object _declaredTextEditingTool;

extension TextEditingTool$Typings on TextEditingTool {
  /* #8713
  source: 
    /**
     * Gets or sets the TextBlock that is being edited.
     * This property is initially null and is set in TextEditingTool#doActivate
     * as the TextBlock at the mouse click point.
     * However, if you set this property beforehand, TextEditingTool#doActivate
     * will not set it, and this tool will edit the given TextBlock.
     */
    get textBlock(): TextBlock | null; */
  /// Gets or sets the TextBlock that is being edited.
  /// This property is initially null and is set in TextEditingTool#doActivate
  /// as the TextBlock at the mouse click point.
  /// However, if you set this property beforehand, TextEditingTool#doActivate
  /// will not set it, and this tool will edit the given TextBlock.
  _i3.TextBlock? get textBlock => _i5.getProperty(
        this,
        'textBlock',
      );
  /* #8713
  source: 
    /**
     * Gets or sets the TextBlock that is being edited.
     * This property is initially null and is set in TextEditingTool#doActivate
     * as the TextBlock at the mouse click point.
     * However, if you set this property beforehand, TextEditingTool#doActivate
     * will not set it, and this tool will edit the given TextBlock.
     */
    get textBlock(): TextBlock | null; */
  // Type InteropUnion#1064009808(parent: InteropGetter#818004269(name: textBlock))
  set textBlock(_i3.TextBlock? value) {
    _i5.setProperty(
      this,
      'textBlock',
      value ?? _i4.undefined,
    );
  }

  /* #8718
  source: 
    /**
     * Gets or sets the HTMLInfo that is editing the text.
     */
    get currentTextEditor(): HTMLInfo | null; */
  /// Gets or sets the HTMLInfo that is editing the text.
  _i3.HTMLInfo? get currentTextEditor => _i5.getProperty(
        this,
        'currentTextEditor',
      );
  /* #8718
  source: 
    /**
     * Gets or sets the HTMLInfo that is editing the text.
     */
    get currentTextEditor(): HTMLInfo | null; */
  // Type InteropUnion#908655371(parent: InteropGetter#553982710(name: currentTextEditor))
  set currentTextEditor(_i3.HTMLInfo? value) {
    _i5.setProperty(
      this,
      'currentTextEditor',
      value ?? _i4.undefined,
    );
  }

  /* #8734
  source: 
    /**
     * Gets or sets the default HTMLInfo that edits the text.
     *
     * When TextEditingTool#doActivate is called, the #currentTextEditor is set to this value by default.
     * If a TextBlock#textEditor is specified on the TextBlock, that editor is used instead.
     *
     * This tool will call HTMLInfo#show during #doActivate,
     * and HTMLInfo#hide during #doDeactivate.
     *
     * By default the value is an HTMLInfo, and the HTMLInfo#mainElement is an `HTMLTextArea`.
     * You can see the default implementation details <a href="../../extensions/TextEditor.html">here</a>.
     *
     * For typical operation, HTMLInfo implementations should have a way of calling TextEditingTool#acceptText.
     */
    get defaultTextEditor(): HTMLInfo; */
  /// Gets or sets the default HTMLInfo that edits the text.
  ///
  /// When TextEditingTool#doActivate is called, the #currentTextEditor is set to this value by default.
  /// If a TextBlock#textEditor is specified on the TextBlock, that editor is used instead.
  ///
  /// This tool will call HTMLInfo#show during #doActivate,
  /// and HTMLInfo#hide during #doDeactivate.
  ///
  /// By default the value is an HTMLInfo, and the HTMLInfo#mainElement is an `HTMLTextArea`.
  /// You can see the default implementation details <a href="../../extensions/TextEditor.html">here</a>.
  ///
  /// For typical operation, HTMLInfo implementations should have a way of calling TextEditingTool#acceptText.
  _i3.HTMLInfo get defaultTextEditor => _i5.getProperty(
        this,
        'defaultTextEditor',
      );
  /* #8734
  source: 
    /**
     * Gets or sets the default HTMLInfo that edits the text.
     *
     * When TextEditingTool#doActivate is called, the #currentTextEditor is set to this value by default.
     * If a TextBlock#textEditor is specified on the TextBlock, that editor is used instead.
     *
     * This tool will call HTMLInfo#show during #doActivate,
     * and HTMLInfo#hide during #doDeactivate.
     *
     * By default the value is an HTMLInfo, and the HTMLInfo#mainElement is an `HTMLTextArea`.
     * You can see the default implementation details <a href="../../extensions/TextEditor.html">here</a>.
     *
     * For typical operation, HTMLInfo implementations should have a way of calling TextEditingTool#acceptText.
     */
    get defaultTextEditor(): HTMLInfo; */
  // Type Instance of 'InteropInterface'
  set defaultTextEditor(_i3.HTMLInfo value) {
    _i5.setProperty(
      this,
      'defaultTextEditor',
      value,
    );
  }

  /* #8743
  source: 
    /**
     * Gets or sets how user gestures can start in-place editing of text.
     *
     * Possible values are TextEditingTool.SingleClickSelected, TextEditingTool.SingleClick, and TextEditingTool.DoubleClick.
     *
     * The default is TextEditingTool.SingleClickSelected
     */
    get starting(): EnumValue; */
  /// Gets or sets how user gestures can start in-place editing of text.
  ///
  /// Possible values are TextEditingTool.SingleClickSelected, TextEditingTool.SingleClick, and TextEditingTool.DoubleClick.
  ///
  /// The default is TextEditingTool.SingleClickSelected
  _i3.EnumValue get starting => _i5.getProperty(
        this,
        'starting',
      );
  /* #8743
  source: 
    /**
     * Gets or sets how user gestures can start in-place editing of text.
     *
     * Possible values are TextEditingTool.SingleClickSelected, TextEditingTool.SingleClick, and TextEditingTool.DoubleClick.
     *
     * The default is TextEditingTool.SingleClickSelected
     */
    get starting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set starting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'starting',
      value,
    );
  }

  /* #8856
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a string of text is valid.
     * If this is non-null, this predicate is called in addition to any TextBlock#textValidation predicate.
     * See #isValidText for more details.
     * The default predicate is null, which is equivalent to simply returning true.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get textValidation(): ((aTextBlock: TextBlock, oldString: string, newString: string) => boolean) | null; */
  /// Gets or sets the predicate that determines whether or not a string of text is valid.
  /// If this is non-null, this predicate is called in addition to any TextBlock#textValidation predicate.
  /// See #isValidText for more details.
  /// The default predicate is null, which is equivalent to simply returning true.
  ///
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i3.TextBlock,
    _i2.String,
    _i2.String,
  )? get textValidation => _i5.getProperty(
        this,
        'textValidation',
      );
  /* #8856
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a string of text is valid.
     * If this is non-null, this predicate is called in addition to any TextBlock#textValidation predicate.
     * See #isValidText for more details.
     * The default predicate is null, which is equivalent to simply returning true.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get textValidation(): ((aTextBlock: TextBlock, oldString: string, newString: string) => boolean) | null; */
  // Type InteropUnion#924291964(parent: InteropGetter#17789921(name: textValidation))
  set textValidation(
      _i2.bool Function(
        _i3.TextBlock,
        _i2.String,
        _i2.String,
      )? value) {
    _i5.setProperty(
      this,
      'textValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #8864
  source: 
    /**
     * Gets or sets whether to select (highlight) the editable text when the TextEditingTool is activated.
     * The default is true.
     * @since 1.5
     */
    get selectsTextOnActivate(): boolean; */
  /// Gets or sets whether to select (highlight) the editable text when the TextEditingTool is activated.
  /// The default is true.
  _i2.bool get selectsTextOnActivate => _i5.getProperty(
        this,
        'selectsTextOnActivate',
      );
  /* #8864
  source: 
    /**
     * Gets or sets whether to select (highlight) the editable text when the TextEditingTool is activated.
     * The default is true.
     * @since 1.5
     */
    get selectsTextOnActivate(): boolean; */
  // Type InteropStaticType.boolean
  set selectsTextOnActivate(_i2.bool value) {
    _i5.setProperty(
      this,
      'selectsTextOnActivate',
      value,
    );
  }

  /* #8882
  source: 
    /**
     * Gets or sets the state of the TextEditingTool.
     * The only accepted values are listed as constant properties of TextEditingTool, including:
     *   - TextEditingTool.StateNone
     *   - TextEditingTool.StateActive
     *   - TextEditingTool.StateEditing
     *   - TextEditingTool.StateValidating
     *   - TextEditingTool.StateValidated
     *
     * The starting value value is TextEditingTool.StateNone,
     * TextEditingTool#doActivate sets the value to TextEditingTool.StateActive.
     * The default text editor receiving focus sets the value to TextEditingTool.StateEditing.
     * TextEditingTool#acceptText sets the value to TextEditingTool.StateValidating.
     * Once accepted and the tool begins the "TextEditing" transaction, the value is set to TextEditingTool.StateValidated.
     * @since 1.7
     */
    get state(): EnumValue; */
  /// Gets or sets the state of the TextEditingTool.
  /// The only accepted values are listed as constant properties of TextEditingTool, including:
  ///   - TextEditingTool.StateNone
  ///   - TextEditingTool.StateActive
  ///   - TextEditingTool.StateEditing
  ///   - TextEditingTool.StateValidating
  ///   - TextEditingTool.StateValidated
  ///
  /// The starting value value is TextEditingTool.StateNone,
  /// TextEditingTool#doActivate sets the value to TextEditingTool.StateActive.
  /// The default text editor receiving focus sets the value to TextEditingTool.StateEditing.
  /// TextEditingTool#acceptText sets the value to TextEditingTool.StateValidating.
  /// Once accepted and the tool begins the "TextEditing" transaction, the value is set to TextEditingTool.StateValidated.
  _i3.EnumValue get state => _i5.getProperty(
        this,
        'state',
      );
  /* #8882
  source: 
    /**
     * Gets or sets the state of the TextEditingTool.
     * The only accepted values are listed as constant properties of TextEditingTool, including:
     *   - TextEditingTool.StateNone
     *   - TextEditingTool.StateActive
     *   - TextEditingTool.StateEditing
     *   - TextEditingTool.StateValidating
     *   - TextEditingTool.StateValidated
     *
     * The starting value value is TextEditingTool.StateNone,
     * TextEditingTool#doActivate sets the value to TextEditingTool.StateActive.
     * The default text editor receiving focus sets the value to TextEditingTool.StateEditing.
     * TextEditingTool#acceptText sets the value to TextEditingTool.StateValidating.
     * Once accepted and the tool begins the "TextEditing" transaction, the value is set to TextEditingTool.StateValidated.
     * @since 1.7
     */
    get state(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set state(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'state',
      value,
    );
  }

  _i2.bool canStart() => _i5.callMethod(
        this,
        'canStart',
        [],
      );
  void doStart() {
    _i5.callMethod(
      this,
      'doStart',
      [],
    );
  }

  void doActivate() {
    _i5.callMethod(
      this,
      'doActivate',
      [],
    );
  }

  void doCancel() {
    _i5.callMethod(
      this,
      'doCancel',
      [],
    );
  }

  void doMouseUp() {
    _i5.callMethod(
      this,
      'doMouseUp',
      [],
    );
  }

  void doMouseDown() {
    _i5.callMethod(
      this,
      'doMouseDown',
      [],
    );
  }

  void acceptText(_i3.EnumValue reason) {
    _i5.callMethod(
      this,
      'acceptText',
      [reason],
    );
  }

  void doError(
    _i2.String oldstring,
    _i2.String newstring,
  ) {
    _i5.callMethod(
      this,
      'doError',
      [
        oldstring,
        newstring,
      ],
    );
  }

  void doSuccess(
    _i2.String oldstring,
    _i2.String newstring,
  ) {
    _i5.callMethod(
      this,
      'doSuccess',
      [
        oldstring,
        newstring,
      ],
    );
  }

  void doDeactivate() {
    _i5.callMethod(
      this,
      'doDeactivate',
      [],
    );
  }

  _i2.bool isValidText(
    _i3.TextBlock textblock,
    _i2.String oldstr,
    _i2.String newstr,
  ) =>
      _i5.callMethod(
        this,
        'isValidText',
        [
          textblock,
          oldstr,
          newstr,
        ],
      );
  _i3.TextBlock measureTemporaryTextBlock(_i2.String text) => _i5.callMethod(
        this,
        'measureTemporaryTextBlock',
        [text],
      );
}

@_i1.JS()
@_i1.staticInterop
class AnimationManager {
  factory AnimationManager([_i4.Partial? init]) => _i5.callConstructor(
        _declaredAnimationManager,
        [init ?? _i4.undefined],
      );

  /* #9116
  source: 
    /**
     * Used as the default value for #initialAnimationStyle.
     * The default initial animation style will "fade up" and in the Diagram's contents by animating the Diagram#position and Diagram#opacity.
     * To make the default initial animation behave like GoJS 2.0, set #initialAnimationStyle to  AnimationManager.AnimateLocations.
     * To customize the default initial animation, set #initialAnimationStyle to  AnimationManager.None
     * and define a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static Default: EnumValue; */
  /// Used as the default value for #initialAnimationStyle.
  /// The default initial animation style will "fade up" and in the Diagram's contents by animating the Diagram#position and Diagram#opacity.
  /// To make the default initial animation behave like GoJS 2.0, set #initialAnimationStyle to  AnimationManager.AnimateLocations.
  /// To customize the default initial animation, set #initialAnimationStyle to  AnimationManager.None
  /// and define a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
  /// See #initialAnimationStyle for details and examples.
  static _i3.EnumValue get default$ => _i5.getProperty(
        _declaredAnimationManager,
        'Default',
      );
  /* #9116
  source: 
    /**
     * Used as the default value for #initialAnimationStyle.
     * The default initial animation style will "fade up" and in the Diagram's contents by animating the Diagram#position and Diagram#opacity.
     * To make the default initial animation behave like GoJS 2.0, set #initialAnimationStyle to  AnimationManager.AnimateLocations.
     * To customize the default initial animation, set #initialAnimationStyle to  AnimationManager.None
     * and define a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static Default: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set default$(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationManager,
      'Default',
      value,
    );
  }

  /* #9125
  source: 
    /**
     * Used as a value for #initialAnimationStyle.
     * This value will cause initial animations to capture Part locations and animate them from `(0, 0)` to those location values.
     * This was the default initial animation behavior in GoJS 2.0 and prior.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static AnimateLocations: EnumValue; */
  /// Used as a value for #initialAnimationStyle.
  /// This value will cause initial animations to capture Part locations and animate them from `(0, 0)` to those location values.
  /// This was the default initial animation behavior in GoJS 2.0 and prior.
  /// See #initialAnimationStyle for details and examples.
  static _i3.EnumValue get animateLocations => _i5.getProperty(
        _declaredAnimationManager,
        'AnimateLocations',
      );
  /* #9125
  source: 
    /**
     * Used as a value for #initialAnimationStyle.
     * This value will cause initial animations to capture Part locations and animate them from `(0, 0)` to those location values.
     * This was the default initial animation behavior in GoJS 2.0 and prior.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static AnimateLocations: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set animateLocations(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationManager,
      'AnimateLocations',
      value,
    );
  }

  /* #9134
  source: 
    /**
     * Used as a value for #initialAnimationStyle.
     * This will turn off the initial animation, but also allows for customizing the initial animation by adding your own properties
     * if you define a `"InitialAnimationStarting"` listener with Diagram#addDiagramListener.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static None: EnumValue; */
  /// Used as a value for #initialAnimationStyle.
  /// This will turn off the initial animation, but also allows for customizing the initial animation by adding your own properties
  /// if you define a `"InitialAnimationStarting"` listener with Diagram#addDiagramListener.
  /// See #initialAnimationStyle for details and examples.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredAnimationManager,
        'None',
      );
  /* #9134
  source: 
    /**
     * Used as a value for #initialAnimationStyle.
     * This will turn off the initial animation, but also allows for customizing the initial animation by adding your own properties
     * if you define a `"InitialAnimationStarting"` listener with Diagram#addDiagramListener.
     * See #initialAnimationStyle for details and examples.
     * @constant
     * @since 2.1
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationManager,
      'None',
      value,
    );
  }

  static void defineAnimationEffect(
    _i2.String effectName,
    void Function(
      _i2.Object,
      _i2.dynamic,
      _i2.dynamic,
      _i3.EasingFunction,
      _i2.num,
      _i2.num,
      _i3.Animation,
    ) animationFunction,
  ) {
    _i5.callMethod(
      _declaredAnimationManager,
      'defineAnimationEffect',
      [
        effectName,
        _i5.allowInterop(animationFunction),
      ],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('AnimationManager')
external _i2.Object _declaredAnimationManager;

extension AnimationManager$Typings on AnimationManager {
  /* #8995
  source: 
    /**
     * Gets or sets whether this AnimationManager operates.
     *
     * The default value is `true`.
     * Setting this to `false` does not stop an animation, it only stops future animations.
     * To stop any ongoing animation, use #stopAnimation.
     * To disable only the default animations, set #canStart to a function that always returns `false`.
     *
     * If any indefinite animations (animations with Animation#runCount set to `Infinity`) were running
     * when this is set to `false`, they will be resumed when this is set to `true`.
     *
     * Setting this property does not raise any events.
     * @see #canStart
     */
    get isEnabled(): boolean; */
  /// Gets or sets whether this AnimationManager operates.
  ///
  /// The default value is `true`.
  /// Setting this to `false` does not stop an animation, it only stops future animations.
  /// To stop any ongoing animation, use #stopAnimation.
  /// To disable only the default animations, set #canStart to a function that always returns `false`.
  ///
  /// If any indefinite animations (animations with Animation#runCount set to `Infinity`) were running
  /// when this is set to `false`, they will be resumed when this is set to `true`.
  ///
  /// Setting this property does not raise any events.
  _i2.bool get isEnabled => _i5.getProperty(
        this,
        'isEnabled',
      );
  /* #8995
  source: 
    /**
     * Gets or sets whether this AnimationManager operates.
     *
     * The default value is `true`.
     * Setting this to `false` does not stop an animation, it only stops future animations.
     * To stop any ongoing animation, use #stopAnimation.
     * To disable only the default animations, set #canStart to a function that always returns `false`.
     *
     * If any indefinite animations (animations with Animation#runCount set to `Infinity`) were running
     * when this is set to `false`, they will be resumed when this is set to `true`.
     *
     * Setting this property does not raise any events.
     * @see #canStart
     */
    get isEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEnabled',
      value,
    );
  }

  /* #9007
  source: 
    /**
     * Gets or sets the default duration, in milliseconds, used as the duration for the #defaultAnimation
     * and for animations that have their Animation#duration set to `NaN`.
     *
     * Typically these values are short. The default value is 600 milliseconds.
     * The value must be a number greater than or equal to 1.
     * Setting this property does not raise any events.
     *
     * @see Animation#duration
     */
    get duration(): number; */
  /// Gets or sets the default duration, in milliseconds, used as the duration for the #defaultAnimation
  /// and for animations that have their Animation#duration set to `NaN`.
  ///
  /// Typically these values are short. The default value is 600 milliseconds.
  /// The value must be a number greater than or equal to 1.
  /// Setting this property does not raise any events.
  _i2.num get duration => _i5.getProperty(
        this,
        'duration',
      );
  /* #9007
  source: 
    /**
     * Gets or sets the default duration, in milliseconds, used as the duration for the #defaultAnimation
     * and for animations that have their Animation#duration set to `NaN`.
     *
     * Typically these values are short. The default value is 600 milliseconds.
     * The value must be a number greater than or equal to 1.
     * Setting this property does not raise any events.
     *
     * @see Animation#duration
     */
    get duration(): number; */
  // Type InteropStaticType.number
  set duration(_i2.num value) {
    _i5.setProperty(
      this,
      'duration',
      value,
    );
  }

  /* #9016
  source: 
    /**
     * This read-only property is true when the animation manager is currently animating any animation,
     * including the #defaultAnimation.
     *
     * This value cannot be set, but animation can be stopped by calling #stopAnimation,
     * and it can be prevented by setting #isEnabled.
     */
    get isAnimating(): boolean; */
  /// This read-only property is true when the animation manager is currently animating any animation,
  /// including the #defaultAnimation.
  ///
  /// This value cannot be set, but animation can be stopped by calling #stopAnimation,
  /// and it can be prevented by setting #isEnabled.
  _i2.bool get isAnimating => _i5.getProperty(
        this,
        'isAnimating',
      );
  /* #9016
  source: 
    /**
     * This read-only property is true when the animation manager is currently animating any animation,
     * including the #defaultAnimation.
     *
     * This value cannot be set, but animation can be stopped by calling #stopAnimation,
     * and it can be prevented by setting #isEnabled.
     */
    get isAnimating(): boolean; */
  // Type InteropStaticType.boolean
  set isAnimating(_i2.bool value) {
    _i5.setProperty(
      this,
      'isAnimating',
      value,
    );
  }

  /* #9023
  source: 
    /**
     * This read-only property is true when the animation manager is in the middle of an animation tick.
     * Animation only operates on GraphObjects during ticks, but code outside of AnimationManager's control may execute between ticks.
     *
     * `isTicking` can only be true when #isAnimating is also true.
     */
    get isTicking(): boolean; */
  /// This read-only property is true when the animation manager is in the middle of an animation tick.
  /// Animation only operates on GraphObjects during ticks, but code outside of AnimationManager's control may execute between ticks.
  ///
  /// `isTicking` can only be true when #isAnimating is also true.
  _i2.bool get isTicking => _i5.getProperty(
        this,
        'isTicking',
      );
  /* #9023
  source: 
    /**
     * This read-only property is true when the animation manager is in the middle of an animation tick.
     * Animation only operates on GraphObjects during ticks, but code outside of AnimationManager's control may execute between ticks.
     *
     * `isTicking` can only be true when #isAnimating is also true.
     */
    get isTicking(): boolean; */
  // Type InteropStaticType.boolean
  set isTicking(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTicking',
      value,
    );
  }

  /* #9032
  source: 
    /**
     * Gets or sets whether a default animation is performed on an initial layout.
     *
     * The default value is true.
     * Changing the value does not affect any ongoing animation.
     * Setting this property does not raise any events.
     * @since 1.6
     */
    get isInitial(): boolean; */
  /// Gets or sets whether a default animation is performed on an initial layout.
  ///
  /// The default value is true.
  /// Changing the value does not affect any ongoing animation.
  /// Setting this property does not raise any events.
  _i2.bool get isInitial => _i5.getProperty(
        this,
        'isInitial',
      );
  /* #9032
  source: 
    /**
     * Gets or sets whether a default animation is performed on an initial layout.
     *
     * The default value is true.
     * Changing the value does not affect any ongoing animation.
     * Setting this property does not raise any events.
     * @since 1.6
     */
    get isInitial(): boolean; */
  // Type InteropStaticType.boolean
  set isInitial(_i2.bool value) {
    _i5.setProperty(
      this,
      'isInitial',
      value,
    );
  }

  /* #9047
  source: 
    /**
     * This read-only property gets the Animation that carries out the default built-in GoJS animations.
     * This animation is usually only referenced to modify default animation properties,
     * such as the Animation#easing or Animation#duration.
     *
     * You should not add anything to or start the default animation, GoJS does so automatically, internally.
     * When the default animation begins it raises the `"AnimationStarting"` Diagram event,
     * upon completion it raises the `"AnimationFinished"` Diagram event.
     * You should not modify the properties Animation#runCount or Animation#reversible on the default animation.
     *
     * See the <a href="../../intro/animation.html">Introduction Page on Animations</a> for more detail.
     * @since 2.1
     */
    get defaultAnimation(): Animation; */
  /// This read-only property gets the Animation that carries out the default built-in GoJS animations.
  /// This animation is usually only referenced to modify default animation properties,
  /// such as the Animation#easing or Animation#duration.
  ///
  /// You should not add anything to or start the default animation, GoJS does so automatically, internally.
  /// When the default animation begins it raises the `"AnimationStarting"` Diagram event,
  /// upon completion it raises the `"AnimationFinished"` Diagram event.
  /// You should not modify the properties Animation#runCount or Animation#reversible on the default animation.
  ///
  /// See the <a href="../../intro/animation.html">Introduction Page on Animations</a> for more detail.
  _i3.Animation get defaultAnimation => _i5.getProperty(
        this,
        'defaultAnimation',
      );
  /* #9047
  source: 
    /**
     * This read-only property gets the Animation that carries out the default built-in GoJS animations.
     * This animation is usually only referenced to modify default animation properties,
     * such as the Animation#easing or Animation#duration.
     *
     * You should not add anything to or start the default animation, GoJS does so automatically, internally.
     * When the default animation begins it raises the `"AnimationStarting"` Diagram event,
     * upon completion it raises the `"AnimationFinished"` Diagram event.
     * You should not modify the properties Animation#runCount or Animation#reversible on the default animation.
     *
     * See the <a href="../../intro/animation.html">Introduction Page on Animations</a> for more detail.
     * @since 2.1
     */
    get defaultAnimation(): Animation; */
  // Type Instance of 'InteropInterface'
  set defaultAnimation(_i3.Animation value) {
    _i5.setProperty(
      this,
      'defaultAnimation',
      value,
    );
  }

  /* #9052
  source: 
    /**
     * Gets the set of currently animating Animations being managed by this AnimationManager, including any running #defaultAnimation.
     * @since 2.1
     */
    get activeAnimations(): Set<Animation>; */
  /// Gets the set of currently animating Animations being managed by this AnimationManager, including any running #defaultAnimation.
  _i3.Set<_i3.Animation> get activeAnimations => _i5.getProperty(
        this,
        'activeAnimations',
      );
  /* #9052
  source: 
    /**
     * Gets the set of currently animating Animations being managed by this AnimationManager, including any running #defaultAnimation.
     * @since 2.1
     */
    get activeAnimations(): Set<Animation>; */
  // Type Instance of 'InteropInterface'
  set activeAnimations(_i3.Set<_i3.Animation> value) {
    _i5.setProperty(
      this,
      'activeAnimations',
      value,
    );
  }

  /* #9078
  source: 
    /**
     * Gets or sets the initial animation style that is set up by the #defaultAnimation.
     * This can be AnimationManager.Default, AnimationManager.AnimateLocations, or AnimationManager.None.
     * - If set to AnimationManager.Default, the initial animation will "fade up"
     *    the Diagram's contents by animating the Diagram#position and Diagram#opacity.
     * - If set to AnimationManager.AnimateLocations, the initial animation will animate Part locations from `(0, 0)` to their values, as GoJS 2.0 and prior do.
     * - If set to AnimationManager.None, no initial animation will happen by default,
     *   which this allows you to specify your own initial animation by defining a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
     *
     * An example custom initial animation, which zooms the Diagram into view:
     *
     * ```js
     * myDiagram.animationManager.initialAnimationStyle = go.AnimationManager.None;
     * myDiagram.addDiagramListener('InitialAnimationStarting', e => {
     *   var animation = e.subject.defaultAnimation;
     *   animation.easing = go.Animation.EaseOutExpo;
     *   animation.duration = 900;
     *   animation.add(e.diagram, 'scale', 0.1, 1);
     *   animation.add(e.diagram, 'opacity', 0, 1);
     * });
     * ```
     *
     *
     * @since 2.1
     */
    get initialAnimationStyle(): EnumValue; */
  /// Gets or sets the initial animation style that is set up by the #defaultAnimation.
  /// This can be AnimationManager.Default, AnimationManager.AnimateLocations, or AnimationManager.None.
  /// - If set to AnimationManager.Default, the initial animation will "fade up"
  ///    the Diagram's contents by animating the Diagram#position and Diagram#opacity.
  /// - If set to AnimationManager.AnimateLocations, the initial animation will animate Part locations from `(0, 0)` to their values, as GoJS 2.0 and prior do.
  /// - If set to AnimationManager.None, no initial animation will happen by default,
  ///   which this allows you to specify your own initial animation by defining a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
  ///
  /// An example custom initial animation, which zooms the Diagram into view:
  ///
  /// ```js
  /// myDiagram.animationManager.initialAnimationStyle = go.AnimationManager.None;
  /// myDiagram.addDiagramListener('InitialAnimationStarting', e => {
  ///   var animation = e.subject.defaultAnimation;
  ///   animation.easing = go.Animation.EaseOutExpo;
  ///   animation.duration = 900;
  ///   animation.add(e.diagram, 'scale', 0.1, 1);
  ///   animation.add(e.diagram, 'opacity', 0, 1);
  /// });
  /// ```
  _i3.EnumValue get initialAnimationStyle => _i5.getProperty(
        this,
        'initialAnimationStyle',
      );
  /* #9078
  source: 
    /**
     * Gets or sets the initial animation style that is set up by the #defaultAnimation.
     * This can be AnimationManager.Default, AnimationManager.AnimateLocations, or AnimationManager.None.
     * - If set to AnimationManager.Default, the initial animation will "fade up"
     *    the Diagram's contents by animating the Diagram#position and Diagram#opacity.
     * - If set to AnimationManager.AnimateLocations, the initial animation will animate Part locations from `(0, 0)` to their values, as GoJS 2.0 and prior do.
     * - If set to AnimationManager.None, no initial animation will happen by default,
     *   which this allows you to specify your own initial animation by defining a `"InitialAnimationStarting"` DiagramEvent listener with Diagram#addDiagramListener.
     *
     * An example custom initial animation, which zooms the Diagram into view:
     *
     * ```js
     * myDiagram.animationManager.initialAnimationStyle = go.AnimationManager.None;
     * myDiagram.addDiagramListener('InitialAnimationStarting', e => {
     *   var animation = e.subject.defaultAnimation;
     *   animation.easing = go.Animation.EaseOutExpo;
     *   animation.duration = 900;
     *   animation.add(e.diagram, 'scale', 0.1, 1);
     *   animation.add(e.diagram, 'opacity', 0, 1);
     * });
     * ```
     *
     *
     * @since 2.1
     */
    get initialAnimationStyle(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set initialAnimationStyle(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'initialAnimationStyle',
      value,
    );
  }

  _i2.bool canStart(_i2.String reason) => _i5.callMethod(
        this,
        'canStart',
        [reason],
      );
  void stopAnimation([_i2.bool? stopsAllAnimations]) {
    _i5.callMethod(
      this,
      'stopAnimation',
      [stopsAllAnimations ?? _i4.undefined],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Animation {
  factory Animation([_i4.Partial? init]) => _i5.callConstructor(
        _declaredAnimation,
        [init ?? _i4.undefined],
      );

  /* #9351
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseLinear: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  static _i3.EasingFunction get easeLinear => _i5.getProperty(
        _declaredAnimation,
        'EaseLinear',
      );
  /* #9351
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseLinear: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeLinear(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseLinear',
      _i5.allowInterop(value),
    );
  }

  /* #9357
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * This is the default value for Animation#easing.
     * @constant
     */
    static EaseInOutQuad: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  /// This is the default value for Animation#easing.
  static _i3.EasingFunction get easeInOutQuad => _i5.getProperty(
        _declaredAnimation,
        'EaseInOutQuad',
      );
  /* #9357
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * This is the default value for Animation#easing.
     * @constant
     */
    static EaseInOutQuad: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeInOutQuad(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseInOutQuad',
      _i5.allowInterop(value),
    );
  }

  /* #9362
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseInQuad: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  static _i3.EasingFunction get easeInQuad => _i5.getProperty(
        _declaredAnimation,
        'EaseInQuad',
      );
  /* #9362
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseInQuad: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeInQuad(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseInQuad',
      _i5.allowInterop(value),
    );
  }

  /* #9367
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseOutQuad: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  static _i3.EasingFunction get easeOutQuad => _i5.getProperty(
        _declaredAnimation,
        'EaseOutQuad',
      );
  /* #9367
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseOutQuad: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeOutQuad(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseOutQuad',
      _i5.allowInterop(value),
    );
  }

  /* #9372
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseInExpo: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  static _i3.EasingFunction get easeInExpo => _i5.getProperty(
        _declaredAnimation,
        'EaseInExpo',
      );
  /* #9372
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseInExpo: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeInExpo(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseInExpo',
      _i5.allowInterop(value),
    );
  }

  /* #9377
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseOutExpo: EasingFunction; */
  /// Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
  static _i3.EasingFunction get easeOutExpo => _i5.getProperty(
        _declaredAnimation,
        'EaseOutExpo',
      );
  /* #9377
  source: 
    /**
     * Built-in static function for computing interpolated values. Can be used as a value for Animation#easing.
     * @constant
     */
    static EaseOutExpo: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  static set easeOutExpo(_i3.EasingFunction value) {
    _i5.setProperty(
      _declaredAnimation,
      'EaseOutExpo',
      _i5.allowInterop(value),
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Animation')
external _i2.Object _declaredAnimation;

extension Animation$Typings on Animation {
  /* #9278
  source: 
    /**
     * Gets or sets the duration for animations, in milliseconds.
     *
     * The default value is `NaN`, which means it inherits the default value from the AnimationManager#duration,
     * which defaults to 600 milliseconds.
     *
     * The value must be a number greater than or equal to 1, or `NaN`.
     * Setting this property does not raise any events.
     */
    get duration(): number; */
  /// Gets or sets the duration for animations, in milliseconds.
  ///
  /// The default value is `NaN`, which means it inherits the default value from the AnimationManager#duration,
  /// which defaults to 600 milliseconds.
  ///
  /// The value must be a number greater than or equal to 1, or `NaN`.
  /// Setting this property does not raise any events.
  _i2.num get duration => _i5.getProperty(
        this,
        'duration',
      );
  /* #9278
  source: 
    /**
     * Gets or sets the duration for animations, in milliseconds.
     *
     * The default value is `NaN`, which means it inherits the default value from the AnimationManager#duration,
     * which defaults to 600 milliseconds.
     *
     * The value must be a number greater than or equal to 1, or `NaN`.
     * Setting this property does not raise any events.
     */
    get duration(): number; */
  // Type InteropStaticType.number
  set duration(_i2.num value) {
    _i5.setProperty(
      this,
      'duration',
      value,
    );
  }

  /* #9288
  source: 
    /**
     * Gets or sets whether this Animation will repeat its animation in reverse at the end of the duration. Default false.
     *
     * A reversible Animation, if stopped early, will end at its original state.
     * Setting this to true doubles the effective #duration of the Animation.
     *
     * This property should not be set on the AnimationManager#defaultAnimation
     */
    get reversible(): boolean; */
  /// Gets or sets whether this Animation will repeat its animation in reverse at the end of the duration. Default false.
  ///
  /// A reversible Animation, if stopped early, will end at its original state.
  /// Setting this to true doubles the effective #duration of the Animation.
  ///
  /// This property should not be set on the AnimationManager#defaultAnimation
  _i2.bool get reversible => _i5.getProperty(
        this,
        'reversible',
      );
  /* #9288
  source: 
    /**
     * Gets or sets whether this Animation will repeat its animation in reverse at the end of the duration. Default false.
     *
     * A reversible Animation, if stopped early, will end at its original state.
     * Setting this to true doubles the effective #duration of the Animation.
     *
     * This property should not be set on the AnimationManager#defaultAnimation
     */
    get reversible(): boolean; */
  // Type InteropStaticType.boolean
  set reversible(_i2.bool value) {
    _i5.setProperty(
      this,
      'reversible',
      value,
    );
  }

  /* #9299
  source: 
    /**
     * Gets or sets whether this Animation should be repeat, and how many times. The default is 1, which means the animation does not repeat.
     *
     * This can be set to any non-zero positive integer, or `Infinity`. Setting this to `Infinity` will repeat an animation forever.
     *
     * This property should not be set on the AnimationManager#defaultAnimation
     *
     * @see #reversible
     */
    get runCount(): number; */
  /// Gets or sets whether this Animation should be repeat, and how many times. The default is 1, which means the animation does not repeat.
  ///
  /// This can be set to any non-zero positive integer, or `Infinity`. Setting this to `Infinity` will repeat an animation forever.
  ///
  /// This property should not be set on the AnimationManager#defaultAnimation
  _i2.num get runCount => _i5.getProperty(
        this,
        'runCount',
      );
  /* #9299
  source: 
    /**
     * Gets or sets whether this Animation should be repeat, and how many times. The default is 1, which means the animation does not repeat.
     *
     * This can be set to any non-zero positive integer, or `Infinity`. Setting this to `Infinity` will repeat an animation forever.
     *
     * This property should not be set on the AnimationManager#defaultAnimation
     *
     * @see #reversible
     */
    get runCount(): number; */
  // Type InteropStaticType.number
  set runCount(_i2.num value) {
    _i5.setProperty(
      this,
      'runCount',
      value,
    );
  }

  /* #9306
  source: 
    /**
     * Gets or sets the function to execute when the user Animation finishes.
     *
     * By default this property is null.
     */
    get finished(): ((animation: Animation) => void) | null; */
  /// Gets or sets the function to execute when the user Animation finishes.
  ///
  /// By default this property is null.
  void Function(_i3.Animation)? get finished => _i5.getProperty(
        this,
        'finished',
      );
  /* #9306
  source: 
    /**
     * Gets or sets the function to execute when the user Animation finishes.
     *
     * By default this property is null.
     */
    get finished(): ((animation: Animation) => void) | null; */
  // Type InteropUnion#1064114134(parent: InteropGetter#696990762(name: finished))
  set finished(void Function(_i3.Animation)? value) {
    _i5.setProperty(
      this,
      'finished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #9321
  source: 
    /**
     * Gets or sets the easing function this Animation will use to modify default properties.
     *
     * Pre-defined animatable values are processed by passing scalars into this easing function.
     *
     * The default value is Animation.EaseInOutQuad.
     *
     *
     * The value can be an arbitrary easing function, or one of the six provided:
     * Animation.EaseLinear, Animation.EaseInOutQuad, Animation.EaseInQuad,
     * Animation.EaseOutQuad, Animation.EaseInExpo, Animation.EaseOutExpo.
     *
     */
    get easing(): EasingFunction; */
  /// Gets or sets the easing function this Animation will use to modify default properties.
  ///
  /// Pre-defined animatable values are processed by passing scalars into this easing function.
  ///
  /// The default value is Animation.EaseInOutQuad.
  ///
  ///
  /// The value can be an arbitrary easing function, or one of the six provided:
  /// Animation.EaseLinear, Animation.EaseInOutQuad, Animation.EaseInQuad,
  /// Animation.EaseOutQuad, Animation.EaseInExpo, Animation.EaseOutExpo.
  _i3.EasingFunction get easing => _i5.getProperty(
        this,
        'easing',
      );
  /* #9321
  source: 
    /**
     * Gets or sets the easing function this Animation will use to modify default properties.
     *
     * Pre-defined animatable values are processed by passing scalars into this easing function.
     *
     * The default value is Animation.EaseInOutQuad.
     *
     *
     * The value can be an arbitrary easing function, or one of the six provided:
     * Animation.EaseLinear, Animation.EaseInOutQuad, Animation.EaseInQuad,
     * Animation.EaseOutQuad, Animation.EaseInExpo, Animation.EaseOutExpo.
     *
     */
    get easing(): EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  set easing(_i3.EasingFunction value) {
    _i5.setProperty(
      this,
      'easing',
      _i5.allowInterop(value),
    );
  }

  /* #9331
  source: 
    /**
     * Gets or sets whether this Animation should allow an unconstrained viewport during the runtime of the animation.
     * This temporarily sets the Diagram#scrollMode to Diagram.InfiniteScroll, and restores the value at the end of the animation.
     * This is done so that animating objects can move out of the viewport temporarily during the animation and not trigger scrollbars.
     *
     * This may be useful to set for animations that have objects or the Diagram bounds animate from outside the viewport into the view.
     * The default value is true.
     */
    get isViewportUnconstrained(): boolean; */
  /// Gets or sets whether this Animation should allow an unconstrained viewport during the runtime of the animation.
  /// This temporarily sets the Diagram#scrollMode to Diagram.InfiniteScroll, and restores the value at the end of the animation.
  /// This is done so that animating objects can move out of the viewport temporarily during the animation and not trigger scrollbars.
  ///
  /// This may be useful to set for animations that have objects or the Diagram bounds animate from outside the viewport into the view.
  /// The default value is true.
  _i2.bool get isViewportUnconstrained => _i5.getProperty(
        this,
        'isViewportUnconstrained',
      );
  /* #9331
  source: 
    /**
     * Gets or sets whether this Animation should allow an unconstrained viewport during the runtime of the animation.
     * This temporarily sets the Diagram#scrollMode to Diagram.InfiniteScroll, and restores the value at the end of the animation.
     * This is done so that animating objects can move out of the viewport temporarily during the animation and not trigger scrollbars.
     *
     * This may be useful to set for animations that have objects or the Diagram bounds animate from outside the viewport into the view.
     * The default value is true.
     */
    get isViewportUnconstrained(): boolean; */
  // Type InteropStaticType.boolean
  set isViewportUnconstrained(_i2.bool value) {
    _i5.setProperty(
      this,
      'isViewportUnconstrained',
      value,
    );
  }

  /* #9338
  source: 
    /**
     * This read-only property is true when the Animation is currently running.
     *
     * This value cannot be set, but Animation can be stopped by calling #stop.
     */
    get isAnimating(): boolean; */
  /// This read-only property is true when the Animation is currently running.
  ///
  /// This value cannot be set, but Animation can be stopped by calling #stop.
  _i2.bool get isAnimating => _i5.getProperty(
        this,
        'isAnimating',
      );
  /* #9338
  source: 
    /**
     * This read-only property is true when the Animation is currently running.
     *
     * This value cannot be set, but Animation can be stopped by calling #stop.
     */
    get isAnimating(): boolean; */
  // Type InteropStaticType.boolean
  set isAnimating(_i2.bool value) {
    _i5.setProperty(
      this,
      'isAnimating',
      value,
    );
  }

  void suspend() {
    _i5.callMethod(
      this,
      'suspend',
      [],
    );
  }

  void advanceTo(
    _i2.num duration, [
    _i2.bool? resume,
  ]) {
    _i5.callMethod(
      this,
      'advanceTo',
      [
        duration,
        resume ?? _i4.undefined,
      ],
    );
  }

  _i3.Animation start() => _i5.callMethod(
        this,
        'start',
        [],
      );
  _i3.Animation addTemporaryPart(
    _i3.Part part,
    _i3.Diagram diagram,
  ) =>
      _i5.callMethod(
        this,
        'addTemporaryPart',
        [
          part,
          diagram,
        ],
      );
  _i3.Animation add(
    _i2.Object obj,
    _i2.String effectName,
    _i2.dynamic startValue,
    _i2.dynamic endValue, [
    _i2.bool? cosmetic,
  ]) =>
      _i5.callMethod(
        this,
        'add',
        [
          obj,
          effectName,
          startValue,
          endValue,
          cosmetic ?? _i4.undefined,
        ],
      );
  _i3.Animation stop() => _i5.callMethod(
        this,
        'stop',
        [],
      );
  _i2.Object getTemporaryState(_i2.Object obj) => _i5.callMethod(
        this,
        'getTemporaryState',
        [obj],
      );
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline0 {}

extension IInline0$Typings on IInline0 {
  /* #9466
  source: 
        duration?: number; */
  _i2.num? get duration => _i5.getProperty(
        this,
        'duration',
      );
  /* #9466
  source: 
        duration?: number; */
  // Type InteropStaticType.number
  set duration(_i2.num? value) {
    _i5.setProperty(
      this,
      'duration',
      value ?? _i4.undefined,
    );
  }

  /* #9467
  source: 
        finished?: (animation: Animation) => void; */
  void Function(_i3.Animation)? get finished => _i5.getProperty(
        this,
        'finished',
      );
  /* #9467
  source: 
        finished?: (animation: Animation) => void; */
  // Type InteropFunction#306222342(parent: InteropGetter#1038399110(name: finished), library: go.d.ts)
  set finished(void Function(_i3.Animation)? value) {
    _i5.setProperty(
      this,
      'finished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #9468
  source: 
        easing?: EasingFunction; */
  _i3.EasingFunction? get easing => _i5.getProperty(
        this,
        'easing',
      );
  /* #9468
  source: 
        easing?: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  set easing(_i3.EasingFunction? value) {
    _i5.setProperty(
      this,
      'easing',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline1 {}

extension IInline1$Typings on IInline1 {
  /* #9522
  source: 
        duration?: number; */
  _i2.num? get duration => _i5.getProperty(
        this,
        'duration',
      );
  /* #9522
  source: 
        duration?: number; */
  // Type InteropStaticType.number
  set duration(_i2.num? value) {
    _i5.setProperty(
      this,
      'duration',
      value ?? _i4.undefined,
    );
  }

  /* #9523
  source: 
        finished?: (animation: Animation) => void; */
  void Function(_i3.Animation)? get finished => _i5.getProperty(
        this,
        'finished',
      );
  /* #9523
  source: 
        finished?: (animation: Animation) => void; */
  // Type InteropFunction#315741981(parent: InteropGetter#964216115(name: finished), library: go.d.ts)
  set finished(void Function(_i3.Animation)? value) {
    _i5.setProperty(
      this,
      'finished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #9524
  source: 
        easing?: EasingFunction; */
  _i3.EasingFunction? get easing => _i5.getProperty(
        this,
        'easing',
      );
  /* #9524
  source: 
        easing?: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  set easing(_i3.EasingFunction? value) {
    _i5.setProperty(
      this,
      'easing',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline2 {}

extension IInline2$Typings on IInline2 {
  /* #9527
  source: 
        duration?: number; */
  _i2.num? get duration => _i5.getProperty(
        this,
        'duration',
      );
  /* #9527
  source: 
        duration?: number; */
  // Type InteropStaticType.number
  set duration(_i2.num? value) {
    _i5.setProperty(
      this,
      'duration',
      value ?? _i4.undefined,
    );
  }

  /* #9528
  source: 
        finished?: (animation: Animation) => void; */
  void Function(_i3.Animation)? get finished => _i5.getProperty(
        this,
        'finished',
      );
  /* #9528
  source: 
        finished?: (animation: Animation) => void; */
  // Type InteropFunction#743371077(parent: InteropGetter#194111974(name: finished), library: go.d.ts)
  set finished(void Function(_i3.Animation)? value) {
    _i5.setProperty(
      this,
      'finished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #9529
  source: 
        easing?: EasingFunction; */
  _i3.EasingFunction? get easing => _i5.getProperty(
        this,
        'easing',
      );
  /* #9529
  source: 
        easing?: EasingFunction; */
  // Type InteropTypedef#314510757(name: EasingFunction)
  set easing(_i3.EasingFunction? value) {
    _i5.setProperty(
      this,
      'easing',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class AnimationTrigger {
  factory AnimationTrigger(
    _i2.String propertyName, [
    _i3.IInline0? animationSettings,
    _i3.EnumValue? startCondition,
  ]) =>
      _i5.callConstructor(
        _declaredAnimationTrigger,
        [
          propertyName,
          animationSettings ?? _i4.undefined,
          startCondition ?? _i4.undefined,
        ],
      );

  /* #9558
  source: 
    /**
     * Used as a value for #startCondition.
     * GoJS will attempt to AnimationTrigger.Bundled or AnimationTrigger.Immediate based on the state of the transaction.
     * If no transaction is ongoing, this trigger will be treated as using AnimationTrigger.Immediate,
     * otherwise it will work as AnimationTrigger.Bundled.
     * @constant
     */
    static Default: EnumValue; */
  /// Used as a value for #startCondition.
  /// GoJS will attempt to AnimationTrigger.Bundled or AnimationTrigger.Immediate based on the state of the transaction.
  /// If no transaction is ongoing, this trigger will be treated as using AnimationTrigger.Immediate,
  /// otherwise it will work as AnimationTrigger.Bundled.
  static _i3.EnumValue get default$ => _i5.getProperty(
        _declaredAnimationTrigger,
        'Default',
      );
  /* #9558
  source: 
    /**
     * Used as a value for #startCondition.
     * GoJS will attempt to AnimationTrigger.Bundled or AnimationTrigger.Immediate based on the state of the transaction.
     * If no transaction is ongoing, this trigger will be treated as using AnimationTrigger.Immediate,
     * otherwise it will work as AnimationTrigger.Bundled.
     * @constant
     */
    static Default: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set default$(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationTrigger,
      'Default',
      value,
    );
  }

  /* #9567
  source: 
    /**
     * Used as a value for #startCondition.
     * A new animation will be created for every instance of the property changed, and started immediately,
     * and run until completion. This may be useful for cosmetic changes, such as animating
     * the opacity or color of an object on mouseEnter or mouseLeave.
     * However, using AnimationTrigger.Bundled may be more efficient, as it will create fewer
     * @constant
     */
    static Immediate: EnumValue; */
  /// Used as a value for #startCondition.
  /// A new animation will be created for every instance of the property changed, and started immediately,
  /// and run until completion. This may be useful for cosmetic changes, such as animating
  /// the opacity or color of an object on mouseEnter or mouseLeave.
  /// However, using AnimationTrigger.Bundled may be more efficient, as it will create fewer
  static _i3.EnumValue get immediate => _i5.getProperty(
        _declaredAnimationTrigger,
        'Immediate',
      );
  /* #9567
  source: 
    /**
     * Used as a value for #startCondition.
     * A new animation will be created for every instance of the property changed, and started immediately,
     * and run until completion. This may be useful for cosmetic changes, such as animating
     * the opacity or color of an object on mouseEnter or mouseLeave.
     * However, using AnimationTrigger.Bundled may be more efficient, as it will create fewer
     * @constant
     */
    static Immediate: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set immediate(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationTrigger,
      'Immediate',
      value,
    );
  }

  /* #9574
  source: 
    /**
     * Used as a value for #startCondition.
     * The AnimationManager will use the default animation to prepare a single Animation that begins when the current transaction has ended.
     * This animation may be canceled if a new transaction is started.
     * @constant
     */
    static Bundled: EnumValue; */
  /// Used as a value for #startCondition.
  /// The AnimationManager will use the default animation to prepare a single Animation that begins when the current transaction has ended.
  /// This animation may be canceled if a new transaction is started.
  static _i3.EnumValue get bundled => _i5.getProperty(
        _declaredAnimationTrigger,
        'Bundled',
      );
  /* #9574
  source: 
    /**
     * Used as a value for #startCondition.
     * The AnimationManager will use the default animation to prepare a single Animation that begins when the current transaction has ended.
     * This animation may be canceled if a new transaction is started.
     * @constant
     */
    static Bundled: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set bundled(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredAnimationTrigger,
      'Bundled',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('AnimationTrigger')
external _i2.Object _declaredAnimationTrigger;

extension AnimationTrigger$Typings on AnimationTrigger {
  /* #9499
  source: 
    /**
     * Gets or sets the name of the property to animate on the target GraphObject.
     * The default value is set during constructor initialization.
     *
     * You can only specify properties that exist on the GraphObject, and are also registered with AnimationManager.defineAnimationEffect.
     * By default these properties are the same as the list of possible Animation effects:
     *
     * * `"position"`
     * * `"location"` (on Parts)
     * * `"scale"`
     * * `"opacity"`
     * * `"angle"`
     * * `"desiredSize"`
     * * `"width"`
     * * `"height"`
     * * `"background"`
     * * `"fill"` (on Shapes)
     * * `"strokeWidth"` (on Shapes)
     * * `"strokeDashOffset"` (on Shapes)
     * * `"stroke"` (on Shapes, TextBlocks)
     *
     * Examples of defining additional properties by adding animation effects are given in the <a href="../../intro/animation.html">Introduction Page on Animations</a>.
     */
    get propertyName(): string; */
  /// Gets or sets the name of the property to animate on the target GraphObject.
  /// The default value is set during constructor initialization.
  ///
  /// You can only specify properties that exist on the GraphObject, and are also registered with AnimationManager.defineAnimationEffect.
  /// By default these properties are the same as the list of possible Animation effects:
  ///
  /// * `"position"`
  /// * `"location"` (on Parts)
  /// * `"scale"`
  /// * `"opacity"`
  /// * `"angle"`
  /// * `"desiredSize"`
  /// * `"width"`
  /// * `"height"`
  /// * `"background"`
  /// * `"fill"` (on Shapes)
  /// * `"strokeWidth"` (on Shapes)
  /// * `"strokeDashOffset"` (on Shapes)
  /// * `"stroke"` (on Shapes, TextBlocks)
  ///
  /// Examples of defining additional properties by adding animation effects are given in the <a href="../../intro/animation.html">Introduction Page on Animations</a>.
  _i2.String get propertyName => _i5.getProperty(
        this,
        'propertyName',
      );
  /* #9499
  source: 
    /**
     * Gets or sets the name of the property to animate on the target GraphObject.
     * The default value is set during constructor initialization.
     *
     * You can only specify properties that exist on the GraphObject, and are also registered with AnimationManager.defineAnimationEffect.
     * By default these properties are the same as the list of possible Animation effects:
     *
     * * `"position"`
     * * `"location"` (on Parts)
     * * `"scale"`
     * * `"opacity"`
     * * `"angle"`
     * * `"desiredSize"`
     * * `"width"`
     * * `"height"`
     * * `"background"`
     * * `"fill"` (on Shapes)
     * * `"strokeWidth"` (on Shapes)
     * * `"strokeDashOffset"` (on Shapes)
     * * `"stroke"` (on Shapes, TextBlocks)
     *
     * Examples of defining additional properties by adding animation effects are given in the <a href="../../intro/animation.html">Introduction Page on Animations</a>.
     */
    get propertyName(): string; */
  // Type InteropStaticType.string
  set propertyName(_i2.String value) {
    _i5.setProperty(
      this,
      'propertyName',
      value,
    );
  }

  /* #9521
  source: 
    /**
     * These settings are only used if the #startCondition is AnimationTrigger.Immediate.
     * Creating a new AnimationTrigger with animationSettings in the constructor automatically sets #startCondition to AnimationTrigger.Immediate
     *
     * This gets or sets the settings for any Animations this trigger creates.
     * Immediate triggers create a new Animation with each triggering, and apply these settings to that Animation.
     *
     * This can be set to an object with a subset of possible Animation settings. The default value is `null`, which keeps default Animation settings.
     *
     * Since a #startCondition of AnimationTrigger.Bundled uses the default animation,
     * you must set the properties of AnimationManager#defaultAnimation, and not this property, to modify the animation settings.
     *
     * To set default settings for *all* created Animations, you can modify the settings on AnimationManager instead, such as AnimationManager#duration.
     *
     * Possible properties to set in this object are:
     *
     * * **duration**: a `number`, corresponding to Animation#duration.
     * * **finished**: a `Function`, corresponding to Animation#finished.
     * * **easing**: an `EasingFunction`, corresponding to Animation#easing.
     */
    get animationSettings(): {
        duration?: number;
        finished?: (animation: Animation) => void;
        easing?: EasingFunction;
    }; */
  /// These settings are only used if the #startCondition is AnimationTrigger.Immediate.
  /// Creating a new AnimationTrigger with animationSettings in the constructor automatically sets #startCondition to AnimationTrigger.Immediate
  ///
  /// This gets or sets the settings for any Animations this trigger creates.
  /// Immediate triggers create a new Animation with each triggering, and apply these settings to that Animation.
  ///
  /// This can be set to an object with a subset of possible Animation settings. The default value is `null`, which keeps default Animation settings.
  ///
  /// Since a #startCondition of AnimationTrigger.Bundled uses the default animation,
  /// you must set the properties of AnimationManager#defaultAnimation, and not this property, to modify the animation settings.
  ///
  /// To set default settings for *all* created Animations, you can modify the settings on AnimationManager instead, such as AnimationManager#duration.
  ///
  /// Possible properties to set in this object are:
  ///
  /// * **duration**: a `number`, corresponding to Animation#duration.
  /// * **finished**: a `Function`, corresponding to Animation#finished.
  /// * **easing**: an `EasingFunction`, corresponding to Animation#easing.
  _i3.IInline1 get animationSettings => _i5.getProperty(
        this,
        'animationSettings',
      );
  /* #9521
  source: 
    /**
     * These settings are only used if the #startCondition is AnimationTrigger.Immediate.
     * Creating a new AnimationTrigger with animationSettings in the constructor automatically sets #startCondition to AnimationTrigger.Immediate
     *
     * This gets or sets the settings for any Animations this trigger creates.
     * Immediate triggers create a new Animation with each triggering, and apply these settings to that Animation.
     *
     * This can be set to an object with a subset of possible Animation settings. The default value is `null`, which keeps default Animation settings.
     *
     * Since a #startCondition of AnimationTrigger.Bundled uses the default animation,
     * you must set the properties of AnimationManager#defaultAnimation, and not this property, to modify the animation settings.
     *
     * To set default settings for *all* created Animations, you can modify the settings on AnimationManager instead, such as AnimationManager#duration.
     *
     * Possible properties to set in this object are:
     *
     * * **duration**: a `number`, corresponding to Animation#duration.
     * * **finished**: a `Function`, corresponding to Animation#finished.
     * * **easing**: an `EasingFunction`, corresponding to Animation#easing.
     */
    get animationSettings(): {
        duration?: number;
        finished?: (animation: Animation) => void;
        easing?: EasingFunction;
    }; */
  // Type Instance of 'InteropInterface'
  set animationSettings(_i3.IInline1 value) {
    _i5.setProperty(
      this,
      'animationSettings',
      value,
    );
  }

  /* #9549
  source: 
    /**
     * Gets or sets the starting condition for this trigger.
     *
     * AnimationTriggers can invoke an animation immediately,
     * starting a new animation with each property of each GraphObject that has been modified,
     * or they can (more efficiently) be bundled together into the default animation (AnimationManager#defaultAnimation)
     * and begin only one animation, at the end of the next transaction.
     *
     * It is useful for the startCondition to be AnimationTrigger.Immediate when changing GraphObject properties
     * on GraphObject#mouseEnter or GraphObject#mouseLeave.
     * It is useful for the startCondition  to be AnimationTrigger.Bundled when changing several GraphObject properties together,
     * such as when highlighting multiple parts, on selection changes, and during transactions, or when performance is a consideration.
     *
     * These behaviors can be set with the values AnimationTrigger.Immediate and AnimationTrigger.Bundled, respectively.
     * The default value, AnimationTrigger.Default, attempts to infer which is best:
     * It will start immediately if there is no ongoing transaction
     * or if Diagram#skipsUndoManager is true, and otherwise bundle them.
     */
    get startCondition(): EnumValue; */
  /// Gets or sets the starting condition for this trigger.
  ///
  /// AnimationTriggers can invoke an animation immediately,
  /// starting a new animation with each property of each GraphObject that has been modified,
  /// or they can (more efficiently) be bundled together into the default animation (AnimationManager#defaultAnimation)
  /// and begin only one animation, at the end of the next transaction.
  ///
  /// It is useful for the startCondition to be AnimationTrigger.Immediate when changing GraphObject properties
  /// on GraphObject#mouseEnter or GraphObject#mouseLeave.
  /// It is useful for the startCondition  to be AnimationTrigger.Bundled when changing several GraphObject properties together,
  /// such as when highlighting multiple parts, on selection changes, and during transactions, or when performance is a consideration.
  ///
  /// These behaviors can be set with the values AnimationTrigger.Immediate and AnimationTrigger.Bundled, respectively.
  /// The default value, AnimationTrigger.Default, attempts to infer which is best:
  /// It will start immediately if there is no ongoing transaction
  /// or if Diagram#skipsUndoManager is true, and otherwise bundle them.
  _i3.EnumValue get startCondition => _i5.getProperty(
        this,
        'startCondition',
      );
  /* #9549
  source: 
    /**
     * Gets or sets the starting condition for this trigger.
     *
     * AnimationTriggers can invoke an animation immediately,
     * starting a new animation with each property of each GraphObject that has been modified,
     * or they can (more efficiently) be bundled together into the default animation (AnimationManager#defaultAnimation)
     * and begin only one animation, at the end of the next transaction.
     *
     * It is useful for the startCondition to be AnimationTrigger.Immediate when changing GraphObject properties
     * on GraphObject#mouseEnter or GraphObject#mouseLeave.
     * It is useful for the startCondition  to be AnimationTrigger.Bundled when changing several GraphObject properties together,
     * such as when highlighting multiple parts, on selection changes, and during transactions, or when performance is a consideration.
     *
     * These behaviors can be set with the values AnimationTrigger.Immediate and AnimationTrigger.Bundled, respectively.
     * The default value, AnimationTrigger.Default, attempts to infer which is best:
     * It will start immediately if there is no ongoing transaction
     * or if Diagram#skipsUndoManager is true, and otherwise bundle them.
     */
    get startCondition(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set startCondition(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'startCondition',
      value,
    );
  }

  _i3.AnimationTrigger copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Layer {
  factory Layer([_i4.Partial? init]) => _i5.callConstructor(
        _declaredLayer,
        [init ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Layer')
external _i2.Object _declaredLayer;

extension Layer$Typings on Layer {
  /* #9693
  source: 
    /**
     * This read-only property returns an iterator for this Layer's Parts.
     * The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
     */
    get parts(): Iterator<Part>; */
  /// This read-only property returns an iterator for this Layer's Parts.
  /// The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
  _i3.Iterator<_i3.Part> get parts => _i5.getProperty(
        this,
        'parts',
      );
  /* #9693
  source: 
    /**
     * This read-only property returns an iterator for this Layer's Parts.
     * The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
     */
    get parts(): Iterator<Part>; */
  // Type Instance of 'InteropInterface'
  set parts(_i3.Iterator<_i3.Part> value) {
    _i5.setProperty(
      this,
      'parts',
      value,
    );
  }

  /* #9699
  source: 
    /**
     * This read-only property returns a backwards iterator for this Layer's Parts,
     * for iterating over the parts in reverse order.
     * The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
     */
    get partsBackwards(): Iterator<Part>; */
  /// This read-only property returns a backwards iterator for this Layer's Parts,
  /// for iterating over the parts in reverse order.
  /// The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
  _i3.Iterator<_i3.Part> get partsBackwards => _i5.getProperty(
        this,
        'partsBackwards',
      );
  /* #9699
  source: 
    /**
     * This read-only property returns a backwards iterator for this Layer's Parts,
     * for iterating over the parts in reverse order.
     * The Parts can be Nodes, Links, Groups, Adornments, or simple Parts.
     */
    get partsBackwards(): Iterator<Part>; */
  // Type Instance of 'InteropInterface'
  set partsBackwards(_i3.Iterator<_i3.Part> value) {
    _i5.setProperty(
      this,
      'partsBackwards',
      value,
    );
  }

  /* #9703
  source: 
    /**
     * This read-only property returns the Diagram that is using this Layer.
     */
    get diagram(): Diagram | null; */
  /// This read-only property returns the Diagram that is using this Layer.
  _i3.Diagram? get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #9703
  source: 
    /**
     * This read-only property returns the Diagram that is using this Layer.
     */
    get diagram(): Diagram | null; */
  // Type InteropUnion#635463400(parent: InteropGetter#374500531(name: diagram))
  set diagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'diagram',
      value ?? _i4.undefined,
    );
  }

  /* #9709
  source: 
    /**
     * Gets or sets the name for this layer.
     * The initial value is an empty string, which is also the name of the default layer.
     * The name should be unique among the diagram's Diagram#layers.
     */
    get name(): string; */
  /// Gets or sets the name for this layer.
  /// The initial value is an empty string, which is also the name of the default layer.
  /// The name should be unique among the diagram's Diagram#layers.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #9709
  source: 
    /**
     * Gets or sets the name for this layer.
     * The initial value is an empty string, which is also the name of the default layer.
     * The name should be unique among the diagram's Diagram#layers.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #9723
  source: 
    /**
     * Gets or sets the opacity for all parts in this layer.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     * This value is multiplicative with any existing transparency,
     * for instance from a Brush or image transparency.
     * The default value is 1.
     *
     * This property, unlike #visible, does not change whether any objects are found by the "find..." methods.
     * @since 1.1
     * @see GraphObject#opacity
     * @see Diagram#opacity
     */
    get opacity(): number; */
  /// Gets or sets the opacity for all parts in this layer.
  /// The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
  /// This value is multiplicative with any existing transparency,
  /// for instance from a Brush or image transparency.
  /// The default value is 1.
  ///
  /// This property, unlike #visible, does not change whether any objects are found by the "find..." methods.
  _i2.num get opacity => _i5.getProperty(
        this,
        'opacity',
      );
  /* #9723
  source: 
    /**
     * Gets or sets the opacity for all parts in this layer.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     * This value is multiplicative with any existing transparency,
     * for instance from a Brush or image transparency.
     * The default value is 1.
     *
     * This property, unlike #visible, does not change whether any objects are found by the "find..." methods.
     * @since 1.1
     * @see GraphObject#opacity
     * @see Diagram#opacity
     */
    get opacity(): number; */
  // Type InteropStaticType.number
  set opacity(_i2.num value) {
    _i5.setProperty(
      this,
      'opacity',
      value,
    );
  }

  /* #9742
  source: 
    /**
     * Gets or sets whether the objects in this layer are considered temporary.
     *
     * Parts in temporary layers are not selectable,
     * and changes to Parts in temporary layers are not recorded in the UndoManager.
     * Objects in temporary layers do not receive click events unless you set their GraphObject#isActionable to true.
     *
     * Temporary layers are excluded from bounds calculations, with the exception of the "Tool" layer,
     * so that temporary objects created while dragging are included in the bounds.
     *
     * Default value is false.
     *
     * When this is set to true, #isInDocumentBounds on this layer is set to false.
     * You can override this behavior by setting #isInDocumentBounds after setting this property.
     *
     * @see #isInDocumentBounds
     */
    get isTemporary(): boolean; */
  /// Gets or sets whether the objects in this layer are considered temporary.
  ///
  /// Parts in temporary layers are not selectable,
  /// and changes to Parts in temporary layers are not recorded in the UndoManager.
  /// Objects in temporary layers do not receive click events unless you set their GraphObject#isActionable to true.
  ///
  /// Temporary layers are excluded from bounds calculations, with the exception of the "Tool" layer,
  /// so that temporary objects created while dragging are included in the bounds.
  ///
  /// Default value is false.
  ///
  /// When this is set to true, #isInDocumentBounds on this layer is set to false.
  /// You can override this behavior by setting #isInDocumentBounds after setting this property.
  _i2.bool get isTemporary => _i5.getProperty(
        this,
        'isTemporary',
      );
  /* #9742
  source: 
    /**
     * Gets or sets whether the objects in this layer are considered temporary.
     *
     * Parts in temporary layers are not selectable,
     * and changes to Parts in temporary layers are not recorded in the UndoManager.
     * Objects in temporary layers do not receive click events unless you set their GraphObject#isActionable to true.
     *
     * Temporary layers are excluded from bounds calculations, with the exception of the "Tool" layer,
     * so that temporary objects created while dragging are included in the bounds.
     *
     * Default value is false.
     *
     * When this is set to true, #isInDocumentBounds on this layer is set to false.
     * You can override this behavior by setting #isInDocumentBounds after setting this property.
     *
     * @see #isInDocumentBounds
     */
    get isTemporary(): boolean; */
  // Type InteropStaticType.boolean
  set isTemporary(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTemporary',
      value,
    );
  }

  /* #9751
  source: 
    /**
     * Gets or sets whether the user may view any of the objects in this layer.
     *
     * The default value is true -- all visible Parts are drawn.
     * When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
     * @see GraphObject#visible
     */
    get visible(): boolean; */
  /// Gets or sets whether the user may view any of the objects in this layer.
  ///
  /// The default value is true -- all visible Parts are drawn.
  /// When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
  _i2.bool get visible => _i5.getProperty(
        this,
        'visible',
      );
  /* #9751
  source: 
    /**
     * Gets or sets whether the user may view any of the objects in this layer.
     *
     * The default value is true -- all visible Parts are drawn.
     * When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
     * @see GraphObject#visible
     */
    get visible(): boolean; */
  // Type InteropStaticType.boolean
  set visible(_i2.bool value) {
    _i5.setProperty(
      this,
      'visible',
      value,
    );
  }

  /* #9768
  source: 
    /**
     * Gets or sets whether methods such as #findObjectAt find any of the objects in this layer.
     *
     * The default value is true.
     * When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
     *
     * Note that setting pickable to false does not prevent users from selecting nodes.
     * It does prevent them from selecting nodes by clicking on them,
     * but does not prevent selection through other mechanisms such as the DragSelectingTool or
     * CommandHandler#selectAll or calls to Diagram#select.
     *
     * You can control whether individual GraphObjects are "hittable" by setting GraphObject#pickable.
     * @since 1.2
     * @see GraphObject#pickable
     */
    get pickable(): boolean; */
  /// Gets or sets whether methods such as #findObjectAt find any of the objects in this layer.
  ///
  /// The default value is true.
  /// When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
  ///
  /// Note that setting pickable to false does not prevent users from selecting nodes.
  /// It does prevent them from selecting nodes by clicking on them,
  /// but does not prevent selection through other mechanisms such as the DragSelectingTool or
  /// CommandHandler#selectAll or calls to Diagram#select.
  ///
  /// You can control whether individual GraphObjects are "hittable" by setting GraphObject#pickable.
  _i2.bool get pickable => _i5.getProperty(
        this,
        'pickable',
      );
  /* #9768
  source: 
    /**
     * Gets or sets whether methods such as #findObjectAt find any of the objects in this layer.
     *
     * The default value is true.
     * When this property is false, all of the "find..." methods will fail to find parts that are in this layer.
     *
     * Note that setting pickable to false does not prevent users from selecting nodes.
     * It does prevent them from selecting nodes by clicking on them,
     * but does not prevent selection through other mechanisms such as the DragSelectingTool or
     * CommandHandler#selectAll or calls to Diagram#select.
     *
     * You can control whether individual GraphObjects are "hittable" by setting GraphObject#pickable.
     * @since 1.2
     * @see GraphObject#pickable
     */
    get pickable(): boolean; */
  // Type InteropStaticType.boolean
  set pickable(_i2.bool value) {
    _i5.setProperty(
      this,
      'pickable',
      value,
    );
  }

  /* #9776
  source: 
    /**
     * Gets or sets whether or not a layer is included in the documentBounds computation.
     * Default value is `true`. However, setting #isTemporary to `true` also sets this property to `false` before version 3.
     * @since 2.2
     * @see #isTemporary
     */
    get isInDocumentBounds(): boolean; */
  /// Gets or sets whether or not a layer is included in the documentBounds computation.
  /// Default value is `true`. However, setting #isTemporary to `true` also sets this property to `false` before version 3.
  _i2.bool get isInDocumentBounds => _i5.getProperty(
        this,
        'isInDocumentBounds',
      );
  /* #9776
  source: 
    /**
     * Gets or sets whether or not a layer is included in the documentBounds computation.
     * Default value is `true`. However, setting #isTemporary to `true` also sets this property to `false` before version 3.
     * @since 2.2
     * @see #isTemporary
     */
    get isInDocumentBounds(): boolean; */
  // Type InteropStaticType.boolean
  set isInDocumentBounds(_i2.bool value) {
    _i5.setProperty(
      this,
      'isInDocumentBounds',
      value,
    );
  }

  /* #9782
  source: 
    /**
     * Gets or sets whether the user may copy objects in this layer.
     * The initial value is true.
     */
    get allowCopy(): boolean; */
  /// Gets or sets whether the user may copy objects in this layer.
  /// The initial value is true.
  _i2.bool get allowCopy => _i5.getProperty(
        this,
        'allowCopy',
      );
  /* #9782
  source: 
    /**
     * Gets or sets whether the user may copy objects in this layer.
     * The initial value is true.
     */
    get allowCopy(): boolean; */
  // Type InteropStaticType.boolean
  set allowCopy(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowCopy',
      value,
    );
  }

  /* #9788
  source: 
    /**
     * Gets or sets whether the user may delete objects in this layer.
     * The initial value is true.
     */
    get allowDelete(): boolean; */
  /// Gets or sets whether the user may delete objects in this layer.
  /// The initial value is true.
  _i2.bool get allowDelete => _i5.getProperty(
        this,
        'allowDelete',
      );
  /* #9788
  source: 
    /**
     * Gets or sets whether the user may delete objects in this layer.
     * The initial value is true.
     */
    get allowDelete(): boolean; */
  // Type InteropStaticType.boolean
  set allowDelete(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowDelete',
      value,
    );
  }

  /* #9794
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing in this layer.
     * The initial value is true.
     */
    get allowTextEdit(): boolean; */
  /// Gets or sets whether the user may do in-place text editing in this layer.
  /// The initial value is true.
  _i2.bool get allowTextEdit => _i5.getProperty(
        this,
        'allowTextEdit',
      );
  /* #9794
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing in this layer.
     * The initial value is true.
     */
    get allowTextEdit(): boolean; */
  // Type InteropStaticType.boolean
  set allowTextEdit(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowTextEdit',
      value,
    );
  }

  /* #9800
  source: 
    /**
     * Gets or sets whether the user may group parts together in this layer.
     * The initial value is true.
     */
    get allowGroup(): boolean; */
  /// Gets or sets whether the user may group parts together in this layer.
  /// The initial value is true.
  _i2.bool get allowGroup => _i5.getProperty(
        this,
        'allowGroup',
      );
  /* #9800
  source: 
    /**
     * Gets or sets whether the user may group parts together in this layer.
     * The initial value is true.
     */
    get allowGroup(): boolean; */
  // Type InteropStaticType.boolean
  set allowGroup(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowGroup',
      value,
    );
  }

  /* #9806
  source: 
    /**
     * Gets or sets whether the user may ungroup existing groups in this layer.
     * The initial value is true.
     */
    get allowUngroup(): boolean; */
  /// Gets or sets whether the user may ungroup existing groups in this layer.
  /// The initial value is true.
  _i2.bool get allowUngroup => _i5.getProperty(
        this,
        'allowUngroup',
      );
  /* #9806
  source: 
    /**
     * Gets or sets whether the user may ungroup existing groups in this layer.
     * The initial value is true.
     */
    get allowUngroup(): boolean; */
  // Type InteropStaticType.boolean
  set allowUngroup(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowUngroup',
      value,
    );
  }

  /* #9812
  source: 
    /**
     * Gets or sets whether the user may draw new links in this layer.
     * The initial value is true.
     */
    get allowLink(): boolean; */
  /// Gets or sets whether the user may draw new links in this layer.
  /// The initial value is true.
  _i2.bool get allowLink => _i5.getProperty(
        this,
        'allowLink',
      );
  /* #9812
  source: 
    /**
     * Gets or sets whether the user may draw new links in this layer.
     * The initial value is true.
     */
    get allowLink(): boolean; */
  // Type InteropStaticType.boolean
  set allowLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowLink',
      value,
    );
  }

  /* #9818
  source: 
    /**
     * Gets or sets whether the user may reconnect existing links in this layer.
     * The initial value is true.
     */
    get allowRelink(): boolean; */
  /// Gets or sets whether the user may reconnect existing links in this layer.
  /// The initial value is true.
  _i2.bool get allowRelink => _i5.getProperty(
        this,
        'allowRelink',
      );
  /* #9818
  source: 
    /**
     * Gets or sets whether the user may reconnect existing links in this layer.
     * The initial value is true.
     */
    get allowRelink(): boolean; */
  // Type InteropStaticType.boolean
  set allowRelink(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowRelink',
      value,
    );
  }

  /* #9824
  source: 
    /**
     * Gets or sets whether the user may move objects in this layer.
     * The initial value is true.
     */
    get allowMove(): boolean; */
  /// Gets or sets whether the user may move objects in this layer.
  /// The initial value is true.
  _i2.bool get allowMove => _i5.getProperty(
        this,
        'allowMove',
      );
  /* #9824
  source: 
    /**
     * Gets or sets whether the user may move objects in this layer.
     * The initial value is true.
     */
    get allowMove(): boolean; */
  // Type InteropStaticType.boolean
  set allowMove(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowMove',
      value,
    );
  }

  /* #9830
  source: 
    /**
     * Gets or sets whether the user may reshape parts in this layer.
     * The initial value is true.
     */
    get allowReshape(): boolean; */
  /// Gets or sets whether the user may reshape parts in this layer.
  /// The initial value is true.
  _i2.bool get allowReshape => _i5.getProperty(
        this,
        'allowReshape',
      );
  /* #9830
  source: 
    /**
     * Gets or sets whether the user may reshape parts in this layer.
     * The initial value is true.
     */
    get allowReshape(): boolean; */
  // Type InteropStaticType.boolean
  set allowReshape(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowReshape',
      value,
    );
  }

  /* #9836
  source: 
    /**
     * Gets or sets whether the user may resize parts in this layer.
     * The initial value is true.
     */
    get allowResize(): boolean; */
  /// Gets or sets whether the user may resize parts in this layer.
  /// The initial value is true.
  _i2.bool get allowResize => _i5.getProperty(
        this,
        'allowResize',
      );
  /* #9836
  source: 
    /**
     * Gets or sets whether the user may resize parts in this layer.
     * The initial value is true.
     */
    get allowResize(): boolean; */
  // Type InteropStaticType.boolean
  set allowResize(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowResize',
      value,
    );
  }

  /* #9842
  source: 
    /**
     * Gets or sets whether the user may rotate parts in this layer.
     * The initial value is true.
     */
    get allowRotate(): boolean; */
  /// Gets or sets whether the user may rotate parts in this layer.
  /// The initial value is true.
  _i2.bool get allowRotate => _i5.getProperty(
        this,
        'allowRotate',
      );
  /* #9842
  source: 
    /**
     * Gets or sets whether the user may rotate parts in this layer.
     * The initial value is true.
     */
    get allowRotate(): boolean; */
  // Type InteropStaticType.boolean
  set allowRotate(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowRotate',
      value,
    );
  }

  /* #9848
  source: 
    /**
     * Gets or sets whether the user may select objects in this layer.
     * The initial value is true.
     */
    get allowSelect(): boolean; */
  /// Gets or sets whether the user may select objects in this layer.
  /// The initial value is true.
  _i2.bool get allowSelect => _i5.getProperty(
        this,
        'allowSelect',
      );
  /* #9848
  source: 
    /**
     * Gets or sets whether the user may select objects in this layer.
     * The initial value is true.
     */
    get allowSelect(): boolean; */
  // Type InteropStaticType.boolean
  set allowSelect(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowSelect',
      value,
    );
  }

  T? findObjectAt<T extends _i3.GraphObject>(
    _i3.Point p, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectAt',
        [
          p,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
        ],
      );
  S findObjectsAt<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Point p, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsAt',
        [
          p,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          coll ?? _i4.undefined,
        ],
      );
  S findObjectsIn<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Rect r, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    _i2.bool? partialInclusion,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsIn',
        [
          r,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          partialInclusion ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  S findObjectsNear<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Point p,
    _i2.num dist, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    _i2.Object? partialInclusion,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsNear',
        [
          p,
          dist,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          partialInclusion ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
}

enum DiagramInitStrings<T$> {
  gridVisible<_i2.bool>(r'grid.visible'),
  gridGridCellSize<_i3.Size>(r'grid.gridCellSize'),
  gridGridOrigin<_i3.Point>(r'grid.gridOrigin'),
  toolManagerMouseWheelBehavior<_i3.EnumValue>(
      r'toolManager.mouseWheelBehavior'),
  toolManagerGestureBehavior<_i3.EnumValue>(r'toolManager.gestureBehavior'),
  toolManagerCurrentToolTip<_i2.dynamic>(r'toolManager.currentToolTip'),
  toolManagerHoverDelay<_i2.num>(r'toolManager.hoverDelay'),
  toolManagerHoldDelay<_i2.num>(r'toolManager.holdDelay'),
  toolManagerDragSize<_i3.Size>(r'toolManager.dragSize'),
  toolManagerToolTipDuration<_i2.num>(r'toolManager.toolTipDuration'),
  commandHandlerCopiesClipboardData<_i2.bool>(
      r'commandHandler.copiesClipboardData'),
  commandHandlerCopiesConnectedLinks<_i2.bool>(
      r'commandHandler.copiesConnectedLinks'),
  commandHandlerDeletesConnectedLinks<_i2.bool>(
      r'commandHandler.deletesConnectedLinks'),
  commandHandlerCopiesTree<_i2.bool>(r'commandHandler.copiesTree'),
  commandHandlerDeletesTree<_i2.bool>(r'commandHandler.deletesTree'),
  commandHandlerCopiesParentKey<_i2.bool>(r'commandHandler.copiesParentKey'),
  commandHandlerCopiesGroupKey<_i2.bool>(r'commandHandler.copiesGroupKey'),
  commandHandlerArchetypeGroupData<_i2.Object>(
      r'commandHandler.archetypeGroupData'),
  commandHandlerMemberValidation<
      _i2.bool Function(
        _i3.Group,
        _i3.Part,
      )?>(r'commandHandler.memberValidation'),
  commandHandlerDefaultScale<_i2.num>(r'commandHandler.defaultScale'),
  commandHandlerZoomFactor<_i2.num>(r'commandHandler.zoomFactor'),
  commandHandlerIsZoomToFitRestoreEnabled<_i2.bool>(
      r'commandHandler.isZoomToFitRestoreEnabled'),
  commandHandlerScrollToPartPause<_i2.num>(r'commandHandler.scrollToPartPause'),
  animationManagerIsEnabled<_i2.bool>(r'animationManager.isEnabled'),
  animationManagerDuration<_i2.num>(r'animationManager.duration'),
  animationManagerIsInitial<_i2.bool>(r'animationManager.isInitial'),
  animationManagerInitialAnimationStyle<_i3.EnumValue>(
      r'animationManager.initialAnimationStyle'),
  draggingToolIsCopyEnabled<_i2.bool>(r'draggingTool.isCopyEnabled'),
  draggingToolCopiesEffectiveCollection<_i2.bool>(
      r'draggingTool.copiesEffectiveCollection'),
  draggingToolDragOptions<_i3.DraggingOptions>(r'draggingTool.dragOptions'),
  draggingToolIsGridSnapEnabled<_i2.bool>(r'draggingTool.isGridSnapEnabled'),
  draggingToolIsComplexRoutingRealtime<_i2.bool>(
      r'draggingTool.isComplexRoutingRealtime'),
  draggingToolIsGridSnapRealtime<_i2.bool>(r'draggingTool.isGridSnapRealtime'),
  draggingToolGridSnapCellSize<_i3.Size>(r'draggingTool.gridSnapCellSize'),
  draggingToolGridSnapCellSpot<_i3.Spot>(r'draggingTool.gridSnapCellSpot'),
  draggingToolGridSnapOrigin<_i3.Point>(r'draggingTool.gridSnapOrigin'),
  draggingToolDragsLink<_i2.bool>(r'draggingTool.dragsLink'),
  draggingToolDragsTree<_i2.bool>(r'draggingTool.dragsTree'),
  draggingToolCopyCursor<_i2.String>(r'draggingTool.copyCursor'),
  draggingToolMoveCursor<_i2.String>(r'draggingTool.moveCursor'),
  draggingToolNodropCursor<_i2.String>(r'draggingTool.nodropCursor'),
  draggingToolCurrentPart<_i3.Part?>(r'draggingTool.currentPart'),
  draggingToolCopiedParts<_i3.Map<_i3.Part, _i3.DraggingInfo>?>(
      r'draggingTool.copiedParts'),
  draggingToolDraggedParts<_i3.Map<_i3.Part, _i3.DraggingInfo>?>(
      r'draggingTool.draggedParts'),
  draggingToolDraggedLink<_i3.Link>(r'draggingTool.draggedLink'),
  draggingToolIsDragOutStarted<_i2.bool>(r'draggingTool.isDragOutStarted'),
  draggingToolStartPoint<_i3.Point>(r'draggingTool.startPoint'),
  draggingToolDelay<_i2.num>(r'draggingTool.delay'),
  undoManagerIsEnabled<_i2.bool>(r'undoManager.isEnabled');

  const DiagramInitStrings(this.value);

  final _i2.String value;
}

@_i1.JS()
@_i1.staticInterop
class Diagram {
  factory Diagram.$1() => _i5.callConstructor(
        _declaredDiagram,
        [],
      );

  factory Diagram.$2([_i3.DiagramInitOptions? init]) => _i5.callConstructor(
        _declaredDiagram,
        [init ?? _i4.undefined ?? _i4.undefined],
      );

  factory Diagram.$3([
    _i2.Object? div,
    _i3.DiagramInitOptions? init,
  ]) =>
      _i5.callConstructor(
        _declaredDiagram,
        [
          div ?? _i4.undefined,
          init ?? _i4.undefined ?? _i4.undefined,
        ],
      );

  /* #11216
  source: 
    /**
     * The default autoScale type, used as the value of Diagram#autoScale:
     * The Diagram does not attempt to scale so that its documentBounds would fit the view.
     * @constant
     */
    static None: EnumValue; */
  /// The default autoScale type, used as the value of Diagram#autoScale:
  /// The Diagram does not attempt to scale so that its documentBounds would fit the view.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredDiagram,
        'None',
      );
  /* #11216
  source: 
    /**
     * The default autoScale type, used as the value of Diagram#autoScale:
     * The Diagram does not attempt to scale so that its documentBounds would fit the view.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'None',
      value,
    );
  }

  /* #11222
  source: 
    /**
     * Diagrams with this autoScale type, used as the value of Diagram#autoScale,
     * are scaled uniformly until the whole documentBounds fits in the view.
     * @constant
     */
    static Uniform: EnumValue; */
  /// Diagrams with this autoScale type, used as the value of Diagram#autoScale,
  /// are scaled uniformly until the whole documentBounds fits in the view.
  static _i3.EnumValue get uniform => _i5.getProperty(
        _declaredDiagram,
        'Uniform',
      );
  /* #11222
  source: 
    /**
     * Diagrams with this autoScale type, used as the value of Diagram#autoScale,
     * are scaled uniformly until the whole documentBounds fits in the view.
     * @constant
     */
    static Uniform: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set uniform(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'Uniform',
      value,
    );
  }

  /* #11229
  source: 
    /**
     * Diagrams with this autoScale type, used as the value of Diagram#autoScale,
     * are scaled until the documentBounds fits in the view in one direction while
     * a scrollbar is still needed in the other direction.
     * @constant
     */
    static UniformToFill: EnumValue; */
  /// Diagrams with this autoScale type, used as the value of Diagram#autoScale,
  /// are scaled until the documentBounds fits in the view in one direction while
  /// a scrollbar is still needed in the other direction.
  static _i3.EnumValue get uniformToFill => _i5.getProperty(
        _declaredDiagram,
        'UniformToFill',
      );
  /* #11229
  source: 
    /**
     * Diagrams with this autoScale type, used as the value of Diagram#autoScale,
     * are scaled until the documentBounds fits in the view in one direction while
     * a scrollbar is still needed in the other direction.
     * @constant
     */
    static UniformToFill: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set uniformToFill(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'UniformToFill',
      value,
    );
  }

  /* #11235
  source: 
    /**
     * This value for Diagram#validCycle states that
     * there are no restrictions on making cycles of links.
     * @constant
     */
    static CycleAll: EnumValue; */
  /// This value for Diagram#validCycle states that
  /// there are no restrictions on making cycles of links.
  static _i3.EnumValue get cycleAll => _i5.getProperty(
        _declaredDiagram,
        'CycleAll',
      );
  /* #11235
  source: 
    /**
     * This value for Diagram#validCycle states that
     * there are no restrictions on making cycles of links.
     * @constant
     */
    static CycleAll: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleAll(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'CycleAll',
      value,
    );
  }

  /* #11241
  source: 
    /**
     * This value for Diagram#validCycle states that
     * a valid link from a node will not produce a directed cycle in the graph.
     * @constant
     */
    static CycleNotDirected: EnumValue; */
  /// This value for Diagram#validCycle states that
  /// a valid link from a node will not produce a directed cycle in the graph.
  static _i3.EnumValue get cycleNotDirected => _i5.getProperty(
        _declaredDiagram,
        'CycleNotDirected',
      );
  /* #11241
  source: 
    /**
     * This value for Diagram#validCycle states that
     * a valid link from a node will not produce a directed cycle in the graph.
     * @constant
     */
    static CycleNotDirected: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleNotDirected(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'CycleNotDirected',
      value,
    );
  }

  /* #11247
  source: 
    /**
     * This value for Diagram#validCycle states that
     * a valid link from a node will not produce an undirected cycle in the graph.
     * @constant
     */
    static CycleNotUndirected: EnumValue; */
  /// This value for Diagram#validCycle states that
  /// a valid link from a node will not produce an undirected cycle in the graph.
  static _i3.EnumValue get cycleNotUndirected => _i5.getProperty(
        _declaredDiagram,
        'CycleNotUndirected',
      );
  /* #11247
  source: 
    /**
     * This value for Diagram#validCycle states that
     * a valid link from a node will not produce an undirected cycle in the graph.
     * @constant
     */
    static CycleNotUndirected: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleNotUndirected(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'CycleNotUndirected',
      value,
    );
  }

  /* #11257
  source: 
    /**
     * This value for Diagram#validCycle states that
     * any number of destination links may go out of a node, but at most one
     * source link may come into a node, and there are no directed cycles.
     *
     * This value assumes that the graph does not already have any cycles in it,
     * or else the behavior may be indeterminate.
     * @constant
     */
    static CycleDestinationTree: EnumValue; */
  /// This value for Diagram#validCycle states that
  /// any number of destination links may go out of a node, but at most one
  /// source link may come into a node, and there are no directed cycles.
  ///
  /// This value assumes that the graph does not already have any cycles in it,
  /// or else the behavior may be indeterminate.
  static _i3.EnumValue get cycleDestinationTree => _i5.getProperty(
        _declaredDiagram,
        'CycleDestinationTree',
      );
  /* #11257
  source: 
    /**
     * This value for Diagram#validCycle states that
     * any number of destination links may go out of a node, but at most one
     * source link may come into a node, and there are no directed cycles.
     *
     * This value assumes that the graph does not already have any cycles in it,
     * or else the behavior may be indeterminate.
     * @constant
     */
    static CycleDestinationTree: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleDestinationTree(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'CycleDestinationTree',
      value,
    );
  }

  /* #11267
  source: 
    /**
     * This value for Diagram#validCycle states that
     * any number of source links may come into a node, but at most one
     * destination link may go out of a node, and there are no directed cycles.
     *
     * This value assumes that the graph does not already have any cycles in it,
     * or else the behavior may be indeterminate.
     * @constant
     */
    static CycleSourceTree: EnumValue; */
  /// This value for Diagram#validCycle states that
  /// any number of source links may come into a node, but at most one
  /// destination link may go out of a node, and there are no directed cycles.
  ///
  /// This value assumes that the graph does not already have any cycles in it,
  /// or else the behavior may be indeterminate.
  static _i3.EnumValue get cycleSourceTree => _i5.getProperty(
        _declaredDiagram,
        'CycleSourceTree',
      );
  /* #11267
  source: 
    /**
     * This value for Diagram#validCycle states that
     * any number of source links may come into a node, but at most one
     * destination link may go out of a node, and there are no directed cycles.
     *
     * This value assumes that the graph does not already have any cycles in it,
     * or else the behavior may be indeterminate.
     * @constant
     */
    static CycleSourceTree: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleSourceTree(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'CycleSourceTree',
      value,
    );
  }

  /* #11273
  source: 
    /**
     * This value for Diagram#scrollMode states that
     * the viewport constrains scrolling to the Diagram document bounds.
     * @constant
     */
    static DocumentScroll: EnumValue; */
  /// This value for Diagram#scrollMode states that
  /// the viewport constrains scrolling to the Diagram document bounds.
  static _i3.EnumValue get documentScroll => _i5.getProperty(
        _declaredDiagram,
        'DocumentScroll',
      );
  /* #11273
  source: 
    /**
     * This value for Diagram#scrollMode states that
     * the viewport constrains scrolling to the Diagram document bounds.
     * @constant
     */
    static DocumentScroll: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set documentScroll(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'DocumentScroll',
      value,
    );
  }

  /* #11279
  source: 
    /**
     * This value for Diagram#scrollMode states that
     * the viewport does not constrain scrolling to the Diagram document bounds.
     * @constant
     */
    static InfiniteScroll: EnumValue; */
  /// This value for Diagram#scrollMode states that
  /// the viewport does not constrain scrolling to the Diagram document bounds.
  static _i3.EnumValue get infiniteScroll => _i5.getProperty(
        _declaredDiagram,
        'InfiniteScroll',
      );
  /* #11279
  source: 
    /**
     * This value for Diagram#scrollMode states that
     * the viewport does not constrain scrolling to the Diagram document bounds.
     * @constant
     */
    static InfiniteScroll: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set infiniteScroll(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredDiagram,
      'InfiniteScroll',
      value,
    );
  }

  /* #12005
  source: 
    /**
     * Gets or sets the license key.
     * @since 2.0
     */
    static get licenseKey(): string; */
  /// Gets or sets the license key.
  static _i2.String get licenseKey => _i5.getProperty(
        _declaredDiagram,
        'licenseKey',
      );
  /* #12005
  source: 
    /**
     * Gets or sets the license key.
     * @since 2.0
     */
    static get licenseKey(): string; */
  // Type InteropStaticType.string
  static set licenseKey(_i2.String value) {
    _i5.setProperty(
      _declaredDiagram,
      'licenseKey',
      value,
    );
  }

  /* #12011
  source: 
    /**
     * Gets the current GoJS version.
     * @since 2.0
     */
    static get version(): string; */
  /// Gets the current GoJS version.
  static _i2.String get version => _i5.getProperty(
        _declaredDiagram,
        'version',
      );
  /* #12011
  source: 
    /**
     * Gets the current GoJS version.
     * @since 2.0
     */
    static get version(): string; */
  // Type InteropStaticType.string
  static set version(_i2.String value) {
    _i5.setProperty(
      _declaredDiagram,
      'version',
      value,
    );
  }

  static _i2.bool isUsingDOM() => _i5.callMethod(
        _declaredDiagram,
        'isUsingDOM',
        [],
      );
  static void useDOM(_i2.bool value) {
    _i5.callMethod(
      _declaredDiagram,
      'useDOM',
      [value],
    );
  }

  static _i3.Diagram? fromDiv(_i2.Object div) => _i5.callMethod(
        _declaredDiagram,
        'fromDiv',
        [div],
      );
  static void inherit(
    _i2.Function derivedclass,
    _i2.Function baseclass,
  ) {
    _i5.callMethod(
      _declaredDiagram,
      'inherit',
      [
        derivedclass,
        baseclass,
      ],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Diagram')
external _i2.Object _declaredDiagram;

extension Diagram$Typings on Diagram {
  /* #10186
  source: 
    /**
     * Gets or sets the rendering context type. Values are `'default'`, which uses the HTML Canvas,
     * or `'svg'`, which builds and updates an SVG DOM.
     *
     * Setting this value dynamically is uncommon, typically a render is chosen only once,
     * when the Diagram is initially created. Using the SVG rendering context is also uncommon,
     * because the default canvas context has considerably greater performance.
     *
     * For more information, see the intro page on the
     * <a href="../../intro/SVGContext.html">SVG drawing context</a>.
     *
     * @since 2.3
     */
    get renderer(): 'default' | 'svg' | 'canvas'; */
  /// Gets or sets the rendering context type. Values are `'default'`, which uses the HTML Canvas,
  /// or `'svg'`, which builds and updates an SVG DOM.
  ///
  /// Setting this value dynamically is uncommon, typically a render is chosen only once,
  /// when the Diagram is initially created. Using the SVG rendering context is also uncommon,
  /// because the default canvas context has considerably greater performance.
  ///
  /// For more information, see the intro page on the
  /// <a href="../../intro/SVGContext.html">SVG drawing context</a>.
  Renderer get renderer => Renderer.values.byName(_i5.getProperty(
        this,
        'renderer',
      ));
  /* #10186
  source: 
    /**
     * Gets or sets the rendering context type. Values are `'default'`, which uses the HTML Canvas,
     * or `'svg'`, which builds and updates an SVG DOM.
     *
     * Setting this value dynamically is uncommon, typically a render is chosen only once,
     * when the Diagram is initially created. Using the SVG rendering context is also uncommon,
     * because the default canvas context has considerably greater performance.
     *
     * For more information, see the intro page on the
     * <a href="../../intro/SVGContext.html">SVG drawing context</a>.
     *
     * @since 2.3
     */
    get renderer(): 'default' | 'svg' | 'canvas'; */
  // Type InteropUnion#519634730(parent: InteropGetter#483054317(name: renderer))
  set renderer(Renderer value) {
    _i5.setProperty(
      this,
      'renderer',
      value.name,
    );
  }

  /* #10264
  source: 
    /**
     * Gets or sets the Diagram's HTMLDivElement, via an HTML Element ID.
     * This is typically set automatically when a Div is supplied as an argument to Diagram's constructor.
     *
     * Setting this property to a new value will clobber any HTML and
     * inner DOM elements inside of both the new and the old divs.
     * It will then populate the Div with the elements
     * (inner Divs, Canvases) needed for the Diagram to function.
     *
     * If you want to disassociate the Diagram from the HTML Div element, set Diagram#div to null.
     * If you remove a part of the HTML DOM containing a Div with a Diagram, you will need to
     * set #div to null in order for the page to recover the memory.
     *
     * You should not attempt to manually modify the contents of this Div.
     * Changing this property value does not raise a Changed event.
     */
    get div(): HTMLDivElement | null; */
  /// Gets or sets the Diagram's HTMLDivElement, via an HTML Element ID.
  /// This is typically set automatically when a Div is supplied as an argument to Diagram's constructor.
  ///
  /// Setting this property to a new value will clobber any HTML and
  /// inner DOM elements inside of both the new and the old divs.
  /// It will then populate the Div with the elements
  /// (inner Divs, Canvases) needed for the Diagram to function.
  ///
  /// If you want to disassociate the Diagram from the HTML Div element, set Diagram#div to null.
  /// If you remove a part of the HTML DOM containing a Div with a Diagram, you will need to
  /// set #div to null in order for the page to recover the memory.
  ///
  /// You should not attempt to manually modify the contents of this Div.
  /// Changing this property value does not raise a Changed event.
  _i4.HTMLDivElement? get div => _i5.getProperty(
        this,
        'div',
      );
  /* #10264
  source: 
    /**
     * Gets or sets the Diagram's HTMLDivElement, via an HTML Element ID.
     * This is typically set automatically when a Div is supplied as an argument to Diagram's constructor.
     *
     * Setting this property to a new value will clobber any HTML and
     * inner DOM elements inside of both the new and the old divs.
     * It will then populate the Div with the elements
     * (inner Divs, Canvases) needed for the Diagram to function.
     *
     * If you want to disassociate the Diagram from the HTML Div element, set Diagram#div to null.
     * If you remove a part of the HTML DOM containing a Div with a Diagram, you will need to
     * set #div to null in order for the page to recover the memory.
     *
     * You should not attempt to manually modify the contents of this Div.
     * Changing this property value does not raise a Changed event.
     */
    get div(): HTMLDivElement | null; */
  // Type InteropUnion#746825114(parent: InteropGetter#806854460(name: div))
  set div(_i4.HTMLDivElement? value) {
    _i5.setProperty(
      this,
      'div',
      value ?? _i4.undefined,
    );
  }

  /* #10954
  source: 
    /**
     * This read-only property returns the AnimationManager for this Diagram.
     * @since 1.4
     */
    get animationManager(): AnimationManager; */
  /// This read-only property returns the AnimationManager for this Diagram.
  _i3.AnimationManager get animationManager => _i5.getProperty(
        this,
        'animationManager',
      );
  /* #10954
  source: 
    /**
     * This read-only property returns the AnimationManager for this Diagram.
     * @since 1.4
     */
    get animationManager(): AnimationManager; */
  // Type Instance of 'InteropInterface'
  set animationManager(_i3.AnimationManager value) {
    _i5.setProperty(
      this,
      'animationManager',
      value,
    );
  }

  /* #10964
  source: 
    /**
     * This read-only property returns the UndoManager for this Diagram, which actually belongs to the #model.
     *
     * The default UndoManager has its UndoManager#isEnabled property set to false.
     * If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
     *
     * Note that the UndoManager might be shared with other Diagrams that are showing the same Model.
     * The UndoManager might also be shared with other Models too.
     */
    get undoManager(): UndoManager; */
  /// This read-only property returns the UndoManager for this Diagram, which actually belongs to the #model.
  ///
  /// The default UndoManager has its UndoManager#isEnabled property set to false.
  /// If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
  ///
  /// Note that the UndoManager might be shared with other Diagrams that are showing the same Model.
  /// The UndoManager might also be shared with other Models too.
  _i3.UndoManager get undoManager => _i5.getProperty(
        this,
        'undoManager',
      );
  /* #10964
  source: 
    /**
     * This read-only property returns the UndoManager for this Diagram, which actually belongs to the #model.
     *
     * The default UndoManager has its UndoManager#isEnabled property set to false.
     * If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
     *
     * Note that the UndoManager might be shared with other Diagrams that are showing the same Model.
     * The UndoManager might also be shared with other Models too.
     */
    get undoManager(): UndoManager; */
  // Type Instance of 'InteropInterface'
  set undoManager(_i3.UndoManager value) {
    _i5.setProperty(
      this,
      'undoManager',
      value,
    );
  }

  /* #10987
  source: 
    /**
     * Gets or sets whether ChangedEvents are not recorded by the UndoManager.
     * The initial and normal value is false.
     * WARNING: while this property is true do not perform any changes that cause any previous transactions
     * to become impossible to undo.
     *
     * While this property is true, changing the Diagram or any GraphObject does not call UndoManager#handleChanged.
     * Even when this property is true,
     * transactions (such as calls to #startTransaction) and
     * undo/redo (such as calls to CommandHandler#undo)
     * are still delegated to the #undoManager.
     *
     * You should set this to true only temporarily, and you should remember its previous value
     * before setting this to true.
     * When finishing the period for which you want the UndoManager to be disabled,
     * you should set this back to the remembered value it had before it was set to true.
     *
     * For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
     *
     * Setting this property also sets Model#skipsUndoManager to the same value.
     * Setting this property does not notify about any changed event.
     */
    get skipsUndoManager(): boolean; */
  /// Gets or sets whether ChangedEvents are not recorded by the UndoManager.
  /// The initial and normal value is false.
  /// WARNING: while this property is true do not perform any changes that cause any previous transactions
  /// to become impossible to undo.
  ///
  /// While this property is true, changing the Diagram or any GraphObject does not call UndoManager#handleChanged.
  /// Even when this property is true,
  /// transactions (such as calls to #startTransaction) and
  /// undo/redo (such as calls to CommandHandler#undo)
  /// are still delegated to the #undoManager.
  ///
  /// You should set this to true only temporarily, and you should remember its previous value
  /// before setting this to true.
  /// When finishing the period for which you want the UndoManager to be disabled,
  /// you should set this back to the remembered value it had before it was set to true.
  ///
  /// For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
  ///
  /// Setting this property also sets Model#skipsUndoManager to the same value.
  /// Setting this property does not notify about any changed event.
  _i2.bool get skipsUndoManager => _i5.getProperty(
        this,
        'skipsUndoManager',
      );
  /* #10987
  source: 
    /**
     * Gets or sets whether ChangedEvents are not recorded by the UndoManager.
     * The initial and normal value is false.
     * WARNING: while this property is true do not perform any changes that cause any previous transactions
     * to become impossible to undo.
     *
     * While this property is true, changing the Diagram or any GraphObject does not call UndoManager#handleChanged.
     * Even when this property is true,
     * transactions (such as calls to #startTransaction) and
     * undo/redo (such as calls to CommandHandler#undo)
     * are still delegated to the #undoManager.
     *
     * You should set this to true only temporarily, and you should remember its previous value
     * before setting this to true.
     * When finishing the period for which you want the UndoManager to be disabled,
     * you should set this back to the remembered value it had before it was set to true.
     *
     * For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
     *
     * Setting this property also sets Model#skipsUndoManager to the same value.
     * Setting this property does not notify about any changed event.
     */
    get skipsUndoManager(): boolean; */
  // Type InteropStaticType.boolean
  set skipsUndoManager(_i2.bool value) {
    _i5.setProperty(
      this,
      'skipsUndoManager',
      value,
    );
  }

  /* #10994
  source: 
    /**
     * (undocumented)
     * When set to true Diagram layouts will not get invalidated.
     * Used by some tools stop real-time layouts from occuring during their operation.
     */
    get delaysLayout(): boolean; */
  /// (undocumented)
  /// When set to true Diagram layouts will not get invalidated.
  /// Used by some tools stop real-time layouts from occuring during their operation.
  _i2.bool get delaysLayout => _i5.getProperty(
        this,
        'delaysLayout',
      );
  /* #10994
  source: 
    /**
     * (undocumented)
     * When set to true Diagram layouts will not get invalidated.
     * Used by some tools stop real-time layouts from occuring during their operation.
     */
    get delaysLayout(): boolean; */
  // Type InteropStaticType.boolean
  set delaysLayout(_i2.bool value) {
    _i5.setProperty(
      this,
      'delaysLayout',
      value,
    );
  }

  /* #11290
  source: 
    /**
     * Gets or sets the opacity for all parts in this diagram.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     * This value is multiplicative with any existing transparency,
     * for instance from a Brush or image transparency.
     * The default value is 1.
     * @since 2.1
     * @see Layer#opacity
     * @see GraphObject#opacity
     */
    get opacity(): number; */
  /// Gets or sets the opacity for all parts in this diagram.
  /// The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
  /// This value is multiplicative with any existing transparency,
  /// for instance from a Brush or image transparency.
  /// The default value is 1.
  _i2.num get opacity => _i5.getProperty(
        this,
        'opacity',
      );
  /* #11290
  source: 
    /**
     * Gets or sets the opacity for all parts in this diagram.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     * This value is multiplicative with any existing transparency,
     * for instance from a Brush or image transparency.
     * The default value is 1.
     * @since 2.1
     * @see Layer#opacity
     * @see GraphObject#opacity
     */
    get opacity(): number; */
  // Type InteropStaticType.number
  set opacity(_i2.num value) {
    _i5.setProperty(
      this,
      'opacity',
      value,
    );
  }

  /* #11297
  source: 
    /**
     * Gets or sets what kinds of graphs this diagram allows the user to draw.
     * By default this property is Diagram.CycleAll -- all kinds of cycles are permitted.
     * Common values include Diagram.CycleDestinationTree and Diagram.CycleNotDirected.
     */
    get validCycle(): EnumValue; */
  /// Gets or sets what kinds of graphs this diagram allows the user to draw.
  /// By default this property is Diagram.CycleAll -- all kinds of cycles are permitted.
  /// Common values include Diagram.CycleDestinationTree and Diagram.CycleNotDirected.
  _i3.EnumValue get validCycle => _i5.getProperty(
        this,
        'validCycle',
      );
  /* #11297
  source: 
    /**
     * Gets or sets what kinds of graphs this diagram allows the user to draw.
     * By default this property is Diagram.CycleAll -- all kinds of cycles are permitted.
     * Common values include Diagram.CycleDestinationTree and Diagram.CycleNotDirected.
     */
    get validCycle(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set validCycle(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'validCycle',
      value,
    );
  }

  /* #11304
  source: 
    /**
     * This read-only property returns an iterator for this Diagram's Layers.
     * @see #addLayer
     * @see #removeLayer
     */
    get layers(): Iterator<Layer>; */
  /// This read-only property returns an iterator for this Diagram's Layers.
  _i3.Iterator<_i3.Layer> get layers => _i5.getProperty(
        this,
        'layers',
      );
  /* #11304
  source: 
    /**
     * This read-only property returns an iterator for this Diagram's Layers.
     * @see #addLayer
     * @see #removeLayer
     */
    get layers(): Iterator<Layer>; */
  // Type Instance of 'InteropInterface'
  set layers(_i3.Iterator<_i3.Layer> value) {
    _i5.setProperty(
      this,
      'layers',
      value,
    );
  }

  /* #11310
  source: 
    /**
     * Gets or sets whether the Diagram's Diagram#model is Model#isReadOnly.
     * @see #isReadOnly
     * @see #isEnabled
     */
    get isModelReadOnly(): boolean; */
  /// Gets or sets whether the Diagram's Diagram#model is Model#isReadOnly.
  _i2.bool get isModelReadOnly => _i5.getProperty(
        this,
        'isModelReadOnly',
      );
  /* #11310
  source: 
    /**
     * Gets or sets whether the Diagram's Diagram#model is Model#isReadOnly.
     * @see #isReadOnly
     * @see #isEnabled
     */
    get isModelReadOnly(): boolean; */
  // Type InteropStaticType.boolean
  set isModelReadOnly(_i2.bool value) {
    _i5.setProperty(
      this,
      'isModelReadOnly',
      value,
    );
  }

  /* #11319
  source: 
    /**
     * Gets or sets whether the Diagram may be modified by the user,
     * while still allowing the user to scroll, zoom, and select.
     * The initial value is false.
     * @see #isModelReadOnly
     * @see #isEnabled
     */
    get isReadOnly(): boolean; */
  /// Gets or sets whether the Diagram may be modified by the user,
  /// while still allowing the user to scroll, zoom, and select.
  /// The initial value is false.
  _i2.bool get isReadOnly => _i5.getProperty(
        this,
        'isReadOnly',
      );
  /* #11319
  source: 
    /**
     * Gets or sets whether the Diagram may be modified by the user,
     * while still allowing the user to scroll, zoom, and select.
     * The initial value is false.
     * @see #isModelReadOnly
     * @see #isEnabled
     */
    get isReadOnly(): boolean; */
  // Type InteropStaticType.boolean
  set isReadOnly(_i2.bool value) {
    _i5.setProperty(
      this,
      'isReadOnly',
      value,
    );
  }

  /* #11326
  source: 
    /**
     * Gets or sets whether the user may interact with the Diagram.
     * @see #isReadOnly
     * @see #isModelReadOnly
     */
    get isEnabled(): boolean; */
  /// Gets or sets whether the user may interact with the Diagram.
  _i2.bool get isEnabled => _i5.getProperty(
        this,
        'isEnabled',
      );
  /* #11326
  source: 
    /**
     * Gets or sets whether the user may interact with the Diagram.
     * @see #isReadOnly
     * @see #isModelReadOnly
     */
    get isEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEnabled',
      value,
    );
  }

  /* #11334
  source: 
    /**
     * Gets or sets whether the user may copy to or paste parts from the internal clipboard.
     * This allows use of CommandHandler#cutSelection,
     * CommandHandler#copySelection and CommandHandler#pasteSelection.
     * The initial value is true.
     */
    get allowClipboard(): boolean; */
  /// Gets or sets whether the user may copy to or paste parts from the internal clipboard.
  /// This allows use of CommandHandler#cutSelection,
  /// CommandHandler#copySelection and CommandHandler#pasteSelection.
  /// The initial value is true.
  _i2.bool get allowClipboard => _i5.getProperty(
        this,
        'allowClipboard',
      );
  /* #11334
  source: 
    /**
     * Gets or sets whether the user may copy to or paste parts from the internal clipboard.
     * This allows use of CommandHandler#cutSelection,
     * CommandHandler#copySelection and CommandHandler#pasteSelection.
     * The initial value is true.
     */
    get allowClipboard(): boolean; */
  // Type InteropStaticType.boolean
  set allowClipboard(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowClipboard',
      value,
    );
  }

  /* #11340
  source: 
    /**
     * Gets or sets whether the user may copy objects.
     * The initial value is true.
     */
    get allowCopy(): boolean; */
  /// Gets or sets whether the user may copy objects.
  /// The initial value is true.
  _i2.bool get allowCopy => _i5.getProperty(
        this,
        'allowCopy',
      );
  /* #11340
  source: 
    /**
     * Gets or sets whether the user may copy objects.
     * The initial value is true.
     */
    get allowCopy(): boolean; */
  // Type InteropStaticType.boolean
  set allowCopy(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowCopy',
      value,
    );
  }

  /* #11346
  source: 
    /**
     * Gets or sets whether the user may delete objects from the Diagram.
     * The initial value is true.
     */
    get allowDelete(): boolean; */
  /// Gets or sets whether the user may delete objects from the Diagram.
  /// The initial value is true.
  _i2.bool get allowDelete => _i5.getProperty(
        this,
        'allowDelete',
      );
  /* #11346
  source: 
    /**
     * Gets or sets whether the user may delete objects from the Diagram.
     * The initial value is true.
     */
    get allowDelete(): boolean; */
  // Type InteropStaticType.boolean
  set allowDelete(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowDelete',
      value,
    );
  }

  /* #11353
  source: 
    /**
     * Gets or sets whether the user may start a drag-and-drop in this Diagram,
     * possibly dropping in a different element.
     * The initial value is false.
     */
    get allowDragOut(): boolean; */
  /// Gets or sets whether the user may start a drag-and-drop in this Diagram,
  /// possibly dropping in a different element.
  /// The initial value is false.
  _i2.bool get allowDragOut => _i5.getProperty(
        this,
        'allowDragOut',
      );
  /* #11353
  source: 
    /**
     * Gets or sets whether the user may start a drag-and-drop in this Diagram,
     * possibly dropping in a different element.
     * The initial value is false.
     */
    get allowDragOut(): boolean; */
  // Type InteropStaticType.boolean
  set allowDragOut(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowDragOut',
      value,
    );
  }

  /* #11361
  source: 
    /**
     * Gets or sets whether the user may end a drag-and-drop operation in this Diagram.
     * This is typically set to true when a Diagram is used with a Palette.
     *
     * The initial value is true.
     */
    get allowDrop(): boolean; */
  /// Gets or sets whether the user may end a drag-and-drop operation in this Diagram.
  /// This is typically set to true when a Diagram is used with a Palette.
  ///
  /// The initial value is true.
  _i2.bool get allowDrop => _i5.getProperty(
        this,
        'allowDrop',
      );
  /* #11361
  source: 
    /**
     * Gets or sets whether the user may end a drag-and-drop operation in this Diagram.
     * This is typically set to true when a Diagram is used with a Palette.
     *
     * The initial value is true.
     */
    get allowDrop(): boolean; */
  // Type InteropStaticType.boolean
  set allowDrop(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowDrop',
      value,
    );
  }

  /* #11367
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing.
     * The initial value is true.
     */
    get allowTextEdit(): boolean; */
  /// Gets or sets whether the user may do in-place text editing.
  /// The initial value is true.
  _i2.bool get allowTextEdit => _i5.getProperty(
        this,
        'allowTextEdit',
      );
  /* #11367
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing.
     * The initial value is true.
     */
    get allowTextEdit(): boolean; */
  // Type InteropStaticType.boolean
  set allowTextEdit(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowTextEdit',
      value,
    );
  }

  /* #11373
  source: 
    /**
     * Gets or sets whether the user may group parts together.
     * The initial value is true.
     */
    get allowGroup(): boolean; */
  /// Gets or sets whether the user may group parts together.
  /// The initial value is true.
  _i2.bool get allowGroup => _i5.getProperty(
        this,
        'allowGroup',
      );
  /* #11373
  source: 
    /**
     * Gets or sets whether the user may group parts together.
     * The initial value is true.
     */
    get allowGroup(): boolean; */
  // Type InteropStaticType.boolean
  set allowGroup(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowGroup',
      value,
    );
  }

  /* #11379
  source: 
    /**
     * Gets or sets whether the user may ungroup existing groups.
     * The initial value is true.
     */
    get allowUngroup(): boolean; */
  /// Gets or sets whether the user may ungroup existing groups.
  /// The initial value is true.
  _i2.bool get allowUngroup => _i5.getProperty(
        this,
        'allowUngroup',
      );
  /* #11379
  source: 
    /**
     * Gets or sets whether the user may ungroup existing groups.
     * The initial value is true.
     */
    get allowUngroup(): boolean; */
  // Type InteropStaticType.boolean
  set allowUngroup(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowUngroup',
      value,
    );
  }

  /* #11385
  source: 
    /**
     * Gets or sets whether the user may add parts to the Diagram.
     * The initial value is true.
     */
    get allowInsert(): boolean; */
  /// Gets or sets whether the user may add parts to the Diagram.
  /// The initial value is true.
  _i2.bool get allowInsert => _i5.getProperty(
        this,
        'allowInsert',
      );
  /* #11385
  source: 
    /**
     * Gets or sets whether the user may add parts to the Diagram.
     * The initial value is true.
     */
    get allowInsert(): boolean; */
  // Type InteropStaticType.boolean
  set allowInsert(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowInsert',
      value,
    );
  }

  /* #11391
  source: 
    /**
     * Gets or sets whether the user may draw new links.
     * The initial value is true.
     */
    get allowLink(): boolean; */
  /// Gets or sets whether the user may draw new links.
  /// The initial value is true.
  _i2.bool get allowLink => _i5.getProperty(
        this,
        'allowLink',
      );
  /* #11391
  source: 
    /**
     * Gets or sets whether the user may draw new links.
     * The initial value is true.
     */
    get allowLink(): boolean; */
  // Type InteropStaticType.boolean
  set allowLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowLink',
      value,
    );
  }

  /* #11397
  source: 
    /**
     * Gets or sets whether the user may reconnect existing links.
     * The initial value is true.
     */
    get allowRelink(): boolean; */
  /// Gets or sets whether the user may reconnect existing links.
  /// The initial value is true.
  _i2.bool get allowRelink => _i5.getProperty(
        this,
        'allowRelink',
      );
  /* #11397
  source: 
    /**
     * Gets or sets whether the user may reconnect existing links.
     * The initial value is true.
     */
    get allowRelink(): boolean; */
  // Type InteropStaticType.boolean
  set allowRelink(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowRelink',
      value,
    );
  }

  /* #11403
  source: 
    /**
     * Gets or sets whether the user may move objects.
     * The initial value is true.
     */
    get allowMove(): boolean; */
  /// Gets or sets whether the user may move objects.
  /// The initial value is true.
  _i2.bool get allowMove => _i5.getProperty(
        this,
        'allowMove',
      );
  /* #11403
  source: 
    /**
     * Gets or sets whether the user may move objects.
     * The initial value is true.
     */
    get allowMove(): boolean; */
  // Type InteropStaticType.boolean
  set allowMove(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowMove',
      value,
    );
  }

  /* #11409
  source: 
    /**
     * Gets or sets whether the user may reshape parts.
     * The initial value is true.
     */
    get allowReshape(): boolean; */
  /// Gets or sets whether the user may reshape parts.
  /// The initial value is true.
  _i2.bool get allowReshape => _i5.getProperty(
        this,
        'allowReshape',
      );
  /* #11409
  source: 
    /**
     * Gets or sets whether the user may reshape parts.
     * The initial value is true.
     */
    get allowReshape(): boolean; */
  // Type InteropStaticType.boolean
  set allowReshape(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowReshape',
      value,
    );
  }

  /* #11415
  source: 
    /**
     * Gets or sets whether the user may resize parts.
     * The initial value is true.
     */
    get allowResize(): boolean; */
  /// Gets or sets whether the user may resize parts.
  /// The initial value is true.
  _i2.bool get allowResize => _i5.getProperty(
        this,
        'allowResize',
      );
  /* #11415
  source: 
    /**
     * Gets or sets whether the user may resize parts.
     * The initial value is true.
     */
    get allowResize(): boolean; */
  // Type InteropStaticType.boolean
  set allowResize(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowResize',
      value,
    );
  }

  /* #11421
  source: 
    /**
     * Gets or sets whether the user may rotate parts.
     * The initial value is true.
     */
    get allowRotate(): boolean; */
  /// Gets or sets whether the user may rotate parts.
  /// The initial value is true.
  _i2.bool get allowRotate => _i5.getProperty(
        this,
        'allowRotate',
      );
  /* #11421
  source: 
    /**
     * Gets or sets whether the user may rotate parts.
     * The initial value is true.
     */
    get allowRotate(): boolean; */
  // Type InteropStaticType.boolean
  set allowRotate(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowRotate',
      value,
    );
  }

  /* #11427
  source: 
    /**
     * Gets or sets whether the user may select objects.
     * The initial value is true.
     */
    get allowSelect(): boolean; */
  /// Gets or sets whether the user may select objects.
  /// The initial value is true.
  _i2.bool get allowSelect => _i5.getProperty(
        this,
        'allowSelect',
      );
  /* #11427
  source: 
    /**
     * Gets or sets whether the user may select objects.
     * The initial value is true.
     */
    get allowSelect(): boolean; */
  // Type InteropStaticType.boolean
  set allowSelect(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowSelect',
      value,
    );
  }

  /* #11433
  source: 
    /**
     * Gets or sets whether the user may undo or redo any changes.
     * The initial value is true.
     */
    get allowUndo(): boolean; */
  /// Gets or sets whether the user may undo or redo any changes.
  /// The initial value is true.
  _i2.bool get allowUndo => _i5.getProperty(
        this,
        'allowUndo',
      );
  /* #11433
  source: 
    /**
     * Gets or sets whether the user may undo or redo any changes.
     * The initial value is true.
     */
    get allowUndo(): boolean; */
  // Type InteropStaticType.boolean
  set allowUndo(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowUndo',
      value,
    );
  }

  /* #11439
  source: 
    /**
     * Gets or sets whether the user may zoom into or out of the Diagram.
     * The initial value is true.
     */
    get allowZoom(): boolean; */
  /// Gets or sets whether the user may zoom into or out of the Diagram.
  /// The initial value is true.
  _i2.bool get allowZoom => _i5.getProperty(
        this,
        'allowZoom',
      );
  /* #11439
  source: 
    /**
     * Gets or sets whether the user may zoom into or out of the Diagram.
     * The initial value is true.
     */
    get allowZoom(): boolean; */
  // Type InteropStaticType.boolean
  set allowZoom(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowZoom',
      value,
    );
  }

  /* #11452
  source: 
    /**
     * Gets or sets whether the Diagram has a vertical Scrollbar.
     *
     * To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
     *
     * Adding or removing a scrollbar modifies the diagram's viewport.
     *
     * The initial value is true.
     * @see #allowVerticalScroll
     * @see #hasHorizontalScrollbar
     */
    get hasVerticalScrollbar(): boolean; */
  /// Gets or sets whether the Diagram has a vertical Scrollbar.
  ///
  /// To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
  ///
  /// Adding or removing a scrollbar modifies the diagram's viewport.
  ///
  /// The initial value is true.
  _i2.bool get hasVerticalScrollbar => _i5.getProperty(
        this,
        'hasVerticalScrollbar',
      );
  /* #11452
  source: 
    /**
     * Gets or sets whether the Diagram has a vertical Scrollbar.
     *
     * To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
     *
     * Adding or removing a scrollbar modifies the diagram's viewport.
     *
     * The initial value is true.
     * @see #allowVerticalScroll
     * @see #hasHorizontalScrollbar
     */
    get hasVerticalScrollbar(): boolean; */
  // Type InteropStaticType.boolean
  set hasVerticalScrollbar(_i2.bool value) {
    _i5.setProperty(
      this,
      'hasVerticalScrollbar',
      value,
    );
  }

  /* #11465
  source: 
    /**
     * Gets or sets whether the Diagram has a horizontal Scrollbar.
     *
     * To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
     *
     * Adding or removing a scrollbar modifies the diagram's viewport.
     *
     * The initial value is true.
     * @see #allowHorizontalScroll
     * @see #hasVerticalScrollbar
     */
    get hasHorizontalScrollbar(): boolean; */
  /// Gets or sets whether the Diagram has a horizontal Scrollbar.
  ///
  /// To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
  ///
  /// Adding or removing a scrollbar modifies the diagram's viewport.
  ///
  /// The initial value is true.
  _i2.bool get hasHorizontalScrollbar => _i5.getProperty(
        this,
        'hasHorizontalScrollbar',
      );
  /* #11465
  source: 
    /**
     * Gets or sets whether the Diagram has a horizontal Scrollbar.
     *
     * To enable or disable scrolling itself, use #allowHorizontalScroll and #allowVerticalScroll.
     *
     * Adding or removing a scrollbar modifies the diagram's viewport.
     *
     * The initial value is true.
     * @see #allowHorizontalScroll
     * @see #hasVerticalScrollbar
     */
    get hasHorizontalScrollbar(): boolean; */
  // Type InteropStaticType.boolean
  set hasHorizontalScrollbar(_i2.bool value) {
    _i5.setProperty(
      this,
      'hasHorizontalScrollbar',
      value,
    );
  }

  /* #11473
  source: 
    /**
     * Gets or sets whether the user is allowed to use the horizontal scrollbar.
     * The initial value is true.
     * @see #hasHorizontalScrollbar
     * @see #allowVerticalScroll
     */
    get allowHorizontalScroll(): boolean; */
  /// Gets or sets whether the user is allowed to use the horizontal scrollbar.
  /// The initial value is true.
  _i2.bool get allowHorizontalScroll => _i5.getProperty(
        this,
        'allowHorizontalScroll',
      );
  /* #11473
  source: 
    /**
     * Gets or sets whether the user is allowed to use the horizontal scrollbar.
     * The initial value is true.
     * @see #hasHorizontalScrollbar
     * @see #allowVerticalScroll
     */
    get allowHorizontalScroll(): boolean; */
  // Type InteropStaticType.boolean
  set allowHorizontalScroll(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowHorizontalScroll',
      value,
    );
  }

  /* #11481
  source: 
    /**
     * Gets or sets whether the user is allowed to use the vertical scrollbar.
     * The initial value is true.
     * @see #hasVerticalScrollbar
     * @see #allowHorizontalScroll
     */
    get allowVerticalScroll(): boolean; */
  /// Gets or sets whether the user is allowed to use the vertical scrollbar.
  /// The initial value is true.
  _i2.bool get allowVerticalScroll => _i5.getProperty(
        this,
        'allowVerticalScroll',
      );
  /* #11481
  source: 
    /**
     * Gets or sets whether the user is allowed to use the vertical scrollbar.
     * The initial value is true.
     * @see #hasVerticalScrollbar
     * @see #allowHorizontalScroll
     */
    get allowVerticalScroll(): boolean; */
  // Type InteropStaticType.boolean
  set allowVerticalScroll(_i2.bool value) {
    _i5.setProperty(
      this,
      'allowVerticalScroll',
      value,
    );
  }

  /* #11490
  source: 
    /**
     * Gets or sets the distance in screen pixels that the horizontal scrollbar will scroll
     * when scrolling by a line.
     *
     * The default value is 16.
     * @see #scrollVerticalLineChange
     */
    get scrollHorizontalLineChange(): number; */
  /// Gets or sets the distance in screen pixels that the horizontal scrollbar will scroll
  /// when scrolling by a line.
  ///
  /// The default value is 16.
  _i2.num get scrollHorizontalLineChange => _i5.getProperty(
        this,
        'scrollHorizontalLineChange',
      );
  /* #11490
  source: 
    /**
     * Gets or sets the distance in screen pixels that the horizontal scrollbar will scroll
     * when scrolling by a line.
     *
     * The default value is 16.
     * @see #scrollVerticalLineChange
     */
    get scrollHorizontalLineChange(): number; */
  // Type InteropStaticType.number
  set scrollHorizontalLineChange(_i2.num value) {
    _i5.setProperty(
      this,
      'scrollHorizontalLineChange',
      value,
    );
  }

  /* #11499
  source: 
    /**
     * Gets or sets the distance in screen pixels that the vertical scrollbar will scroll
     * when scrolling by a line.
     *
     * The default value is 16.
     * @see #scrollHorizontalLineChange
     */
    get scrollVerticalLineChange(): number; */
  /// Gets or sets the distance in screen pixels that the vertical scrollbar will scroll
  /// when scrolling by a line.
  ///
  /// The default value is 16.
  _i2.num get scrollVerticalLineChange => _i5.getProperty(
        this,
        'scrollVerticalLineChange',
      );
  /* #11499
  source: 
    /**
     * Gets or sets the distance in screen pixels that the vertical scrollbar will scroll
     * when scrolling by a line.
     *
     * The default value is 16.
     * @see #scrollHorizontalLineChange
     */
    get scrollVerticalLineChange(): number; */
  // Type InteropStaticType.number
  set scrollVerticalLineChange(_i2.num value) {
    _i5.setProperty(
      this,
      'scrollVerticalLineChange',
      value,
    );
  }

  /* #11510
  source: 
    /**
     * Gets or sets the last InputEvent that occurred.
     *
     * This property is useful in tools and real-time operations for determining
     * where the mouse pointer was most recently located.
     *
     * Setting this property does not notify about any changed event.
     * @see #firstInput
     */
    get lastInput(): InputEvent; */
  /// Gets or sets the last InputEvent that occurred.
  ///
  /// This property is useful in tools and real-time operations for determining
  /// where the mouse pointer was most recently located.
  ///
  /// Setting this property does not notify about any changed event.
  _i3.InputEvent get lastInput => _i5.getProperty(
        this,
        'lastInput',
      );
  /* #11510
  source: 
    /**
     * Gets or sets the last InputEvent that occurred.
     *
     * This property is useful in tools and real-time operations for determining
     * where the mouse pointer was most recently located.
     *
     * Setting this property does not notify about any changed event.
     * @see #firstInput
     */
    get lastInput(): InputEvent; */
  // Type Instance of 'InteropInterface'
  set lastInput(_i3.InputEvent value) {
    _i5.setProperty(
      this,
      'lastInput',
      value,
    );
  }

  /* #11519
  source: 
    /**
     * Gets or sets the most recent mouse-down InputEvent that occurred.
     *
     * Setting this property does not notify about any changed event.
     * @see #lastInput
     */
    get firstInput(): InputEvent; */
  /// Gets or sets the most recent mouse-down InputEvent that occurred.
  ///
  /// Setting this property does not notify about any changed event.
  _i3.InputEvent get firstInput => _i5.getProperty(
        this,
        'firstInput',
      );
  /* #11519
  source: 
    /**
     * Gets or sets the most recent mouse-down InputEvent that occurred.
     *
     * Setting this property does not notify about any changed event.
     * @see #lastInput
     */
    get firstInput(): InputEvent; */
  // Type Instance of 'InteropInterface'
  set firstInput(_i3.InputEvent value) {
    _i5.setProperty(
      this,
      'firstInput',
      value,
    );
  }

  /* #11541
  source: 
    /**
     * Gets or sets the current cursor for the Diagram, overriding the #defaultCursor.
     *
     * Valid CSS cursors are accepted,
     * such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
     *
     * It is possible to use custom cursors with the syntax "url(path_to_image), default".
     * A fallback (like default here) is necessary for a custom cursor to work.
     *
     * To read more about cursor syntax, go to:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     *
     * If the specified cursor is not accepted by the platform, this property setter will try prepending
     * `-webkit-` and `-moz-` prefixes when assigning the "cursor" CSS style property.
     *
     * Setting this property does not notify about any changed event.
     * Setting this value to the empty string ('') returns the Diagram's cursor to the #defaultCursor.
     * @see #defaultCursor
     * @see GraphObject#cursor
     */
    get currentCursor(): string; */
  /// Gets or sets the current cursor for the Diagram, overriding the #defaultCursor.
  ///
  /// Valid CSS cursors are accepted,
  /// such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
  ///
  /// It is possible to use custom cursors with the syntax "url(path_to_image), default".
  /// A fallback (like default here) is necessary for a custom cursor to work.
  ///
  /// To read more about cursor syntax, go to:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
  ///
  /// If the specified cursor is not accepted by the platform, this property setter will try prepending
  /// `-webkit-` and `-moz-` prefixes when assigning the "cursor" CSS style property.
  ///
  /// Setting this property does not notify about any changed event.
  /// Setting this value to the empty string ('') returns the Diagram's cursor to the #defaultCursor.
  _i2.String get currentCursor => _i5.getProperty(
        this,
        'currentCursor',
      );
  /* #11541
  source: 
    /**
     * Gets or sets the current cursor for the Diagram, overriding the #defaultCursor.
     *
     * Valid CSS cursors are accepted,
     * such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
     *
     * It is possible to use custom cursors with the syntax "url(path_to_image), default".
     * A fallback (like default here) is necessary for a custom cursor to work.
     *
     * To read more about cursor syntax, go to:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     *
     * If the specified cursor is not accepted by the platform, this property setter will try prepending
     * `-webkit-` and `-moz-` prefixes when assigning the "cursor" CSS style property.
     *
     * Setting this property does not notify about any changed event.
     * Setting this value to the empty string ('') returns the Diagram's cursor to the #defaultCursor.
     * @see #defaultCursor
     * @see GraphObject#cursor
     */
    get currentCursor(): string; */
  // Type InteropStaticType.string
  set currentCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'currentCursor',
      value,
    );
  }

  /* #11559
  source: 
    /**
     * Gets or sets the cursor to be used for the Diagram
     * when no GraphObject specifies a different cursor.
     *
     * Valid CSS cursors are accepted,
     * such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
     *
     * It is possible to use custom cursors with the syntax "url(path_to_image), default".
     * A fallback (like default here) is necessary for a custom cursor to work.
     *
     * To read more about cursor syntax, go to:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     * The default value is "auto".
     * @see #currentCursor
     * @see GraphObject#cursor
     */
    get defaultCursor(): string; */
  /// Gets or sets the cursor to be used for the Diagram
  /// when no GraphObject specifies a different cursor.
  ///
  /// Valid CSS cursors are accepted,
  /// such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
  ///
  /// It is possible to use custom cursors with the syntax "url(path_to_image), default".
  /// A fallback (like default here) is necessary for a custom cursor to work.
  ///
  /// To read more about cursor syntax, go to:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
  /// The default value is "auto".
  _i2.String get defaultCursor => _i5.getProperty(
        this,
        'defaultCursor',
      );
  /* #11559
  source: 
    /**
     * Gets or sets the cursor to be used for the Diagram
     * when no GraphObject specifies a different cursor.
     *
     * Valid CSS cursors are accepted,
     * such as "auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", etc.
     *
     * It is possible to use custom cursors with the syntax "url(path_to_image), default".
     * A fallback (like default here) is necessary for a custom cursor to work.
     *
     * To read more about cursor syntax, go to:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     * The default value is "auto".
     * @see #currentCursor
     * @see GraphObject#cursor
     */
    get defaultCursor(): string; */
  // Type InteropStaticType.string
  set defaultCursor(_i2.String value) {
    _i5.setProperty(
      this,
      'defaultCursor',
      value,
    );
  }

  /* #11581
  source: 
    /**
     * Gets or sets the function to execute when the user single-primary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundSingleClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #doubleClick
     * @see #contextClick
     * @see GraphObject#click
     */
    get click(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user single-primary-clicks
  /// on the background of the Diagram.
  /// This typically involves a mouse-down followed by a prompt mouse-up
  /// at approximately the same position using the left (primary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on no object.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name "BackgroundSingleClicked".
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get click => _i5.getProperty(
        this,
        'click',
      );
  /* #11581
  source: 
    /**
     * Gets or sets the function to execute when the user single-primary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundSingleClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #doubleClick
     * @see #contextClick
     * @see GraphObject#click
     */
    get click(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#601092244(parent: InteropGetter#229619056(name: click))
  set click(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'click',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11603
  source: 
    /**
     * Gets or sets the function to execute when the user double-primary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down/up/down/up in rapid succession
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundDoubleClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #click
     * @see #contextClick
     * @see GraphObject#doubleClick
     */
    get doubleClick(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user double-primary-clicks
  /// on the background of the Diagram.
  /// This typically involves a mouse-down/up/down/up in rapid succession
  /// at approximately the same position using the left (primary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on no object.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name "BackgroundDoubleClicked".
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get doubleClick => _i5.getProperty(
        this,
        'doubleClick',
      );
  /* #11603
  source: 
    /**
     * Gets or sets the function to execute when the user double-primary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down/up/down/up in rapid succession
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundDoubleClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #click
     * @see #contextClick
     * @see GraphObject#doubleClick
     */
    get doubleClick(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#1048120000(parent: InteropGetter#32778741(name: doubleClick))
  set doubleClick(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'doubleClick',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11625
  source: 
    /**
     * Gets or sets the function to execute when the user single-secondary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the right (secondary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundContextClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #click
     * @see #doubleClick
     * @see GraphObject#contextClick
     */
    get contextClick(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user single-secondary-clicks
  /// on the background of the Diagram.
  /// This typically involves a mouse-down followed by a prompt mouse-up
  /// at approximately the same position using the right (secondary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on no object.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name "BackgroundContextClicked".
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get contextClick => _i5.getProperty(
        this,
        'contextClick',
      );
  /* #11625
  source: 
    /**
     * Gets or sets the function to execute when the user single-secondary-clicks
     * on the background of the Diagram.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the right (secondary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on no object.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name "BackgroundContextClicked".
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #click
     * @see #doubleClick
     * @see GraphObject#contextClick
     */
    get contextClick(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#1036152112(parent: InteropGetter#208297844(name: contextClick))
  set contextClick(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'contextClick',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11643
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse (pointer) in
     * the background of the Diagram without holding down any buttons,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     * @see #mouseHover
     * @see GraphObject#mouseOver
     */
    get mouseOver(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse (pointer) in
  /// the background of the Diagram without holding down any buttons,
  /// not over any GraphObjects.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  /// After calling this function the diagram will be updated immediately.
  void Function(_i3.InputEvent)? get mouseOver => _i5.getProperty(
        this,
        'mouseOver',
      );
  /* #11643
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse (pointer) in
     * the background of the Diagram without holding down any buttons,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     * @see #mouseHover
     * @see GraphObject#mouseOver
     */
    get mouseOver(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#669336641(parent: InteropGetter#573016794(name: mouseOver))
  set mouseOver(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseOver',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11661
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
     * the background of the Diagram without holding down any buttons,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseOver
     * @see GraphObject#mouseHover
     * @see ToolManager#doMouseHover
     */
    get mouseHover(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
  /// the background of the Diagram without holding down any buttons,
  /// not over any GraphObjects.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get mouseHover => _i5.getProperty(
        this,
        'mouseHover',
      );
  /* #11661
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
     * the background of the Diagram without holding down any buttons,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseOver
     * @see GraphObject#mouseHover
     * @see ToolManager#doMouseHover
     */
    get mouseHover(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#977560263(parent: InteropGetter#258435388(name: mouseHover))
  set mouseHover(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseHover',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11678
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
     * the background of the Diagram while holding down a button,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see GraphObject#mouseHold
     * @see ToolManager#doMouseHover
     */
    get mouseHold(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
  /// the background of the Diagram while holding down a button,
  /// not over any GraphObjects.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get mouseHold => _i5.getProperty(
        this,
        'mouseHold',
      );
  /* #11678
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse (pointer) stationary in
     * the background of the Diagram while holding down a button,
     * not over any GraphObjects.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see GraphObject#mouseHold
     * @see ToolManager#doMouseHover
     */
    get mouseHold(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#919877051(parent: InteropGetter#366339229(name: mouseHold))
  set mouseHold(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseHold',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11709
  source: 
    /**
     * Gets or sets the function to execute when the user is dragging the selection in
     * the background of the Diagram during a DraggingTool drag-and-drop,
     * not over any GraphObjects.
     *
     * If this property value is a function, it is called with an InputEvent.
     * It is called within the transaction performed by the DraggingTool.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, if you want to prevent the user from dropping Parts into the background of the diagram,
     * and want to provide feedback about that during a drag:
     * ```js
     *   myDiagram.mouseDragOver = e => {
     *     myDiagram.currentCursor = "no-drop";
     *   }
     * ```
     * @see #mouseDrop
     * @see GraphObject#mouseDragEnter
     * @see GraphObject#mouseDragLeave
     */
    get mouseDragOver(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user is dragging the selection in
  /// the background of the Diagram during a DraggingTool drag-and-drop,
  /// not over any GraphObjects.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// It is called within the transaction performed by the DraggingTool.
  /// By default this property is null.
  ///
  /// Note that for a drag-and-drop that originates in a different diagram, the target diagram's
  /// selection collection will not be the parts that are being dragged.
  /// Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  /// After calling this function the diagram will be updated immediately.
  ///
  /// For example, if you want to prevent the user from dropping Parts into the background of the diagram,
  /// and want to provide feedback about that during a drag:
  /// ```js
  ///   myDiagram.mouseDragOver = e => {
  ///     myDiagram.currentCursor = "no-drop";
  ///   }
  /// ```
  void Function(_i3.InputEvent)? get mouseDragOver => _i5.getProperty(
        this,
        'mouseDragOver',
      );
  /* #11709
  source: 
    /**
     * Gets or sets the function to execute when the user is dragging the selection in
     * the background of the Diagram during a DraggingTool drag-and-drop,
     * not over any GraphObjects.
     *
     * If this property value is a function, it is called with an InputEvent.
     * It is called within the transaction performed by the DraggingTool.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, if you want to prevent the user from dropping Parts into the background of the diagram,
     * and want to provide feedback about that during a drag:
     * ```js
     *   myDiagram.mouseDragOver = e => {
     *     myDiagram.currentCursor = "no-drop";
     *   }
     * ```
     * @see #mouseDrop
     * @see GraphObject#mouseDragEnter
     * @see GraphObject#mouseDragLeave
     */
    get mouseDragOver(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#1022394154(parent: InteropGetter#974509137(name: mouseDragOver))
  set mouseDragOver(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseDragOver',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11729
  source: 
    /**
     * Gets or sets the function to execute when the user drops the selection in
     * the background of the Diagram at the end of a DraggingTool drag-and-drop,
     * not onto any GraphObjects.
     *
     * If this property value is a function, it is called with an InputEvent.
     * It is called within the transaction performed by the DraggingTool.
     * By default this property is null.
     *
     * For example, if you want to prevent the user from dropping Parts into the background of the diagram:
     * ```js
     *   myDiagram.mouseDrop = e => {
     *     myDiagram.currentTool.doCancel();
     *   }
     * ```
     * @see #mouseDragOver
     * @see GraphObject#mouseDrop
     */
    get mouseDrop(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the user drops the selection in
  /// the background of the Diagram at the end of a DraggingTool drag-and-drop,
  /// not onto any GraphObjects.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// It is called within the transaction performed by the DraggingTool.
  /// By default this property is null.
  ///
  /// For example, if you want to prevent the user from dropping Parts into the background of the diagram:
  /// ```js
  ///   myDiagram.mouseDrop = e => {
  ///     myDiagram.currentTool.doCancel();
  ///   }
  /// ```
  void Function(_i3.InputEvent)? get mouseDrop => _i5.getProperty(
        this,
        'mouseDrop',
      );
  /* #11729
  source: 
    /**
     * Gets or sets the function to execute when the user drops the selection in
     * the background of the Diagram at the end of a DraggingTool drag-and-drop,
     * not onto any GraphObjects.
     *
     * If this property value is a function, it is called with an InputEvent.
     * It is called within the transaction performed by the DraggingTool.
     * By default this property is null.
     *
     * For example, if you want to prevent the user from dropping Parts into the background of the diagram:
     * ```js
     *   myDiagram.mouseDrop = e => {
     *     myDiagram.currentTool.doCancel();
     *   }
     * ```
     * @see #mouseDragOver
     * @see GraphObject#mouseDrop
     */
    get mouseDrop(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#28430358(parent: InteropGetter#965886951(name: mouseDrop))
  set mouseDrop(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseDrop',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11751
  source: 
    /**
     * Gets or sets whether drag-and-drop events may be bubbled up to the diagram if not handled by a part.
     * The default value is false -- each Node or Link that in the diagram needs to define
     * its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
     * event handlers if you want dragging/dropping on a part to act as if the user were acting on the diagram.
     *
     * If set to true, this will call Diagram#mouseDragOver during a drag, even while dragging over top-level parts,
     * and Diagram#mouseDrop will be called even when dropping onto parts.
     *
     * This property will have no impact while dropping on a Group.
     * The Group's mouseDrop and Group#handlesDragDropForMembers should be set if desired.
     *
     * GraphObjects do not have a mouseDragOver property, so if this is set to true, the Diagram's mouseDragOver will
     * always be called, even when dragging over a part.
     * @see #mouseDragOver
     * @see #mouseDrop
     * @see Group#handlesDragDropForMembers
     * @see GraphObject#mouseDrop
     * @since 2.0
     */
    get handlesDragDropForTopLevelParts(): boolean; */
  /// Gets or sets whether drag-and-drop events may be bubbled up to the diagram if not handled by a part.
  /// The default value is false -- each Node or Link that in the diagram needs to define
  /// its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
  /// event handlers if you want dragging/dropping on a part to act as if the user were acting on the diagram.
  ///
  /// If set to true, this will call Diagram#mouseDragOver during a drag, even while dragging over top-level parts,
  /// and Diagram#mouseDrop will be called even when dropping onto parts.
  ///
  /// This property will have no impact while dropping on a Group.
  /// The Group's mouseDrop and Group#handlesDragDropForMembers should be set if desired.
  ///
  /// GraphObjects do not have a mouseDragOver property, so if this is set to true, the Diagram's mouseDragOver will
  /// always be called, even when dragging over a part.
  _i2.bool get handlesDragDropForTopLevelParts => _i5.getProperty(
        this,
        'handlesDragDropForTopLevelParts',
      );
  /* #11751
  source: 
    /**
     * Gets or sets whether drag-and-drop events may be bubbled up to the diagram if not handled by a part.
     * The default value is false -- each Node or Link that in the diagram needs to define
     * its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
     * event handlers if you want dragging/dropping on a part to act as if the user were acting on the diagram.
     *
     * If set to true, this will call Diagram#mouseDragOver during a drag, even while dragging over top-level parts,
     * and Diagram#mouseDrop will be called even when dropping onto parts.
     *
     * This property will have no impact while dropping on a Group.
     * The Group's mouseDrop and Group#handlesDragDropForMembers should be set if desired.
     *
     * GraphObjects do not have a mouseDragOver property, so if this is set to true, the Diagram's mouseDragOver will
     * always be called, even when dragging over a part.
     * @see #mouseDragOver
     * @see #mouseDrop
     * @see Group#handlesDragDropForMembers
     * @see GraphObject#mouseDrop
     * @since 2.0
     */
    get handlesDragDropForTopLevelParts(): boolean; */
  // Type InteropStaticType.boolean
  set handlesDragDropForTopLevelParts(_i2.bool value) {
    _i5.setProperty(
      this,
      'handlesDragDropForTopLevelParts',
      value,
    );
  }

  /* #11767
  source: 
    /**
     * Gets or sets the function to execute when the mouse (pointer) enters the Diagram.
     * (When the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter">mouseEnter</a> event fires on the Diagram canvas.)
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseLeave
     * @see GraphObject#mouseEnter
     * @since 2.0
     */
    get mouseEnter(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the mouse (pointer) enters the Diagram.
  /// (When the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter">mouseEnter</a> event fires on the Diagram canvas.)
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get mouseEnter => _i5.getProperty(
        this,
        'mouseEnter',
      );
  /* #11767
  source: 
    /**
     * Gets or sets the function to execute when the mouse (pointer) enters the Diagram.
     * (When the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter">mouseEnter</a> event fires on the Diagram canvas.)
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseLeave
     * @see GraphObject#mouseEnter
     * @since 2.0
     */
    get mouseEnter(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#470365942(parent: InteropGetter#988250431(name: mouseEnter))
  set mouseEnter(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseEnter',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11782
  source: 
    /**
     * Gets or sets the function to execute when the mouse (pointer) leaves the Diagram.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseEnter
     * @see GraphObject#mouseLeave
     * @since 2.0
     */
    get mouseLeave(): ((e: InputEvent) => void) | null; */
  /// Gets or sets the function to execute when the mouse (pointer) leaves the Diagram.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call #startTransaction and #commitTransaction,
  /// or call #commit.
  void Function(_i3.InputEvent)? get mouseLeave => _i5.getProperty(
        this,
        'mouseLeave',
      );
  /* #11782
  source: 
    /**
     * Gets or sets the function to execute when the mouse (pointer) leaves the Diagram.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call #startTransaction and #commitTransaction,
     * or call #commit.
     * @see #mouseEnter
     * @see GraphObject#mouseLeave
     * @since 2.0
     */
    get mouseLeave(): ((e: InputEvent) => void) | null; */
  // Type InteropUnion#277987047(parent: InteropGetter#533365790(name: mouseLeave))
  set mouseLeave(void Function(_i3.InputEvent)? value) {
    _i5.setProperty(
      this,
      'mouseLeave',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #11800
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the mouse (pointer) stays motionless in the background.
     * The default value is null, which means no tooltip is shown.
     *
     * Here is a simple example:
     * ```js
     *  diagram.toolTip =
     *    $(go.Adornment, "Auto",
     *      $(go.Shape, { fill: "#CCFFCC" }),
     *      $(go.TextBlock, { margin: 4 },
     *        "This diagram lets you control the world.")
     *    );
     * ```
     * @see GraphObject#toolTip
     * @see ToolManager#doToolTip
     */
    get toolTip(): Adornment | HTMLInfo | null; */
  /// This Adornment or HTMLInfo is shown when the mouse (pointer) stays motionless in the background.
  /// The default value is null, which means no tooltip is shown.
  ///
  /// Here is a simple example:
  /// ```js
  ///  diagram.toolTip =
  ///    $(go.Adornment, "Auto",
  ///      $(go.Shape, { fill: "#CCFFCC" }),
  ///      $(go.TextBlock, { margin: 4 },
  ///        "This diagram lets you control the world.")
  ///    );
  /// ```
  _i2.dynamic get toolTip => _i5.getProperty(
        this,
        'toolTip',
      );
  /* #11800
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the mouse (pointer) stays motionless in the background.
     * The default value is null, which means no tooltip is shown.
     *
     * Here is a simple example:
     * ```js
     *  diagram.toolTip =
     *    $(go.Adornment, "Auto",
     *      $(go.Shape, { fill: "#CCFFCC" }),
     *      $(go.TextBlock, { margin: 4 },
     *        "This diagram lets you control the world.")
     *    );
     * ```
     * @see GraphObject#toolTip
     * @see ToolManager#doToolTip
     */
    get toolTip(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#212944134(parent: InteropGetter#515291472(name: toolTip))
  set toolTip(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'toolTip',
      value ?? _i4.undefined,
    );
  }

  /* #11824
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the use context clicks in the background.
     * The default value is null, which means no context menu is shown.
     * On touch devices, a special default context menu will appear even there is no context menu defined.
     * See ContextMenuTool#defaultTouchContextMenu for details.
     *
     * ```js
     *  diagram.contextMenu =
     *    $("ContextMenu",
     *      $("ContextMenuButton",
     *        $(go.TextBlock, "Undo"),
     *        { click: (e, obj) => e.diagram.commandHandler.undo() },
     *        new go.Binding("visible", "", o => o.diagram.commandHandler.canUndo()).ofObject()),
     *      $("ContextMenuButton",
     *        $(go.TextBlock, "Redo"),
     *        { click: (e, obj) => e.diagram.commandHandler.redo() },
     *        new go.Binding("visible", "", o => o.diagram.commandHandler.canRedo()).ofObject())
     *    );
     * ```
     * @see GraphObject#contextMenu
     * @see ContextMenuTool
     */
    get contextMenu(): Adornment | HTMLInfo | null; */
  /// This Adornment or HTMLInfo is shown when the use context clicks in the background.
  /// The default value is null, which means no context menu is shown.
  /// On touch devices, a special default context menu will appear even there is no context menu defined.
  /// See ContextMenuTool#defaultTouchContextMenu for details.
  ///
  /// ```js
  ///  diagram.contextMenu =
  ///    $("ContextMenu",
  ///      $("ContextMenuButton",
  ///        $(go.TextBlock, "Undo"),
  ///        { click: (e, obj) => e.diagram.commandHandler.undo() },
  ///        new go.Binding("visible", "", o => o.diagram.commandHandler.canUndo()).ofObject()),
  ///      $("ContextMenuButton",
  ///        $(go.TextBlock, "Redo"),
  ///        { click: (e, obj) => e.diagram.commandHandler.redo() },
  ///        new go.Binding("visible", "", o => o.diagram.commandHandler.canRedo()).ofObject())
  ///    );
  /// ```
  _i2.dynamic get contextMenu => _i5.getProperty(
        this,
        'contextMenu',
      );
  /* #11824
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the use context clicks in the background.
     * The default value is null, which means no context menu is shown.
     * On touch devices, a special default context menu will appear even there is no context menu defined.
     * See ContextMenuTool#defaultTouchContextMenu for details.
     *
     * ```js
     *  diagram.contextMenu =
     *    $("ContextMenu",
     *      $("ContextMenuButton",
     *        $(go.TextBlock, "Undo"),
     *        { click: (e, obj) => e.diagram.commandHandler.undo() },
     *        new go.Binding("visible", "", o => o.diagram.commandHandler.canUndo()).ofObject()),
     *      $("ContextMenuButton",
     *        $(go.TextBlock, "Redo"),
     *        { click: (e, obj) => e.diagram.commandHandler.redo() },
     *        new go.Binding("visible", "", o => o.diagram.commandHandler.canRedo()).ofObject())
     *    );
     * ```
     * @see GraphObject#contextMenu
     * @see ContextMenuTool
     */
    get contextMenu(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#275480129(parent: InteropGetter#582210206(name: contextMenu))
  set contextMenu(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'contextMenu',
      value ?? _i4.undefined,
    );
  }

  /* #11834
  source: 
    /**
     * Gets or sets the CommandHandler for this Diagram.
     *
     * This is set to a new instance of CommandHandler on Diagram instantiation.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     */
    get commandHandler(): CommandHandler; */
  /// Gets or sets the CommandHandler for this Diagram.
  ///
  /// This is set to a new instance of CommandHandler on Diagram instantiation.
  ///
  /// Setting this property does not notify about any changed event.
  /// The value cannot be null and must not be shared with other Diagrams.
  _i3.CommandHandler get commandHandler => _i5.getProperty(
        this,
        'commandHandler',
      );
  /* #11834
  source: 
    /**
     * Gets or sets the CommandHandler for this Diagram.
     *
     * This is set to a new instance of CommandHandler on Diagram instantiation.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     */
    get commandHandler(): CommandHandler; */
  // Type Instance of 'InteropInterface'
  set commandHandler(_i3.CommandHandler value) {
    _i5.setProperty(
      this,
      'commandHandler',
      value,
    );
  }

  /* #11850
  source: 
    /**
     * Gets or sets the ToolManager for this Diagram.
     * This tool is used for mode-less operation.
     * It is responsible for choosing a particular tool to run as the #currentTool.
     *
     * This tool is normally also the #defaultTool.
     * If you don't want the ToolManager to run at all,
     * replace the #defaultTool with your own tool.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     * If you set this property, you will probably also want to set #defaultTool.
     * @see #defaultTool
     */
    get toolManager(): ToolManager; */
  /// Gets or sets the ToolManager for this Diagram.
  /// This tool is used for mode-less operation.
  /// It is responsible for choosing a particular tool to run as the #currentTool.
  ///
  /// This tool is normally also the #defaultTool.
  /// If you don't want the ToolManager to run at all,
  /// replace the #defaultTool with your own tool.
  ///
  /// Setting this property does not notify about any changed event.
  /// The value cannot be null and must not be shared with other Diagrams.
  /// If you set this property, you will probably also want to set #defaultTool.
  _i3.ToolManager get toolManager => _i5.getProperty(
        this,
        'toolManager',
      );
  /* #11850
  source: 
    /**
     * Gets or sets the ToolManager for this Diagram.
     * This tool is used for mode-less operation.
     * It is responsible for choosing a particular tool to run as the #currentTool.
     *
     * This tool is normally also the #defaultTool.
     * If you don't want the ToolManager to run at all,
     * replace the #defaultTool with your own tool.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     * If you set this property, you will probably also want to set #defaultTool.
     * @see #defaultTool
     */
    get toolManager(): ToolManager; */
  // Type Instance of 'InteropInterface'
  set toolManager(_i3.ToolManager value) {
    _i5.setProperty(
      this,
      'toolManager',
      value,
    );
  }

  /* #11863
  source: 
    /**
     * Gets or sets the default tool for this Diagram that becomes the current tool when the current tool stops.
     * Initially this value is the same tool as #toolManager, which is an instance of ToolManager.
     *
     * Setting this property also sets the #currentTool if the old default tool is the currently running tool.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     * @see #currentTool
     * @see #toolManager
     */
    get defaultTool(): Tool; */
  /// Gets or sets the default tool for this Diagram that becomes the current tool when the current tool stops.
  /// Initially this value is the same tool as #toolManager, which is an instance of ToolManager.
  ///
  /// Setting this property also sets the #currentTool if the old default tool is the currently running tool.
  ///
  /// Setting this property does not notify about any changed event.
  /// The value cannot be null and must not be shared with other Diagrams.
  _i3.Tool get defaultTool => _i5.getProperty(
        this,
        'defaultTool',
      );
  /* #11863
  source: 
    /**
     * Gets or sets the default tool for this Diagram that becomes the current tool when the current tool stops.
     * Initially this value is the same tool as #toolManager, which is an instance of ToolManager.
     *
     * Setting this property also sets the #currentTool if the old default tool is the currently running tool.
     *
     * Setting this property does not notify about any changed event.
     * The value cannot be null and must not be shared with other Diagrams.
     * @see #currentTool
     * @see #toolManager
     */
    get defaultTool(): Tool; */
  // Type Instance of 'InteropInterface'
  set defaultTool(_i3.Tool value) {
    _i5.setProperty(
      this,
      'defaultTool',
      value,
    );
  }

  /* #11885
  source: 
    /**
     * Gets or sets the current tool for this Diagram that handles all input events.
     * This value is frequently replaced by the #toolManager as different tools run.
     *
     * Each Diagram has a number of tools that define its behavior when responding to mouse events.
     * These include ClickSelectingTool, DraggingTool, DragSelectingTool, LinkingTool, and ResizingTool, among others.
     *
     * Initially this is set to the value of #defaultTool.
     * Setting this to a null value is treated as if it were set to the #defaultTool,
     * because there should always be a currently running tool, except when the diagram is being initialized.
     *
     * A ToolManager is the default tool used by a Diagram - it chooses to run one of the other tools
     * depending on the circumstances.
     *
     * Setting this property to a new tool stops the previous current tool
     *
     * Setting this property does not notify about any changed event.
     * @see #defaultTool
     * @see #toolManager
     */
    get currentTool(): Tool; */
  /// Gets or sets the current tool for this Diagram that handles all input events.
  /// This value is frequently replaced by the #toolManager as different tools run.
  ///
  /// Each Diagram has a number of tools that define its behavior when responding to mouse events.
  /// These include ClickSelectingTool, DraggingTool, DragSelectingTool, LinkingTool, and ResizingTool, among others.
  ///
  /// Initially this is set to the value of #defaultTool.
  /// Setting this to a null value is treated as if it were set to the #defaultTool,
  /// because there should always be a currently running tool, except when the diagram is being initialized.
  ///
  /// A ToolManager is the default tool used by a Diagram - it chooses to run one of the other tools
  /// depending on the circumstances.
  ///
  /// Setting this property to a new tool stops the previous current tool
  ///
  /// Setting this property does not notify about any changed event.
  _i3.Tool get currentTool => _i5.getProperty(
        this,
        'currentTool',
      );
  /* #11885
  source: 
    /**
     * Gets or sets the current tool for this Diagram that handles all input events.
     * This value is frequently replaced by the #toolManager as different tools run.
     *
     * Each Diagram has a number of tools that define its behavior when responding to mouse events.
     * These include ClickSelectingTool, DraggingTool, DragSelectingTool, LinkingTool, and ResizingTool, among others.
     *
     * Initially this is set to the value of #defaultTool.
     * Setting this to a null value is treated as if it were set to the #defaultTool,
     * because there should always be a currently running tool, except when the diagram is being initialized.
     *
     * A ToolManager is the default tool used by a Diagram - it chooses to run one of the other tools
     * depending on the circumstances.
     *
     * Setting this property to a new tool stops the previous current tool
     *
     * Setting this property does not notify about any changed event.
     * @see #defaultTool
     * @see #toolManager
     */
    get currentTool(): Tool; */
  // Type Instance of 'InteropInterface'
  set currentTool(_i3.Tool value) {
    _i5.setProperty(
      this,
      'currentTool',
      value,
    );
  }

  /* #11906
  source: 
    /**
     * This read-only property returns the read-only collection of selected objects.
     * Most commands and many tools operate on this collection.
     *
     * Do not modify this collection.
     * If you want to select or deselect a particular object in a Diagram,
     * set the Part#isSelected property.
     * If you want to select a collection of Parts, call #selectCollection.
     * If you want to deselect all objects, call #clearSelection.
     * If you want to deselect all objects and select a single object, call #select.
     *
     * You can limit how many objects the user can select by setting #maxSelectionCount.
     *
     * There are also DiagramEvents for "ChangingSelection" and "ChangedSelection",
     * which are raised by commands and tools before and after changes to this selection collection.
     *
     * Note that selection collection and Part#isSelected property are completely independent
     * of the #highlighteds collection and the Part#isHighlighted property.
     */
    get selection(): Set<Part>; */
  /// This read-only property returns the read-only collection of selected objects.
  /// Most commands and many tools operate on this collection.
  ///
  /// Do not modify this collection.
  /// If you want to select or deselect a particular object in a Diagram,
  /// set the Part#isSelected property.
  /// If you want to select a collection of Parts, call #selectCollection.
  /// If you want to deselect all objects, call #clearSelection.
  /// If you want to deselect all objects and select a single object, call #select.
  ///
  /// You can limit how many objects the user can select by setting #maxSelectionCount.
  ///
  /// There are also DiagramEvents for "ChangingSelection" and "ChangedSelection",
  /// which are raised by commands and tools before and after changes to this selection collection.
  ///
  /// Note that selection collection and Part#isSelected property are completely independent
  /// of the #highlighteds collection and the Part#isHighlighted property.
  _i3.Set<_i3.Part> get selection => _i5.getProperty(
        this,
        'selection',
      );
  /* #11906
  source: 
    /**
     * This read-only property returns the read-only collection of selected objects.
     * Most commands and many tools operate on this collection.
     *
     * Do not modify this collection.
     * If you want to select or deselect a particular object in a Diagram,
     * set the Part#isSelected property.
     * If you want to select a collection of Parts, call #selectCollection.
     * If you want to deselect all objects, call #clearSelection.
     * If you want to deselect all objects and select a single object, call #select.
     *
     * You can limit how many objects the user can select by setting #maxSelectionCount.
     *
     * There are also DiagramEvents for "ChangingSelection" and "ChangedSelection",
     * which are raised by commands and tools before and after changes to this selection collection.
     *
     * Note that selection collection and Part#isSelected property are completely independent
     * of the #highlighteds collection and the Part#isHighlighted property.
     */
    get selection(): Set<Part>; */
  // Type Instance of 'InteropInterface'
  set selection(_i3.Set<_i3.Part> value) {
    _i5.setProperty(
      this,
      'selection',
      value,
    );
  }

  /* #11914
  source: 
    /**
     * Gets or sets the maximum number of selected objects.
     * The default value is a large positive integer.
     * Values must be non-negative.
     * Decreasing this value may cause objects to be removed from #selection
     * in order to meet the new lower limit.
     */
    get maxSelectionCount(): number; */
  /// Gets or sets the maximum number of selected objects.
  /// The default value is a large positive integer.
  /// Values must be non-negative.
  /// Decreasing this value may cause objects to be removed from #selection
  /// in order to meet the new lower limit.
  _i2.num get maxSelectionCount => _i5.getProperty(
        this,
        'maxSelectionCount',
      );
  /* #11914
  source: 
    /**
     * Gets or sets the maximum number of selected objects.
     * The default value is a large positive integer.
     * Values must be non-negative.
     * Decreasing this value may cause objects to be removed from #selection
     * in order to meet the new lower limit.
     */
    get maxSelectionCount(): number; */
  // Type InteropStaticType.number
  set maxSelectionCount(_i2.num value) {
    _i5.setProperty(
      this,
      'maxSelectionCount',
      value,
    );
  }

  /* #11924
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Parts other than Groups or Links.
     *
     * Each Node or simple Part can have its own Part#selectionAdornmentTemplate,
     * which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get nodeSelectionAdornmentTemplate(): Adornment; */
  /// Gets or sets the default selection Adornment template, used to adorn selected Parts other than Groups or Links.
  ///
  /// Each Node or simple Part can have its own Part#selectionAdornmentTemplate,
  /// which if non-null will take precedence over this Diagram property.
  ///
  /// This Adornment must not be in the visual tree of any Diagram.
  _i3.Adornment get nodeSelectionAdornmentTemplate => _i5.getProperty(
        this,
        'nodeSelectionAdornmentTemplate',
      );
  /* #11924
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Parts other than Groups or Links.
     *
     * Each Node or simple Part can have its own Part#selectionAdornmentTemplate,
     * which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get nodeSelectionAdornmentTemplate(): Adornment; */
  // Type Instance of 'InteropInterface'
  set nodeSelectionAdornmentTemplate(_i3.Adornment value) {
    _i5.setProperty(
      this,
      'nodeSelectionAdornmentTemplate',
      value,
    );
  }

  /* #11933
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Groups.
     *
     * Each Group can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get groupSelectionAdornmentTemplate(): Adornment; */
  /// Gets or sets the default selection Adornment template, used to adorn selected Groups.
  ///
  /// Each Group can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
  ///
  /// This Adornment must not be in the visual tree of any Diagram.
  _i3.Adornment get groupSelectionAdornmentTemplate => _i5.getProperty(
        this,
        'groupSelectionAdornmentTemplate',
      );
  /* #11933
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Groups.
     *
     * Each Group can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get groupSelectionAdornmentTemplate(): Adornment; */
  // Type Instance of 'InteropInterface'
  set groupSelectionAdornmentTemplate(_i3.Adornment value) {
    _i5.setProperty(
      this,
      'groupSelectionAdornmentTemplate',
      value,
    );
  }

  /* #11942
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Links.
     *
     * Each Link can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get linkSelectionAdornmentTemplate(): Adornment; */
  /// Gets or sets the default selection Adornment template, used to adorn selected Links.
  ///
  /// Each Link can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
  ///
  /// This Adornment must not be in the visual tree of any Diagram.
  _i3.Adornment get linkSelectionAdornmentTemplate => _i5.getProperty(
        this,
        'linkSelectionAdornmentTemplate',
      );
  /* #11942
  source: 
    /**
     * Gets or sets the default selection Adornment template, used to adorn selected Links.
     *
     * Each Link can have its own Part#selectionAdornmentTemplate, which if non-null will take precedence over this Diagram property.
     *
     * This Adornment must not be in the visual tree of any Diagram.
     */
    get linkSelectionAdornmentTemplate(): Adornment; */
  // Type Instance of 'InteropInterface'
  set linkSelectionAdornmentTemplate(_i3.Adornment value) {
    _i5.setProperty(
      this,
      'linkSelectionAdornmentTemplate',
      value,
    );
  }

  /* #11958
  source: 
    /**
     * This read-only property returns the read-only collection of highlighted parts.
     *
     * Do not modify this collection.
     * If you want to highlight or remove the highlight for a particular Part in a Diagram,
     * set the Part#isHighlighted property.
     * If you want to highlight a collection of Parts, call #highlightCollection.
     * If you want to remove all highlights and highlight a single object, call #highlight.
     * If you want to remove all highlights, call #clearHighlighteds.
     *
     * Note that highlighteds collection and Part#isHighlighted property are completely independent
     * of the #selection collection and the Part#isSelected property.
     * No predefined command or tool operates on this highlighteds collection.
     */
    get highlighteds(): Set<Part>; */
  /// This read-only property returns the read-only collection of highlighted parts.
  ///
  /// Do not modify this collection.
  /// If you want to highlight or remove the highlight for a particular Part in a Diagram,
  /// set the Part#isHighlighted property.
  /// If you want to highlight a collection of Parts, call #highlightCollection.
  /// If you want to remove all highlights and highlight a single object, call #highlight.
  /// If you want to remove all highlights, call #clearHighlighteds.
  ///
  /// Note that highlighteds collection and Part#isHighlighted property are completely independent
  /// of the #selection collection and the Part#isSelected property.
  /// No predefined command or tool operates on this highlighteds collection.
  _i3.Set<_i3.Part> get highlighteds => _i5.getProperty(
        this,
        'highlighteds',
      );
  /* #11958
  source: 
    /**
     * This read-only property returns the read-only collection of highlighted parts.
     *
     * Do not modify this collection.
     * If you want to highlight or remove the highlight for a particular Part in a Diagram,
     * set the Part#isHighlighted property.
     * If you want to highlight a collection of Parts, call #highlightCollection.
     * If you want to remove all highlights and highlight a single object, call #highlight.
     * If you want to remove all highlights, call #clearHighlighteds.
     *
     * Note that highlighteds collection and Part#isHighlighted property are completely independent
     * of the #selection collection and the Part#isSelected property.
     * No predefined command or tool operates on this highlighteds collection.
     */
    get highlighteds(): Set<Part>; */
  // Type Instance of 'InteropInterface'
  set highlighteds(_i3.Set<_i3.Part> value) {
    _i5.setProperty(
      this,
      'highlighteds',
      value,
    );
  }

  /* #11973
  source: 
    /**
     * Gets or sets whether this Diagram's state has been modified.
     * Setting this property does not notify about any changed event,
     * but it does raise the "Modified" DiagramEvent,
     * although perhaps not immediately.
     *
     * Returns true if the Diagram has been changed,
     * if the #undoManager has recorded any changes, or
     * if an undo has been performed without a corresponding redo.
     *
     * Replacing the #model automatically sets this property to false after the initial layout has completed.
     * The "Modified" DiagramEvent is also raised when an undo or a redo has finished.
     * A "Modified" DiagramEvent listener must not modify this Diagram or its Model.
     */
    get isModified(): boolean; */
  /// Gets or sets whether this Diagram's state has been modified.
  /// Setting this property does not notify about any changed event,
  /// but it does raise the "Modified" DiagramEvent,
  /// although perhaps not immediately.
  ///
  /// Returns true if the Diagram has been changed,
  /// if the #undoManager has recorded any changes, or
  /// if an undo has been performed without a corresponding redo.
  ///
  /// Replacing the #model automatically sets this property to false after the initial layout has completed.
  /// The "Modified" DiagramEvent is also raised when an undo or a redo has finished.
  /// A "Modified" DiagramEvent listener must not modify this Diagram or its Model.
  _i2.bool get isModified => _i5.getProperty(
        this,
        'isModified',
      );
  /* #11973
  source: 
    /**
     * Gets or sets whether this Diagram's state has been modified.
     * Setting this property does not notify about any changed event,
     * but it does raise the "Modified" DiagramEvent,
     * although perhaps not immediately.
     *
     * Returns true if the Diagram has been changed,
     * if the #undoManager has recorded any changes, or
     * if an undo has been performed without a corresponding redo.
     *
     * Replacing the #model automatically sets this property to false after the initial layout has completed.
     * The "Modified" DiagramEvent is also raised when an undo or a redo has finished.
     * A "Modified" DiagramEvent listener must not modify this Diagram or its Model.
     */
    get isModified(): boolean; */
  // Type InteropStaticType.boolean
  set isModified(_i2.bool value) {
    _i5.setProperty(
      this,
      'isModified',
      value,
    );
  }

  /* #11999
  source: 
    /**
     * Gets or sets the Model holding data corresponding to the
     * data-bound nodes and links of this Diagram.
     *
     * Replacing this value causes all of the bound Nodes and Links to be deleted and re-created
     * from the new model data.
     *
     * Models may be shared by multiple Diagrams. One common approach is to have two
     * Diagrams displaying the same Model but using different templates
     * (see #nodeTemplate, #nodeTemplateMap, and the associated link and group properties) and sometimes even different Layouts.
     *
     * Setting this property does not notify about any changed event; the new value must not be null.
     * Typically a new Model will have its own UndoManager, thereby replacing the Diagram's
     * current UndoManager.
     *
     * Replacing or re-setting the model will re-initialize the Diagram, taking in to account
     * #initialPosition, #initialScale, #initialAutoScale, and #initialContentAlignment.
     * It will also set #isModified to false.
     *
     * The default behavior when replacing the model is to copy a few UndoManager properties to the
     * new UndoManager, including UndoManager#isEnabled and UndoManager#maxHistoryLength.
     *
     * It is an error to replace the Diagram.model while a transaction is in progress.
     */
    get model(): Model; */
  /// Gets or sets the Model holding data corresponding to the
  /// data-bound nodes and links of this Diagram.
  ///
  /// Replacing this value causes all of the bound Nodes and Links to be deleted and re-created
  /// from the new model data.
  ///
  /// Models may be shared by multiple Diagrams. One common approach is to have two
  /// Diagrams displaying the same Model but using different templates
  /// (see #nodeTemplate, #nodeTemplateMap, and the associated link and group properties) and sometimes even different Layouts.
  ///
  /// Setting this property does not notify about any changed event; the new value must not be null.
  /// Typically a new Model will have its own UndoManager, thereby replacing the Diagram's
  /// current UndoManager.
  ///
  /// Replacing or re-setting the model will re-initialize the Diagram, taking in to account
  /// #initialPosition, #initialScale, #initialAutoScale, and #initialContentAlignment.
  /// It will also set #isModified to false.
  ///
  /// The default behavior when replacing the model is to copy a few UndoManager properties to the
  /// new UndoManager, including UndoManager#isEnabled and UndoManager#maxHistoryLength.
  ///
  /// It is an error to replace the Diagram.model while a transaction is in progress.
  _i3.Model get model => _i5.getProperty(
        this,
        'model',
      );
  /* #11999
  source: 
    /**
     * Gets or sets the Model holding data corresponding to the
     * data-bound nodes and links of this Diagram.
     *
     * Replacing this value causes all of the bound Nodes and Links to be deleted and re-created
     * from the new model data.
     *
     * Models may be shared by multiple Diagrams. One common approach is to have two
     * Diagrams displaying the same Model but using different templates
     * (see #nodeTemplate, #nodeTemplateMap, and the associated link and group properties) and sometimes even different Layouts.
     *
     * Setting this property does not notify about any changed event; the new value must not be null.
     * Typically a new Model will have its own UndoManager, thereby replacing the Diagram's
     * current UndoManager.
     *
     * Replacing or re-setting the model will re-initialize the Diagram, taking in to account
     * #initialPosition, #initialScale, #initialAutoScale, and #initialContentAlignment.
     * It will also set #isModified to false.
     *
     * The default behavior when replacing the model is to copy a few UndoManager properties to the
     * new UndoManager, including UndoManager#isEnabled and UndoManager#maxHistoryLength.
     *
     * It is an error to replace the Diagram.model while a transaction is in progress.
     */
    get model(): Model; */
  // Type Instance of 'InteropInterface'
  set model(_i3.Model value) {
    _i5.setProperty(
      this,
      'model',
      value,
    );
  }

  /* #12148
  source: 
    /**
     * Gets or sets the default Node template used as the archetype
     * for node data that is added to the #model.
     * Setting this property just modifies the #nodeTemplateMap
     * by replacing the entry named with the empty string.
     *
     * The value must not be null.
     * The template may be either a Node or a simple Part,
     * but not a Link or a Group.
     *
     * This Part must not be in the visual tree of any Diagram.
     */
    get nodeTemplate(): Part; */
  /// Gets or sets the default Node template used as the archetype
  /// for node data that is added to the #model.
  /// Setting this property just modifies the #nodeTemplateMap
  /// by replacing the entry named with the empty string.
  ///
  /// The value must not be null.
  /// The template may be either a Node or a simple Part,
  /// but not a Link or a Group.
  ///
  /// This Part must not be in the visual tree of any Diagram.
  _i3.Part get nodeTemplate => _i5.getProperty(
        this,
        'nodeTemplate',
      );
  /* #12148
  source: 
    /**
     * Gets or sets the default Node template used as the archetype
     * for node data that is added to the #model.
     * Setting this property just modifies the #nodeTemplateMap
     * by replacing the entry named with the empty string.
     *
     * The value must not be null.
     * The template may be either a Node or a simple Part,
     * but not a Link or a Group.
     *
     * This Part must not be in the visual tree of any Diagram.
     */
    get nodeTemplate(): Part; */
  // Type Instance of 'InteropInterface'
  set nodeTemplate(_i3.Part value) {
    _i5.setProperty(
      this,
      'nodeTemplate',
      value,
    );
  }

  /* #12164
  source: 
    /**
     * Gets or sets a Map mapping template names to Parts.
     * These nodes are copied for each node data that is added to the #model.
     *
     * The new value must not be null and must contain Nodes or simple Parts.
     * These Parts must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Node or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     * Any new map values must not be Links or Groups.
     *
     * If you want to create Groups, use #groupTemplateMap instead.
     */
    get nodeTemplateMap(): Map<string, Part>; */
  /// Gets or sets a Map mapping template names to Parts.
  /// These nodes are copied for each node data that is added to the #model.
  ///
  /// The new value must not be null and must contain Nodes or simple Parts.
  /// These Parts must not be in the visual tree of any Diagram.
  /// Replacing this Map will automatically call #rebuildParts.
  ///
  /// If you modify this Map, by replacing a Node or by adding or
  /// removing a map entry, you need to explicitly call #rebuildParts afterwards.
  /// Any new map values must not be Links or Groups.
  ///
  /// If you want to create Groups, use #groupTemplateMap instead.
  _i3.Map<_i2.String, _i3.Part> get nodeTemplateMap => _i5.getProperty(
        this,
        'nodeTemplateMap',
      );
  /* #12164
  source: 
    /**
     * Gets or sets a Map mapping template names to Parts.
     * These nodes are copied for each node data that is added to the #model.
     *
     * The new value must not be null and must contain Nodes or simple Parts.
     * These Parts must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Node or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     * Any new map values must not be Links or Groups.
     *
     * If you want to create Groups, use #groupTemplateMap instead.
     */
    get nodeTemplateMap(): Map<string, Part>; */
  // Type Instance of 'InteropInterface'
  set nodeTemplateMap(_i3.Map<_i2.String, _i3.Part> value) {
    _i5.setProperty(
      this,
      'nodeTemplateMap',
      value,
    );
  }

  /* #12175
  source: 
    /**
     * Gets or sets the default Group template used as the archetype
     * for group data that is added to the #model.
     *
     * Setting this property just modifies the #groupTemplateMap
     * by replacing the entry named with the empty string.
     * The value must not be null and must be a Group, not a Node or simple Part.
     * This Part must not be in the visual tree of any Diagram.
     */
    get groupTemplate(): Group; */
  /// Gets or sets the default Group template used as the archetype
  /// for group data that is added to the #model.
  ///
  /// Setting this property just modifies the #groupTemplateMap
  /// by replacing the entry named with the empty string.
  /// The value must not be null and must be a Group, not a Node or simple Part.
  /// This Part must not be in the visual tree of any Diagram.
  _i3.Group get groupTemplate => _i5.getProperty(
        this,
        'groupTemplate',
      );
  /* #12175
  source: 
    /**
     * Gets or sets the default Group template used as the archetype
     * for group data that is added to the #model.
     *
     * Setting this property just modifies the #groupTemplateMap
     * by replacing the entry named with the empty string.
     * The value must not be null and must be a Group, not a Node or simple Part.
     * This Part must not be in the visual tree of any Diagram.
     */
    get groupTemplate(): Group; */
  // Type Instance of 'InteropInterface'
  set groupTemplate(_i3.Group value) {
    _i5.setProperty(
      this,
      'groupTemplate',
      value,
    );
  }

  /* #12188
  source: 
    /**
     * Gets or sets a Map mapping template names to Groups.
     * These groups are copied for each group data that is added to the #model.
     *
     * The new value must not be null, nor may it contain a Node or Link or simple Part.
     * The Links must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Group in it or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     */
    get groupTemplateMap(): Map<string, Group>; */
  /// Gets or sets a Map mapping template names to Groups.
  /// These groups are copied for each group data that is added to the #model.
  ///
  /// The new value must not be null, nor may it contain a Node or Link or simple Part.
  /// The Links must not be in the visual tree of any Diagram.
  /// Replacing this Map will automatically call #rebuildParts.
  ///
  /// If you modify this Map, by replacing a Group in it or by adding or
  /// removing a map entry, you need to explicitly call #rebuildParts afterwards.
  _i3.Map<_i2.String, _i3.Group> get groupTemplateMap => _i5.getProperty(
        this,
        'groupTemplateMap',
      );
  /* #12188
  source: 
    /**
     * Gets or sets a Map mapping template names to Groups.
     * These groups are copied for each group data that is added to the #model.
     *
     * The new value must not be null, nor may it contain a Node or Link or simple Part.
     * The Links must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Group in it or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     */
    get groupTemplateMap(): Map<string, Group>; */
  // Type Instance of 'InteropInterface'
  set groupTemplateMap(_i3.Map<_i2.String, _i3.Group> value) {
    _i5.setProperty(
      this,
      'groupTemplateMap',
      value,
    );
  }

  /* #12199
  source: 
    /**
     * Gets or sets the default Link template used as the archetype
     * for link data that is added to the #model.
     *
     * Setting this property just modifies the #linkTemplateMap
     * by replacing the entry named with the empty string.
     * The value must not be null and must be a Link, not a Node or simple Part.
     * This Link must not be in the visual tree of any Diagram.
     */
    get linkTemplate(): Link; */
  /// Gets or sets the default Link template used as the archetype
  /// for link data that is added to the #model.
  ///
  /// Setting this property just modifies the #linkTemplateMap
  /// by replacing the entry named with the empty string.
  /// The value must not be null and must be a Link, not a Node or simple Part.
  /// This Link must not be in the visual tree of any Diagram.
  _i3.Link get linkTemplate => _i5.getProperty(
        this,
        'linkTemplate',
      );
  /* #12199
  source: 
    /**
     * Gets or sets the default Link template used as the archetype
     * for link data that is added to the #model.
     *
     * Setting this property just modifies the #linkTemplateMap
     * by replacing the entry named with the empty string.
     * The value must not be null and must be a Link, not a Node or simple Part.
     * This Link must not be in the visual tree of any Diagram.
     */
    get linkTemplate(): Link; */
  // Type Instance of 'InteropInterface'
  set linkTemplate(_i3.Link value) {
    _i5.setProperty(
      this,
      'linkTemplate',
      value,
    );
  }

  /* #12212
  source: 
    /**
     * Gets or sets a Map mapping template names to Links.
     * These links are copied for each link data that is added to the #model.
     *
     * The new value must not be null and must contain only Links, not Nodes or simple Parts.
     * The Links must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Link in it or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     */
    get linkTemplateMap(): Map<string, Link>; */
  /// Gets or sets a Map mapping template names to Links.
  /// These links are copied for each link data that is added to the #model.
  ///
  /// The new value must not be null and must contain only Links, not Nodes or simple Parts.
  /// The Links must not be in the visual tree of any Diagram.
  /// Replacing this Map will automatically call #rebuildParts.
  ///
  /// If you modify this Map, by replacing a Link in it or by adding or
  /// removing a map entry, you need to explicitly call #rebuildParts afterwards.
  _i3.Map<_i2.String, _i3.Link> get linkTemplateMap => _i5.getProperty(
        this,
        'linkTemplateMap',
      );
  /* #12212
  source: 
    /**
     * Gets or sets a Map mapping template names to Links.
     * These links are copied for each link data that is added to the #model.
     *
     * The new value must not be null and must contain only Links, not Nodes or simple Parts.
     * The Links must not be in the visual tree of any Diagram.
     * Replacing this Map will automatically call #rebuildParts.
     *
     * If you modify this Map, by replacing a Link in it or by adding or
     * removing a map entry, you need to explicitly call #rebuildParts afterwards.
     */
    get linkTemplateMap(): Map<string, Link>; */
  // Type Instance of 'InteropInterface'
  set linkTemplateMap(_i3.Map<_i2.String, _i3.Link> value) {
    _i5.setProperty(
      this,
      'linkTemplateMap',
      value,
    );
  }

  /* #12219
  source: 
    /**
     * Gets or sets whether mouse events initiated within the Diagram will be captured.
     * The initial value is true.
     * Setting this property does not notify about any changed event.
     */
    get isMouseCaptured(): boolean; */
  /// Gets or sets whether mouse events initiated within the Diagram will be captured.
  /// The initial value is true.
  /// Setting this property does not notify about any changed event.
  _i2.bool get isMouseCaptured => _i5.getProperty(
        this,
        'isMouseCaptured',
      );
  /* #12219
  source: 
    /**
     * Gets or sets whether mouse events initiated within the Diagram will be captured.
     * The initial value is true.
     * Setting this property does not notify about any changed event.
     */
    get isMouseCaptured(): boolean; */
  // Type InteropStaticType.boolean
  set isMouseCaptured(_i2.bool value) {
    _i5.setProperty(
      this,
      'isMouseCaptured',
      value,
    );
  }

  /* #12240
  source: 
    /**
     * Gets or sets the coordinates of this Diagram in the viewport.
     * Value must be of type Point in document coordinates.
     * The default is Point(NaN, NaN), but is typically set to a real value when a Diagram is initialized.
     *
     * Scrolling and panning the Diagram modify the Diagram's position.
     *
     * Setting this property does not notify about any changed event.
     * However you can listen with #addDiagramListener for a DiagramEvent
     * with the name "ViewportBoundsChanged".
     *
     * The #viewportBounds x and y values are always the same as the Diagram's position values.
     *
     * If you set this property any replacement of the #model will result in a layout
     * and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
     * and zoomed, depending on various Diagram properties named "initial...".
     * You may want to set #initialPosition instead of setting this property around the time
     * that you are loading a model.
     */
    get position(): Point; */
  /// Gets or sets the coordinates of this Diagram in the viewport.
  /// Value must be of type Point in document coordinates.
  /// The default is Point(NaN, NaN), but is typically set to a real value when a Diagram is initialized.
  ///
  /// Scrolling and panning the Diagram modify the Diagram's position.
  ///
  /// Setting this property does not notify about any changed event.
  /// However you can listen with #addDiagramListener for a DiagramEvent
  /// with the name "ViewportBoundsChanged".
  ///
  /// The #viewportBounds x and y values are always the same as the Diagram's position values.
  ///
  /// If you set this property any replacement of the #model will result in a layout
  /// and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
  /// and zoomed, depending on various Diagram properties named "initial...".
  /// You may want to set #initialPosition instead of setting this property around the time
  /// that you are loading a model.
  _i3.Point get position => _i5.getProperty(
        this,
        'position',
      );
  /* #12240
  source: 
    /**
     * Gets or sets the coordinates of this Diagram in the viewport.
     * Value must be of type Point in document coordinates.
     * The default is Point(NaN, NaN), but is typically set to a real value when a Diagram is initialized.
     *
     * Scrolling and panning the Diagram modify the Diagram's position.
     *
     * Setting this property does not notify about any changed event.
     * However you can listen with #addDiagramListener for a DiagramEvent
     * with the name "ViewportBoundsChanged".
     *
     * The #viewportBounds x and y values are always the same as the Diagram's position values.
     *
     * If you set this property any replacement of the #model will result in a layout
     * and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
     * and zoomed, depending on various Diagram properties named "initial...".
     * You may want to set #initialPosition instead of setting this property around the time
     * that you are loading a model.
     */
    get position(): Point; */
  // Type Instance of 'InteropInterface'
  set position(_i3.Point value) {
    _i5.setProperty(
      this,
      'position',
      value,
    );
  }

  /* #12256
  source: 
    /**
     * Gets or sets the initial coordinates of this Diagram in the viewport, eventually setting the #position.
     * This value is relevant on initialization of a #model or if #delayInitialization is called.
     * Value must be of type Point in document coordinates.
     * The default is Point(NaN, NaN).
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that sets #position.
     *
     * Setting this property does not notify about any changed event.
     * @see #initialDocumentSpot
     * @see #initialViewportSpot
     * @since 1.1
     */
    get initialPosition(): Point; */
  /// Gets or sets the initial coordinates of this Diagram in the viewport, eventually setting the #position.
  /// This value is relevant on initialization of a #model or if #delayInitialization is called.
  /// Value must be of type Point in document coordinates.
  /// The default is Point(NaN, NaN).
  ///
  /// Setting this property has the same effect as implementing
  /// an "InitialLayoutCompleted" DiagramEvent listener that sets #position.
  ///
  /// Setting this property does not notify about any changed event.
  _i3.Point get initialPosition => _i5.getProperty(
        this,
        'initialPosition',
      );
  /* #12256
  source: 
    /**
     * Gets or sets the initial coordinates of this Diagram in the viewport, eventually setting the #position.
     * This value is relevant on initialization of a #model or if #delayInitialization is called.
     * Value must be of type Point in document coordinates.
     * The default is Point(NaN, NaN).
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that sets #position.
     *
     * Setting this property does not notify about any changed event.
     * @see #initialDocumentSpot
     * @see #initialViewportSpot
     * @since 1.1
     */
    get initialPosition(): Point; */
  // Type Instance of 'InteropInterface'
  set initialPosition(_i3.Point value) {
    _i5.setProperty(
      this,
      'initialPosition',
      value,
    );
  }

  /* #12267
  source: 
    /**
     * Gets or sets the initial scale of this Diagram in the viewport, eventually setting the #scale.
     * This value is relevant on initialization of a #model or if #delayInitialization is called.
     * The default is NaN.
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that sets #scale.
     * @since 1.1
     */
    get initialScale(): number; */
  /// Gets or sets the initial scale of this Diagram in the viewport, eventually setting the #scale.
  /// This value is relevant on initialization of a #model or if #delayInitialization is called.
  /// The default is NaN.
  ///
  /// Setting this property has the same effect as implementing
  /// an "InitialLayoutCompleted" DiagramEvent listener that sets #scale.
  _i2.num get initialScale => _i5.getProperty(
        this,
        'initialScale',
      );
  /* #12267
  source: 
    /**
     * Gets or sets the initial scale of this Diagram in the viewport, eventually setting the #scale.
     * This value is relevant on initialization of a #model or if #delayInitialization is called.
     * The default is NaN.
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that sets #scale.
     * @since 1.1
     */
    get initialScale(): number; */
  // Type InteropStaticType.number
  set initialScale(_i2.num value) {
    _i5.setProperty(
      this,
      'initialScale',
      value,
    );
  }

  /* #12273
  source: 
    /**
     * Gets or sets a Panel of type Panel.Grid acting as the background grid
     * extending across the whole viewport of this diagram.
     */
    get grid(): Panel; */
  /// Gets or sets a Panel of type Panel.Grid acting as the background grid
  /// extending across the whole viewport of this diagram.
  _i3.Panel get grid => _i5.getProperty(
        this,
        'grid',
      );
  /* #12273
  source: 
    /**
     * Gets or sets a Panel of type Panel.Grid acting as the background grid
     * extending across the whole viewport of this diagram.
     */
    get grid(): Panel; */
  // Type Instance of 'InteropInterface'
  set grid(_i3.Panel value) {
    _i5.setProperty(
      this,
      'grid',
      value,
    );
  }

  /* #12283
  source: 
    /**
     * This read-only property returns the bounds of the portion of the Diagram in document coordinates that is viewable from its HTML Canvas.
     * Typically when the viewport bounds are smaller than the #documentBounds, the user can scroll or pan the view.
     *
     * The x and y coordinates are equal to the #position of the Diagram,
     * and the width and height are equal to the Diagram's canvas width and height,
     * divided by the #scale.
     */
    get viewportBounds(): Rect; */
  /// This read-only property returns the bounds of the portion of the Diagram in document coordinates that is viewable from its HTML Canvas.
  /// Typically when the viewport bounds are smaller than the #documentBounds, the user can scroll or pan the view.
  ///
  /// The x and y coordinates are equal to the #position of the Diagram,
  /// and the width and height are equal to the Diagram's canvas width and height,
  /// divided by the #scale.
  _i3.Rect get viewportBounds => _i5.getProperty(
        this,
        'viewportBounds',
      );
  /* #12283
  source: 
    /**
     * This read-only property returns the bounds of the portion of the Diagram in document coordinates that is viewable from its HTML Canvas.
     * Typically when the viewport bounds are smaller than the #documentBounds, the user can scroll or pan the view.
     *
     * The x and y coordinates are equal to the #position of the Diagram,
     * and the width and height are equal to the Diagram's canvas width and height,
     * divided by the #scale.
     */
    get viewportBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set viewportBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'viewportBounds',
      value,
    );
  }

  /* #12298
  source: 
    /**
     * Gets or sets a fixed size in document coordinates to be returned by #viewportBounds. This is typically only set when the Diagram's #div is `null`.
     * This property is intended to be used in DOM-less environments where there is no Diagram #div expected, to simulate the size of the DIV.
     * Normally, the #viewportBounds is sized by the DIV instead.
     *
     * By default this is `Size(NaN, NaN)`.
     * If this property is set, its size will always be used to compute the #viewportBounds, even if
     * a #div is also set. It is uncommon to set both this property and a Diagram DIV.
     *
     * See the intro page on <a href="../../intro/nodeScript.html">GoJS within Node.js</a> for a usage example.
     *
     * @see #viewportBounds
     * @since 2.0
     */
    get viewSize(): Size; */
  /// Gets or sets a fixed size in document coordinates to be returned by #viewportBounds. This is typically only set when the Diagram's #div is `null`.
  /// This property is intended to be used in DOM-less environments where there is no Diagram #div expected, to simulate the size of the DIV.
  /// Normally, the #viewportBounds is sized by the DIV instead.
  ///
  /// By default this is `Size(NaN, NaN)`.
  /// If this property is set, its size will always be used to compute the #viewportBounds, even if
  /// a #div is also set. It is uncommon to set both this property and a Diagram DIV.
  ///
  /// See the intro page on <a href="../../intro/nodeScript.html">GoJS within Node.js</a> for a usage example.
  _i3.Size get viewSize => _i5.getProperty(
        this,
        'viewSize',
      );
  /* #12298
  source: 
    /**
     * Gets or sets a fixed size in document coordinates to be returned by #viewportBounds. This is typically only set when the Diagram's #div is `null`.
     * This property is intended to be used in DOM-less environments where there is no Diagram #div expected, to simulate the size of the DIV.
     * Normally, the #viewportBounds is sized by the DIV instead.
     *
     * By default this is `Size(NaN, NaN)`.
     * If this property is set, its size will always be used to compute the #viewportBounds, even if
     * a #div is also set. It is uncommon to set both this property and a Diagram DIV.
     *
     * See the intro page on <a href="../../intro/nodeScript.html">GoJS within Node.js</a> for a usage example.
     *
     * @see #viewportBounds
     * @since 2.0
     */
    get viewSize(): Size; */
  // Type Instance of 'InteropInterface'
  set viewSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'viewSize',
      value,
    );
  }

  /* #12307
  source: 
    /**
     * Gets or sets a fixed bounding rectangle to be returned by #documentBounds
     * and #computeBounds.
     * By default this has NaN values, meaning that #computeBounds
     * will compute the union of all of the parts in the Diagram to determine the #documentBounds.
     * If all x/y/width/height values are real numbers, this value is used as the #documentBounds.
     */
    get fixedBounds(): Rect; */
  /// Gets or sets a fixed bounding rectangle to be returned by #documentBounds
  /// and #computeBounds.
  /// By default this has NaN values, meaning that #computeBounds
  /// will compute the union of all of the parts in the Diagram to determine the #documentBounds.
  /// If all x/y/width/height values are real numbers, this value is used as the #documentBounds.
  _i3.Rect get fixedBounds => _i5.getProperty(
        this,
        'fixedBounds',
      );
  /* #12307
  source: 
    /**
     * Gets or sets a fixed bounding rectangle to be returned by #documentBounds
     * and #computeBounds.
     * By default this has NaN values, meaning that #computeBounds
     * will compute the union of all of the parts in the Diagram to determine the #documentBounds.
     * If all x/y/width/height values are real numbers, this value is used as the #documentBounds.
     */
    get fixedBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set fixedBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'fixedBounds',
      value,
    );
  }

  /* #12317
  source: 
    /**
     * Gets or sets a scrollable area in document coordinates that surrounds the document bounds, allowing the user to scroll into empty space.
     *
     * The margin is only effective in each direction when the document bounds plus margin is greater than the viewport bounds.
     *
     * The default value is a margin of 0, all around the edge of the document.
     * @since 1.5
     */
    get scrollMargin(): MarginLike; */
  /// Gets or sets a scrollable area in document coordinates that surrounds the document bounds, allowing the user to scroll into empty space.
  ///
  /// The margin is only effective in each direction when the document bounds plus margin is greater than the viewport bounds.
  ///
  /// The default value is a margin of 0, all around the edge of the document.
  _i3.MarginLike get scrollMargin => _i5.getProperty(
        this,
        'scrollMargin',
      );
  /* #12317
  source: 
    /**
     * Gets or sets a scrollable area in document coordinates that surrounds the document bounds, allowing the user to scroll into empty space.
     *
     * The margin is only effective in each direction when the document bounds plus margin is greater than the viewport bounds.
     *
     * The default value is a margin of 0, all around the edge of the document.
     * @since 1.5
     */
    get scrollMargin(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set scrollMargin(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'scrollMargin',
      value,
    );
  }

  /* #12328
  source: 
    /**
     * Gets or sets the scrollMode of the Diagram, allowing the user to either
     * scroll to document bound borders with Diagram.DocumentScroll,
     * or scroll endlessly with Diagram.InfiniteScroll.
     *
     * The default value is Diagram.DocumentScroll.
     * Changing this property value does not raise a Changed event.
     * @since 1.5
     */
    get scrollMode(): EnumValue; */
  /// Gets or sets the scrollMode of the Diagram, allowing the user to either
  /// scroll to document bound borders with Diagram.DocumentScroll,
  /// or scroll endlessly with Diagram.InfiniteScroll.
  ///
  /// The default value is Diagram.DocumentScroll.
  /// Changing this property value does not raise a Changed event.
  _i3.EnumValue get scrollMode => _i5.getProperty(
        this,
        'scrollMode',
      );
  /* #12328
  source: 
    /**
     * Gets or sets the scrollMode of the Diagram, allowing the user to either
     * scroll to document bound borders with Diagram.DocumentScroll,
     * or scroll endlessly with Diagram.InfiniteScroll.
     *
     * The default value is Diagram.DocumentScroll.
     * Changing this property value does not raise a Changed event.
     * @since 1.5
     */
    get scrollMode(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set scrollMode(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'scrollMode',
      value,
    );
  }

  /* #12338
  source: 
    /**
     * Gets or sets whether the page may be scrolled when the diagram receives focus.
     * This happens in some browsers when the top-left corner of the diagram's HTMLDivElement
     * is scrolled out of view, the diagram does not have focus, and the user clicks in the diagram.
     *
     * The default value is false.
     * @since 1.8
     */
    get scrollsPageOnFocus(): boolean; */
  /// Gets or sets whether the page may be scrolled when the diagram receives focus.
  /// This happens in some browsers when the top-left corner of the diagram's HTMLDivElement
  /// is scrolled out of view, the diagram does not have focus, and the user clicks in the diagram.
  ///
  /// The default value is false.
  _i2.bool get scrollsPageOnFocus => _i5.getProperty(
        this,
        'scrollsPageOnFocus',
      );
  /* #12338
  source: 
    /**
     * Gets or sets whether the page may be scrolled when the diagram receives focus.
     * This happens in some browsers when the top-left corner of the diagram's HTMLDivElement
     * is scrolled out of view, the diagram does not have focus, and the user clicks in the diagram.
     *
     * The default value is false.
     * @since 1.8
     */
    get scrollsPageOnFocus(): boolean; */
  // Type InteropStaticType.boolean
  set scrollsPageOnFocus(_i2.bool value) {
    _i5.setProperty(
      this,
      'scrollsPageOnFocus',
      value,
    );
  }

  /* #12358
  source: 
    /**
     * Gets or sets the function used to determine the position that this Diagram can be scrolled or moved to.
     *
     * By default this function is null and the Diagram's position is bound only by the document bounds.
     *
     * When this property is set the function is given a reference to the diagram and the proposed new position Point.
     * The function must return a new point.
     *
     * An example that disallows decimal position values:
     * ```js
     *   function computeIntegralPosition(diagram, pt) {
     *     return new go.Point(Math.floor(pt.x), Math.floor(pt.y));
     *   }
     * ```
     *
     * The function, if supplied, must not have any side-effects.
     * @since 1.5
     */
    get positionComputation(): ((thisDiagram: Diagram, newPosition: Point) => Point) | null; */
  /// Gets or sets the function used to determine the position that this Diagram can be scrolled or moved to.
  ///
  /// By default this function is null and the Diagram's position is bound only by the document bounds.
  ///
  /// When this property is set the function is given a reference to the diagram and the proposed new position Point.
  /// The function must return a new point.
  ///
  /// An example that disallows decimal position values:
  /// ```js
  ///   function computeIntegralPosition(diagram, pt) {
  ///     return new go.Point(Math.floor(pt.x), Math.floor(pt.y));
  ///   }
  /// ```
  ///
  /// The function, if supplied, must not have any side-effects.
  _i3.Point Function(
    _i3.Diagram,
    _i3.Point,
  )? get positionComputation => _i5.getProperty(
        this,
        'positionComputation',
      );
  /* #12358
  source: 
    /**
     * Gets or sets the function used to determine the position that this Diagram can be scrolled or moved to.
     *
     * By default this function is null and the Diagram's position is bound only by the document bounds.
     *
     * When this property is set the function is given a reference to the diagram and the proposed new position Point.
     * The function must return a new point.
     *
     * An example that disallows decimal position values:
     * ```js
     *   function computeIntegralPosition(diagram, pt) {
     *     return new go.Point(Math.floor(pt.x), Math.floor(pt.y));
     *   }
     * ```
     *
     * The function, if supplied, must not have any side-effects.
     * @since 1.5
     */
    get positionComputation(): ((thisDiagram: Diagram, newPosition: Point) => Point) | null; */
  // Type InteropUnion#209407859(parent: InteropGetter#842573075(name: positionComputation))
  set positionComputation(
      _i3.Point Function(
        _i3.Diagram,
        _i3.Point,
      )? value) {
    _i5.setProperty(
      this,
      'positionComputation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #12364
  source: 
    /**
     * Gets or sets the function used to determine valid scale values for this Diagram.
     * @since 1.5
     */
    get scaleComputation(): ((thisDiagram: Diagram, newScale: number) => number) | null; */
  /// Gets or sets the function used to determine valid scale values for this Diagram.
  _i2.num Function(
    _i3.Diagram,
    _i2.num,
  )? get scaleComputation => _i5.getProperty(
        this,
        'scaleComputation',
      );
  /* #12364
  source: 
    /**
     * Gets or sets the function used to determine valid scale values for this Diagram.
     * @since 1.5
     */
    get scaleComputation(): ((thisDiagram: Diagram, newScale: number) => number) | null; */
  // Type InteropUnion#728825449(parent: InteropGetter#574972947(name: scaleComputation))
  set scaleComputation(
      _i2.num Function(
        _i3.Diagram,
        _i2.num,
      )? value) {
    _i5.setProperty(
      this,
      'scaleComputation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #12381
  source: 
    /**
     * This read-only property returns the bounds of the diagram's contents, in document coordinates.
     *
     * This is normally computed and set by #computeBounds during Diagram updates
     * that can occur for any number of relevant reasons, such as a Part changing size.
     *
     * The Diagram's documentBounds can have an unvarying specific value
     * by setting the #fixedBounds property.
     *
     * If the documentBounds are larger than the #viewportBounds,
     * scrollbars will appear on desktop browsers. You can disable scrolling with the
     * #allowHorizontalScroll and #allowVerticalScroll properties, and
     * you can disable scrollbars themselves with the #hasHorizontalScrollbar
     * and #hasVerticalScrollbar properties.
     */
    get documentBounds(): Rect; */
  /// This read-only property returns the bounds of the diagram's contents, in document coordinates.
  ///
  /// This is normally computed and set by #computeBounds during Diagram updates
  /// that can occur for any number of relevant reasons, such as a Part changing size.
  ///
  /// The Diagram's documentBounds can have an unvarying specific value
  /// by setting the #fixedBounds property.
  ///
  /// If the documentBounds are larger than the #viewportBounds,
  /// scrollbars will appear on desktop browsers. You can disable scrolling with the
  /// #allowHorizontalScroll and #allowVerticalScroll properties, and
  /// you can disable scrollbars themselves with the #hasHorizontalScrollbar
  /// and #hasVerticalScrollbar properties.
  _i3.Rect get documentBounds => _i5.getProperty(
        this,
        'documentBounds',
      );
  /* #12381
  source: 
    /**
     * This read-only property returns the bounds of the diagram's contents, in document coordinates.
     *
     * This is normally computed and set by #computeBounds during Diagram updates
     * that can occur for any number of relevant reasons, such as a Part changing size.
     *
     * The Diagram's documentBounds can have an unvarying specific value
     * by setting the #fixedBounds property.
     *
     * If the documentBounds are larger than the #viewportBounds,
     * scrollbars will appear on desktop browsers. You can disable scrolling with the
     * #allowHorizontalScroll and #allowVerticalScroll properties, and
     * you can disable scrollbars themselves with the #hasHorizontalScrollbar
     * and #hasVerticalScrollbar properties.
     */
    get documentBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set documentBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'documentBounds',
      value,
    );
  }

  /* #12395
  source: 
    /**
     * (undocumented)
     */
    get isVirtualized(): boolean; */
  /// (undocumented)
  _i2.bool get isVirtualized => _i5.getProperty(
        this,
        'isVirtualized',
      );
  /* #12395
  source: 
    /**
     * (undocumented)
     */
    get isVirtualized(): boolean; */
  // Type InteropStaticType.boolean
  set isVirtualized(_i2.bool value) {
    _i5.setProperty(
      this,
      'isVirtualized',
      value,
    );
  }

  /* #12417
  source: 
    /**
     * Gets or sets the scale transform of this Diagram.
     * Value must be a positive number.
     * The default value is 1.
     * Any new value will be coerced to be between #minScale and #maxScale.
     *
     * Scale can automatically be set by the #autoScale property.
     * There are also #initialScale and #initialAutoScale for
     * setting the scale on (re)initialization of a Diagram.
     *
     * Setting this property does not notify about any changed event.
     * However you can listen with #addDiagramListener for a DiagramEvent
     * with the name "ViewportBoundsChanged".
     *
     * If you set this property any replacement of the #model will result in a layout
     * and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
     * and zoomed, depending on various Diagram properties named "initial...".
     * You may want to set #initialScale instead of setting this property around the time
     * that you are loading a model.
     */
    get scale(): number; */
  /// Gets or sets the scale transform of this Diagram.
  /// Value must be a positive number.
  /// The default value is 1.
  /// Any new value will be coerced to be between #minScale and #maxScale.
  ///
  /// Scale can automatically be set by the #autoScale property.
  /// There are also #initialScale and #initialAutoScale for
  /// setting the scale on (re)initialization of a Diagram.
  ///
  /// Setting this property does not notify about any changed event.
  /// However you can listen with #addDiagramListener for a DiagramEvent
  /// with the name "ViewportBoundsChanged".
  ///
  /// If you set this property any replacement of the #model will result in a layout
  /// and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
  /// and zoomed, depending on various Diagram properties named "initial...".
  /// You may want to set #initialScale instead of setting this property around the time
  /// that you are loading a model.
  _i2.num get scale => _i5.getProperty(
        this,
        'scale',
      );
  /* #12417
  source: 
    /**
     * Gets or sets the scale transform of this Diagram.
     * Value must be a positive number.
     * The default value is 1.
     * Any new value will be coerced to be between #minScale and #maxScale.
     *
     * Scale can automatically be set by the #autoScale property.
     * There are also #initialScale and #initialAutoScale for
     * setting the scale on (re)initialization of a Diagram.
     *
     * Setting this property does not notify about any changed event.
     * However you can listen with #addDiagramListener for a DiagramEvent
     * with the name "ViewportBoundsChanged".
     *
     * If you set this property any replacement of the #model will result in a layout
     * and a computation of new #documentBounds, which in turn may cause the diagram to be scrolled
     * and zoomed, depending on various Diagram properties named "initial...".
     * You may want to set #initialScale instead of setting this property around the time
     * that you are loading a model.
     */
    get scale(): number; */
  // Type InteropStaticType.number
  set scale(_i2.num value) {
    _i5.setProperty(
      this,
      'scale',
      value,
    );
  }

  /* #12429
  source: 
    /**
     * Gets or sets the Diagram#scale set by CommandHandler#resetZoom
     * and when computing stretch values, such as when #autoScale or
     * #initialAutoScale are set, or when #zoomToFit is called.
     *
     * The default value is 1.0.
     * The value must be a number larger than 0.
     * Setting this property does not raise any events.
     * @since 2.0
     */
    get defaultScale(): number; */
  /// Gets or sets the Diagram#scale set by CommandHandler#resetZoom
  /// and when computing stretch values, such as when #autoScale or
  /// #initialAutoScale are set, or when #zoomToFit is called.
  ///
  /// The default value is 1.0.
  /// The value must be a number larger than 0.
  /// Setting this property does not raise any events.
  _i2.num get defaultScale => _i5.getProperty(
        this,
        'defaultScale',
      );
  /* #12429
  source: 
    /**
     * Gets or sets the Diagram#scale set by CommandHandler#resetZoom
     * and when computing stretch values, such as when #autoScale or
     * #initialAutoScale are set, or when #zoomToFit is called.
     *
     * The default value is 1.0.
     * The value must be a number larger than 0.
     * Setting this property does not raise any events.
     * @since 2.0
     */
    get defaultScale(): number; */
  // Type InteropStaticType.number
  set defaultScale(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultScale',
      value,
    );
  }

  /* #12453
  source: 
    /**
     * Gets or sets the autoScale behavior of the Diagram, controlling whether or not the
     * Diagram's bounds automatically scale to fit the view.
     *
     * The only accepted values are the constant properties of Diagram,
     * Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
     * Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
     *
     * The default value is Diagram.None - the scale and position are not automatically adjusted
     * according to the area covered by the document.
     * When the value is not None, any value for #initialAutoScale or #initialScale is ignored.
     * <p class="box">
     * When autoScale is set to a non-Diagram.None value,
     * the user will not be able to zoom, and setting #scale will do nothing.
     * If you only want to scale automatically on initialization, use #initialAutoScale.
     *
     * Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
     * all the time, or just disabling interactive zooming.
     *
     * Note that depending on the values of #maxScale and #minScale, the actual value for #scale
     * might be limited.
     */
    get autoScale(): EnumValue; */
  /// Gets or sets the autoScale behavior of the Diagram, controlling whether or not the
  /// Diagram's bounds automatically scale to fit the view.
  ///
  /// The only accepted values are the constant properties of Diagram,
  /// Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
  /// Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
  ///
  /// The default value is Diagram.None - the scale and position are not automatically adjusted
  /// according to the area covered by the document.
  /// When the value is not None, any value for #initialAutoScale or #initialScale is ignored.
  /// <p class="box">
  /// When autoScale is set to a non-Diagram.None value,
  /// the user will not be able to zoom, and setting #scale will do nothing.
  /// If you only want to scale automatically on initialization, use #initialAutoScale.
  ///
  /// Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
  /// all the time, or just disabling interactive zooming.
  ///
  /// Note that depending on the values of #maxScale and #minScale, the actual value for #scale
  /// might be limited.
  _i3.EnumValue get autoScale => _i5.getProperty(
        this,
        'autoScale',
      );
  /* #12453
  source: 
    /**
     * Gets or sets the autoScale behavior of the Diagram, controlling whether or not the
     * Diagram's bounds automatically scale to fit the view.
     *
     * The only accepted values are the constant properties of Diagram,
     * Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
     * Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
     *
     * The default value is Diagram.None - the scale and position are not automatically adjusted
     * according to the area covered by the document.
     * When the value is not None, any value for #initialAutoScale or #initialScale is ignored.
     * <p class="box">
     * When autoScale is set to a non-Diagram.None value,
     * the user will not be able to zoom, and setting #scale will do nothing.
     * If you only want to scale automatically on initialization, use #initialAutoScale.
     *
     * Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
     * all the time, or just disabling interactive zooming.
     *
     * Note that depending on the values of #maxScale and #minScale, the actual value for #scale
     * might be limited.
     */
    get autoScale(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set autoScale(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'autoScale',
      value,
    );
  }

  /* #12476
  source: 
    /**
     * Gets or sets how the scale of the diagram is automatically
     * set at the time of the "InitialLayoutCompleted" DiagramEvent, after the model has been replaced.
     *
     * The only accepted values are listed as constant properties of Diagram,
     * such as Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
     * Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
     *
     * If you want to always automatically scale the Diagram, set #autoScale instead.
     * If you want to set the scale to a specific value on initialization (each time the model is replaced),
     * set #initialScale.
     *
     * The default value is Diagram.None -- the scale and position are not automatically adjusted
     * according to the area covered by the document.
     *
     * Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
     * in an "InitialLayoutCompleted" DiagramEvent listener.
     *
     * Note that depending on the values of #maxScale and #minScale, the actual value for #scale
     * might be limited.
     */
    get initialAutoScale(): EnumValue; */
  /// Gets or sets how the scale of the diagram is automatically
  /// set at the time of the "InitialLayoutCompleted" DiagramEvent, after the model has been replaced.
  ///
  /// The only accepted values are listed as constant properties of Diagram,
  /// such as Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
  /// Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
  ///
  /// If you want to always automatically scale the Diagram, set #autoScale instead.
  /// If you want to set the scale to a specific value on initialization (each time the model is replaced),
  /// set #initialScale.
  ///
  /// The default value is Diagram.None -- the scale and position are not automatically adjusted
  /// according to the area covered by the document.
  ///
  /// Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
  /// in an "InitialLayoutCompleted" DiagramEvent listener.
  ///
  /// Note that depending on the values of #maxScale and #minScale, the actual value for #scale
  /// might be limited.
  _i3.EnumValue get initialAutoScale => _i5.getProperty(
        this,
        'initialAutoScale',
      );
  /* #12476
  source: 
    /**
     * Gets or sets how the scale of the diagram is automatically
     * set at the time of the "InitialLayoutCompleted" DiagramEvent, after the model has been replaced.
     *
     * The only accepted values are listed as constant properties of Diagram,
     * such as Diagram.None, Diagram.Uniform, or Diagram.UniformToFill.
     * Setting this will change the Diagram's Diagram#scale and Diagram#position, if appropriate.
     *
     * If you want to always automatically scale the Diagram, set #autoScale instead.
     * If you want to set the scale to a specific value on initialization (each time the model is replaced),
     * set #initialScale.
     *
     * The default value is Diagram.None -- the scale and position are not automatically adjusted
     * according to the area covered by the document.
     *
     * Setting this property to Diagram.Uniform is basically the same as calling #zoomToFit
     * in an "InitialLayoutCompleted" DiagramEvent listener.
     *
     * Note that depending on the values of #maxScale and #minScale, the actual value for #scale
     * might be limited.
     */
    get initialAutoScale(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set initialAutoScale(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'initialAutoScale',
      value,
    );
  }

  /* #12492
  source: 
    /**
     * Gets or sets the spot in the viewport that should be coincident with the
     * #initialDocumentSpot of the document when the document is first initialized.
     * The default value is Spot.TopLeft.
     *
     * If you set this, often you will also want to set #initialDocumentSpot.
     * If you set #initialPosition, it will take precedence over this property.
     *
     * Setting this property and #initialDocumentSpot has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
     *
     * @see #initialDocumentSpot
     * @see #initialContentAlignment
     */
    get initialViewportSpot(): Spot; */
  /// Gets or sets the spot in the viewport that should be coincident with the
  /// #initialDocumentSpot of the document when the document is first initialized.
  /// The default value is Spot.TopLeft.
  ///
  /// If you set this, often you will also want to set #initialDocumentSpot.
  /// If you set #initialPosition, it will take precedence over this property.
  ///
  /// Setting this property and #initialDocumentSpot has the same effect as implementing
  /// an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
  _i3.Spot get initialViewportSpot => _i5.getProperty(
        this,
        'initialViewportSpot',
      );
  /* #12492
  source: 
    /**
     * Gets or sets the spot in the viewport that should be coincident with the
     * #initialDocumentSpot of the document when the document is first initialized.
     * The default value is Spot.TopLeft.
     *
     * If you set this, often you will also want to set #initialDocumentSpot.
     * If you set #initialPosition, it will take precedence over this property.
     *
     * Setting this property and #initialDocumentSpot has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
     *
     * @see #initialDocumentSpot
     * @see #initialContentAlignment
     */
    get initialViewportSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set initialViewportSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'initialViewportSpot',
      value,
    );
  }

  /* #12509
  source: 
    /**
     * Gets or sets the spot in the document's area that should be coincident with the
     * #initialViewportSpot of the viewport when the document is first initialized.
     * The default value is Spot.TopLeft.
     *
     * If you set this, often you will also want to set #initialViewportSpot.
     * If you set #initialPosition, it will take precedence over this property.
     *
     * Setting this property and #initialViewportSpot has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
     *
     * @see #initialViewportSpot
     * @see #initialPosition
     * @see #initialContentAlignment
     */
    get initialDocumentSpot(): Spot; */
  /// Gets or sets the spot in the document's area that should be coincident with the
  /// #initialViewportSpot of the viewport when the document is first initialized.
  /// The default value is Spot.TopLeft.
  ///
  /// If you set this, often you will also want to set #initialViewportSpot.
  /// If you set #initialPosition, it will take precedence over this property.
  ///
  /// Setting this property and #initialViewportSpot has the same effect as implementing
  /// an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
  _i3.Spot get initialDocumentSpot => _i5.getProperty(
        this,
        'initialDocumentSpot',
      );
  /* #12509
  source: 
    /**
     * Gets or sets the spot in the document's area that should be coincident with the
     * #initialViewportSpot of the viewport when the document is first initialized.
     * The default value is Spot.TopLeft.
     *
     * If you set this, often you will also want to set #initialViewportSpot.
     * If you set #initialPosition, it will take precedence over this property.
     *
     * Setting this property and #initialViewportSpot has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that calls #alignDocument.
     *
     * @see #initialViewportSpot
     * @see #initialPosition
     * @see #initialContentAlignment
     */
    get initialDocumentSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set initialDocumentSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'initialDocumentSpot',
      value,
    );
  }

  /* #12520
  source: 
    /**
     * Gets or sets the smallest value greater than zero that #scale may take.
     * This property is only used to limit the range of new values of #scale.
     *
     * The default value is 0.0001.
     * Values must be larger than zero and not greater than one.
     * Setting this to a value that is greater than the current #scale
     * will cause the current diagram scale to be set to this new value.
     */
    get minScale(): number; */
  /// Gets or sets the smallest value greater than zero that #scale may take.
  /// This property is only used to limit the range of new values of #scale.
  ///
  /// The default value is 0.0001.
  /// Values must be larger than zero and not greater than one.
  /// Setting this to a value that is greater than the current #scale
  /// will cause the current diagram scale to be set to this new value.
  _i2.num get minScale => _i5.getProperty(
        this,
        'minScale',
      );
  /* #12520
  source: 
    /**
     * Gets or sets the smallest value greater than zero that #scale may take.
     * This property is only used to limit the range of new values of #scale.
     *
     * The default value is 0.0001.
     * Values must be larger than zero and not greater than one.
     * Setting this to a value that is greater than the current #scale
     * will cause the current diagram scale to be set to this new value.
     */
    get minScale(): number; */
  // Type InteropStaticType.number
  set minScale(_i2.num value) {
    _i5.setProperty(
      this,
      'minScale',
      value,
    );
  }

  /* #12531
  source: 
    /**
     * Gets or sets the largest value that #scale may take.
     * This property is only used to limit the range of new values of #scale.
     *
     * The default value is 100.0.
     * Values must be no less than one.
     * Setting this to a value that is less than the current #scale
     * will cause the current diagram scale to be set to this new value.
     */
    get maxScale(): number; */
  /// Gets or sets the largest value that #scale may take.
  /// This property is only used to limit the range of new values of #scale.
  ///
  /// The default value is 100.0.
  /// Values must be no less than one.
  /// Setting this to a value that is less than the current #scale
  /// will cause the current diagram scale to be set to this new value.
  _i2.num get maxScale => _i5.getProperty(
        this,
        'maxScale',
      );
  /* #12531
  source: 
    /**
     * Gets or sets the largest value that #scale may take.
     * This property is only used to limit the range of new values of #scale.
     *
     * The default value is 100.0.
     * Values must be no less than one.
     * Setting this to a value that is less than the current #scale
     * will cause the current diagram scale to be set to this new value.
     */
    get maxScale(): number; */
  // Type InteropStaticType.number
  set maxScale(_i2.num value) {
    _i5.setProperty(
      this,
      'maxScale',
      value,
    );
  }

  /* #12549
  source: 
    /**
     * Gets or sets the zoom point of this Diagram, in viewport coordinates.
     * This is used by Tool#standardMouseWheel and scale-setting commands to control where to zoom in or out.
     *
     * Typical usage is to remember the value of this property and
     * to set this property to some point within the viewport (between zero and the canvas width and height).
     * This is commonly accomplished by using the InputEvent#viewPoint of Diagram#lastInput.
     * Then one changes the #scale somehow, perhaps by executing one of the CommandHandler commands,
     * or by rotating the mouse wheel, or just by setting the Diagram#scale property.
     * Finally one restores the original value of this property.
     *
     * The default value is Point(NaN, NaN).
     * Value must be of type Point, in element coordinates, not in document coordinates.
     * Setting this property does not notify about any changed event.
     * @since 1.2
     */
    get zoomPoint(): Point; */
  /// Gets or sets the zoom point of this Diagram, in viewport coordinates.
  /// This is used by Tool#standardMouseWheel and scale-setting commands to control where to zoom in or out.
  ///
  /// Typical usage is to remember the value of this property and
  /// to set this property to some point within the viewport (between zero and the canvas width and height).
  /// This is commonly accomplished by using the InputEvent#viewPoint of Diagram#lastInput.
  /// Then one changes the #scale somehow, perhaps by executing one of the CommandHandler commands,
  /// or by rotating the mouse wheel, or just by setting the Diagram#scale property.
  /// Finally one restores the original value of this property.
  ///
  /// The default value is Point(NaN, NaN).
  /// Value must be of type Point, in element coordinates, not in document coordinates.
  /// Setting this property does not notify about any changed event.
  _i3.Point get zoomPoint => _i5.getProperty(
        this,
        'zoomPoint',
      );
  /* #12549
  source: 
    /**
     * Gets or sets the zoom point of this Diagram, in viewport coordinates.
     * This is used by Tool#standardMouseWheel and scale-setting commands to control where to zoom in or out.
     *
     * Typical usage is to remember the value of this property and
     * to set this property to some point within the viewport (between zero and the canvas width and height).
     * This is commonly accomplished by using the InputEvent#viewPoint of Diagram#lastInput.
     * Then one changes the #scale somehow, perhaps by executing one of the CommandHandler commands,
     * or by rotating the mouse wheel, or just by setting the Diagram#scale property.
     * Finally one restores the original value of this property.
     *
     * The default value is Point(NaN, NaN).
     * Value must be of type Point, in element coordinates, not in document coordinates.
     * Setting this property does not notify about any changed event.
     * @since 1.2
     */
    get zoomPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set zoomPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'zoomPoint',
      value,
    );
  }

  /* #12567
  source: 
    /**
     * Gets or sets the content alignment Spot of this Diagram, to be used in determining
     * how parts are positioned when the #viewportBounds width or height is larger than the #documentBounds.
     *
     * For instance a spot of Spot.Center would ensure that the Diagram's
     * contents are always centered in the viewport.
     *
     * If you want the content to be aligned only initially, use #initialContentAlignment instead.
     *
     * The default value is Spot.Default, which causes no automatic scrolling or positioning.
     * When the value is not Default, any value for #initialContentAlignment or #initialPosition is ignored.
     *
     * Setting this property has the same effect as implementing
     * a "LayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
     *
     */
    get contentAlignment(): Spot; */
  /// Gets or sets the content alignment Spot of this Diagram, to be used in determining
  /// how parts are positioned when the #viewportBounds width or height is larger than the #documentBounds.
  ///
  /// For instance a spot of Spot.Center would ensure that the Diagram's
  /// contents are always centered in the viewport.
  ///
  /// If you want the content to be aligned only initially, use #initialContentAlignment instead.
  ///
  /// The default value is Spot.Default, which causes no automatic scrolling or positioning.
  /// When the value is not Default, any value for #initialContentAlignment or #initialPosition is ignored.
  ///
  /// Setting this property has the same effect as implementing
  /// a "LayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
  _i3.Spot get contentAlignment => _i5.getProperty(
        this,
        'contentAlignment',
      );
  /* #12567
  source: 
    /**
     * Gets or sets the content alignment Spot of this Diagram, to be used in determining
     * how parts are positioned when the #viewportBounds width or height is larger than the #documentBounds.
     *
     * For instance a spot of Spot.Center would ensure that the Diagram's
     * contents are always centered in the viewport.
     *
     * If you want the content to be aligned only initially, use #initialContentAlignment instead.
     *
     * The default value is Spot.Default, which causes no automatic scrolling or positioning.
     * When the value is not Default, any value for #initialContentAlignment or #initialPosition is ignored.
     *
     * Setting this property has the same effect as implementing
     * a "LayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
     *
     */
    get contentAlignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set contentAlignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'contentAlignment',
      value,
    );
  }

  /* #12587
  source: 
    /**
     * Gets or sets the initial content alignment Spot of this Diagram, to be used in determining
     * how parts are positioned initially relative to the viewport, when the #viewportBounds width or height is larger than the #documentBounds.
     *
     * For instance a spot of Spot.Center would ensure that the Diagram's contents are initially centered in the viewport.
     *
     * To initially align the document when the documentBounds are larger than the viewport, use #initialDocumentSpot and #initialViewportSpot.
     *
     * If you want the content to be constantly aligned with a spot, use #contentAlignment instead.
     *
     * The default value is Spot.Default, which causes no automatic scrolling or positioning.
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
     *
     * @see #initialDocumentSpot
     * @see #initialViewportSpot
     */
    get initialContentAlignment(): Spot; */
  /// Gets or sets the initial content alignment Spot of this Diagram, to be used in determining
  /// how parts are positioned initially relative to the viewport, when the #viewportBounds width or height is larger than the #documentBounds.
  ///
  /// For instance a spot of Spot.Center would ensure that the Diagram's contents are initially centered in the viewport.
  ///
  /// To initially align the document when the documentBounds are larger than the viewport, use #initialDocumentSpot and #initialViewportSpot.
  ///
  /// If you want the content to be constantly aligned with a spot, use #contentAlignment instead.
  ///
  /// The default value is Spot.Default, which causes no automatic scrolling or positioning.
  ///
  /// Setting this property has the same effect as implementing
  /// an "InitialLayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
  _i3.Spot get initialContentAlignment => _i5.getProperty(
        this,
        'initialContentAlignment',
      );
  /* #12587
  source: 
    /**
     * Gets or sets the initial content alignment Spot of this Diagram, to be used in determining
     * how parts are positioned initially relative to the viewport, when the #viewportBounds width or height is larger than the #documentBounds.
     *
     * For instance a spot of Spot.Center would ensure that the Diagram's contents are initially centered in the viewport.
     *
     * To initially align the document when the documentBounds are larger than the viewport, use #initialDocumentSpot and #initialViewportSpot.
     *
     * If you want the content to be constantly aligned with a spot, use #contentAlignment instead.
     *
     * The default value is Spot.Default, which causes no automatic scrolling or positioning.
     *
     * Setting this property has the same effect as implementing
     * an "InitialLayoutCompleted" DiagramEvent listener that scrolls the viewport to align the content.
     *
     * @see #initialDocumentSpot
     * @see #initialViewportSpot
     */
    get initialContentAlignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set initialContentAlignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'initialContentAlignment',
      value,
    );
  }

  /* #12596
  source: 
    /**
     * Gets or sets the Margin that describes the Diagram's padding,
     * which controls how much extra space in document coordinates there is around the area occupied by the document.
     * This keeps nodes from butting up against the side of the diagram (unless scrolled).
     *
     * The default value is a margin of 5, all around the edge of the document.
     */
    get padding(): MarginLike; */
  /// Gets or sets the Margin that describes the Diagram's padding,
  /// which controls how much extra space in document coordinates there is around the area occupied by the document.
  /// This keeps nodes from butting up against the side of the diagram (unless scrolled).
  ///
  /// The default value is a margin of 5, all around the edge of the document.
  _i3.MarginLike get padding => _i5.getProperty(
        this,
        'padding',
      );
  /* #12596
  source: 
    /**
     * Gets or sets the Margin that describes the Diagram's padding,
     * which controls how much extra space in document coordinates there is around the area occupied by the document.
     * This keeps nodes from butting up against the side of the diagram (unless scrolled).
     *
     * The default value is a margin of 5, all around the edge of the document.
     */
    get padding(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set padding(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'padding',
      value,
    );
  }

  /* #12607
  source: 
    /**
     * This read-only property returns an iterator of all Nodes and Groups in the Diagram.
     *
     * This includes both data-bound and unbound nodes,
     * and both top-level nodes and nodes inside Groups.
     * All of the simple Parts are accessible via the #parts property.
     * @see #findTopLevelGroups
     * @see #findTreeRoots
     */
    get nodes(): Iterator<Node>; */
  /// This read-only property returns an iterator of all Nodes and Groups in the Diagram.
  ///
  /// This includes both data-bound and unbound nodes,
  /// and both top-level nodes and nodes inside Groups.
  /// All of the simple Parts are accessible via the #parts property.
  _i3.Iterator<_i3.Node> get nodes => _i5.getProperty(
        this,
        'nodes',
      );
  /* #12607
  source: 
    /**
     * This read-only property returns an iterator of all Nodes and Groups in the Diagram.
     *
     * This includes both data-bound and unbound nodes,
     * and both top-level nodes and nodes inside Groups.
     * All of the simple Parts are accessible via the #parts property.
     * @see #findTopLevelGroups
     * @see #findTreeRoots
     */
    get nodes(): Iterator<Node>; */
  // Type Instance of 'InteropInterface'
  set nodes(_i3.Iterator<_i3.Node> value) {
    _i5.setProperty(
      this,
      'nodes',
      value,
    );
  }

  /* #12614
  source: 
    /**
     * This read-only property returns an iterator of all Links in the Diagram.
     *
     * This includes both data-bound and unbound links,
     * and both top-level links and links inside Groups.
     */
    get links(): Iterator<Link>; */
  /// This read-only property returns an iterator of all Links in the Diagram.
  ///
  /// This includes both data-bound and unbound links,
  /// and both top-level links and links inside Groups.
  _i3.Iterator<_i3.Link> get links => _i5.getProperty(
        this,
        'links',
      );
  /* #12614
  source: 
    /**
     * This read-only property returns an iterator of all Links in the Diagram.
     *
     * This includes both data-bound and unbound links,
     * and both top-level links and links inside Groups.
     */
    get links(): Iterator<Link>; */
  // Type Instance of 'InteropInterface'
  set links(_i3.Iterator<_i3.Link> value) {
    _i5.setProperty(
      this,
      'links',
      value,
    );
  }

  /* #12624
  source: 
    /**
     * This read-only property returns an iterator of all Parts in the Diagram
     * that are not Nodes or Links or Adornments.
     *
     * This includes both data-bound and unbound parts,
     * and both top-level parts and parts inside Groups.
     * Use the #nodes or #links properties for getting the
     * collection of all Nodes or Links in the diagram.
     */
    get parts(): Iterator<Part>; */
  /// This read-only property returns an iterator of all Parts in the Diagram
  /// that are not Nodes or Links or Adornments.
  ///
  /// This includes both data-bound and unbound parts,
  /// and both top-level parts and parts inside Groups.
  /// Use the #nodes or #links properties for getting the
  /// collection of all Nodes or Links in the diagram.
  _i3.Iterator<_i3.Part> get parts => _i5.getProperty(
        this,
        'parts',
      );
  /* #12624
  source: 
    /**
     * This read-only property returns an iterator of all Parts in the Diagram
     * that are not Nodes or Links or Adornments.
     *
     * This includes both data-bound and unbound parts,
     * and both top-level parts and parts inside Groups.
     * Use the #nodes or #links properties for getting the
     * collection of all Nodes or Links in the diagram.
     */
    get parts(): Iterator<Part>; */
  // Type Instance of 'InteropInterface'
  set parts(_i3.Iterator<_i3.Part> value) {
    _i5.setProperty(
      this,
      'parts',
      value,
    );
  }

  /* #12640
  source: 
    /**
     * Gets or sets the Layout used to position all of the top-level nodes and links in this Diagram.
     * By default this property is an instance of a simple Layout
     * that assigns positions to all parts that need it.
     * The value cannot be null and must not be shared with other Diagrams.
     */
    get layout(): Layout; */
  /// Gets or sets the Layout used to position all of the top-level nodes and links in this Diagram.
  /// By default this property is an instance of a simple Layout
  /// that assigns positions to all parts that need it.
  /// The value cannot be null and must not be shared with other Diagrams.
  _i3.Layout get layout => _i5.getProperty(
        this,
        'layout',
      );
  /* #12640
  source: 
    /**
     * Gets or sets the Layout used to position all of the top-level nodes and links in this Diagram.
     * By default this property is an instance of a simple Layout
     * that assigns positions to all parts that need it.
     * The value cannot be null and must not be shared with other Diagrams.
     */
    get layout(): Layout; */
  // Type Instance of 'InteropInterface'
  set layout(_i3.Layout value) {
    _i5.setProperty(
      this,
      'layout',
      value,
    );
  }

  /* #12662
  source: 
    /**
     * Gets or sets whether the Diagram tree structure is defined by
     * links going from the parent node to their children, or vice-versa.
     * By default this property is true: links go from the parent node to the child node.
     */
    get isTreePathToChildren(): boolean; */
  /// Gets or sets whether the Diagram tree structure is defined by
  /// links going from the parent node to their children, or vice-versa.
  /// By default this property is true: links go from the parent node to the child node.
  _i2.bool get isTreePathToChildren => _i5.getProperty(
        this,
        'isTreePathToChildren',
      );
  /* #12662
  source: 
    /**
     * Gets or sets whether the Diagram tree structure is defined by
     * links going from the parent node to their children, or vice-versa.
     * By default this property is true: links go from the parent node to the child node.
     */
    get isTreePathToChildren(): boolean; */
  // Type InteropStaticType.boolean
  set isTreePathToChildren(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTreePathToChildren',
      value,
    );
  }

  /* #12706
  source: 
    /**
     * (undocumented)
     */
    get avoidanceCellSize(): Size; */
  /// (undocumented)
  _i3.Size get avoidanceCellSize => _i5.getProperty(
        this,
        'avoidanceCellSize',
      );
  /* #12706
  source: 
    /**
     * (undocumented)
     */
    get avoidanceCellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set avoidanceCellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'avoidanceCellSize',
      value,
    );
  }

  /* #12711
  source: 
    /**
     * (undocumented)
     */
    get avoidanceLimit(): number; */
  /// (undocumented)
  _i2.num get avoidanceLimit => _i5.getProperty(
        this,
        'avoidanceLimit',
      );
  /* #12711
  source: 
    /**
     * (undocumented)
     */
    get avoidanceLimit(): number; */
  // Type InteropStaticType.number
  set avoidanceLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'avoidanceLimit',
      value,
    );
  }

  /* #12718
  source: 
    /**
     * Gets or sets number of milliseconds between autoscroll events.
     * The default value is 250.
     * @since 2.2
     */
    get autoScrollInterval(): number; */
  /// Gets or sets number of milliseconds between autoscroll events.
  /// The default value is 250.
  _i2.num get autoScrollInterval => _i5.getProperty(
        this,
        'autoScrollInterval',
      );
  /* #12718
  source: 
    /**
     * Gets or sets number of milliseconds between autoscroll events.
     * The default value is 250.
     * @since 2.2
     */
    get autoScrollInterval(): number; */
  // Type InteropStaticType.number
  set autoScrollInterval(_i2.num value) {
    _i5.setProperty(
      this,
      'autoScrollInterval',
      value,
    );
  }

  /* #12736
  source: 
    /**
     * Gets or sets the Margin that describes the area along the inside edges of the viewport,
     * in viewport coordinates, where autoscrolling will occur while the mouse (pointer) is held there
     * during dragging or linking or drag-selecting.
     *
     * The default value is a Margin of 16 on all sides.
     * Increase this value in order to make it easier for the user to autoscroll by having
     * a larger area in which to hold the mouse (pointer) down during a dragging operation.
     *
     * When the mouse (pointer) drag point is within this region on the left or right sides,
     * the view will automatically scroll horizontally in that direction.
     * When the point is within the region on the top or bottom, the view will automatically scroll
     * vertically in that direction.
     * You can specify a Margin side of zero to disable autoscrolling in a particular direction;
     * a value of Margin(0,0,0,0) turns off autoscrolling in all four directions.
     */
    get autoScrollRegion(): MarginLike; */
  /// Gets or sets the Margin that describes the area along the inside edges of the viewport,
  /// in viewport coordinates, where autoscrolling will occur while the mouse (pointer) is held there
  /// during dragging or linking or drag-selecting.
  ///
  /// The default value is a Margin of 16 on all sides.
  /// Increase this value in order to make it easier for the user to autoscroll by having
  /// a larger area in which to hold the mouse (pointer) down during a dragging operation.
  ///
  /// When the mouse (pointer) drag point is within this region on the left or right sides,
  /// the view will automatically scroll horizontally in that direction.
  /// When the point is within the region on the top or bottom, the view will automatically scroll
  /// vertically in that direction.
  /// You can specify a Margin side of zero to disable autoscrolling in a particular direction;
  /// a value of Margin(0,0,0,0) turns off autoscrolling in all four directions.
  _i3.MarginLike get autoScrollRegion => _i5.getProperty(
        this,
        'autoScrollRegion',
      );
  /* #12736
  source: 
    /**
     * Gets or sets the Margin that describes the area along the inside edges of the viewport,
     * in viewport coordinates, where autoscrolling will occur while the mouse (pointer) is held there
     * during dragging or linking or drag-selecting.
     *
     * The default value is a Margin of 16 on all sides.
     * Increase this value in order to make it easier for the user to autoscroll by having
     * a larger area in which to hold the mouse (pointer) down during a dragging operation.
     *
     * When the mouse (pointer) drag point is within this region on the left or right sides,
     * the view will automatically scroll horizontally in that direction.
     * When the point is within the region on the top or bottom, the view will automatically scroll
     * vertically in that direction.
     * You can specify a Margin side of zero to disable autoscrolling in a particular direction;
     * a value of Margin(0,0,0,0) turns off autoscrolling in all four directions.
     */
    get autoScrollRegion(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set autoScrollRegion(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'autoScrollRegion',
      value,
    );
  }

  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  void reset() {
    _i5.callMethod(
      this,
      'reset',
      [],
    );
  }

  void setRTL([_i4.HTMLElement? elem]) {
    _i5.callMethod(
      this,
      'setRTL',
      [elem ?? _i4.undefined],
    );
  }

  void setScrollWidth([_i4.HTMLElement? elem]) {
    _i5.callMethod(
      this,
      'setScrollWidth',
      [elem ?? _i4.undefined],
    );
  }

  void addEventListener(
    _i2.Object domElement,
    _i2.String name,
    _i2.dynamic listener,
    _i2.bool capture,
  ) {
    _i5.callMethod(
      this,
      'addEventListener',
      [
        domElement,
        name,
        listener,
        capture,
      ],
    );
  }

  void removeEventListener(
    _i2.Object domElement,
    _i2.String name,
    _i2.dynamic listener,
    _i2.bool capture,
  ) {
    _i5.callMethod(
      this,
      'removeEventListener',
      [
        domElement,
        name,
        listener,
        capture,
      ],
    );
  }

  _i2.num computePixelRatio() => _i5.callMethod(
        this,
        'computePixelRatio',
        [],
      );
  void doFocus() {
    _i5.callMethod(
      this,
      'doFocus',
      [],
    );
  }

  void focus() {
    _i5.callMethod(
      this,
      'focus',
      [],
    );
  }

  _i3.Rect computeBounds([_i3.Rect? rect]) => _i5.callMethod(
        this,
        'computeBounds',
        [rect ?? _i4.undefined],
      );
  _i3.Rect computePartsBounds(
    _i2.Object coll, [
    _i2.bool? includeLinks,
  ]) =>
      _i5.callMethod(
        this,
        'computePartsBounds',
        [
          coll,
          includeLinks ?? _i4.undefined,
        ],
      );
  void zoomToFit() {
    _i5.callMethod(
      this,
      'zoomToFit',
      [],
    );
  }

  void zoomToRect(
    _i3.Rect r, [
    _i3.EnumValue? scaling,
  ]) {
    _i5.callMethod(
      this,
      'zoomToRect',
      [
        r,
        scaling ?? _i4.undefined,
      ],
    );
  }

  void alignDocument(
    _i3.Spot documentspot,
    _i3.Spot viewportspot,
  ) {
    _i5.callMethod(
      this,
      'alignDocument',
      [
        documentspot,
        viewportspot,
      ],
    );
  }

  void focusObject([_i3.GraphObject? obj]) {
    _i5.callMethod(
      this,
      'focusObject',
      [obj ?? _i4.undefined],
    );
  }

  _i3.Part? findPartAt(
    _i3.Point p, [
    _i2.bool? selectable,
  ]) =>
      _i5.callMethod(
        this,
        'findPartAt',
        [
          p,
          selectable ?? _i4.undefined,
        ],
      );
  T? findObjectAt<T extends _i3.GraphObject>(
    _i3.Point p, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectAt',
        [
          p,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
        ],
      );
  S findPartsAt<T extends _i3.Part, S extends _i3.Iterable<T>>(
    _i3.Point p, [
    _i2.bool? selectable,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findPartsAt',
        [
          p,
          selectable ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  S findObjectsAt<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Point p, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsAt',
        [
          p,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          coll ?? _i4.undefined,
        ],
      );
  S findPartsIn<T extends _i3.Part, S extends _i3.Iterable<T>>(
    _i3.Rect r, [
    _i2.bool? partialInclusion,
    _i2.bool? selectable,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findPartsIn',
        [
          r,
          partialInclusion ?? _i4.undefined,
          selectable ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  S findObjectsIn<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Rect r, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    _i2.bool? partialInclusion,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsIn',
        [
          r,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          partialInclusion ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  S findPartsNear<T extends _i3.Part, S extends _i3.Iterable<T>>(
    _i3.Point p,
    _i2.num dist, [
    _i2.bool? partialInclusion,
    _i2.bool? selectable,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findPartsNear',
        [
          p,
          dist,
          partialInclusion ?? _i4.undefined,
          selectable ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  S findObjectsNear<T extends _i3.GraphObject, S extends _i3.Iterable<T>>(
    _i3.Point p,
    _i2.num dist, [
    T? Function(_i3.GraphObject)? navig,
    _i2.bool Function(T)? pred,
    _i2.Object? partialInclusion,
    S? coll,
  ]) =>
      _i5.callMethod(
        this,
        'findObjectsNear',
        [
          p,
          dist,
          navig == null ? _i4.undefined : _i5.allowInterop(navig),
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
          partialInclusion ?? _i4.undefined,
          coll ?? _i4.undefined,
        ],
      );
  void invalidateDocumentBounds() {
    _i5.callMethod(
      this,
      'invalidateDocumentBounds',
      [],
    );
  }

  void redraw() {
    _i5.callMethod(
      this,
      'redraw',
      [],
    );
  }

  void delayInitialization([void Function(_i3.Diagram?)? func]) {
    _i5.callMethod(
      this,
      'delayInitialization',
      [func == null ? _i4.undefined : _i5.allowInterop(func)],
    );
  }

  void requestUpdate([_i2.bool? alwaysQueueUpdate]) {
    _i5.callMethod(
      this,
      'requestUpdate',
      [alwaysQueueUpdate ?? _i4.undefined],
    );
  }

  void maybeUpdate() {
    _i5.callMethod(
      this,
      'maybeUpdate',
      [],
    );
  }

  _i2.dynamic getRenderingHint(_i2.String name) => _i5.callMethod(
        this,
        'getRenderingHint',
        [name],
      );
  void setRenderingHint(
    _i2.String name,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'setRenderingHint',
      [
        name,
        val,
      ],
    );
  }

  _i2.dynamic getInputOption(_i2.String name) => _i5.callMethod(
        this,
        'getInputOption',
        [name],
      );
  void setInputOption(
    _i2.String name,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'setInputOption',
      [
        name,
        val,
      ],
    );
  }

  _i3.Diagram set(_i4.Partial config) => _i5.callMethod(
        this,
        'set',
        [config],
      );
  _i3.Diagram attach(_i2.Object props) => _i5.callMethod(
        this,
        'attach',
        [props],
      );
  _i3.Diagram setProperties(_i2.Object props) => _i5.callMethod(
        this,
        'setProperties',
        [props],
      );
  void add(_i3.Part part) {
    _i5.callMethod(
      this,
      'add',
      [part],
    );
  }

  void remove(_i3.Part part) {
    _i5.callMethod(
      this,
      'remove',
      [part],
    );
  }

  void removeParts(
    _i2.Object coll, [
    _i2.bool? check,
  ]) {
    _i5.callMethod(
      this,
      'removeParts',
      [
        coll,
        check ?? _i4.undefined,
      ],
    );
  }

  _i3.Map<_i3.Part, _i3.Part> copyParts(
    _i2.Object coll, [
    _i3.Diagram? diagram,
    _i2.bool? check,
  ]) =>
      _i5.callMethod(
        this,
        'copyParts',
        [
          coll,
          diagram ?? _i4.undefined,
          check ?? _i4.undefined,
        ],
      );
  void moveParts(
    _i2.Object coll,
    _i3.Point offset, [
    _i2.bool? check,
    _i3.DraggingOptions? dragOptions,
  ]) {
    _i5.callMethod(
      this,
      'moveParts',
      [
        coll,
        offset,
        check ?? _i4.undefined,
        dragOptions ?? _i4.undefined,
      ],
    );
  }

  _i3.Point computeMove(
    _i3.Part n,
    _i3.Point newloc,
    _i3.DraggingOptions dragOptions, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'computeMove',
        [
          n,
          newloc,
          dragOptions,
          result ?? _i4.undefined,
        ],
      );
  _i3.Diagram addLayer(_i3.Layer layer) => _i5.callMethod(
        this,
        'addLayer',
        [layer],
      );
  _i3.Diagram addLayerBefore(
    _i3.Layer layer,
    _i3.Layer existingLayer,
  ) =>
      _i5.callMethod(
        this,
        'addLayerBefore',
        [
          layer,
          existingLayer,
        ],
      );
  _i3.Diagram addLayerAfter(
    _i3.Layer layer,
    _i3.Layer existingLayer,
  ) =>
      _i5.callMethod(
        this,
        'addLayerAfter',
        [
          layer,
          existingLayer,
        ],
      );
  void removeLayer(_i3.Layer layer) {
    _i5.callMethod(
      this,
      'removeLayer',
      [layer],
    );
  }

  _i3.Layer? findLayer(_i2.String name) => _i5.callMethod(
        this,
        'findLayer',
        [name],
      );
  _i3.Diagram addModelChangedListener(
          void Function(_i3.ChangedEvent) listener) =>
      _i5.callMethod(
        this,
        'addModelChangedListener',
        [_i5.allowInterop(listener)],
      );
  void removeModelChangedListener(void Function(_i3.ChangedEvent) listener) {
    _i5.callMethod(
      this,
      'removeModelChangedListener',
      [_i5.allowInterop(listener)],
    );
  }

  _i3.Diagram addChangedListener(void Function(_i3.ChangedEvent) listener) =>
      _i5.callMethod(
        this,
        'addChangedListener',
        [_i5.allowInterop(listener)],
      );
  void removeChangedListener(void Function(_i3.ChangedEvent) listener) {
    _i5.callMethod(
      this,
      'removeChangedListener',
      [_i5.allowInterop(listener)],
    );
  }

  _i2.bool startTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'startTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool commitTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'commitTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool rollbackTransaction() => _i5.callMethod(
        this,
        'rollbackTransaction',
        [],
      );
  void commit(
    void Function(_i3.Diagram) func, [
    _i2.String? tname,
  ]) {
    _i5.callMethod(
      this,
      'commit',
      [
        _i5.allowInterop(func),
        tname ?? _i4.undefined,
      ],
    );
  }

  void updateAllTargetBindings([_i2.String? srcprop]) {
    _i5.callMethod(
      this,
      'updateAllTargetBindings',
      [srcprop ?? _i4.undefined],
    );
  }

  void updateAllRelationshipsFromData() {
    _i5.callMethod(
      this,
      'updateAllRelationshipsFromData',
      [],
    );
  }

  void clearSelection([_i2.bool? skipsEvents]) {
    _i5.callMethod(
      this,
      'clearSelection',
      [skipsEvents ?? _i4.undefined],
    );
  }

  void select([_i3.Part? part]) {
    _i5.callMethod(
      this,
      'select',
      [part ?? _i4.undefined],
    );
  }

  void selectCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'selectCollection',
      [coll],
    );
  }

  void clearHighlighteds() {
    _i5.callMethod(
      this,
      'clearHighlighteds',
      [],
    );
  }

  void highlight([_i3.Part? part]) {
    _i5.callMethod(
      this,
      'highlight',
      [part ?? _i4.undefined],
    );
  }

  void highlightCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'highlightCollection',
      [coll],
    );
  }

  void scroll(
    Scroll unit,
    ScrollOptions dir, [
    _i2.num? dist,
  ]) {
    _i5.callMethod(
      this,
      'scroll',
      [
        unit.name,
        dir.name,
        dist ?? _i4.undefined,
      ],
    );
  }

  void scrollToRect(_i3.Rect r) {
    _i5.callMethod(
      this,
      'scrollToRect',
      [r],
    );
  }

  void centerRect(_i3.Rect r) {
    _i5.callMethod(
      this,
      'centerRect',
      [r],
    );
  }

  _i3.Point transformDocToView(_i3.Point p) => _i5.callMethod(
        this,
        'transformDocToView',
        [p],
      );
  _i3.Point transformViewToDoc(_i3.Point p) => _i5.callMethod(
        this,
        'transformViewToDoc',
        [p],
      );
  void rebuildParts() {
    _i5.callMethod(
      this,
      'rebuildParts',
      [],
    );
  }

  _i3.Part? findPartForKey(_i3.Key key) => _i5.callMethod(
        this,
        'findPartForKey',
        [key ?? _i4.undefined],
      );
  _i3.Node? findNodeForKey(_i3.Key key) => _i5.callMethod(
        this,
        'findNodeForKey',
        [key ?? _i4.undefined],
      );
  _i3.Link? findLinkForKey(_i3.Key key) => _i5.callMethod(
        this,
        'findLinkForKey',
        [key ?? _i4.undefined],
      );
  _i3.Part? findPartForData(_i2.Object data) => _i5.callMethod(
        this,
        'findPartForData',
        [data],
      );
  _i3.Node? findNodeForData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'findNodeForData',
        [nodedata],
      );
  _i3.Link? findLinkForData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'findLinkForData',
        [linkdata],
      );
  _i3.Iterator<_i3.Node> findNodesByExample(
          [_i2.Iterable<_i2.dynamic>? examples]) =>
      _i5.callMethod(
        this,
        'findNodesByExample',
        [...?examples],
      );
  _i3.Iterator<_i3.Link> findLinksByExample(
          [_i2.Iterable<_i2.dynamic>? examples]) =>
      _i5.callMethod(
        this,
        'findLinksByExample',
        [...?examples],
      );
  void ensureBounds() {
    _i5.callMethod(
      this,
      'ensureBounds',
      [],
    );
  }

  _i3.Iterator<_i3.Group> findTopLevelGroups() => _i5.callMethod(
        this,
        'findTopLevelGroups',
        [],
      );
  void layoutDiagram([_i2.bool? invalidateAll]) {
    _i5.callMethod(
      this,
      'layoutDiagram',
      [invalidateAll ?? _i4.undefined],
    );
  }

  _i3.Iterator<_i3.Node> findTreeRoots() => _i5.callMethod(
        this,
        'findTreeRoots',
        [],
      );
  _i3.Diagram addDiagramListener(
    _i3.DiagramEventName name,
    void Function(_i3.DiagramEvent) listener,
  ) =>
      _i5.callMethod(
        this,
        'addDiagramListener',
        [
          name.name,
          _i5.allowInterop(listener),
        ],
      );
  void removeDiagramListener(
    _i3.DiagramEventName name,
    void Function(_i3.DiagramEvent) listener,
  ) {
    _i5.callMethod(
      this,
      'removeDiagramListener',
      [
        name.name,
        _i5.allowInterop(listener),
      ],
    );
  }

  void raiseDiagramEvent(
    _i3.DiagramEventName name, [
    _i2.Object? obj,
    _i2.dynamic param,
  ]) {
    _i5.callMethod(
      this,
      'raiseDiagramEvent',
      [
        name.name,
        obj ?? _i4.undefined,
        param ?? _i4.undefined,
      ],
    );
  }

  void doAutoScroll(_i3.Point viewPt) {
    _i5.callMethod(
      this,
      'doAutoScroll',
      [viewPt],
    );
  }

  void stopAutoScroll() {
    _i5.callMethod(
      this,
      'stopAutoScroll',
      [],
    );
  }

  _i3.Point computeAutoScrollPosition(_i3.Point viewPnt) => _i5.callMethod(
        this,
        'computeAutoScrollPosition',
        [viewPnt],
      );
  _i4.SVGElement? makeSvg([_i3.SvgRendererOptions? options]) => _i5.callMethod(
        this,
        'makeSvg',
        [options ?? _i4.undefined],
      );
  void addRenderer(
    _i2.String name,
    _i3.ISurface surface,
  ) {
    _i5.callMethod(
      this,
      'addRenderer',
      [
        name,
        surface,
      ],
    );
  }

  void cacheGroupExternalLinks(_i2.bool start) {
    _i5.callMethod(
      this,
      'cacheGroupExternalLinks',
      [start],
    );
  }

  _i4.HTMLImageElement? makeImage([_i3.ImageRendererOptions? options]) =>
      _i5.callMethod(
        this,
        'makeImage',
        [options ?? _i4.undefined],
      );
  _i2.dynamic makeImageData([_i3.ImageRendererOptions? options]) =>
      _i5.callMethod(
        this,
        'makeImageData',
        [options ?? _i4.undefined],
      );
}

@_i1.JS()
@_i1.staticInterop
class DraggingInfo {
  factory DraggingInfo([_i3.Point? pt]) => _i5.callConstructor(
        _declaredDraggingInfo,
        [pt ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('DraggingInfo')
external _i2.Object _declaredDraggingInfo;

extension DraggingInfo$Typings on DraggingInfo {
  /* #12999
  source: 
    /**
     * Gets or sets the initial location for a dragged object.
     * This is most commonly the Part.location of the dragged object, or a rounded Part.location if snapping.
     */
    get point(): Point; */
  /// Gets or sets the initial location for a dragged object.
  /// This is most commonly the Part.location of the dragged object, or a rounded Part.location if snapping.
  _i3.Point get point => _i5.getProperty(
        this,
        'point',
      );
  /* #12999
  source: 
    /**
     * Gets or sets the initial location for a dragged object.
     * This is most commonly the Part.location of the dragged object, or a rounded Part.location if snapping.
     */
    get point(): Point; */
  // Type Instance of 'InteropInterface'
  set point(_i3.Point value) {
    _i5.setProperty(
      this,
      'point',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class DraggingOptions {
  factory DraggingOptions() => _i5.callConstructor(
        _declaredDraggingOptions,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('DraggingOptions')
external _i2.Object _declaredDraggingOptions;

extension DraggingOptions$Typings on DraggingOptions {
  /* #13026
  source: 
    /**
     * Whether or not the dragged parts snap to the Diagram#grid.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#isGridSnapEnabled.
     */
    isGridSnapEnabled: boolean; */
  /// Whether or not the dragged parts snap to the Diagram#grid.
  ///  By default this property is false.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#isGridSnapEnabled.
  _i2.bool get isGridSnapEnabled => _i5.getProperty(
        this,
        'isGridSnapEnabled',
      );
  /* #13026
  source: 
    /**
     * Whether or not the dragged parts snap to the Diagram#grid.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#isGridSnapEnabled.
     */
    isGridSnapEnabled: boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapEnabled',
      value,
    );
  }

  /* #13034
  source: 
    /**
     * If dragging with the DraggingTool, whether or not Parts snap to a grid (if applicable) in real-time,
     * or only at the end of the dragging transaction.
     * By default this property is true.
     *
     * In typical DraggingTool operation this is set via DraggingTool#isGridSnapRealtime.
     */
    isGridSnapRealtime: boolean; */
  /// If dragging with the DraggingTool, whether or not Parts snap to a grid (if applicable) in real-time,
  ///  or only at the end of the dragging transaction.
  ///  By default this property is true.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#isGridSnapRealtime.
  _i2.bool get isGridSnapRealtime => _i5.getProperty(
        this,
        'isGridSnapRealtime',
      );
  /* #13034
  source: 
    /**
     * If dragging with the DraggingTool, whether or not Parts snap to a grid (if applicable) in real-time,
     * or only at the end of the dragging transaction.
     * By default this property is true.
     *
     * In typical DraggingTool operation this is set via DraggingTool#isGridSnapRealtime.
     */
    isGridSnapRealtime: boolean; */
  // Type InteropStaticType.boolean
  set isGridSnapRealtime(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGridSnapRealtime',
      value,
    );
  }

  /* #13041
  source: 
    /**
     * Gets or sets the size of the grid cell used when snapping during a drag.
     * By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSize.
     */
    gridSnapCellSize: Size; */
  /// Gets or sets the size of the grid cell used when snapping during a drag.
  ///  By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSize.
  _i3.Size get gridSnapCellSize => _i5.getProperty(
        this,
        'gridSnapCellSize',
      );
  /* #13041
  source: 
    /**
     * Gets or sets the size of the grid cell used when snapping during a drag.
     * By default this property is the Size(NaN, NaN), which causes this tool to use the Panel#gridCellSize value of the Diagram#grid.
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSize.
     */
    gridSnapCellSize: Size; */
  // Type Instance of 'InteropInterface'
  set gridSnapCellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'gridSnapCellSize',
      value,
    );
  }

  /* #13048
  source: 
    /**
     * Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
     * if the value of #isGridSnapEnabled is true. By default this property is Spot.TopLeft.
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSpot.
     */
    gridSnapCellSpot: Spot; */
  /// Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
  ///  if the value of #isGridSnapEnabled is true. By default this property is Spot.TopLeft.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSpot.
  _i3.Spot get gridSnapCellSpot => _i5.getProperty(
        this,
        'gridSnapCellSpot',
      );
  /* #13048
  source: 
    /**
     * Gets or sets the Spot that specifies what point in the grid cell dragged parts snap to,
     * if the value of #isGridSnapEnabled is true. By default this property is Spot.TopLeft.
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapCellSpot.
     */
    gridSnapCellSpot: Spot; */
  // Type Instance of 'InteropInterface'
  set gridSnapCellSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'gridSnapCellSpot',
      value,
    );
  }

  /* #13055
  source: 
    /**
     * Gets or sets the snapping grid's origin point, in document coordinates,
     * if the value of #isGridSnapEnabled is true. By default this property is the Point(NaN, NaN).
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapOrigin.
     */
    gridSnapOrigin: Point; */
  /// Gets or sets the snapping grid's origin point, in document coordinates,
  ///  if the value of #isGridSnapEnabled is true. By default this property is the Point(NaN, NaN).
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#gridSnapOrigin.
  _i3.Point get gridSnapOrigin => _i5.getProperty(
        this,
        'gridSnapOrigin',
      );
  /* #13055
  source: 
    /**
     * Gets or sets the snapping grid's origin point, in document coordinates,
     * if the value of #isGridSnapEnabled is true. By default this property is the Point(NaN, NaN).
     *
     * In typical DraggingTool operation this is set via DraggingTool#gridSnapOrigin.
     */
    gridSnapOrigin: Point; */
  // Type Instance of 'InteropInterface'
  set gridSnapOrigin(_i3.Point value) {
    _i5.setProperty(
      this,
      'gridSnapOrigin',
      value,
    );
  }

  /* #13063
  source: 
    /**
     * Gets or sets whether the user can move a single Link,
     * disconnecting it from connected nodes and possibly connecting it to valid ports.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#dragsLink.
     */
    dragsLink: boolean; */
  /// Gets or sets whether the user can move a single Link,
  ///  disconnecting it from connected nodes and possibly connecting it to valid ports.
  ///  By default this property is false.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#dragsLink.
  _i2.bool get dragsLink => _i5.getProperty(
        this,
        'dragsLink',
      );
  /* #13063
  source: 
    /**
     * Gets or sets whether the user can move a single Link,
     * disconnecting it from connected nodes and possibly connecting it to valid ports.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#dragsLink.
     */
    dragsLink: boolean; */
  // Type InteropStaticType.boolean
  set dragsLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsLink',
      value,
    );
  }

  /* #13071
  source: 
    /**
     * Gets or sets whether moving or copying a node also includes all of the
     * node's tree children and their descendants, along with the links to those additional nodes.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#dragsTree.
     */
    dragsTree: boolean; */
  /// Gets or sets whether moving or copying a node also includes all of the
  ///  node's tree children and their descendants, along with the links to those additional nodes.
  ///  By default this property is false.
  ///
  ///  In typical DraggingTool operation this is set via DraggingTool#dragsTree.
  _i2.bool get dragsTree => _i5.getProperty(
        this,
        'dragsTree',
      );
  /* #13071
  source: 
    /**
     * Gets or sets whether moving or copying a node also includes all of the
     * node's tree children and their descendants, along with the links to those additional nodes.
     * By default this property is false.
     *
     * In typical DraggingTool operation this is set via DraggingTool#dragsTree.
     */
    dragsTree: boolean; */
  // Type InteropStaticType.boolean
  set dragsTree(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsTree',
      value,
    );
  }

  /* #13076
  source: 
    /**
     * Determines whether or not Groups will snap their member Parts in addition to themselves when moving.
     * By default this property is false.
     */
    groupsSnapMembers: boolean; */
  /// Determines whether or not Groups will snap their member Parts in addition to themselves when moving.
  ///  By default this property is false.
  _i2.bool get groupsSnapMembers => _i5.getProperty(
        this,
        'groupsSnapMembers',
      );
  /* #13076
  source: 
    /**
     * Determines whether or not Groups will snap their member Parts in addition to themselves when moving.
     * By default this property is false.
     */
    groupsSnapMembers: boolean; */
  // Type InteropStaticType.boolean
  set groupsSnapMembers(_i2.bool value) {
    _i5.setProperty(
      this,
      'groupsSnapMembers',
      value,
    );
  }

  /* #13082
  source: 
    /**
     * Determines whether or not Groups will ensure their member Parts always move,
     * even if those member parts have Part#copyable and Part#movable set to false.
     * By default this property is true.
     */
    groupsAlwaysMove: boolean; */
  /// Determines whether or not Groups will ensure their member Parts always move,
  ///  even if those member parts have Part#copyable and Part#movable set to false.
  ///  By default this property is true.
  _i2.bool get groupsAlwaysMove => _i5.getProperty(
        this,
        'groupsAlwaysMove',
      );
  /* #13082
  source: 
    /**
     * Determines whether or not Groups will ensure their member Parts always move,
     * even if those member parts have Part#copyable and Part#movable set to false.
     * By default this property is true.
     */
    groupsAlwaysMove: boolean; */
  // Type InteropStaticType.boolean
  set groupsAlwaysMove(_i2.bool value) {
    _i5.setProperty(
      this,
      'groupsAlwaysMove',
      value,
    );
  }

  /* #13087
  source: 
    /**
     * Determines whether dragging a Group also drags its member Parts if there is no Group.placeholder.
     * By default this property is true.
     */
    dragsMembers: boolean; */
  /// Determines whether dragging a Group also drags its member Parts if there is no Group.placeholder.
  ///  By default this property is true.
  _i2.bool get dragsMembers => _i5.getProperty(
        this,
        'dragsMembers',
      );
  /* #13087
  source: 
    /**
     * Determines whether dragging a Group also drags its member Parts if there is no Group.placeholder.
     * By default this property is true.
     */
    dragsMembers: boolean; */
  // Type InteropStaticType.boolean
  set dragsMembers(_i2.bool value) {
    _i5.setProperty(
      this,
      'dragsMembers',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class DiagramRendererOptions {
  external factory DiagramRendererOptions._({
    _i2.dynamic size,
    _i2.dynamic scale,
    _i2.dynamic maxSize,
    _i2.dynamic position,
    _i2.dynamic parts,
    _i2.dynamic padding,
    _i2.dynamic background,
    _i2.dynamic showTemporary,
    _i2.dynamic showGrid,
    _i2.dynamic document,
  });

  factory DiagramRendererOptions({
    _i3.Size? size,
    _i2.num? scale,
    _i3.Size? maxSize,
    _i3.Point? position,
    _i3.Iterable<_i3.Part>? parts,
    _i3.MarginLike? padding,
    _i3.BrushLike? background,
    _i2.bool? showTemporary,
    _i2.bool? showGrid,
    _i4.HTMLDocument? document,
  }) =>
      DiagramRendererOptions._(
        size: size ?? _i4.undefined,
        scale: scale ?? _i4.undefined,
        maxSize: maxSize ?? _i4.undefined,
        position: position ?? _i4.undefined,
        parts: parts ?? _i4.undefined,
        padding: padding ?? _i4.undefined ?? _i4.undefined,
        background: background ?? _i4.undefined ?? _i4.undefined,
        showTemporary: showTemporary ?? _i4.undefined,
        showGrid: showGrid ?? _i4.undefined,
        document: document ?? _i4.undefined,
      );
}

extension DiagramRendererOptions$Typings on DiagramRendererOptions {
  /* #13094
  source: 
    size?: Size; */
  _i3.Size? get size => _i5.getProperty(
        this,
        'size',
      );
  /* #13094
  source: 
    size?: Size; */
  // Type Instance of 'InteropInterface'
  set size(_i3.Size? value) {
    _i5.setProperty(
      this,
      'size',
      value ?? _i4.undefined,
    );
  }

  /* #13095
  source: 
    scale?: number; */
  _i2.num? get scale => _i5.getProperty(
        this,
        'scale',
      );
  /* #13095
  source: 
    scale?: number; */
  // Type InteropStaticType.number
  set scale(_i2.num? value) {
    _i5.setProperty(
      this,
      'scale',
      value ?? _i4.undefined,
    );
  }

  /* #13096
  source: 
    maxSize?: Size; */
  _i3.Size? get maxSize => _i5.getProperty(
        this,
        'maxSize',
      );
  /* #13096
  source: 
    maxSize?: Size; */
  // Type Instance of 'InteropInterface'
  set maxSize(_i3.Size? value) {
    _i5.setProperty(
      this,
      'maxSize',
      value ?? _i4.undefined,
    );
  }

  /* #13097
  source: 
    position?: Point; */
  _i3.Point? get position => _i5.getProperty(
        this,
        'position',
      );
  /* #13097
  source: 
    position?: Point; */
  // Type Instance of 'InteropInterface'
  set position(_i3.Point? value) {
    _i5.setProperty(
      this,
      'position',
      value ?? _i4.undefined,
    );
  }

  /* #13098
  source: 
    parts?: Iterable<Part>; */
  _i3.Iterable<_i3.Part>? get parts => _i5.getProperty(
        this,
        'parts',
      );
  /* #13098
  source: 
    parts?: Iterable<Part>; */
  // Type Instance of 'InteropInterface'
  set parts(_i3.Iterable<_i3.Part>? value) {
    _i5.setProperty(
      this,
      'parts',
      value ?? _i4.undefined,
    );
  }

  /* #13099
  source: 
    padding?: MarginLike; */
  _i3.MarginLike? get padding => _i5.getProperty(
        this,
        'padding',
      );
  /* #13099
  source: 
    padding?: MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set padding(_i3.MarginLike? value) {
    _i5.setProperty(
      this,
      'padding',
      value ?? _i4.undefined ?? _i4.undefined,
    );
  }

  /* #13100
  source: 
    background?: BrushLike; */
  _i3.BrushLike? get background => _i5.getProperty(
        this,
        'background',
      );
  /* #13100
  source: 
    background?: BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set background(_i3.BrushLike? value) {
    _i5.setProperty(
      this,
      'background',
      value ?? _i4.undefined ?? _i4.undefined,
    );
  }

  /* #13101
  source: 
    showTemporary?: boolean; */
  _i2.bool? get showTemporary => _i5.getProperty(
        this,
        'showTemporary',
      );
  /* #13101
  source: 
    showTemporary?: boolean; */
  // Type InteropStaticType.boolean
  set showTemporary(_i2.bool? value) {
    _i5.setProperty(
      this,
      'showTemporary',
      value ?? _i4.undefined,
    );
  }

  /* #13102
  source: 
    showGrid?: boolean; */
  _i2.bool? get showGrid => _i5.getProperty(
        this,
        'showGrid',
      );
  /* #13102
  source: 
    showGrid?: boolean; */
  // Type InteropStaticType.boolean
  set showGrid(_i2.bool? value) {
    _i5.setProperty(
      this,
      'showGrid',
      value ?? _i4.undefined,
    );
  }

  /* #13103
  source: 
    document?: HTMLDocument; */
  _i4.HTMLDocument? get document => _i5.getProperty(
        this,
        'document',
      );
  /* #13103
  source: 
    document?: HTMLDocument; */
  // Type Instance of 'ExternalInteropType'
  set document(_i4.HTMLDocument? value) {
    _i5.setProperty(
      this,
      'document',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class SvgRendererOptions implements _i3.DiagramRendererOptions {
  external factory SvgRendererOptions._({
    _i2.dynamic elementFinished,
    _i2.dynamic size,
    _i2.dynamic scale,
    _i2.dynamic maxSize,
    _i2.dynamic position,
    _i2.dynamic parts,
    _i2.dynamic padding,
    _i2.dynamic background,
    _i2.dynamic showTemporary,
    _i2.dynamic showGrid,
    _i2.dynamic document,
  });

  factory SvgRendererOptions({
    void Function(
      _i3.GraphObject,
      _i4.SVGElement,
    )? elementFinished,
    _i3.Size? size,
    _i2.num? scale,
    _i3.Size? maxSize,
    _i3.Point? position,
    _i3.Iterable<_i3.Part>? parts,
    _i3.MarginLike? padding,
    _i3.BrushLike? background,
    _i2.bool? showTemporary,
    _i2.bool? showGrid,
    _i4.HTMLDocument? document,
  }) =>
      SvgRendererOptions._(
        elementFinished: elementFinished == null
            ? _i4.undefined
            : _i5.allowInterop(elementFinished),
        size: size ?? _i4.undefined,
        scale: scale ?? _i4.undefined,
        maxSize: maxSize ?? _i4.undefined,
        position: position ?? _i4.undefined,
        parts: parts ?? _i4.undefined,
        padding: padding ?? _i4.undefined ?? _i4.undefined,
        background: background ?? _i4.undefined ?? _i4.undefined,
        showTemporary: showTemporary ?? _i4.undefined,
        showGrid: showGrid ?? _i4.undefined,
        document: document ?? _i4.undefined,
      );
}

extension SvgRendererOptions$Typings on SvgRendererOptions {
  /* #13109
  source: 
    elementFinished?: ((graphobj: GraphObject, svgelt: SVGElement) => void) | null; */
  void Function(
    _i3.GraphObject,
    _i4.SVGElement,
  )? get elementFinished => _i5.getProperty(
        this,
        'elementFinished',
      );
  /* #13109
  source: 
    elementFinished?: ((graphobj: GraphObject, svgelt: SVGElement) => void) | null; */
  // Type InteropUnion#687753731(parent: InteropGetter#608078386(name: elementFinished))
  set elementFinished(
      void Function(
        _i3.GraphObject,
        _i4.SVGElement,
      )? value) {
    _i5.setProperty(
      this,
      'elementFinished',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class ImageRendererOptions implements _i3.DiagramRendererOptions {
  external factory ImageRendererOptions._({
    _i2.dynamic type,
    _i2.dynamic returnType,
    _i2.dynamic callback,
    _i2.dynamic callbackTimeout,
    _i2.dynamic details,
    _i2.dynamic size,
    _i2.dynamic scale,
    _i2.dynamic maxSize,
    _i2.dynamic position,
    _i2.dynamic parts,
    _i2.dynamic padding,
    _i2.dynamic background,
    _i2.dynamic showTemporary,
    _i2.dynamic showGrid,
    _i2.dynamic document,
  });

  factory ImageRendererOptions({
    _i2.String? type,
    _i2.String? returnType,
    void Function(_i2.dynamic)? callback,
    _i2.num? callbackTimeout,
    _i2.Object? details,
    _i3.Size? size,
    _i2.num? scale,
    _i3.Size? maxSize,
    _i3.Point? position,
    _i3.Iterable<_i3.Part>? parts,
    _i3.MarginLike? padding,
    _i3.BrushLike? background,
    _i2.bool? showTemporary,
    _i2.bool? showGrid,
    _i4.HTMLDocument? document,
  }) =>
      ImageRendererOptions._(
        type: type ?? _i4.undefined,
        returnType: returnType ?? _i4.undefined,
        callback: callback == null ? _i4.undefined : _i5.allowInterop(callback),
        callbackTimeout: callbackTimeout ?? _i4.undefined,
        details: details ?? _i4.undefined,
        size: size ?? _i4.undefined,
        scale: scale ?? _i4.undefined,
        maxSize: maxSize ?? _i4.undefined,
        position: position ?? _i4.undefined,
        parts: parts ?? _i4.undefined,
        padding: padding ?? _i4.undefined ?? _i4.undefined,
        background: background ?? _i4.undefined ?? _i4.undefined,
        showTemporary: showTemporary ?? _i4.undefined,
        showGrid: showGrid ?? _i4.undefined,
        document: document ?? _i4.undefined,
      );
}

extension ImageRendererOptions$Typings on ImageRendererOptions {
  /* #13115
  source: 
    type?: string; */
  _i2.String? get type => _i5.getProperty(
        this,
        'type',
      );
  /* #13115
  source: 
    type?: string; */
  // Type InteropStaticType.string
  set type(_i2.String? value) {
    _i5.setProperty(
      this,
      'type',
      value ?? _i4.undefined,
    );
  }

  /* #13116
  source: 
    returnType?: string; */
  _i2.String? get returnType => _i5.getProperty(
        this,
        'returnType',
      );
  /* #13116
  source: 
    returnType?: string; */
  // Type InteropStaticType.string
  set returnType(_i2.String? value) {
    _i5.setProperty(
      this,
      'returnType',
      value ?? _i4.undefined,
    );
  }

  /* #13117
  source: 
    callback?: ((result: any) => void) | null; */
  void Function(_i2.dynamic)? get callback => _i5.getProperty(
        this,
        'callback',
      );
  /* #13117
  source: 
    callback?: ((result: any) => void) | null; */
  // Type InteropUnion#472719904(parent: InteropGetter#508015359(name: callback))
  set callback(void Function(_i2.dynamic)? value) {
    _i5.setProperty(
      this,
      'callback',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #13118
  source: 
    callbackTimeout?: number; */
  _i2.num? get callbackTimeout => _i5.getProperty(
        this,
        'callbackTimeout',
      );
  /* #13118
  source: 
    callbackTimeout?: number; */
  // Type InteropStaticType.number
  set callbackTimeout(_i2.num? value) {
    _i5.setProperty(
      this,
      'callbackTimeout',
      value ?? _i4.undefined,
    );
  }

  /* #13119
  source: 
    details?: ObjectData; */
  _i2.Object? get details => _i5.getProperty(
        this,
        'details',
      );
  /* #13119
  source: 
    details?: ObjectData; */
  // Type Instance of 'InteropInterface'
  set details(_i2.Object? value) {
    _i5.setProperty(
      this,
      'details',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Palette implements _i3.Diagram {
  factory Palette.$1() => _i5.callConstructor(
        _declaredPalette,
        [],
      );

  factory Palette.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredPalette,
        [init ?? _i4.undefined],
      );

  factory Palette.$3([
    _i2.Object? div,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredPalette,
        [
          div ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Palette')
external _i2.Object _declaredPalette;

@_i1.JS()
@_i1.staticInterop
class Overview implements _i3.Diagram {
  factory Overview.$1() => _i5.callConstructor(
        _declaredOverview,
        [],
      );

  factory Overview.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredOverview,
        [init ?? _i4.undefined],
      );

  factory Overview.$3([
    _i2.Object? div,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredOverview,
        [
          div ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Overview')
external _i2.Object _declaredOverview;

extension Overview$Typings on Overview {
  /* #13212
  source: 
    /**
     * Gets or sets the Diagram for which this Overview is
     * displaying a model and showing its viewport into that model.
     *
     * The value must be null or another Diagram, but may not be an Overview.
     */
    get observed(): Diagram | null; */
  /// Gets or sets the Diagram for which this Overview is
  /// displaying a model and showing its viewport into that model.
  ///
  /// The value must be null or another Diagram, but may not be an Overview.
  _i3.Diagram? get observed => _i5.getProperty(
        this,
        'observed',
      );
  /* #13212
  source: 
    /**
     * Gets or sets the Diagram for which this Overview is
     * displaying a model and showing its viewport into that model.
     *
     * The value must be null or another Diagram, but may not be an Overview.
     */
    get observed(): Diagram | null; */
  // Type InteropUnion#818288283(parent: InteropGetter#838548806(name: observed))
  set observed(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'observed',
      value ?? _i4.undefined,
    );
  }

  /* #13220
  source: 
    /**
     * Gets or sets the rectangular Part that represents the
     * viewport of the #observed Diagram.
     * By default the part contains only a magenta Shape.
     * The box's Part#selectionObject is what is resized by the Overview to the apparent size of the observed diagram's viewport.
     */
    get box(): Part; */
  /// Gets or sets the rectangular Part that represents the
  /// viewport of the #observed Diagram.
  /// By default the part contains only a magenta Shape.
  /// The box's Part#selectionObject is what is resized by the Overview to the apparent size of the observed diagram's viewport.
  _i3.Part get box => _i5.getProperty(
        this,
        'box',
      );
  /* #13220
  source: 
    /**
     * Gets or sets the rectangular Part that represents the
     * viewport of the #observed Diagram.
     * By default the part contains only a magenta Shape.
     * The box's Part#selectionObject is what is resized by the Overview to the apparent size of the observed diagram's viewport.
     */
    get box(): Part; */
  // Type Instance of 'InteropInterface'
  set box(_i3.Part value) {
    _i5.setProperty(
      this,
      'box',
      value,
    );
  }

  /* #13231
  source: 
    /**
     * Gets or sets whether this overview draws the temporary layers of the observed Diagram.
     * The default value is true.
     * Setting this property to false may improve drawing performance,
     * especially if the Diagram#grid is visible.
     *
     * Setting this property does not notify about any changed event.
     * @since 1.2
     */
    get drawsTemporaryLayers(): boolean; */
  /// Gets or sets whether this overview draws the temporary layers of the observed Diagram.
  /// The default value is true.
  /// Setting this property to false may improve drawing performance,
  /// especially if the Diagram#grid is visible.
  ///
  /// Setting this property does not notify about any changed event.
  _i2.bool get drawsTemporaryLayers => _i5.getProperty(
        this,
        'drawsTemporaryLayers',
      );
  /* #13231
  source: 
    /**
     * Gets or sets whether this overview draws the temporary layers of the observed Diagram.
     * The default value is true.
     * Setting this property to false may improve drawing performance,
     * especially if the Diagram#grid is visible.
     *
     * Setting this property does not notify about any changed event.
     * @since 1.2
     */
    get drawsTemporaryLayers(): boolean; */
  // Type InteropStaticType.boolean
  set drawsTemporaryLayers(_i2.bool value) {
    _i5.setProperty(
      this,
      'drawsTemporaryLayers',
      value,
    );
  }

  /* #13243
  source: 
    /**
     * Gets or sets whether this overview draws the Diagram#grid of the observed Diagram,
     * if it is visible.  The default value is true.
     *
     * This property is only considered when #drawsTemporaryLayers is true.
     * Setting this to false may help improve drawing performance.
     *
     * Setting this property does not notify about any changed event.
     * @since 2.2
     */
    get drawsGrid(): boolean; */
  /// Gets or sets whether this overview draws the Diagram#grid of the observed Diagram,
  /// if it is visible.  The default value is true.
  ///
  /// This property is only considered when #drawsTemporaryLayers is true.
  /// Setting this to false may help improve drawing performance.
  ///
  /// Setting this property does not notify about any changed event.
  _i2.bool get drawsGrid => _i5.getProperty(
        this,
        'drawsGrid',
      );
  /* #13243
  source: 
    /**
     * Gets or sets whether this overview draws the Diagram#grid of the observed Diagram,
     * if it is visible.  The default value is true.
     *
     * This property is only considered when #drawsTemporaryLayers is true.
     * Setting this to false may help improve drawing performance.
     *
     * Setting this property does not notify about any changed event.
     * @since 2.2
     */
    get drawsGrid(): boolean; */
  // Type InteropStaticType.boolean
  set drawsGrid(_i2.bool value) {
    _i5.setProperty(
      this,
      'drawsGrid',
      value,
    );
  }

  /* #13253
  source: 
    /**
     * Gets or sets how long it waits before updating, in milliseconds.
     * The default value is zero.
     * Any new value must be a non-negative number.
     *
     * Setting this property does not notify about any changed event.
     * @since 2.2
     */
    get updateDelay(): number; */
  /// Gets or sets how long it waits before updating, in milliseconds.
  /// The default value is zero.
  /// Any new value must be a non-negative number.
  ///
  /// Setting this property does not notify about any changed event.
  _i2.num get updateDelay => _i5.getProperty(
        this,
        'updateDelay',
      );
  /* #13253
  source: 
    /**
     * Gets or sets how long it waits before updating, in milliseconds.
     * The default value is zero.
     * Any new value must be a non-negative number.
     *
     * Setting this property does not notify about any changed event.
     * @since 2.2
     */
    get updateDelay(): number; */
  // Type InteropStaticType.number
  set updateDelay(_i2.num value) {
    _i5.setProperty(
      this,
      'updateDelay',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class CommandHandler {
  factory CommandHandler() => _i5.callConstructor(
        _declaredCommandHandler,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('CommandHandler')
external _i2.Object _declaredCommandHandler;

extension CommandHandler$Typings on CommandHandler {
  /* #13313
  source: 
    /**
     * This read-only property returns the Diagram that is using this CommandHandler,
     * after Diagram#commandHandler has been set to this object.
     */
    get diagram(): Diagram; */
  /// This read-only property returns the Diagram that is using this CommandHandler,
  /// after Diagram#commandHandler has been set to this object.
  _i3.Diagram get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #13313
  source: 
    /**
     * This read-only property returns the Diagram that is using this CommandHandler,
     * after Diagram#commandHandler has been set to this object.
     */
    get diagram(): Diagram; */
  // Type Instance of 'InteropInterface'
  set diagram(_i3.Diagram value) {
    _i5.setProperty(
      this,
      'diagram',
      value,
    );
  }

  /* #14051
  source: 
    /**
     * Gets or sets whether #copySelection should also copy Links that connect with selected Nodes.
     * The default value is true.
     * Setting this property does not raise any events.
     *
     * The DraggingTool#copiesEffectiveCollection property serves a similar role for the DraggingTool
     * when the user holds down the control key to modify the drag into a copy operation.
     * @since 1.5
     */
    get copiesConnectedLinks(): boolean; */
  /// Gets or sets whether #copySelection should also copy Links that connect with selected Nodes.
  /// The default value is true.
  /// Setting this property does not raise any events.
  ///
  /// The DraggingTool#copiesEffectiveCollection property serves a similar role for the DraggingTool
  /// when the user holds down the control key to modify the drag into a copy operation.
  _i2.bool get copiesConnectedLinks => _i5.getProperty(
        this,
        'copiesConnectedLinks',
      );
  /* #14051
  source: 
    /**
     * Gets or sets whether #copySelection should also copy Links that connect with selected Nodes.
     * The default value is true.
     * Setting this property does not raise any events.
     *
     * The DraggingTool#copiesEffectiveCollection property serves a similar role for the DraggingTool
     * when the user holds down the control key to modify the drag into a copy operation.
     * @since 1.5
     */
    get copiesConnectedLinks(): boolean; */
  // Type InteropStaticType.boolean
  set copiesConnectedLinks(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesConnectedLinks',
      value,
    );
  }

  /* #14059
  source: 
    /**
     * Gets or sets whether #deleteSelection should also delete links that are connected to nodes that are deleted.
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 1.6
     */
    get deletesConnectedLinks(): boolean; */
  /// Gets or sets whether #deleteSelection should also delete links that are connected to nodes that are deleted.
  /// The default value is true.
  /// Setting this property does not raise any events.
  _i2.bool get deletesConnectedLinks => _i5.getProperty(
        this,
        'deletesConnectedLinks',
      );
  /* #14059
  source: 
    /**
     * Gets or sets whether #deleteSelection should also delete links that are connected to nodes that are deleted.
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 1.6
     */
    get deletesConnectedLinks(): boolean; */
  // Type InteropStaticType.boolean
  set deletesConnectedLinks(_i2.bool value) {
    _i5.setProperty(
      this,
      'deletesConnectedLinks',
      value,
    );
  }

  /* #14069
  source: 
    /**
     * Gets or sets whether #copySelection should also copy subtrees.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * The DraggingTool#dragsTree property serves a similar role for the DraggingTool
     * for both moving and copying operations.
     */
    get copiesTree(): boolean; */
  /// Gets or sets whether #copySelection should also copy subtrees.
  /// The default value is false.
  /// Setting this property does not raise any events.
  ///
  /// The DraggingTool#dragsTree property serves a similar role for the DraggingTool
  /// for both moving and copying operations.
  _i2.bool get copiesTree => _i5.getProperty(
        this,
        'copiesTree',
      );
  /* #14069
  source: 
    /**
     * Gets or sets whether #copySelection should also copy subtrees.
     * The default value is false.
     * Setting this property does not raise any events.
     *
     * The DraggingTool#dragsTree property serves a similar role for the DraggingTool
     * for both moving and copying operations.
     */
    get copiesTree(): boolean; */
  // Type InteropStaticType.boolean
  set copiesTree(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesTree',
      value,
    );
  }

  /* #14076
  source: 
    /**
     * Gets or sets whether #deleteSelection should also delete subtrees.
     * The default value is false.
     * Setting this property does not raise any events.
     */
    get deletesTree(): boolean; */
  /// Gets or sets whether #deleteSelection should also delete subtrees.
  /// The default value is false.
  /// Setting this property does not raise any events.
  _i2.bool get deletesTree => _i5.getProperty(
        this,
        'deletesTree',
      );
  /* #14076
  source: 
    /**
     * Gets or sets whether #deleteSelection should also delete subtrees.
     * The default value is false.
     * Setting this property does not raise any events.
     */
    get deletesTree(): boolean; */
  // Type InteropStaticType.boolean
  set deletesTree(_i2.bool value) {
    _i5.setProperty(
      this,
      'deletesTree',
      value,
    );
  }

  /* #14088
  source: 
    /**
     * Gets or sets whether #copySelection and #copyToClipboard copy the node data property
     * whose value is the tree-parent node data's key.
     *
     * Set this property to true if you want a copy/paste of a node to automatically have the new node be a tree-child of the original tree-parent node.
     * Caution: this only has an effect if the Diagram's Diagram#model is a TreeModel.
     *
     * The default value is false.
     * @since 1.3
     */
    get copiesParentKey(): boolean; */
  /// Gets or sets whether #copySelection and #copyToClipboard copy the node data property
  /// whose value is the tree-parent node data's key.
  ///
  /// Set this property to true if you want a copy/paste of a node to automatically have the new node be a tree-child of the original tree-parent node.
  /// Caution: this only has an effect if the Diagram's Diagram#model is a TreeModel.
  ///
  /// The default value is false.
  _i2.bool get copiesParentKey => _i5.getProperty(
        this,
        'copiesParentKey',
      );
  /* #14088
  source: 
    /**
     * Gets or sets whether #copySelection and #copyToClipboard copy the node data property
     * whose value is the tree-parent node data's key.
     *
     * Set this property to true if you want a copy/paste of a node to automatically have the new node be a tree-child of the original tree-parent node.
     * Caution: this only has an effect if the Diagram's Diagram#model is a TreeModel.
     *
     * The default value is false.
     * @since 1.3
     */
    get copiesParentKey(): boolean; */
  // Type InteropStaticType.boolean
  set copiesParentKey(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesParentKey',
      value,
    );
  }

  /* #14100
  source: 
    /**
     * Gets or sets whether #copySelection and #copyToClipboard copy the node data property
     * whose value is the containing group data's key.
     *
     * Set this property to true if you want a copy/paste of a node to automatically have the new node be a member of the original group.
     * Caution: this only has an effect if the Diagram's Diagram#model is a GraphLinksModel.
     *
     * The default value is false.
     * @since 1.3
     */
    get copiesGroupKey(): boolean; */
  /// Gets or sets whether #copySelection and #copyToClipboard copy the node data property
  /// whose value is the containing group data's key.
  ///
  /// Set this property to true if you want a copy/paste of a node to automatically have the new node be a member of the original group.
  /// Caution: this only has an effect if the Diagram's Diagram#model is a GraphLinksModel.
  ///
  /// The default value is false.
  _i2.bool get copiesGroupKey => _i5.getProperty(
        this,
        'copiesGroupKey',
      );
  /* #14100
  source: 
    /**
     * Gets or sets whether #copySelection and #copyToClipboard copy the node data property
     * whose value is the containing group data's key.
     *
     * Set this property to true if you want a copy/paste of a node to automatically have the new node be a member of the original group.
     * Caution: this only has an effect if the Diagram's Diagram#model is a GraphLinksModel.
     *
     * The default value is false.
     * @since 1.3
     */
    get copiesGroupKey(): boolean; */
  // Type InteropStaticType.boolean
  set copiesGroupKey(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesGroupKey',
      value,
    );
  }

  /* #14110
  source: 
    /**
     * Gets or sets a data object that is copied by #groupSelection
     * when creating a new Group.
     *
     * The default value is null.
     * If you set this to an Object, be sure that GraphLinksModel#isGroupForNodeData is true for that object.
     * Setting this property does not raise any events.
     */
    get archetypeGroupData(): ObjectData; */
  /// Gets or sets a data object that is copied by #groupSelection
  /// when creating a new Group.
  ///
  /// The default value is null.
  /// If you set this to an Object, be sure that GraphLinksModel#isGroupForNodeData is true for that object.
  /// Setting this property does not raise any events.
  _i2.Object get archetypeGroupData => _i5.getProperty(
        this,
        'archetypeGroupData',
      );
  /* #14110
  source: 
    /**
     * Gets or sets a data object that is copied by #groupSelection
     * when creating a new Group.
     *
     * The default value is null.
     * If you set this to an Object, be sure that GraphLinksModel#isGroupForNodeData is true for that object.
     * Setting this property does not raise any events.
     */
    get archetypeGroupData(): ObjectData; */
  // Type Instance of 'InteropInterface'
  set archetypeGroupData(_i2.Object value) {
    _i5.setProperty(
      this,
      'archetypeGroupData',
      value,
    );
  }

  /* #14123
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a node may become a member of a group.
     * This predicate is called in addition to any existing group's Group#memberValidation predicate.
     * The default predicate is null, which is equivalent to simply returning true.
     * The predicate may be called passing null as the first argument (the Group) --
     * this asks whether it is OK to make the second argument (the Part, but not a Link) a top-level Part of the diagram.
     * <p class="box">
     * For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get memberValidation(): ((aGroup: Group, somePart: Part) => boolean) | null; */
  /// Gets or sets the predicate that determines whether or not a node may become a member of a group.
  /// This predicate is called in addition to any existing group's Group#memberValidation predicate.
  /// The default predicate is null, which is equivalent to simply returning true.
  /// The predicate may be called passing null as the first argument (the Group) --
  /// this asks whether it is OK to make the second argument (the Part, but not a Link) a top-level Part of the diagram.
  /// <p class="box">
  /// For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
  ///
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i3.Group,
    _i3.Part,
  )? get memberValidation => _i5.getProperty(
        this,
        'memberValidation',
      );
  /* #14123
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a node may become a member of a group.
     * This predicate is called in addition to any existing group's Group#memberValidation predicate.
     * The default predicate is null, which is equivalent to simply returning true.
     * The predicate may be called passing null as the first argument (the Group) --
     * this asks whether it is OK to make the second argument (the Part, but not a Link) a top-level Part of the diagram.
     * <p class="box">
     * For a more general discussion of validation, see <a href="../../intro/validation.html">Introduction to Validation</a>.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get memberValidation(): ((aGroup: Group, somePart: Part) => boolean) | null; */
  // Type InteropUnion#366986942(parent: InteropGetter#71644085(name: memberValidation))
  set memberValidation(
      _i2.bool Function(
        _i3.Group,
        _i3.Part,
      )? value) {
    _i5.setProperty(
      this,
      'memberValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #14129
  source: 
    /**
     * (undocumented)
     * Deprecated in favor of Diagram#defaultScale.
     */
    get defaultScale(): number; */
  /// (undocumented)
  /// Deprecated in favor of Diagram#defaultScale.
  _i2.num get defaultScale => _i5.getProperty(
        this,
        'defaultScale',
      );
  /* #14129
  source: 
    /**
     * (undocumented)
     * Deprecated in favor of Diagram#defaultScale.
     */
    get defaultScale(): number; */
  // Type InteropStaticType.number
  set defaultScale(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultScale',
      value,
    );
  }

  /* #14140
  source: 
    /**
     * Gets or sets the amount by which #decreaseZoom and #increaseZoom change
     * the Diagram#scale.
     *
     * The default value is 1.05 (5%).
     * The value must be a number larger than 1.0.
     * Setting this property does not raise any events.
     * @since 1.1
     */
    get zoomFactor(): number; */
  /// Gets or sets the amount by which #decreaseZoom and #increaseZoom change
  /// the Diagram#scale.
  ///
  /// The default value is 1.05 (5%).
  /// The value must be a number larger than 1.0.
  /// Setting this property does not raise any events.
  _i2.num get zoomFactor => _i5.getProperty(
        this,
        'zoomFactor',
      );
  /* #14140
  source: 
    /**
     * Gets or sets the amount by which #decreaseZoom and #increaseZoom change
     * the Diagram#scale.
     *
     * The default value is 1.05 (5%).
     * The value must be a number larger than 1.0.
     * Setting this property does not raise any events.
     * @since 1.1
     */
    get zoomFactor(): number; */
  // Type InteropStaticType.number
  set zoomFactor(_i2.num value) {
    _i5.setProperty(
      this,
      'zoomFactor',
      value,
    );
  }

  /* #14151
  source: 
    /**
     * Gets or sets whether the #zoomToFit command ever restores the previous
     * Diagram scale and position.
     * When this property is false, this command always calls Diagram#zoomToFit.
     *
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 2.2
     */
    get isZoomToFitRestoreEnabled(): boolean; */
  /// Gets or sets whether the #zoomToFit command ever restores the previous
  /// Diagram scale and position.
  /// When this property is false, this command always calls Diagram#zoomToFit.
  ///
  /// The default value is true.
  /// Setting this property does not raise any events.
  _i2.bool get isZoomToFitRestoreEnabled => _i5.getProperty(
        this,
        'isZoomToFitRestoreEnabled',
      );
  /* #14151
  source: 
    /**
     * Gets or sets whether the #zoomToFit command ever restores the previous
     * Diagram scale and position.
     * When this property is false, this command always calls Diagram#zoomToFit.
     *
     * The default value is true.
     * Setting this property does not raise any events.
     * @since 2.2
     */
    get isZoomToFitRestoreEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isZoomToFitRestoreEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isZoomToFitRestoreEnabled',
      value,
    );
  }

  void doKeyDown() {
    _i5.callMethod(
      this,
      'doKeyDown',
      [],
    );
  }

  void doKeyUp() {
    _i5.callMethod(
      this,
      'doKeyUp',
      [],
    );
  }

  void stopCommand() {
    _i5.callMethod(
      this,
      'stopCommand',
      [],
    );
  }

  _i2.bool canStopCommand() => _i5.callMethod(
        this,
        'canStopCommand',
        [],
      );
  void selectAll() {
    _i5.callMethod(
      this,
      'selectAll',
      [],
    );
  }

  _i2.bool canSelectAll() => _i5.callMethod(
        this,
        'canSelectAll',
        [],
      );
  void deleteSelection() {
    _i5.callMethod(
      this,
      'deleteSelection',
      [],
    );
  }

  _i2.bool canDeleteSelection() => _i5.callMethod(
        this,
        'canDeleteSelection',
        [],
      );
  void copySelection() {
    _i5.callMethod(
      this,
      'copySelection',
      [],
    );
  }

  _i2.bool canCopySelection() => _i5.callMethod(
        this,
        'canCopySelection',
        [],
      );
  void cutSelection() {
    _i5.callMethod(
      this,
      'cutSelection',
      [],
    );
  }

  _i2.bool canCutSelection() => _i5.callMethod(
        this,
        'canCutSelection',
        [],
      );
  void copyToClipboard([_i3.Iterable<_i3.Part>? coll]) {
    _i5.callMethod(
      this,
      'copyToClipboard',
      [coll ?? _i4.undefined],
    );
  }

  _i3.Set<_i3.Part> pasteFromClipboard() => _i5.callMethod(
        this,
        'pasteFromClipboard',
        [],
      );
  void pasteSelection([_i3.Point? pos]) {
    _i5.callMethod(
      this,
      'pasteSelection',
      [pos ?? _i4.undefined],
    );
  }

  _i2.bool canPasteSelection([_i3.Point? pos]) => _i5.callMethod(
        this,
        'canPasteSelection',
        [pos ?? _i4.undefined],
      );
  void undo() {
    _i5.callMethod(
      this,
      'undo',
      [],
    );
  }

  _i2.bool canUndo() => _i5.callMethod(
        this,
        'canUndo',
        [],
      );
  void redo() {
    _i5.callMethod(
      this,
      'redo',
      [],
    );
  }

  _i2.bool canRedo() => _i5.callMethod(
        this,
        'canRedo',
        [],
      );
  void decreaseZoom([_i2.num? factor]) {
    _i5.callMethod(
      this,
      'decreaseZoom',
      [factor ?? _i4.undefined],
    );
  }

  _i2.bool canDecreaseZoom([_i2.num? factor]) => _i5.callMethod(
        this,
        'canDecreaseZoom',
        [factor ?? _i4.undefined],
      );
  void increaseZoom([_i2.num? factor]) {
    _i5.callMethod(
      this,
      'increaseZoom',
      [factor ?? _i4.undefined],
    );
  }

  _i2.bool canIncreaseZoom([_i2.num? factor]) => _i5.callMethod(
        this,
        'canIncreaseZoom',
        [factor ?? _i4.undefined],
      );
  void resetZoom([_i2.num? newscale]) {
    _i5.callMethod(
      this,
      'resetZoom',
      [newscale ?? _i4.undefined],
    );
  }

  _i2.bool canResetZoom([_i2.num? newscale]) => _i5.callMethod(
        this,
        'canResetZoom',
        [newscale ?? _i4.undefined],
      );
  void zoomToFit() {
    _i5.callMethod(
      this,
      'zoomToFit',
      [],
    );
  }

  _i2.bool canZoomToFit() => _i5.callMethod(
        this,
        'canZoomToFit',
        [],
      );
  void scrollToPart([_i3.Part? part]) {
    _i5.callMethod(
      this,
      'scrollToPart',
      [part ?? _i4.undefined],
    );
  }

  _i2.bool canScrollToPart([_i3.Part? part]) => _i5.callMethod(
        this,
        'canScrollToPart',
        [part ?? _i4.undefined],
      );
  void collapseTree([_i3.Node? node]) {
    _i5.callMethod(
      this,
      'collapseTree',
      [node ?? _i4.undefined],
    );
  }

  _i2.bool canCollapseTree([_i3.Node? node]) => _i5.callMethod(
        this,
        'canCollapseTree',
        [node ?? _i4.undefined],
      );
  void expandTree([_i3.Node? node]) {
    _i5.callMethod(
      this,
      'expandTree',
      [node ?? _i4.undefined],
    );
  }

  _i2.bool canExpandTree([_i3.Node? node]) => _i5.callMethod(
        this,
        'canExpandTree',
        [node ?? _i4.undefined],
      );
  void groupSelection() {
    _i5.callMethod(
      this,
      'groupSelection',
      [],
    );
  }

  _i2.bool canGroupSelection() => _i5.callMethod(
        this,
        'canGroupSelection',
        [],
      );
  _i2.bool isValidMember(
    _i3.Group group,
    _i3.Part part,
  ) =>
      _i5.callMethod(
        this,
        'isValidMember',
        [
          group,
          part,
        ],
      );
  void ungroupSelection([_i3.Group? group]) {
    _i5.callMethod(
      this,
      'ungroupSelection',
      [group ?? _i4.undefined],
    );
  }

  _i2.bool canUngroupSelection([_i3.Group? group]) => _i5.callMethod(
        this,
        'canUngroupSelection',
        [group ?? _i4.undefined],
      );
  _i2.bool addTopLevelParts(
    _i3.Iterable<_i3.Part> coll, [
    _i2.bool? check,
  ]) =>
      _i5.callMethod(
        this,
        'addTopLevelParts',
        [
          coll,
          check ?? _i4.undefined,
        ],
      );
  void collapseSubGraph([_i3.Group? group]) {
    _i5.callMethod(
      this,
      'collapseSubGraph',
      [group ?? _i4.undefined],
    );
  }

  _i2.bool canCollapseSubGraph([_i3.Group? group]) => _i5.callMethod(
        this,
        'canCollapseSubGraph',
        [group ?? _i4.undefined],
      );
  void expandSubGraph([_i3.Group? group]) {
    _i5.callMethod(
      this,
      'expandSubGraph',
      [group ?? _i4.undefined],
    );
  }

  _i2.bool canExpandSubGraph([_i3.Group? group]) => _i5.callMethod(
        this,
        'canExpandSubGraph',
        [group ?? _i4.undefined],
      );
  void editTextBlock([_i3.TextBlock? textblock]) {
    _i5.callMethod(
      this,
      'editTextBlock',
      [textblock ?? _i4.undefined],
    );
  }

  _i2.bool canEditTextBlock([_i3.TextBlock? textblock]) => _i5.callMethod(
        this,
        'canEditTextBlock',
        [textblock ?? _i4.undefined],
      );
  void showContextMenu([_i2.Object? obj]) {
    _i5.callMethod(
      this,
      'showContextMenu',
      [obj ?? _i4.undefined],
    );
  }

  _i2.bool canShowContextMenu([_i2.Object? obj]) => _i5.callMethod(
        this,
        'canShowContextMenu',
        [obj ?? _i4.undefined],
      );
  _i3.Map<_i3.Part, _i3.DraggingInfo> computeEffectiveCollection(
    _i3.Iterable<_i3.Part> parts, [
    _i3.DraggingOptions? options,
  ]) =>
      _i5.callMethod(
        this,
        'computeEffectiveCollection',
        [
          parts,
          options ?? _i4.undefined,
        ],
      );
}

@_i1.JS()
@_i1.staticInterop
class GraphObject {
  factory GraphObject() => _i5.callConstructor(
        _declaredGraphObject,
        [],
      );

  /* #14437
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are not automatically scaled to fit in the given bounds;
     * there may be clipping in one or both directions if the available dimensions are too small.
     * @constant
     */
    static None: EnumValue; */
  /// GraphObjects with this enumeration as the value of GraphObject#stretch
  /// are not automatically scaled to fit in the given bounds;
  /// there may be clipping in one or both directions if the available dimensions are too small.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredGraphObject,
        'None',
      );
  /* #14437
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are not automatically scaled to fit in the given bounds;
     * there may be clipping in one or both directions if the available dimensions are too small.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'None',
      value,
    );
  }

  /* #14444
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are stretched depending on the context they are used. For instance a 'Circle' figure might
     * be uniformly stretched whereas an 'Ellipse' figure might be non-uniformly stretched.
     * @constant
     */
    static Default: EnumValue; */
  /// GraphObjects with this enumeration as the value of GraphObject#stretch
  /// are stretched depending on the context they are used. For instance a 'Circle' figure might
  /// be uniformly stretched whereas an 'Ellipse' figure might be non-uniformly stretched.
  static _i3.EnumValue get default$ => _i5.getProperty(
        _declaredGraphObject,
        'Default',
      );
  /* #14444
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are stretched depending on the context they are used. For instance a 'Circle' figure might
     * be uniformly stretched whereas an 'Ellipse' figure might be non-uniformly stretched.
     * @constant
     */
    static Default: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set default$(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'Default',
      value,
    );
  }

  /* #14450
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled as much as possible in the y-axis. In another context, can be used as a value of PanelLayout, so type is "any".
     * @constant
     */
    static Vertical: any; */
  /// GraphObjects with this enumeration as the value of GraphObject#stretch
  /// are scaled as much as possible in the y-axis. In another context, can be used as a value of PanelLayout, so type is "any".
  static _i2.dynamic get vertical => _i5.getProperty(
        _declaredGraphObject,
        'Vertical',
      );
  /* #14450
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled as much as possible in the y-axis. In another context, can be used as a value of PanelLayout, so type is "any".
     * @constant
     */
    static Vertical: any; */
  // Type InteropStaticType.dyn
  static set vertical(_i2.dynamic value) {
    _i5.setProperty(
      _declaredGraphObject,
      'Vertical',
      value,
    );
  }

  /* #14456
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled as much as possible in the x-axis. In another context, can be used as a value of PanelLayout, so type is "any".
     * @constant
     */
    static Horizontal: any; */
  /// GraphObjects with this enumeration as the value of GraphObject#stretch
  /// are scaled as much as possible in the x-axis. In another context, can be used as a value of PanelLayout, so type is "any".
  static _i2.dynamic get horizontal => _i5.getProperty(
        _declaredGraphObject,
        'Horizontal',
      );
  /* #14456
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled as much as possible in the x-axis. In another context, can be used as a value of PanelLayout, so type is "any".
     * @constant
     */
    static Horizontal: any; */
  // Type InteropStaticType.dyn
  static set horizontal(_i2.dynamic value) {
    _i5.setProperty(
      _declaredGraphObject,
      'Horizontal',
      value,
    );
  }

  /* #14463
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled in both directions so as to fit exactly in the given bounds;
     * there is no clipping but the aspect ratio may change, causing the object to appear stretched.
     * @constant
     */
    static Fill: EnumValue; */
  /// GraphObjects with this enumeration as the value of GraphObject#stretch
  /// are scaled in both directions so as to fit exactly in the given bounds;
  /// there is no clipping but the aspect ratio may change, causing the object to appear stretched.
  static _i3.EnumValue get fill => _i5.getProperty(
        _declaredGraphObject,
        'Fill',
      );
  /* #14463
  source: 
    /**
     * GraphObjects with this enumeration as the value of GraphObject#stretch
     * are scaled in both directions so as to fit exactly in the given bounds;
     * there is no clipping but the aspect ratio may change, causing the object to appear stretched.
     * @constant
     */
    static Fill: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set fill(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'Fill',
      value,
    );
  }

  /* #14472
  source: 
    /**
     * Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
     * scale in both directions to fit the larger side of the image bounds;
     * Panels of type Viewbox with this as the value of Panel#viewboxStretch
     * scale the contained element equally in both directions to fit the larger side
     * of the element's bounds in the given bounds.
     * @constant
     */
    static Uniform: EnumValue; */
  /// Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
  /// scale in both directions to fit the larger side of the image bounds;
  /// Panels of type Viewbox with this as the value of Panel#viewboxStretch
  /// scale the contained element equally in both directions to fit the larger side
  /// of the element's bounds in the given bounds.
  static _i3.EnumValue get uniform => _i5.getProperty(
        _declaredGraphObject,
        'Uniform',
      );
  /* #14472
  source: 
    /**
     * Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
     * scale in both directions to fit the larger side of the image bounds;
     * Panels of type Viewbox with this as the value of Panel#viewboxStretch
     * scale the contained element equally in both directions to fit the larger side
     * of the element's bounds in the given bounds.
     * @constant
     */
    static Uniform: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set uniform(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'Uniform',
      value,
    );
  }

  /* #14482
  source: 
    /**
     * Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
     * scale in both directions to fit the arranged (actual) bounds;
     * Panels of type Viewbox with this as the value of Panel#viewboxStretch
     * scale the contained element equally in both directions to fit the smaller side
     * of the element's bounds in the given bounds.
     * There may be clipping in one dimension.
     * @constant
     */
    static UniformToFill: EnumValue; */
  /// Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
  /// scale in both directions to fit the arranged (actual) bounds;
  /// Panels of type Viewbox with this as the value of Panel#viewboxStretch
  /// scale the contained element equally in both directions to fit the smaller side
  /// of the element's bounds in the given bounds.
  /// There may be clipping in one dimension.
  static _i3.EnumValue get uniformToFill => _i5.getProperty(
        _declaredGraphObject,
        'UniformToFill',
      );
  /* #14482
  source: 
    /**
     * Pictures with this enumeration as the value of Picture#imageStretch are drawn with equal
     * scale in both directions to fit the arranged (actual) bounds;
     * Panels of type Viewbox with this as the value of Panel#viewboxStretch
     * scale the contained element equally in both directions to fit the smaller side
     * of the element's bounds in the given bounds.
     * There may be clipping in one dimension.
     * @constant
     */
    static UniformToFill: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set uniformToFill(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'UniformToFill',
      value,
    );
  }

  /* #14489
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn upside-down, with Y coordinate points increasing upwards.
     * @constant
     * @since 2.0
     */
    static FlipVertical: EnumValue; */
  /// GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
  /// are drawn upside-down, with Y coordinate points increasing upwards.
  static _i3.EnumValue get flipVertical => _i5.getProperty(
        _declaredGraphObject,
        'FlipVertical',
      );
  /* #14489
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn upside-down, with Y coordinate points increasing upwards.
     * @constant
     * @since 2.0
     */
    static FlipVertical: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set flipVertical(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'FlipVertical',
      value,
    );
  }

  /* #14496
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn mirror-image, with X coordinate points increasing towards the left.
     * @constant
     * @since 2.0
     */
    static FlipHorizontal: EnumValue; */
  /// GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
  /// are drawn mirror-image, with X coordinate points increasing towards the left.
  static _i3.EnumValue get flipHorizontal => _i5.getProperty(
        _declaredGraphObject,
        'FlipHorizontal',
      );
  /* #14496
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn mirror-image, with X coordinate points increasing towards the left.
     * @constant
     * @since 2.0
     */
    static FlipHorizontal: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set flipHorizontal(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'FlipHorizontal',
      value,
    );
  }

  /* #14503
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn with both X and Y coordinates reversed.
     * @constant
     * @since 2.0
     */
    static FlipBoth: EnumValue; */
  /// GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
  /// are drawn with both X and Y coordinates reversed.
  static _i3.EnumValue get flipBoth => _i5.getProperty(
        _declaredGraphObject,
        'FlipBoth',
      );
  /* #14503
  source: 
    /**
     * GraphObjects with this enumeration as the value of Picture#flip or TextBlock#flip
     * are drawn with both X and Y coordinates reversed.
     * @constant
     * @since 2.0
     */
    static FlipBoth: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set flipBoth(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGraphObject,
      'FlipBoth',
      value,
    );
  }

  static T build<T extends _i3.GraphObject>(
    _i2.String name, [
    _i4.Partial? config,
    _i2.Iterable<_i2.dynamic>? args,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'build',
        [
          name,
          config ?? _i4.undefined,
          ...?args,
        ],
      );
  static T _make$1<T extends _i3.Adornment>(
    Make cls, [
    _i2.Iterable<_i2.dynamic>? initializers,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'make',
        [
          cls.name,
          ...?initializers,
        ],
      );
  static T _make$2<T extends _i3.Panel>(
    MakeOptions cls, [
    _i2.Iterable<_i2.dynamic>? initializers,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'make',
        [
          cls.name,
          ...?initializers,
        ],
      );
  static T _make$3<T extends _i3.GraphObject>(
    _i2.String cls, [
    _i2.Iterable<_i2.dynamic>? initializers,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'make',
        [
          cls,
          ...?initializers,
        ],
      );
  static _i4.InstanceType _make$4<CT extends _i3.ConstructorType<CT>>(
    CT cls, [
    _i2.Iterable<_i2.dynamic>? initializers,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'make',
        [
          cls,
          ...?initializers,
        ],
      );
  // HEYA make
  static ({
    T Function<T extends _i3.Adornment>(
      Make cls, [
      _i2.Iterable<_i2.dynamic>? initializers,
    ]) $1,
    T Function<T extends _i3.Panel>(
      MakeOptions cls, [
      _i2.Iterable<_i2.dynamic>? initializers,
    ]) $2,
    T Function<T extends _i3.GraphObject>(
      _i2.String cls, [
      _i2.Iterable<_i2.dynamic>? initializers,
    ]) $3,
    _i4.InstanceType Function<CT extends _i3.ConstructorType<CT>>(
      CT cls, [
      _i2.Iterable<_i2.dynamic>? initializers,
    ]) $4,
  }) get make => (
        $1: _make$1,
        $2: _make$2,
        $3: _make$3,
        $4: _make$4,
      );
  static void defineBuilder(
    _i2.String name,
    _i2.Object Function(_i4.Array) func,
  ) {
    _i5.callMethod(
      _declaredGraphObject,
      'defineBuilder',
      [
        name,
        _i5.allowInterop(func),
      ],
    );
  }

  static _i2.dynamic takeBuilderArgument(
    _i4.Array args, [
    _i2.dynamic defval,
    _i2.bool Function(_i2.dynamic)? pred,
  ]) =>
      _i5.callMethod(
        _declaredGraphObject,
        'takeBuilderArgument',
        [
          args,
          defval ?? _i4.undefined,
          pred == null ? _i4.undefined : _i5.allowInterop(pred),
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('GraphObject')
external _i2.Object _declaredGraphObject;

extension GraphObject$Typings on GraphObject {
  /* #14584
  source: 
    /**
     * Gets or sets whether or not this GraphObject will be shadowed inside a Part that has Part#isShadowed set to true.
     *
     * The default is null, which means this GraphObject will obey the default shadow rules (see Part#isShadowed).
     *
     * A value of true or false will ensure that this part is shadowed or not regardless of the default shadow rules,
     * but this GraphObject's shadowed status will not affect other GraphObjects in the Part.
     *
     * Typically this property does not need to be set, but you may need to set this value to false
     * on GraphObjects inside a Part that you do not wish to be shadowed.
     * @see Part#isShadowed
     * @since 1.6
     */
    get shadowVisible(): boolean | null; */
  /// Gets or sets whether or not this GraphObject will be shadowed inside a Part that has Part#isShadowed set to true.
  ///
  /// The default is null, which means this GraphObject will obey the default shadow rules (see Part#isShadowed).
  ///
  /// A value of true or false will ensure that this part is shadowed or not regardless of the default shadow rules,
  /// but this GraphObject's shadowed status will not affect other GraphObjects in the Part.
  ///
  /// Typically this property does not need to be set, but you may need to set this value to false
  /// on GraphObjects inside a Part that you do not wish to be shadowed.
  _i2.bool? get shadowVisible => _i5.getProperty(
        this,
        'shadowVisible',
      );
  /* #14584
  source: 
    /**
     * Gets or sets whether or not this GraphObject will be shadowed inside a Part that has Part#isShadowed set to true.
     *
     * The default is null, which means this GraphObject will obey the default shadow rules (see Part#isShadowed).
     *
     * A value of true or false will ensure that this part is shadowed or not regardless of the default shadow rules,
     * but this GraphObject's shadowed status will not affect other GraphObjects in the Part.
     *
     * Typically this property does not need to be set, but you may need to set this value to false
     * on GraphObjects inside a Part that you do not wish to be shadowed.
     * @see Part#isShadowed
     * @since 1.6
     */
    get shadowVisible(): boolean | null; */
  // Type InteropUnion#778793909(parent: InteropGetter#667886401(name: shadowVisible))
  set shadowVisible(_i2.bool? value) {
    _i5.setProperty(
      this,
      'shadowVisible',
      value ?? _i4.undefined,
    );
  }

  /* #14632
  source: 
    /**
     * Gets or sets the function to execute when some containing Panel changes the value of Panel#isEnabled.
     * It is typically used to modify the appearance of the object.
     * This function must not change the value of any panel Panel#isEnabled.
     *
     * If this property value is a function, it is called with two arguments,
     * this GraphObject and the new value.
     * By default this property is null -- no function is called.
     * @see #isEnabledObject
     * @see Panel#isEnabled
     * @since 1.7
     */
    get enabledChanged(): ((thisObj: GraphObject, enabled: boolean) => void) | null; */
  /// Gets or sets the function to execute when some containing Panel changes the value of Panel#isEnabled.
  /// It is typically used to modify the appearance of the object.
  /// This function must not change the value of any panel Panel#isEnabled.
  ///
  /// If this property value is a function, it is called with two arguments,
  /// this GraphObject and the new value.
  /// By default this property is null -- no function is called.
  void Function(
    _i3.GraphObject,
    _i2.bool,
  )? get enabledChanged => _i5.getProperty(
        this,
        'enabledChanged',
      );
  /* #14632
  source: 
    /**
     * Gets or sets the function to execute when some containing Panel changes the value of Panel#isEnabled.
     * It is typically used to modify the appearance of the object.
     * This function must not change the value of any panel Panel#isEnabled.
     *
     * If this property value is a function, it is called with two arguments,
     * this GraphObject and the new value.
     * By default this property is null -- no function is called.
     * @see #isEnabledObject
     * @see Panel#isEnabled
     * @since 1.7
     */
    get enabledChanged(): ((thisObj: GraphObject, enabled: boolean) => void) | null; */
  // Type InteropUnion#78382668(parent: InteropGetter#604906852(name: enabledChanged))
  set enabledChanged(
      void Function(
        _i3.GraphObject,
        _i2.bool,
      )? value) {
    _i5.setProperty(
      this,
      'enabledChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #14660
  source: 
    /**
     * Gets or sets the orientation of a GraphObject that is in a Link or Panel.Graduated.
     * This controls the automatic rotation of the object by the Link Panel or Graduated Panel.
     * The only accepted values are the Link "Orient..." values of Link
     * and the default value: Link.None.
     *
     * When the value is Link.None, the #angle of this object is unchanged as the link is routed.
     * Setting this to a value of Link.OrientAlong will cause routing to set the #angle
     * to be the angle of the segment that this object is on.
     * Other values compute the angle somewhat differently.
     * If the value is changed back to Link.None, the #angle of this object is set to zero.
     *
     * Note that when this property is not Link.None, this property takes precedence
     * over any setting or binding of the #angle property.
     * Changes to the angle caused by orientation might not result in Changed events,
     * and any original value for the angle may be lost.
     *
     * In the case of Graduated Panels, if this value is Link.None, Link.OrientAlong, or Link.OrientUpright,
     * any TextBlock label #angle will be respected. Depending on this value, the effective TextBlock angle will be either
     * fixed or relative to the slope of the path where it is rendered.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentIndex
     * @see #segmentOffset
     */
    get segmentOrientation(): EnumValue; */
  /// Gets or sets the orientation of a GraphObject that is in a Link or Panel.Graduated.
  /// This controls the automatic rotation of the object by the Link Panel or Graduated Panel.
  /// The only accepted values are the Link "Orient..." values of Link
  /// and the default value: Link.None.
  ///
  /// When the value is Link.None, the #angle of this object is unchanged as the link is routed.
  /// Setting this to a value of Link.OrientAlong will cause routing to set the #angle
  /// to be the angle of the segment that this object is on.
  /// Other values compute the angle somewhat differently.
  /// If the value is changed back to Link.None, the #angle of this object is set to zero.
  ///
  /// Note that when this property is not Link.None, this property takes precedence
  /// over any setting or binding of the #angle property.
  /// Changes to the angle caused by orientation might not result in Changed events,
  /// and any original value for the angle may be lost.
  ///
  /// In the case of Graduated Panels, if this value is Link.None, Link.OrientAlong, or Link.OrientUpright,
  /// any TextBlock label #angle will be respected. Depending on this value, the effective TextBlock angle will be either
  /// fixed or relative to the slope of the path where it is rendered.
  ///
  /// For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
  _i3.EnumValue get segmentOrientation => _i5.getProperty(
        this,
        'segmentOrientation',
      );
  /* #14660
  source: 
    /**
     * Gets or sets the orientation of a GraphObject that is in a Link or Panel.Graduated.
     * This controls the automatic rotation of the object by the Link Panel or Graduated Panel.
     * The only accepted values are the Link "Orient..." values of Link
     * and the default value: Link.None.
     *
     * When the value is Link.None, the #angle of this object is unchanged as the link is routed.
     * Setting this to a value of Link.OrientAlong will cause routing to set the #angle
     * to be the angle of the segment that this object is on.
     * Other values compute the angle somewhat differently.
     * If the value is changed back to Link.None, the #angle of this object is set to zero.
     *
     * Note that when this property is not Link.None, this property takes precedence
     * over any setting or binding of the #angle property.
     * Changes to the angle caused by orientation might not result in Changed events,
     * and any original value for the angle may be lost.
     *
     * In the case of Graduated Panels, if this value is Link.None, Link.OrientAlong, or Link.OrientUpright,
     * any TextBlock label #angle will be respected. Depending on this value, the effective TextBlock angle will be either
     * fixed or relative to the slope of the path where it is rendered.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentIndex
     * @see #segmentOffset
     */
    get segmentOrientation(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set segmentOrientation(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'segmentOrientation',
      value,
    );
  }

  /* #14680
  source: 
    /**
     * Gets or sets the segment index of a GraphObject that is in a Link.
     * Non-negative numbers count up from zero, which is the first segment, at the "from" end of the Link.
     * Negative numbers count segments from the "to" end of the Link, where -1 means the last segment
     * and -2 means the next-to-last segment.
     * The default value is -Infinity. The value should be an integer or NaN.
     *
     * Setting this value to NaN means #segmentFraction's fractional distance will be calculated along the entire link route.
     * A NaN value also means the Link#midPoint and Link#midAngle will not be used when determining label positions.
     *
     * If you do not set this property, the Link will choose a place that is approximately at the
     * mid-point of the link's route.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentOffset
     * @see #segmentOrientation
     */
    get segmentIndex(): number; */
  /// Gets or sets the segment index of a GraphObject that is in a Link.
  /// Non-negative numbers count up from zero, which is the first segment, at the "from" end of the Link.
  /// Negative numbers count segments from the "to" end of the Link, where -1 means the last segment
  /// and -2 means the next-to-last segment.
  /// The default value is -Infinity. The value should be an integer or NaN.
  ///
  /// Setting this value to NaN means #segmentFraction's fractional distance will be calculated along the entire link route.
  /// A NaN value also means the Link#midPoint and Link#midAngle will not be used when determining label positions.
  ///
  /// If you do not set this property, the Link will choose a place that is approximately at the
  /// mid-point of the link's route.
  ///
  /// For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
  _i2.num get segmentIndex => _i5.getProperty(
        this,
        'segmentIndex',
      );
  /* #14680
  source: 
    /**
     * Gets or sets the segment index of a GraphObject that is in a Link.
     * Non-negative numbers count up from zero, which is the first segment, at the "from" end of the Link.
     * Negative numbers count segments from the "to" end of the Link, where -1 means the last segment
     * and -2 means the next-to-last segment.
     * The default value is -Infinity. The value should be an integer or NaN.
     *
     * Setting this value to NaN means #segmentFraction's fractional distance will be calculated along the entire link route.
     * A NaN value also means the Link#midPoint and Link#midAngle will not be used when determining label positions.
     *
     * If you do not set this property, the Link will choose a place that is approximately at the
     * mid-point of the link's route.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentOffset
     * @see #segmentOrientation
     */
    get segmentIndex(): number; */
  // Type InteropStaticType.number
  set segmentIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'segmentIndex',
      value,
    );
  }

  /* #14695
  source: 
    /**
     * Gets or sets the fractional distance along a segment of a GraphObject that is in a Link.
     * The value should be between zero and one, where zero is at the point at the start of the segment,
     * and where one is at the point at the end of the segment.
     * The default value is zero.
     *
     * If #segmentIndex is set to NaN, the fractional distance will be calculated along the entire link route.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentIndex
     * @see #segmentOffset
     * @see #segmentOrientation
     */
    get segmentFraction(): number; */
  /// Gets or sets the fractional distance along a segment of a GraphObject that is in a Link.
  /// The value should be between zero and one, where zero is at the point at the start of the segment,
  /// and where one is at the point at the end of the segment.
  /// The default value is zero.
  ///
  /// If #segmentIndex is set to NaN, the fractional distance will be calculated along the entire link route.
  ///
  /// For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
  _i2.num get segmentFraction => _i5.getProperty(
        this,
        'segmentFraction',
      );
  /* #14695
  source: 
    /**
     * Gets or sets the fractional distance along a segment of a GraphObject that is in a Link.
     * The value should be between zero and one, where zero is at the point at the start of the segment,
     * and where one is at the point at the end of the segment.
     * The default value is zero.
     *
     * If #segmentIndex is set to NaN, the fractional distance will be calculated along the entire link route.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentIndex
     * @see #segmentOffset
     * @see #segmentOrientation
     */
    get segmentFraction(): number; */
  // Type InteropStaticType.number
  set segmentFraction(_i2.num value) {
    _i5.setProperty(
      this,
      'segmentFraction',
      value,
    );
  }

  /* #14716
  source: 
    /**
     * Gets or sets the offset of a GraphObject that is in a Link from a point on a segment
     * or in a Panel.Graduated from a point along the main element.
     * The X component of the Point indicates the distance along the route,
     * with positive values going further toward the "to" end of the link or panel.
     * The Y component of the Point indicates the distance away from the route,
     * with positive values towards the right as seen when facing further towards the "to" end of the link or panel.
     * The value defaults to the Point (0, 0).
     * You cannot modify the x or y of the value of this property --
     * if you want to change the segmentOffset you must set this property to a different Point.
     *
     * For labels that are near either end of a link, it may be convenient to set the segmentOffset
     * to Point(NaN, NaN). This causes the offset to be half the width and half the height of the label object.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentIndex
     * @see #segmentOrientation
     */
    get segmentOffset(): Point; */
  /// Gets or sets the offset of a GraphObject that is in a Link from a point on a segment
  /// or in a Panel.Graduated from a point along the main element.
  /// The X component of the Point indicates the distance along the route,
  /// with positive values going further toward the "to" end of the link or panel.
  /// The Y component of the Point indicates the distance away from the route,
  /// with positive values towards the right as seen when facing further towards the "to" end of the link or panel.
  /// The value defaults to the Point (0, 0).
  /// You cannot modify the x or y of the value of this property --
  /// if you want to change the segmentOffset you must set this property to a different Point.
  ///
  /// For labels that are near either end of a link, it may be convenient to set the segmentOffset
  /// to Point(NaN, NaN). This causes the offset to be half the width and half the height of the label object.
  ///
  /// For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
  _i3.Point get segmentOffset => _i5.getProperty(
        this,
        'segmentOffset',
      );
  /* #14716
  source: 
    /**
     * Gets or sets the offset of a GraphObject that is in a Link from a point on a segment
     * or in a Panel.Graduated from a point along the main element.
     * The X component of the Point indicates the distance along the route,
     * with positive values going further toward the "to" end of the link or panel.
     * The Y component of the Point indicates the distance away from the route,
     * with positive values towards the right as seen when facing further towards the "to" end of the link or panel.
     * The value defaults to the Point (0, 0).
     * You cannot modify the x or y of the value of this property --
     * if you want to change the segmentOffset you must set this property to a different Point.
     *
     * For labels that are near either end of a link, it may be convenient to set the segmentOffset
     * to Point(NaN, NaN). This causes the offset to be half the width and half the height of the label object.
     *
     * For examples of how to use this property, see <a href="../../intro/linkLabels.html">Link Labels</a>.
     * @see #segmentFraction
     * @see #segmentIndex
     * @see #segmentOrientation
     */
    get segmentOffset(): Point; */
  // Type Instance of 'InteropInterface'
  set segmentOffset(_i3.Point value) {
    _i5.setProperty(
      this,
      'segmentOffset',
      value,
    );
  }

  /* #14745
  source: 
    /**
     * Gets or sets the stretch of the GraphObject.
     * This controls whether the width and/or height of this object automatically adjusts to fill
     * the area allotted by the containing Panel.
     *
     * The only accepted values are listed as constant properties of GraphObject,
     * such as GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, or GraphObject.Vertical.
     * The default value is GraphObject.Default, which allows the Panel to decide how to treat this object, depending on the type of Panel.
     *
     * Objects with an #angle that are stretched may look incorrect unless the angle is a multiple of 90.
     *
     * Stretch will have have different effects based upon the Panel containing this object. Elements of:
     * - Auto panels will not stretch, except the main element growing to fill the panel or being made uniform
     * - Horizontal panels will only stretch vertically
     * - Vertical panels will only stretch horizontally
     * - Spot panels will stretch to the size of the main element
     * - Table panels will stretch to the size of their cell, defined by their row and column, which is usually determined by other GraphObjects in that cell that are not stretching
     * - Grid panels, Link panels, and Graduated panels will not stretch
     * @see Panel#defaultStretch
     * @see #desiredSize
     * @see #minSize
     * @see #maxSize
     * @see #measuredBounds
     * @see #actualBounds
     * @see #scale
     * @see Picture#imageStretch
     */
    get stretch(): EnumValue; */
  /// Gets or sets the stretch of the GraphObject.
  /// This controls whether the width and/or height of this object automatically adjusts to fill
  /// the area allotted by the containing Panel.
  ///
  /// The only accepted values are listed as constant properties of GraphObject,
  /// such as GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, or GraphObject.Vertical.
  /// The default value is GraphObject.Default, which allows the Panel to decide how to treat this object, depending on the type of Panel.
  ///
  /// Objects with an #angle that are stretched may look incorrect unless the angle is a multiple of 90.
  ///
  /// Stretch will have have different effects based upon the Panel containing this object. Elements of:
  /// - Auto panels will not stretch, except the main element growing to fill the panel or being made uniform
  /// - Horizontal panels will only stretch vertically
  /// - Vertical panels will only stretch horizontally
  /// - Spot panels will stretch to the size of the main element
  /// - Table panels will stretch to the size of their cell, defined by their row and column, which is usually determined by other GraphObjects in that cell that are not stretching
  /// - Grid panels, Link panels, and Graduated panels will not stretch
  _i3.EnumValue get stretch => _i5.getProperty(
        this,
        'stretch',
      );
  /* #14745
  source: 
    /**
     * Gets or sets the stretch of the GraphObject.
     * This controls whether the width and/or height of this object automatically adjusts to fill
     * the area allotted by the containing Panel.
     *
     * The only accepted values are listed as constant properties of GraphObject,
     * such as GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, or GraphObject.Vertical.
     * The default value is GraphObject.Default, which allows the Panel to decide how to treat this object, depending on the type of Panel.
     *
     * Objects with an #angle that are stretched may look incorrect unless the angle is a multiple of 90.
     *
     * Stretch will have have different effects based upon the Panel containing this object. Elements of:
     * - Auto panels will not stretch, except the main element growing to fill the panel or being made uniform
     * - Horizontal panels will only stretch vertically
     * - Vertical panels will only stretch horizontally
     * - Spot panels will stretch to the size of the main element
     * - Table panels will stretch to the size of their cell, defined by their row and column, which is usually determined by other GraphObjects in that cell that are not stretching
     * - Grid panels, Link panels, and Graduated panels will not stretch
     * @see Panel#defaultStretch
     * @see #desiredSize
     * @see #minSize
     * @see #maxSize
     * @see #measuredBounds
     * @see #actualBounds
     * @see #scale
     * @see Picture#imageStretch
     */
    get stretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set stretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'stretch',
      value,
    );
  }

  /* #14759
  source: 
    /**
     * Gets or sets the name for this object.
     * The default value is the empty string.
     * The name should be unique within a Panel, although if it isn't,
     * it reduces the usefulness of methods such as Panel#findObject.
     *
     * You must not modify the name of a GraphObject once it is in the visual tree of a Part.
     *
     * This is frequently needed to identify a particular GraphObject in the visual tree of a Part,
     * for example as the value of the Part#locationObjectName or
     * Part#selectionObjectName properties.
     */
    get name(): string; */
  /// Gets or sets the name for this object.
  /// The default value is the empty string.
  /// The name should be unique within a Panel, although if it isn't,
  /// it reduces the usefulness of methods such as Panel#findObject.
  ///
  /// You must not modify the name of a GraphObject once it is in the visual tree of a Part.
  ///
  /// This is frequently needed to identify a particular GraphObject in the visual tree of a Part,
  /// for example as the value of the Part#locationObjectName or
  /// Part#selectionObjectName properties.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #14759
  source: 
    /**
     * Gets or sets the name for this object.
     * The default value is the empty string.
     * The name should be unique within a Panel, although if it isn't,
     * it reduces the usefulness of methods such as Panel#findObject.
     *
     * You must not modify the name of a GraphObject once it is in the visual tree of a Part.
     *
     * This is frequently needed to identify a particular GraphObject in the visual tree of a Part,
     * for example as the value of the Part#locationObjectName or
     * Part#selectionObjectName properties.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #14779
  source: 
    /**
     * Gets or sets the multiplicative opacity for this GraphObject and (if a Panel) all elements.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     *
     * Unlike #visible, Opacity only affects drawing, it does not cause objects to be resized or remeasured.
     * Opacity settings do not change the shape of the object or exclude it from object-picking
     * (does not change whether any objects are found by the "find..." methods).
     *
     * This value is multiplicative with any existing transparency,
     * for instance from Layer#opacity or a GraphObject's opacity higher in the visual tree,
     * or from a Brush or image transparency.
     * The default value is 1.
     * @see #visible
     * @see #pickable
     * @see Layer#opacity
     * @see Diagram#opacity
     * @since 1.4
     */
    get opacity(): number; */
  /// Gets or sets the multiplicative opacity for this GraphObject and (if a Panel) all elements.
  /// The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
  ///
  /// Unlike #visible, Opacity only affects drawing, it does not cause objects to be resized or remeasured.
  /// Opacity settings do not change the shape of the object or exclude it from object-picking
  /// (does not change whether any objects are found by the "find..." methods).
  ///
  /// This value is multiplicative with any existing transparency,
  /// for instance from Layer#opacity or a GraphObject's opacity higher in the visual tree,
  /// or from a Brush or image transparency.
  /// The default value is 1.
  _i2.num get opacity => _i5.getProperty(
        this,
        'opacity',
      );
  /* #14779
  source: 
    /**
     * Gets or sets the multiplicative opacity for this GraphObject and (if a Panel) all elements.
     * The value must be between 0.0 (fully transparent) and 1.0 (no additional transparency).
     *
     * Unlike #visible, Opacity only affects drawing, it does not cause objects to be resized or remeasured.
     * Opacity settings do not change the shape of the object or exclude it from object-picking
     * (does not change whether any objects are found by the "find..." methods).
     *
     * This value is multiplicative with any existing transparency,
     * for instance from Layer#opacity or a GraphObject's opacity higher in the visual tree,
     * or from a Brush or image transparency.
     * The default value is 1.
     * @see #visible
     * @see #pickable
     * @see Layer#opacity
     * @see Diagram#opacity
     * @since 1.4
     */
    get opacity(): number; */
  // Type InteropStaticType.number
  set opacity(_i2.num value) {
    _i5.setProperty(
      this,
      'opacity',
      value,
    );
  }

  /* #14784
  source: 
    /**
     * Undocumented. May not work in Safari.
     */
    get filter(): string; */
  /// Undocumented. May not work in Safari.
  _i2.String get filter => _i5.getProperty(
        this,
        'filter',
      );
  /* #14784
  source: 
    /**
     * Undocumented. May not work in Safari.
     */
    get filter(): string; */
  // Type InteropStaticType.string
  set filter(_i2.String value) {
    _i5.setProperty(
      this,
      'filter',
      value,
    );
  }

  /* #14817
  source: 
    /**
     * Gets or sets whether a GraphObject is visible.
     * The default value is true.
     * A not visible object takes no space in the Panel that it is in.
     * Toggling visibility may cause elements in the visual tree to re-measure and re-arrange.
     * Making a Panel not visible causes all of its elements not to be seen or receive input events.
     * Changing a Panel to become visible causes all of its elements to be seen and be active,
     * unless those elements are themselves not visible.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * One can have a visible Shape that is not drawn by setting its Shape#fill
     * and Shape#stroke to null or to `"transparent"`.
     * Similarly, one can set TextBlock#stroke to null or to `"transparent"`.
     * It is also possible make a GraphObjects transparent by setting GraphObject#opacity to 0.
     * Finally, one can make a whole Layer-full of Parts invisible by setting Layer#visible to false.
     *
     * Use the #isVisibleObject predicate to see if this GraphObject is visible and is inside a Panel
     * that is #isVisibleObject, and so forth up the chain of panels until reaching the Part.
     *
     * For Parts, you can call the Part#isVisible predicate to determine
     * if not only the Part is visible but also any containing Group or Link,
     * and whether the Layer it is in is visible.
     * @see #opacity
     * @see #pickable
     * @see Layer#visible
     */
    get visible(): boolean; */
  /// Gets or sets whether a GraphObject is visible.
  /// The default value is true.
  /// A not visible object takes no space in the Panel that it is in.
  /// Toggling visibility may cause elements in the visual tree to re-measure and re-arrange.
  /// Making a Panel not visible causes all of its elements not to be seen or receive input events.
  /// Changing a Panel to become visible causes all of its elements to be seen and be active,
  /// unless those elements are themselves not visible.
  ///
  /// This object does not get any mouse/touch events if it is not #visible
  /// or if it is not #pickable.
  ///
  /// One can have a visible Shape that is not drawn by setting its Shape#fill
  /// and Shape#stroke to null or to `"transparent"`.
  /// Similarly, one can set TextBlock#stroke to null or to `"transparent"`.
  /// It is also possible make a GraphObjects transparent by setting GraphObject#opacity to 0.
  /// Finally, one can make a whole Layer-full of Parts invisible by setting Layer#visible to false.
  ///
  /// Use the #isVisibleObject predicate to see if this GraphObject is visible and is inside a Panel
  /// that is #isVisibleObject, and so forth up the chain of panels until reaching the Part.
  ///
  /// For Parts, you can call the Part#isVisible predicate to determine
  /// if not only the Part is visible but also any containing Group or Link,
  /// and whether the Layer it is in is visible.
  _i2.bool get visible => _i5.getProperty(
        this,
        'visible',
      );
  /* #14817
  source: 
    /**
     * Gets or sets whether a GraphObject is visible.
     * The default value is true.
     * A not visible object takes no space in the Panel that it is in.
     * Toggling visibility may cause elements in the visual tree to re-measure and re-arrange.
     * Making a Panel not visible causes all of its elements not to be seen or receive input events.
     * Changing a Panel to become visible causes all of its elements to be seen and be active,
     * unless those elements are themselves not visible.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * One can have a visible Shape that is not drawn by setting its Shape#fill
     * and Shape#stroke to null or to `"transparent"`.
     * Similarly, one can set TextBlock#stroke to null or to `"transparent"`.
     * It is also possible make a GraphObjects transparent by setting GraphObject#opacity to 0.
     * Finally, one can make a whole Layer-full of Parts invisible by setting Layer#visible to false.
     *
     * Use the #isVisibleObject predicate to see if this GraphObject is visible and is inside a Panel
     * that is #isVisibleObject, and so forth up the chain of panels until reaching the Part.
     *
     * For Parts, you can call the Part#isVisible predicate to determine
     * if not only the Part is visible but also any containing Group or Link,
     * and whether the Layer it is in is visible.
     * @see #opacity
     * @see #pickable
     * @see Layer#visible
     */
    get visible(): boolean; */
  // Type InteropStaticType.boolean
  set visible(_i2.bool value) {
    _i5.setProperty(
      this,
      'visible',
      value,
    );
  }

  /* #14835
  source: 
    /**
     * Gets or sets whether or not this GraphObject can be chosen by visual "find" or "hit-test" methods such
     * as Diagram#findObjectAt.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * The default value is true -- mouse events on this object will be noticed.
     * If this value is false and this object is a Panel, not only is this Panel not "hittable",
     * but all of the elements inside the Panel will be ignored.
     * @see #visible
     * @see #opacity
     * @see Layer#pickable
     * @see Panel#isEnabled
     * @since 1.2
     */
    get pickable(): boolean; */
  /// Gets or sets whether or not this GraphObject can be chosen by visual "find" or "hit-test" methods such
  /// as Diagram#findObjectAt.
  ///
  /// This object does not get any mouse/touch events if it is not #visible
  /// or if it is not #pickable.
  ///
  /// The default value is true -- mouse events on this object will be noticed.
  /// If this value is false and this object is a Panel, not only is this Panel not "hittable",
  /// but all of the elements inside the Panel will be ignored.
  _i2.bool get pickable => _i5.getProperty(
        this,
        'pickable',
      );
  /* #14835
  source: 
    /**
     * Gets or sets whether or not this GraphObject can be chosen by visual "find" or "hit-test" methods such
     * as Diagram#findObjectAt.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * The default value is true -- mouse events on this object will be noticed.
     * If this value is false and this object is a Panel, not only is this Panel not "hittable",
     * but all of the elements inside the Panel will be ignored.
     * @see #visible
     * @see #opacity
     * @see Layer#pickable
     * @see Panel#isEnabled
     * @since 1.2
     */
    get pickable(): boolean; */
  // Type InteropStaticType.boolean
  set pickable(_i2.bool value) {
    _i5.setProperty(
      this,
      'pickable',
      value,
    );
  }

  /* #14849
  source: 
    /**
     * Gets or sets whether the user may draw duplicate Links from this port.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #fromLinkableSelfNode
     * @see #toLinkableDuplicates
     */
    get fromLinkableDuplicates(): boolean; */
  /// Gets or sets whether the user may draw duplicate Links from this port.
  /// This property is used by LinkingBaseTool#isValidLink.
  /// The default value is false.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.bool get fromLinkableDuplicates => _i5.getProperty(
        this,
        'fromLinkableDuplicates',
      );
  /* #14849
  source: 
    /**
     * Gets or sets whether the user may draw duplicate Links from this port.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #fromLinkableSelfNode
     * @see #toLinkableDuplicates
     */
    get fromLinkableDuplicates(): boolean; */
  // Type InteropStaticType.boolean
  set fromLinkableDuplicates(_i2.bool value) {
    _i5.setProperty(
      this,
      'fromLinkableDuplicates',
      value,
    );
  }

  /* #14863
  source: 
    /**
     * Gets or sets whether the user may draw Links that connect from this port's Node.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #fromLinkableDuplicates
     * @see #toLinkableSelfNode
     */
    get fromLinkableSelfNode(): boolean; */
  /// Gets or sets whether the user may draw Links that connect from this port's Node.
  /// This property is used by LinkingBaseTool#isValidLink.
  /// The default value is false.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.bool get fromLinkableSelfNode => _i5.getProperty(
        this,
        'fromLinkableSelfNode',
      );
  /* #14863
  source: 
    /**
     * Gets or sets whether the user may draw Links that connect from this port's Node.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #fromLinkableDuplicates
     * @see #toLinkableSelfNode
     */
    get fromLinkableSelfNode(): boolean; */
  // Type InteropStaticType.boolean
  set fromLinkableSelfNode(_i2.bool value) {
    _i5.setProperty(
      this,
      'fromLinkableSelfNode',
      value,
    );
  }

  /* #14877
  source: 
    /**
     * Gets or sets whether the user may draw duplicate Links to this port.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #toLinkableSelfNode
     * @see #fromLinkableDuplicates
     */
    get toLinkableDuplicates(): boolean; */
  /// Gets or sets whether the user may draw duplicate Links to this port.
  /// This property is used by LinkingBaseTool#isValidLink.
  /// The default value is false.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.bool get toLinkableDuplicates => _i5.getProperty(
        this,
        'toLinkableDuplicates',
      );
  /* #14877
  source: 
    /**
     * Gets or sets whether the user may draw duplicate Links to this port.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #toLinkableSelfNode
     * @see #fromLinkableDuplicates
     */
    get toLinkableDuplicates(): boolean; */
  // Type InteropStaticType.boolean
  set toLinkableDuplicates(_i2.bool value) {
    _i5.setProperty(
      this,
      'toLinkableDuplicates',
      value,
    );
  }

  /* #14891
  source: 
    /**
     * Gets or sets whether the user may draw Links that connect to this port's Node.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #toLinkableDuplicates
     * @see #fromLinkableSelfNode
     */
    get toLinkableSelfNode(): boolean; */
  /// Gets or sets whether the user may draw Links that connect to this port's Node.
  /// This property is used by LinkingBaseTool#isValidLink.
  /// The default value is false.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.bool get toLinkableSelfNode => _i5.getProperty(
        this,
        'toLinkableSelfNode',
      );
  /* #14891
  source: 
    /**
     * Gets or sets whether the user may draw Links that connect to this port's Node.
     * This property is used by LinkingBaseTool#isValidLink.
     * The default value is false.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #toLinkableDuplicates
     * @see #fromLinkableSelfNode
     */
    get toLinkableSelfNode(): boolean; */
  // Type InteropStaticType.boolean
  set toLinkableSelfNode(_i2.bool value) {
    _i5.setProperty(
      this,
      'toLinkableSelfNode',
      value,
    );
  }

  /* #14902
  source: 
    /**
     * Gets or sets whether a GraphObject is the "main" object for some types of Panel.
     * Panels that use a "main" object include Panel.Auto, Panel.Spot, and Panel.Link.
     *
     * Panels that use a "main" object will use the first object that has this property set to true,
     * or else just the first object, if none have the property set.
     *
     * Do not modify this property once this object is an element of a panel.
     */
    get isPanelMain(): boolean; */
  /// Gets or sets whether a GraphObject is the "main" object for some types of Panel.
  /// Panels that use a "main" object include Panel.Auto, Panel.Spot, and Panel.Link.
  ///
  /// Panels that use a "main" object will use the first object that has this property set to true,
  /// or else just the first object, if none have the property set.
  ///
  /// Do not modify this property once this object is an element of a panel.
  _i2.bool get isPanelMain => _i5.getProperty(
        this,
        'isPanelMain',
      );
  /* #14902
  source: 
    /**
     * Gets or sets whether a GraphObject is the "main" object for some types of Panel.
     * Panels that use a "main" object include Panel.Auto, Panel.Spot, and Panel.Link.
     *
     * Panels that use a "main" object will use the first object that has this property set to true,
     * or else just the first object, if none have the property set.
     *
     * Do not modify this property once this object is an element of a panel.
     */
    get isPanelMain(): boolean; */
  // Type InteropStaticType.boolean
  set isPanelMain(_i2.bool value) {
    _i5.setProperty(
      this,
      'isPanelMain',
      value,
    );
  }

  /* #14923
  source: 
    /**
     * This property determines whether or not this GraphObject's events occur
     * before all other events, including selection. This enables the #actionDown,
     * #actionMove, #actionUp, and #actionCancel events,
     * which are all handled by the ActionTool.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * This property is infrequently used -- typically only when implementing objects
     * that act as buttons or knobs or sliders.
     * The default value is false.
     * @see #actionDown
     * @see #actionMove
     * @see #actionUp
     * @see #actionCancel
     * @see #pickable
     * @see Panel#isEnabled
     */
    get isActionable(): boolean; */
  /// This property determines whether or not this GraphObject's events occur
  /// before all other events, including selection. This enables the #actionDown,
  /// #actionMove, #actionUp, and #actionCancel events,
  /// which are all handled by the ActionTool.
  ///
  /// This object does not get any mouse/touch events if it is not #visible
  /// or if it is not #pickable.
  ///
  /// This property is infrequently used -- typically only when implementing objects
  /// that act as buttons or knobs or sliders.
  /// The default value is false.
  _i2.bool get isActionable => _i5.getProperty(
        this,
        'isActionable',
      );
  /* #14923
  source: 
    /**
     * This property determines whether or not this GraphObject's events occur
     * before all other events, including selection. This enables the #actionDown,
     * #actionMove, #actionUp, and #actionCancel events,
     * which are all handled by the ActionTool.
     *
     * This object does not get any mouse/touch events if it is not #visible
     * or if it is not #pickable.
     *
     * This property is infrequently used -- typically only when implementing objects
     * that act as buttons or knobs or sliders.
     * The default value is false.
     * @see #actionDown
     * @see #actionMove
     * @see #actionUp
     * @see #actionCancel
     * @see #pickable
     * @see Panel#isEnabled
     */
    get isActionable(): boolean; */
  // Type InteropStaticType.boolean
  set isActionable(_i2.bool value) {
    _i5.setProperty(
      this,
      'isActionable',
      value,
    );
  }

  /* #14938
  source: 
    /**
     * Gets or sets the areaBackground Brush of this GraphObject.
     * The areaBackground fills the rectangle described by this GraphObject's containing panel's coordinates.
     * If the object is rotated, the area background will expand to fill the entire measured bounds of the object,
     * without rotating the brush.
     *
     * The value may be either a Brush object or a string that is a CSS color.
     * The default value is null -- no area background is drawn.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     * @see #background
     * @see Shape#fill
     */
    get areaBackground(): BrushLike; */
  /// Gets or sets the areaBackground Brush of this GraphObject.
  /// The areaBackground fills the rectangle described by this GraphObject's containing panel's coordinates.
  /// If the object is rotated, the area background will expand to fill the entire measured bounds of the object,
  /// without rotating the brush.
  ///
  /// The value may be either a Brush object or a string that is a CSS color.
  /// The default value is null -- no area background is drawn.
  /// More information about the syntax of CSS color strings is available at:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
  _i3.BrushLike get areaBackground => _i5.getProperty(
        this,
        'areaBackground',
      );
  /* #14938
  source: 
    /**
     * Gets or sets the areaBackground Brush of this GraphObject.
     * The areaBackground fills the rectangle described by this GraphObject's containing panel's coordinates.
     * If the object is rotated, the area background will expand to fill the entire measured bounds of the object,
     * without rotating the brush.
     *
     * The value may be either a Brush object or a string that is a CSS color.
     * The default value is null -- no area background is drawn.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     * @see #background
     * @see Shape#fill
     */
    get areaBackground(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set areaBackground(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'areaBackground',
      value ?? _i4.undefined,
    );
  }

  /* #14951
  source: 
    /**
     * Gets or sets the background Brush of this GraphObject,
     * filling the rectangle of this object's local coordinate space.
     * If the object is rotated, the background will rotate with it.
     *
     * The value may be either a Brush object or a string that is a CSS color.
     * The default value is null -- no background is drawn.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     * @see Shape#fill
     */
    get background(): BrushLike; */
  /// Gets or sets the background Brush of this GraphObject,
  /// filling the rectangle of this object's local coordinate space.
  /// If the object is rotated, the background will rotate with it.
  ///
  /// The value may be either a Brush object or a string that is a CSS color.
  /// The default value is null -- no background is drawn.
  /// More information about the syntax of CSS color strings is available at:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
  _i3.BrushLike get background => _i5.getProperty(
        this,
        'background',
      );
  /* #14951
  source: 
    /**
     * Gets or sets the background Brush of this GraphObject,
     * filling the rectangle of this object's local coordinate space.
     * If the object is rotated, the background will rotate with it.
     *
     * The value may be either a Brush object or a string that is a CSS color.
     * The default value is null -- no background is drawn.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     * @see Shape#fill
     */
    get background(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set background(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'background',
      value ?? _i4.undefined,
    );
  }

  /* #14970
  source: 
    /**
     * This read-only property returns the Part containing this object, if any.
     * The Part will be the root GraphObject in this GraphObject's visual tree.
     *
     * It is common to refer to the containing Part of a GraphObject
     * in order to refer to the Panel#data to which it is bound.
     *
     * This property is not settable.
     * If you want this GraphObject to belong to a Part, you will need to add it to a Part,
     * or else add it to some visual tree structure that is added to a Part using Panel#add.
     *
     * Note that for objects such as buttons that are in Adornments such as tooltips or context menus,
     * this property will return that Adornment, not the Node or Link that is adorned.
     *
     * If you want to find a Group that contains a Part, use the Part#containingGroup property:
     * `someObj.part.containingGroup`
     */
    get part(): Part | null; */
  /// This read-only property returns the Part containing this object, if any.
  /// The Part will be the root GraphObject in this GraphObject's visual tree.
  ///
  /// It is common to refer to the containing Part of a GraphObject
  /// in order to refer to the Panel#data to which it is bound.
  ///
  /// This property is not settable.
  /// If you want this GraphObject to belong to a Part, you will need to add it to a Part,
  /// or else add it to some visual tree structure that is added to a Part using Panel#add.
  ///
  /// Note that for objects such as buttons that are in Adornments such as tooltips or context menus,
  /// this property will return that Adornment, not the Node or Link that is adorned.
  ///
  /// If you want to find a Group that contains a Part, use the Part#containingGroup property:
  /// `someObj.part.containingGroup`
  _i3.Part? get part => _i5.getProperty(
        this,
        'part',
      );
  /* #14970
  source: 
    /**
     * This read-only property returns the Part containing this object, if any.
     * The Part will be the root GraphObject in this GraphObject's visual tree.
     *
     * It is common to refer to the containing Part of a GraphObject
     * in order to refer to the Panel#data to which it is bound.
     *
     * This property is not settable.
     * If you want this GraphObject to belong to a Part, you will need to add it to a Part,
     * or else add it to some visual tree structure that is added to a Part using Panel#add.
     *
     * Note that for objects such as buttons that are in Adornments such as tooltips or context menus,
     * this property will return that Adornment, not the Node or Link that is adorned.
     *
     * If you want to find a Group that contains a Part, use the Part#containingGroup property:
     * `someObj.part.containingGroup`
     */
    get part(): Part | null; */
  // Type InteropUnion#343620681(parent: InteropGetter#466423537(name: part))
  set part(_i3.Part? value) {
    _i5.setProperty(
      this,
      'part',
      value ?? _i4.undefined,
    );
  }

  /* #14981
  source: 
    /**
     * This read-only property returns the GraphObject's containing Panel, or null if this object is not in a Panel.
     *
     * Although Part inherits from this class, a Part will never belong to a Panel,
     * so this property will always be null for every Node or Link.
     *
     * This property is not settable.
     * Instead, call Panel#add in order to put a GraphObject in a Panel.
     */
    get panel(): Panel | null; */
  /// This read-only property returns the GraphObject's containing Panel, or null if this object is not in a Panel.
  ///
  /// Although Part inherits from this class, a Part will never belong to a Panel,
  /// so this property will always be null for every Node or Link.
  ///
  /// This property is not settable.
  /// Instead, call Panel#add in order to put a GraphObject in a Panel.
  _i3.Panel? get panel => _i5.getProperty(
        this,
        'panel',
      );
  /* #14981
  source: 
    /**
     * This read-only property returns the GraphObject's containing Panel, or null if this object is not in a Panel.
     *
     * Although Part inherits from this class, a Part will never belong to a Panel,
     * so this property will always be null for every Node or Link.
     *
     * This property is not settable.
     * Instead, call Panel#add in order to put a GraphObject in a Panel.
     */
    get panel(): Panel | null; */
  // Type InteropUnion#754319456(parent: InteropGetter#552915716(name: panel))
  set panel(_i3.Panel? value) {
    _i5.setProperty(
      this,
      'panel',
      value ?? _i4.undefined,
    );
  }

  /* #14990
  source: 
    /**
     * This read-only property returns the GraphObject's containing Layer, if there is any.
     * A plain GraphObject cannot belong directly to a Layer -- only a Part can belong directly to a Layer.
     *
     * This property is not settable.
     * Normally one changes which Layer that a GraphObject is in by setting Part#layerName.
     * Adding a Part to a Diagram will automatically add that Part to a Layer in that Diagram based on the layerName.
     */
    get layer(): Layer | null; */
  /// This read-only property returns the GraphObject's containing Layer, if there is any.
  /// A plain GraphObject cannot belong directly to a Layer -- only a Part can belong directly to a Layer.
  ///
  /// This property is not settable.
  /// Normally one changes which Layer that a GraphObject is in by setting Part#layerName.
  /// Adding a Part to a Diagram will automatically add that Part to a Layer in that Diagram based on the layerName.
  _i3.Layer? get layer => _i5.getProperty(
        this,
        'layer',
      );
  /* #14990
  source: 
    /**
     * This read-only property returns the GraphObject's containing Layer, if there is any.
     * A plain GraphObject cannot belong directly to a Layer -- only a Part can belong directly to a Layer.
     *
     * This property is not settable.
     * Normally one changes which Layer that a GraphObject is in by setting Part#layerName.
     * Adding a Part to a Diagram will automatically add that Part to a Layer in that Diagram based on the layerName.
     */
    get layer(): Layer | null; */
  // Type InteropUnion#308757369(parent: InteropGetter#101797070(name: layer))
  set layer(_i3.Layer? value) {
    _i5.setProperty(
      this,
      'layer',
      value ?? _i4.undefined,
    );
  }

  /* #14998
  source: 
    /**
     * This read-only property returns the Diagram that this GraphObject is in, if it is.
     *
     * This property is not settable.
     * Although you cannot add any plain GraphObject to a Diagram, you can call Diagram#add
     * to add a Part to a Diagram.
     */
    get diagram(): Diagram | null; */
  /// This read-only property returns the Diagram that this GraphObject is in, if it is.
  ///
  /// This property is not settable.
  /// Although you cannot add any plain GraphObject to a Diagram, you can call Diagram#add
  /// to add a Part to a Diagram.
  _i3.Diagram? get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #14998
  source: 
    /**
     * This read-only property returns the Diagram that this GraphObject is in, if it is.
     *
     * This property is not settable.
     * Although you cannot add any plain GraphObject to a Diagram, you can call Diagram#add
     * to add a Part to a Diagram.
     */
    get diagram(): Diagram | null; */
  // Type InteropUnion#227456004(parent: InteropGetter#980085102(name: diagram))
  set diagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'diagram',
      value ?? _i4.undefined,
    );
  }

  /* #15009
  source: 
    /**
     * Gets or sets the position of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Value must be of type Point.
     * You cannot modify the x or y of the value of this property --
     * if you want to change the position you must set this property to a different Point.
     * Default is `Point(NaN, NaN)`.
     *
     * For Parts, see also Part#location.
     */
    get position(): Point; */
  /// Gets or sets the position of this GraphObject in container coordinates
  /// (either a Panel or the document).
  /// Value must be of type Point.
  /// You cannot modify the x or y of the value of this property --
  /// if you want to change the position you must set this property to a different Point.
  /// Default is `Point(NaN, NaN)`.
  ///
  /// For Parts, see also Part#location.
  _i3.Point get position => _i5.getProperty(
        this,
        'position',
      );
  /* #15009
  source: 
    /**
     * Gets or sets the position of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Value must be of type Point.
     * You cannot modify the x or y of the value of this property --
     * if you want to change the position you must set this property to a different Point.
     * Default is `Point(NaN, NaN)`.
     *
     * For Parts, see also Part#location.
     */
    get position(): Point; */
  // Type Instance of 'InteropInterface'
  set position(_i3.Point value) {
    _i5.setProperty(
      this,
      'position',
      value,
    );
  }

  /* #15039
  source: 
    /**
     * This read-only property returns the bounds of this GraphObject in container coordinates. This means that
     * the actualBounds are in the coordinate space of the GraphObject's Panel,
     * unless this is a Part, in which case they are in
     * the Diagram's coordinate system.
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * If this GraphObject is a Part,
     * then the x and y values of the actualBounds are identical to that Part's #position,
     * and the width and height values of the actualBounds represent the rectangular space occupied
     * by the Part in Diagram#documentBounds coordinates.
     *
     * If this GraphObject is not a top-level object (not a Part), then the actualBounds
     * x and y values represent that GraphObject's position within its Panel. In a Panel of type Panel.Position
     * this is identical to the GraphObject's #position, but in other cases it is dependent on
     * the unique workings of each Panel type. The actualBounds width and height
     * of a GraphObject are the final size after the #scale and #angle are applied.
     *
     * It is possible for a GraphObject (be it an GraphObject or a Panel containing several more GraphObjects)
     * to have no containing Part, in which case these GraphObjects cannot possibly be in a Diagram.
     * These GraphObjects are unlikely to have real-number values for their actualBounds, as they may
     * never have had the chance to be measured and arranged.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #measuredBounds
     * @see #desiredSize
     */
    get actualBounds(): Rect; */
  /// This read-only property returns the bounds of this GraphObject in container coordinates. This means that
  /// the actualBounds are in the coordinate space of the GraphObject's Panel,
  /// unless this is a Part, in which case they are in
  /// the Diagram's coordinate system.
  ///
  /// You must not modify any of the properties of the Rect that is the value of this property.
  ///
  /// If this GraphObject is a Part,
  /// then the x and y values of the actualBounds are identical to that Part's #position,
  /// and the width and height values of the actualBounds represent the rectangular space occupied
  /// by the Part in Diagram#documentBounds coordinates.
  ///
  /// If this GraphObject is not a top-level object (not a Part), then the actualBounds
  /// x and y values represent that GraphObject's position within its Panel. In a Panel of type Panel.Position
  /// this is identical to the GraphObject's #position, but in other cases it is dependent on
  /// the unique workings of each Panel type. The actualBounds width and height
  /// of a GraphObject are the final size after the #scale and #angle are applied.
  ///
  /// It is possible for a GraphObject (be it an GraphObject or a Panel containing several more GraphObjects)
  /// to have no containing Part, in which case these GraphObjects cannot possibly be in a Diagram.
  /// These GraphObjects are unlikely to have real-number values for their actualBounds, as they may
  /// never have had the chance to be measured and arranged.
  ///
  /// As with all read-only properties, using this property as a binding source is unlikely to be useful.
  _i3.Rect get actualBounds => _i5.getProperty(
        this,
        'actualBounds',
      );
  /* #15039
  source: 
    /**
     * This read-only property returns the bounds of this GraphObject in container coordinates. This means that
     * the actualBounds are in the coordinate space of the GraphObject's Panel,
     * unless this is a Part, in which case they are in
     * the Diagram's coordinate system.
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * If this GraphObject is a Part,
     * then the x and y values of the actualBounds are identical to that Part's #position,
     * and the width and height values of the actualBounds represent the rectangular space occupied
     * by the Part in Diagram#documentBounds coordinates.
     *
     * If this GraphObject is not a top-level object (not a Part), then the actualBounds
     * x and y values represent that GraphObject's position within its Panel. In a Panel of type Panel.Position
     * this is identical to the GraphObject's #position, but in other cases it is dependent on
     * the unique workings of each Panel type. The actualBounds width and height
     * of a GraphObject are the final size after the #scale and #angle are applied.
     *
     * It is possible for a GraphObject (be it an GraphObject or a Panel containing several more GraphObjects)
     * to have no containing Part, in which case these GraphObjects cannot possibly be in a Diagram.
     * These GraphObjects are unlikely to have real-number values for their actualBounds, as they may
     * never have had the chance to be measured and arranged.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #measuredBounds
     * @see #desiredSize
     */
    get actualBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set actualBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'actualBounds',
      value,
    );
  }

  /* #15047
  source: 
    /**
     * Gets or sets the scale transform of this GraphObject.
     * Value must be a number; larger values will make this object appear bigger.
     * Default is 1.
     * @see #angle
     * @see #stretch
     */
    get scale(): number; */
  /// Gets or sets the scale transform of this GraphObject.
  /// Value must be a number; larger values will make this object appear bigger.
  /// Default is 1.
  _i2.num get scale => _i5.getProperty(
        this,
        'scale',
      );
  /* #15047
  source: 
    /**
     * Gets or sets the scale transform of this GraphObject.
     * Value must be a number; larger values will make this object appear bigger.
     * Default is 1.
     * @see #angle
     * @see #stretch
     */
    get scale(): number; */
  // Type InteropStaticType.number
  set scale(_i2.num value) {
    _i5.setProperty(
      this,
      'scale',
      value,
    );
  }

  /* #15064
  source: 
    /**
     * Gets or sets the angle transform, in degrees, of this GraphObject.
     * Value must be a number. If the value is not between (0 &lt;= value &lt; 360),
     * it will be normalized to be in that range.
     * Zero is along the positive X-axis (rightwards); 90 is along the positive Y-axis (downwards).
     * Default is 0.
     *
     * When set on a Graduated Panel's TextBlock label, this value will be be ignored if #segmentOrientation is not
     * Link.None, Link.OrientAlong, or Link.OrientUpright. OrientAlong and OrientUpright will use this angle
     * relative to the slope of the main path.
     *
     * When set on a Link label, this value will be be ignored if #segmentOrientation is not Link.None.
     * @see #scale
     * @see #stretch
     */
    get angle(): number; */
  /// Gets or sets the angle transform, in degrees, of this GraphObject.
  /// Value must be a number. If the value is not between (0 &lt;= value &lt; 360),
  /// it will be normalized to be in that range.
  /// Zero is along the positive X-axis (rightwards); 90 is along the positive Y-axis (downwards).
  /// Default is 0.
  ///
  /// When set on a Graduated Panel's TextBlock label, this value will be be ignored if #segmentOrientation is not
  /// Link.None, Link.OrientAlong, or Link.OrientUpright. OrientAlong and OrientUpright will use this angle
  /// relative to the slope of the main path.
  ///
  /// When set on a Link label, this value will be be ignored if #segmentOrientation is not Link.None.
  _i2.num get angle => _i5.getProperty(
        this,
        'angle',
      );
  /* #15064
  source: 
    /**
     * Gets or sets the angle transform, in degrees, of this GraphObject.
     * Value must be a number. If the value is not between (0 &lt;= value &lt; 360),
     * it will be normalized to be in that range.
     * Zero is along the positive X-axis (rightwards); 90 is along the positive Y-axis (downwards).
     * Default is 0.
     *
     * When set on a Graduated Panel's TextBlock label, this value will be be ignored if #segmentOrientation is not
     * Link.None, Link.OrientAlong, or Link.OrientUpright. OrientAlong and OrientUpright will use this angle
     * relative to the slope of the main path.
     *
     * When set on a Link label, this value will be be ignored if #segmentOrientation is not Link.None.
     * @see #scale
     * @see #stretch
     */
    get angle(): number; */
  // Type InteropStaticType.number
  set angle(_i2.num value) {
    _i5.setProperty(
      this,
      'angle',
      value,
    );
  }

  /* #15088
  source: 
    /**
     * Gets or sets the desired size of this GraphObject in local coordinates.
     * Value must be of type Size.
     * Default is Size(NaN, NaN).
     * You cannot modify the width or height of the value of this property --
     * if you want to change the desiredSize you must set this property to a different Size.
     *
     * Getting or setting #width or #height is equivalent to getting or setting the
     * width or height of this property.
     *
     * The size does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     * If the desiredSize is greater than the allowed size that the GraphObject's Panel determines,
     * then the GraphObject may be visually clipped. If the desiredSize does not meet the constraints
     * of #minSize and #maxSize, the GraphObject will be resized to meet them.
     * @see #minSize
     * @see #maxSize
     * @see #naturalBounds
     * @see #measuredBounds
     * @see #actualBounds
     */
    get desiredSize(): Size; */
  /// Gets or sets the desired size of this GraphObject in local coordinates.
  /// Value must be of type Size.
  /// Default is Size(NaN, NaN).
  /// You cannot modify the width or height of the value of this property --
  /// if you want to change the desiredSize you must set this property to a different Size.
  ///
  /// Getting or setting #width or #height is equivalent to getting or setting the
  /// width or height of this property.
  ///
  /// The size does not include any transformation due to #scale or #angle,
  /// nor any pen thickness due to Shape#strokeWidth if this is a Shape.
  /// If there is a containing Panel the Panel will determine the actual size.
  /// If the desiredSize is greater than the allowed size that the GraphObject's Panel determines,
  /// then the GraphObject may be visually clipped. If the desiredSize does not meet the constraints
  /// of #minSize and #maxSize, the GraphObject will be resized to meet them.
  _i3.Size get desiredSize => _i5.getProperty(
        this,
        'desiredSize',
      );
  /* #15088
  source: 
    /**
     * Gets or sets the desired size of this GraphObject in local coordinates.
     * Value must be of type Size.
     * Default is Size(NaN, NaN).
     * You cannot modify the width or height of the value of this property --
     * if you want to change the desiredSize you must set this property to a different Size.
     *
     * Getting or setting #width or #height is equivalent to getting or setting the
     * width or height of this property.
     *
     * The size does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     * If the desiredSize is greater than the allowed size that the GraphObject's Panel determines,
     * then the GraphObject may be visually clipped. If the desiredSize does not meet the constraints
     * of #minSize and #maxSize, the GraphObject will be resized to meet them.
     * @see #minSize
     * @see #maxSize
     * @see #naturalBounds
     * @see #measuredBounds
     * @see #actualBounds
     */
    get desiredSize(): Size; */
  // Type Instance of 'InteropInterface'
  set desiredSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'desiredSize',
      value,
    );
  }

  /* #15101
  source: 
    /**
     * Gets or sets the desired width of this GraphObject in local coordinates.
     * This just gets or sets the width component of the #desiredSize.
     * Default is NaN.
     *
     * Size can also be constrained by setting #minSize and #maxSize.
     *
     * The width does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     */
    get width(): number; */
  /// Gets or sets the desired width of this GraphObject in local coordinates.
  /// This just gets or sets the width component of the #desiredSize.
  /// Default is NaN.
  ///
  /// Size can also be constrained by setting #minSize and #maxSize.
  ///
  /// The width does not include any transformation due to #scale or #angle,
  /// nor any pen thickness due to Shape#strokeWidth if this is a Shape.
  /// If there is a containing Panel the Panel will determine the actual size.
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #15101
  source: 
    /**
     * Gets or sets the desired width of this GraphObject in local coordinates.
     * This just gets or sets the width component of the #desiredSize.
     * Default is NaN.
     *
     * Size can also be constrained by setting #minSize and #maxSize.
     *
     * The width does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     */
    get width(): number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #15114
  source: 
    /**
     * Gets or sets the desired height of this GraphObject in local coordinates.
     * This just gets or sets the height component of the #desiredSize.
     * Default is NaN.
     *
     * Size can also be constrained by setting #minSize and #maxSize.
     *
     * The height does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     */
    get height(): number; */
  /// Gets or sets the desired height of this GraphObject in local coordinates.
  /// This just gets or sets the height component of the #desiredSize.
  /// Default is NaN.
  ///
  /// Size can also be constrained by setting #minSize and #maxSize.
  ///
  /// The height does not include any transformation due to #scale or #angle,
  /// nor any pen thickness due to Shape#strokeWidth if this is a Shape.
  /// If there is a containing Panel the Panel will determine the actual size.
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #15114
  source: 
    /**
     * Gets or sets the desired height of this GraphObject in local coordinates.
     * This just gets or sets the height component of the #desiredSize.
     * Default is NaN.
     *
     * Size can also be constrained by setting #minSize and #maxSize.
     *
     * The height does not include any transformation due to #scale or #angle,
     * nor any pen thickness due to Shape#strokeWidth if this is a Shape.
     * If there is a containing Panel the Panel will determine the actual size.
     */
    get height(): number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  /* #15128
  source: 
    /**
     * Gets or sets the minimum size of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Any new value must be of type Size; NaN values are treated as 0.
     *
     * You cannot modify the width or height of the value of this property --
     * if you want to change the minSize you must set this property to a different Size.
     * The default value is zero by zero.
     * A containing Panel will determine the actual size of this object.
     * @see #maxSize
     * @see #desiredSize
     */
    get minSize(): Size; */
  /// Gets or sets the minimum size of this GraphObject in container coordinates
  /// (either a Panel or the document).
  /// Any new value must be of type Size; NaN values are treated as 0.
  ///
  /// You cannot modify the width or height of the value of this property --
  /// if you want to change the minSize you must set this property to a different Size.
  /// The default value is zero by zero.
  /// A containing Panel will determine the actual size of this object.
  _i3.Size get minSize => _i5.getProperty(
        this,
        'minSize',
      );
  /* #15128
  source: 
    /**
     * Gets or sets the minimum size of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Any new value must be of type Size; NaN values are treated as 0.
     *
     * You cannot modify the width or height of the value of this property --
     * if you want to change the minSize you must set this property to a different Size.
     * The default value is zero by zero.
     * A containing Panel will determine the actual size of this object.
     * @see #maxSize
     * @see #desiredSize
     */
    get minSize(): Size; */
  // Type Instance of 'InteropInterface'
  set minSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'minSize',
      value,
    );
  }

  /* #15142
  source: 
    /**
     * Gets or sets the maximum size of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Any new value must be of type Size; NaN values are treated as Infinity. If you want no maximum width or height, use NaN or Infinity.
     *
     * You cannot modify the width or height of the value of this property --
     * if you want to change the maxSize you must set this property to a different Size.
     * The default value is Infinity by Infinity.
     * A containing Panel will determine the actual size of this object.
     * @see #minSize
     * @see #desiredSize
     */
    get maxSize(): Size; */
  /// Gets or sets the maximum size of this GraphObject in container coordinates
  /// (either a Panel or the document).
  /// Any new value must be of type Size; NaN values are treated as Infinity. If you want no maximum width or height, use NaN or Infinity.
  ///
  /// You cannot modify the width or height of the value of this property --
  /// if you want to change the maxSize you must set this property to a different Size.
  /// The default value is Infinity by Infinity.
  /// A containing Panel will determine the actual size of this object.
  _i3.Size get maxSize => _i5.getProperty(
        this,
        'maxSize',
      );
  /* #15142
  source: 
    /**
     * Gets or sets the maximum size of this GraphObject in container coordinates
     * (either a Panel or the document).
     * Any new value must be of type Size; NaN values are treated as Infinity. If you want no maximum width or height, use NaN or Infinity.
     *
     * You cannot modify the width or height of the value of this property --
     * if you want to change the maxSize you must set this property to a different Size.
     * The default value is Infinity by Infinity.
     * A containing Panel will determine the actual size of this object.
     * @see #minSize
     * @see #desiredSize
     */
    get maxSize(): Size; */
  // Type Instance of 'InteropInterface'
  set maxSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'maxSize',
      value,
    );
  }

  /* #15156
  source: 
    /**
     * This read-only property returns the measuredBounds of the GraphObject in container coordinates
     * (either a Panel or the document).
     * This describes the transformed bounds with margins excluded.
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #naturalBounds
     * @see #desiredSize
     * @see #actualBounds
     */
    get measuredBounds(): Rect; */
  /// This read-only property returns the measuredBounds of the GraphObject in container coordinates
  /// (either a Panel or the document).
  /// This describes the transformed bounds with margins excluded.
  ///
  /// You must not modify any of the properties of the Rect that is the value of this property.
  ///
  /// As with all read-only properties, using this property as a binding source is unlikely to be useful.
  _i3.Rect get measuredBounds => _i5.getProperty(
        this,
        'measuredBounds',
      );
  /* #15156
  source: 
    /**
     * This read-only property returns the measuredBounds of the GraphObject in container coordinates
     * (either a Panel or the document).
     * This describes the transformed bounds with margins excluded.
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #naturalBounds
     * @see #desiredSize
     * @see #actualBounds
     */
    get measuredBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set measuredBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'measuredBounds',
      value,
    );
  }

  /* #15173
  source: 
    /**
     * This read-only property returns the natural bounding rectangle of this GraphObject in local coordinates,
     * before any transformation by #scale or #angle,
     * and before any resizing due to #minSize or #maxSize or #stretch.
     * Defaults to unknown (NaN,NaN).
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * The value can only be changed by changing properties of the particular GraphObject,
     * such as GraphObject#desiredSize, Shape#geometry, or TextBlock#font.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #desiredSize
     * @see #measuredBounds
     * @see #actualBounds
     */
    get naturalBounds(): Rect; */
  /// This read-only property returns the natural bounding rectangle of this GraphObject in local coordinates,
  /// before any transformation by #scale or #angle,
  /// and before any resizing due to #minSize or #maxSize or #stretch.
  /// Defaults to unknown (NaN,NaN).
  ///
  /// You must not modify any of the properties of the Rect that is the value of this property.
  ///
  /// The value can only be changed by changing properties of the particular GraphObject,
  /// such as GraphObject#desiredSize, Shape#geometry, or TextBlock#font.
  ///
  /// As with all read-only properties, using this property as a binding source is unlikely to be useful.
  _i3.Rect get naturalBounds => _i5.getProperty(
        this,
        'naturalBounds',
      );
  /* #15173
  source: 
    /**
     * This read-only property returns the natural bounding rectangle of this GraphObject in local coordinates,
     * before any transformation by #scale or #angle,
     * and before any resizing due to #minSize or #maxSize or #stretch.
     * Defaults to unknown (NaN,NaN).
     *
     * You must not modify any of the properties of the Rect that is the value of this property.
     *
     * The value can only be changed by changing properties of the particular GraphObject,
     * such as GraphObject#desiredSize, Shape#geometry, or TextBlock#font.
     *
     * As with all read-only properties, using this property as a binding source is unlikely to be useful.
     * @see #desiredSize
     * @see #measuredBounds
     * @see #actualBounds
     */
    get naturalBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set naturalBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'naturalBounds',
      value,
    );
  }

  /* #15195
  source: 
    /**
     * Gets or sets the size of empty area around this GraphObject, as a Margin,
     * in the containing Panel coordinates.
     *
     * Negative values are permitted but may cause overlaps with adjacent
     * objects in a Panel.
     * You cannot modify the top or left or right or bottom of the value of this property --
     * if you want to change the margin you must set this property to a different Margin.
     * Default margin is `Margin(0,0,0,0)`.
     *
     * For most uses, increasing a margin will increase the space this GraphObject takes in its containing panel.
     * When an object has a GraphObject#stretch value applied, margins may decrease the size of that object.
     *
     * The property setter accepts a number instead of a Margin object: providing a
     * number `N` will result in using a `Margin(N, N, N, N)`.
     * The property getter will always return a Margin.
     * @see #desiredSize
     * @see #measuredBounds
     * @see #actualBounds
     * @see Panel#padding
     */
    get margin(): MarginLike; */
  /// Gets or sets the size of empty area around this GraphObject, as a Margin,
  /// in the containing Panel coordinates.
  ///
  /// Negative values are permitted but may cause overlaps with adjacent
  /// objects in a Panel.
  /// You cannot modify the top or left or right or bottom of the value of this property --
  /// if you want to change the margin you must set this property to a different Margin.
  /// Default margin is `Margin(0,0,0,0)`.
  ///
  /// For most uses, increasing a margin will increase the space this GraphObject takes in its containing panel.
  /// When an object has a GraphObject#stretch value applied, margins may decrease the size of that object.
  ///
  /// The property setter accepts a number instead of a Margin object: providing a
  /// number `N` will result in using a `Margin(N, N, N, N)`.
  /// The property getter will always return a Margin.
  _i3.MarginLike get margin => _i5.getProperty(
        this,
        'margin',
      );
  /* #15195
  source: 
    /**
     * Gets or sets the size of empty area around this GraphObject, as a Margin,
     * in the containing Panel coordinates.
     *
     * Negative values are permitted but may cause overlaps with adjacent
     * objects in a Panel.
     * You cannot modify the top or left or right or bottom of the value of this property --
     * if you want to change the margin you must set this property to a different Margin.
     * Default margin is `Margin(0,0,0,0)`.
     *
     * For most uses, increasing a margin will increase the space this GraphObject takes in its containing panel.
     * When an object has a GraphObject#stretch value applied, margins may decrease the size of that object.
     *
     * The property setter accepts a number instead of a Margin object: providing a
     * number `N` will result in using a `Margin(N, N, N, N)`.
     * The property getter will always return a Margin.
     * @see #desiredSize
     * @see #measuredBounds
     * @see #actualBounds
     * @see Panel#padding
     */
    get margin(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set margin(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'margin',
      value,
    );
  }

  /* #15217
  source: 
    /**********************************************************
    Panel-specific properties:
    ***********************************************************/
    /**
     * Gets or sets the alignment Spot of this GraphObject used in Panel layouts,
     * to determine where in the area allocated by the panel this object should be placed.
     *
     * The default value is Spot.Default, which lets the Panel determine the Spot using
     * Panel#defaultAlignment. If that property is also Spot.Default,
     * then the alignment spot will be different depending on the Panel type.
     *
     * The #alignmentFocus is often used along with this property to specify
     * where this object should be positioned in a Panel.
     *
     * A Spot.Default is equivalent to Spot.Center in Spot, Auto, Horizontal, and Vertical panels.
     * For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
     *
     * @see #alignmentFocus
     * @see Panel#defaultAlignment
     */
    get alignment(): Spot; */
  /// Gets or sets the alignment Spot of this GraphObject used in Panel layouts,
  /// to determine where in the area allocated by the panel this object should be placed.
  ///
  /// The default value is Spot.Default, which lets the Panel determine the Spot using
  /// Panel#defaultAlignment. If that property is also Spot.Default,
  /// then the alignment spot will be different depending on the Panel type.
  ///
  /// The #alignmentFocus is often used along with this property to specify
  /// where this object should be positioned in a Panel.
  ///
  /// A Spot.Default is equivalent to Spot.Center in Spot, Auto, Horizontal, and Vertical panels.
  /// For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
  _i3.Spot get alignment => _i5.getProperty(
        this,
        'alignment',
      );
  /* #15217
  source: 
    /**********************************************************
    Panel-specific properties:
    ***********************************************************/
    /**
     * Gets or sets the alignment Spot of this GraphObject used in Panel layouts,
     * to determine where in the area allocated by the panel this object should be placed.
     *
     * The default value is Spot.Default, which lets the Panel determine the Spot using
     * Panel#defaultAlignment. If that property is also Spot.Default,
     * then the alignment spot will be different depending on the Panel type.
     *
     * The #alignmentFocus is often used along with this property to specify
     * where this object should be positioned in a Panel.
     *
     * A Spot.Default is equivalent to Spot.Center in Spot, Auto, Horizontal, and Vertical panels.
     * For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
     *
     * @see #alignmentFocus
     * @see Panel#defaultAlignment
     */
    get alignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set alignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'alignment',
      value,
    );
  }

  /* #15223
  source: 
    /**
     * Gets or sets the column of this GraphObject if it is in a Table Panel.
     * The value must be a small non-negative integer. The default is 0.
     */
    get column(): number; */
  /// Gets or sets the column of this GraphObject if it is in a Table Panel.
  /// The value must be a small non-negative integer. The default is 0.
  _i2.num get column => _i5.getProperty(
        this,
        'column',
      );
  /* #15223
  source: 
    /**
     * Gets or sets the column of this GraphObject if it is in a Table Panel.
     * The value must be a small non-negative integer. The default is 0.
     */
    get column(): number; */
  // Type InteropStaticType.number
  set column(_i2.num value) {
    _i5.setProperty(
      this,
      'column',
      value,
    );
  }

  /* #15229
  source: 
    /**
     * Gets or sets the number of columns spanned by this GraphObject if it is in a Table Panel.
     * The value must be a small positive integer. The default is 1.
     */
    get columnSpan(): number; */
  /// Gets or sets the number of columns spanned by this GraphObject if it is in a Table Panel.
  /// The value must be a small positive integer. The default is 1.
  _i2.num get columnSpan => _i5.getProperty(
        this,
        'columnSpan',
      );
  /* #15229
  source: 
    /**
     * Gets or sets the number of columns spanned by this GraphObject if it is in a Table Panel.
     * The value must be a small positive integer. The default is 1.
     */
    get columnSpan(): number; */
  // Type InteropStaticType.number
  set columnSpan(_i2.num value) {
    _i5.setProperty(
      this,
      'columnSpan',
      value,
    );
  }

  /* #15235
  source: 
    /**
     * Gets or sets the row of this GraphObject if it is in a Table Panel.
     * The value must be a small non-negative integer. The default is 0.
     */
    get row(): number; */
  /// Gets or sets the row of this GraphObject if it is in a Table Panel.
  /// The value must be a small non-negative integer. The default is 0.
  _i2.num get row => _i5.getProperty(
        this,
        'row',
      );
  /* #15235
  source: 
    /**
     * Gets or sets the row of this GraphObject if it is in a Table Panel.
     * The value must be a small non-negative integer. The default is 0.
     */
    get row(): number; */
  // Type InteropStaticType.number
  set row(_i2.num value) {
    _i5.setProperty(
      this,
      'row',
      value,
    );
  }

  /* #15241
  source: 
    /**
     * Gets or sets the number of rows spanned by this GraphObject if it is in a Table Panel.
     * The value must be a small positive integer. The default is 1.
     */
    get rowSpan(): number; */
  /// Gets or sets the number of rows spanned by this GraphObject if it is in a Table Panel.
  /// The value must be a small positive integer. The default is 1.
  _i2.num get rowSpan => _i5.getProperty(
        this,
        'rowSpan',
      );
  /* #15241
  source: 
    /**
     * Gets or sets the number of rows spanned by this GraphObject if it is in a Table Panel.
     * The value must be a small positive integer. The default is 1.
     */
    get rowSpan(): number; */
  // Type InteropStaticType.number
  set rowSpan(_i2.num value) {
    _i5.setProperty(
      this,
      'rowSpan',
      value,
    );
  }

  /* #15246
  source: 
    /**
     * (undocumented)
     */
    get spanAllocation(): ((a: GraphObject, b: RowColumnDefinition, c: number) => number) | null; */
  /// (undocumented)
  _i2.num Function(
    _i3.GraphObject,
    _i3.RowColumnDefinition,
    _i2.num,
  )? get spanAllocation => _i5.getProperty(
        this,
        'spanAllocation',
      );
  /* #15246
  source: 
    /**
     * (undocumented)
     */
    get spanAllocation(): ((a: GraphObject, b: RowColumnDefinition, c: number) => number) | null; */
  // Type InteropUnion#292210508(parent: InteropGetter#978001060(name: spanAllocation))
  set spanAllocation(
      _i2.num Function(
        _i3.GraphObject,
        _i3.RowColumnDefinition,
        _i2.num,
      )? value) {
    _i5.setProperty(
      this,
      'spanAllocation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15271
  source: 
    /**
     * Gets or sets the spot on this GraphObject to be used as the alignment point
     * in Spot and Fixed Panels.
     * Value must be of the Spot.
     *
     * The default value is Spot.Default, which means that the Panel type can decide the effective alignment spot.
     *
     * The #alignment is often used along with this property to specify
     * where this object should be positioned in a Panel.
     *
     * For Panel.Graduated, the alignmentFocus spot determines the spot on a child element to be aligned with some
     * point along the main element.
     *
     * When you want a link label Node to be positioned by its location spot rather than by this alignmentFocus spot,
     * you can set this property to Spot.None, only on Nodes.
     *
     * For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
     *
     * WARNING: Since 2.0, for Spot Panels, the offsetX/offsetY of #alignmentFocus has been reversed.
     * The offsetX/Y now describes offset distance from the alignmentFocus point to the alignment point, rather than the opposite.
     * This is what it has always described when using #alignmentFocus with Link Labels.
     * @see Panel#alignmentFocusName
     */
    get alignmentFocus(): Spot; */
  /// Gets or sets the spot on this GraphObject to be used as the alignment point
  /// in Spot and Fixed Panels.
  /// Value must be of the Spot.
  ///
  /// The default value is Spot.Default, which means that the Panel type can decide the effective alignment spot.
  ///
  /// The #alignment is often used along with this property to specify
  /// where this object should be positioned in a Panel.
  ///
  /// For Panel.Graduated, the alignmentFocus spot determines the spot on a child element to be aligned with some
  /// point along the main element.
  ///
  /// When you want a link label Node to be positioned by its location spot rather than by this alignmentFocus spot,
  /// you can set this property to Spot.None, only on Nodes.
  ///
  /// For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
  ///
  /// WARNING: Since 2.0, for Spot Panels, the offsetX/offsetY of #alignmentFocus has been reversed.
  /// The offsetX/Y now describes offset distance from the alignmentFocus point to the alignment point, rather than the opposite.
  /// This is what it has always described when using #alignmentFocus with Link Labels.
  _i3.Spot get alignmentFocus => _i5.getProperty(
        this,
        'alignmentFocus',
      );
  /* #15271
  source: 
    /**
     * Gets or sets the spot on this GraphObject to be used as the alignment point
     * in Spot and Fixed Panels.
     * Value must be of the Spot.
     *
     * The default value is Spot.Default, which means that the Panel type can decide the effective alignment spot.
     *
     * The #alignment is often used along with this property to specify
     * where this object should be positioned in a Panel.
     *
     * For Panel.Graduated, the alignmentFocus spot determines the spot on a child element to be aligned with some
     * point along the main element.
     *
     * When you want a link label Node to be positioned by its location spot rather than by this alignmentFocus spot,
     * you can set this property to Spot.None, only on Nodes.
     *
     * For examples of alignments in different panels, see the <a href="../../intro/panels.html">Introduction page on Panels</a>.
     *
     * WARNING: Since 2.0, for Spot Panels, the offsetX/offsetY of #alignmentFocus has been reversed.
     * The offsetX/Y now describes offset distance from the alignmentFocus point to the alignment point, rather than the opposite.
     * This is what it has always described when using #alignmentFocus with Link Labels.
     * @see Panel#alignmentFocusName
     */
    get alignmentFocus(): Spot; */
  // Type Instance of 'InteropInterface'
  set alignmentFocus(_i3.Spot value) {
    _i5.setProperty(
      this,
      'alignmentFocus',
      value,
    );
  }

  /* #15301
  source: 
    /**********************************************************
    Port-specific properties:
    ***********************************************************/
    /**
     * Gets or sets an identifier for an object acting as a port on a Node.
     * The default value is null -- this object is not a port.
     *
     * A value that is the empty string is used by convention to mean the primary
     * (and usually only) port of the node.
     *
     * If a Node has no named ports, then the Node itself is the sole port.
     *
     * Note: the only kind of model that can save port information, i.e. portIds that are not an empty string,
     * for links is a GraphLinksModel whose GraphLinksModel#linkFromPortIdProperty and
     * GraphLinksModel#linkToPortIdProperty have been set to name properties on the link data objects.
     *
     * The value should be unique within the Node.
     * You must not modify this property once this GraphObject is in the visual tree of a Node.
     * <p class="boxread">
     * See <a href="../../intro/ports.html">the Introduction page on ports</a>
     * for usage information and examples.
     * @see #fromLinkable
     * @see #toLinkable
     * @see #fromSpot
     * @see #toSpot
     * @see Link#fromSpot
     * @see Link#toSpot
     */
    get portId(): string; */
  /// Gets or sets an identifier for an object acting as a port on a Node.
  /// The default value is null -- this object is not a port.
  ///
  /// A value that is the empty string is used by convention to mean the primary
  /// (and usually only) port of the node.
  ///
  /// If a Node has no named ports, then the Node itself is the sole port.
  ///
  /// Note: the only kind of model that can save port information, i.e. portIds that are not an empty string,
  /// for links is a GraphLinksModel whose GraphLinksModel#linkFromPortIdProperty and
  /// GraphLinksModel#linkToPortIdProperty have been set to name properties on the link data objects.
  ///
  /// The value should be unique within the Node.
  /// You must not modify this property once this GraphObject is in the visual tree of a Node.
  /// <p class="boxread">
  /// See <a href="../../intro/ports.html">the Introduction page on ports</a>
  /// for usage information and examples.
  _i2.String get portId => _i5.getProperty(
        this,
        'portId',
      );
  /* #15301
  source: 
    /**********************************************************
    Port-specific properties:
    ***********************************************************/
    /**
     * Gets or sets an identifier for an object acting as a port on a Node.
     * The default value is null -- this object is not a port.
     *
     * A value that is the empty string is used by convention to mean the primary
     * (and usually only) port of the node.
     *
     * If a Node has no named ports, then the Node itself is the sole port.
     *
     * Note: the only kind of model that can save port information, i.e. portIds that are not an empty string,
     * for links is a GraphLinksModel whose GraphLinksModel#linkFromPortIdProperty and
     * GraphLinksModel#linkToPortIdProperty have been set to name properties on the link data objects.
     *
     * The value should be unique within the Node.
     * You must not modify this property once this GraphObject is in the visual tree of a Node.
     * <p class="boxread">
     * See <a href="../../intro/ports.html">the Introduction page on ports</a>
     * for usage information and examples.
     * @see #fromLinkable
     * @see #toLinkable
     * @see #fromSpot
     * @see #toSpot
     * @see Link#fromSpot
     * @see Link#toSpot
     */
    get portId(): string; */
  // Type InteropStaticType.string
  set portId(_i2.String value) {
    _i5.setProperty(
      this,
      'portId',
      value,
    );
  }

  /* #15325
  source: 
    /**
     * Gets or sets where a link should connect to this port.
     * The default value is Spot.None, meaning that the link routing
     * must consider the shape of the port and connect to the closest point.
     *
     * The value of Link#toSpot, if not Spot.Default, takes precedence over the value at this port
     * when determining the route of the link.
     * A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
     * thereby causing this property and #fromSpot on the port element to be ignored.
     * Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
     * TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#toSpot
     * @see Link#computeSpot
     * @see #fromSpot
     * @see #portId
     */
    get toSpot(): Spot; */
  /// Gets or sets where a link should connect to this port.
  /// The default value is Spot.None, meaning that the link routing
  /// must consider the shape of the port and connect to the closest point.
  ///
  /// The value of Link#toSpot, if not Spot.Default, takes precedence over the value at this port
  /// when determining the route of the link.
  /// A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
  /// thereby causing this property and #fromSpot on the port element to be ignored.
  /// Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
  /// TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i3.Spot get toSpot => _i5.getProperty(
        this,
        'toSpot',
      );
  /* #15325
  source: 
    /**
     * Gets or sets where a link should connect to this port.
     * The default value is Spot.None, meaning that the link routing
     * must consider the shape of the port and connect to the closest point.
     *
     * The value of Link#toSpot, if not Spot.Default, takes precedence over the value at this port
     * when determining the route of the link.
     * A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
     * thereby causing this property and #fromSpot on the port element to be ignored.
     * Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
     * TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#toSpot
     * @see Link#computeSpot
     * @see #fromSpot
     * @see #portId
     */
    get toSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set toSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'toSpot',
      value,
    );
  }

  /* #15346
  source: 
    /**
     * Gets or sets the length of the last segment of a link going to this port.
     * This value is used when the computed "to spot" is not Spot.None.
     * The default value is 10.
     *
     * The value of Link#toEndSegmentLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     * This value also limits how short the Link#toShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#toEndSegmentLength
     * @see Link#computeEndSegmentLength
     * @see #fromEndSegmentLength
     * @see #portId
     */
    get toEndSegmentLength(): number; */
  /// Gets or sets the length of the last segment of a link going to this port.
  /// This value is used when the computed "to spot" is not Spot.None.
  /// The default value is 10.
  ///
  /// The value of Link#toEndSegmentLength, if not NaN, takes precedence over the value at this port
  /// when determining the route of the link.
  /// This value also limits how short the Link#toShortLength may be drawn.
  ///
  /// For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get toEndSegmentLength => _i5.getProperty(
        this,
        'toEndSegmentLength',
      );
  /* #15346
  source: 
    /**
     * Gets or sets the length of the last segment of a link going to this port.
     * This value is used when the computed "to spot" is not Spot.None.
     * The default value is 10.
     *
     * The value of Link#toEndSegmentLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     * This value also limits how short the Link#toShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#toEndSegmentLength
     * @see Link#computeEndSegmentLength
     * @see #fromEndSegmentLength
     * @see #portId
     */
    get toEndSegmentLength(): number; */
  // Type InteropStaticType.number
  set toEndSegmentLength(_i2.num value) {
    _i5.setProperty(
      this,
      'toEndSegmentLength',
      value,
    );
  }

  /* #15376
  source: 
    /**
     * Gets or sets how far the end segment of a link going to this port stops short of the actual port.
     * Positive values are limited by the #toEndSegmentLength or Link#toEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is zero.
     *
     * This property is useful when you have a thick link and a pointy arrowhead.
     * Normally the link Shape extends all the way to the end of the arrowhead.
     * If the link Shape is wide, its edges will be seen behind the arrowhead.
     * By setting this property to a small positive value, the link Shape can end within the
     * body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
     *
     * A negative value for this property can also be useful when you want the link Shape to continue
     * into the port, perhaps because a portion of the port is transparent and you want the link to
     * appear to connect visually with a different point on the node.
     *
     * The value of Link#toShortLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromShortLength
     * @see Link#toShortLength
     * @see #portId
     */
    get toShortLength(): number; */
  /// Gets or sets how far the end segment of a link going to this port stops short of the actual port.
  /// Positive values are limited by the #toEndSegmentLength or Link#toEndSegmentLength.
  /// Negative values cause the link to extend into the port.
  /// The default value is zero.
  ///
  /// This property is useful when you have a thick link and a pointy arrowhead.
  /// Normally the link Shape extends all the way to the end of the arrowhead.
  /// If the link Shape is wide, its edges will be seen behind the arrowhead.
  /// By setting this property to a small positive value, the link Shape can end within the
  /// body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
  ///
  /// A negative value for this property can also be useful when you want the link Shape to continue
  /// into the port, perhaps because a portion of the port is transparent and you want the link to
  /// appear to connect visually with a different point on the node.
  ///
  /// The value of Link#toShortLength, if not NaN, takes precedence over the value at this port
  /// when determining the route of the link.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get toShortLength => _i5.getProperty(
        this,
        'toShortLength',
      );
  /* #15376
  source: 
    /**
     * Gets or sets how far the end segment of a link going to this port stops short of the actual port.
     * Positive values are limited by the #toEndSegmentLength or Link#toEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is zero.
     *
     * This property is useful when you have a thick link and a pointy arrowhead.
     * Normally the link Shape extends all the way to the end of the arrowhead.
     * If the link Shape is wide, its edges will be seen behind the arrowhead.
     * By setting this property to a small positive value, the link Shape can end within the
     * body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
     *
     * A negative value for this property can also be useful when you want the link Shape to continue
     * into the port, perhaps because a portion of the port is transparent and you want the link to
     * appear to connect visually with a different point on the node.
     *
     * The value of Link#toShortLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromShortLength
     * @see Link#toShortLength
     * @see #portId
     */
    get toShortLength(): number; */
  // Type InteropStaticType.number
  set toShortLength(_i2.num value) {
    _i5.setProperty(
      this,
      'toShortLength',
      value,
    );
  }

  /* #15395
  source: 
    /**
     * Gets or sets whether the user may draw Links to this port.
     * This property is used by LinkingBaseTool#isValidTo.
     *
     * The default value is null, which indicates that the real value is inherited from
     * the parent Panel, or false if there is no containing panel.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node,
     * or unless you are disabling the "linkability" of a particular GraphObject
     * inside a Panel whose toLinkable has been set or bound to true.
     * @see #fromLinkable
     * @see #toMaxLinks
     * @see #portId
     * @see #cursor
     */
    get toLinkable(): boolean | null; */
  /// Gets or sets whether the user may draw Links to this port.
  /// This property is used by LinkingBaseTool#isValidTo.
  ///
  /// The default value is null, which indicates that the real value is inherited from
  /// the parent Panel, or false if there is no containing panel.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node,
  /// or unless you are disabling the "linkability" of a particular GraphObject
  /// inside a Panel whose toLinkable has been set or bound to true.
  _i2.bool? get toLinkable => _i5.getProperty(
        this,
        'toLinkable',
      );
  /* #15395
  source: 
    /**
     * Gets or sets whether the user may draw Links to this port.
     * This property is used by LinkingBaseTool#isValidTo.
     *
     * The default value is null, which indicates that the real value is inherited from
     * the parent Panel, or false if there is no containing panel.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node,
     * or unless you are disabling the "linkability" of a particular GraphObject
     * inside a Panel whose toLinkable has been set or bound to true.
     * @see #fromLinkable
     * @see #toMaxLinks
     * @see #portId
     * @see #cursor
     */
    get toLinkable(): boolean | null; */
  // Type InteropUnion#27276305(parent: InteropGetter#272908060(name: toLinkable))
  set toLinkable(_i2.bool? value) {
    _i5.setProperty(
      this,
      'toLinkable',
      value ?? _i4.undefined,
    );
  }

  /* #15411
  source: 
    /**
     * Gets or sets the maximum number of links that may go into this port.
     * This property is used by LinkingBaseTool#isValidTo.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #fromMaxLinks
     * @see #portId
     */
    get toMaxLinks(): number; */
  /// Gets or sets the maximum number of links that may go into this port.
  /// This property is used by LinkingBaseTool#isValidTo.
  ///
  /// The value must be non-negative.
  /// The default value is Infinity.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get toMaxLinks => _i5.getProperty(
        this,
        'toMaxLinks',
      );
  /* #15411
  source: 
    /**
     * Gets or sets the maximum number of links that may go into this port.
     * This property is used by LinkingBaseTool#isValidTo.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toLinkable
     * @see #fromMaxLinks
     * @see #portId
     */
    get toMaxLinks(): number; */
  // Type InteropStaticType.number
  set toMaxLinks(_i2.num value) {
    _i5.setProperty(
      this,
      'toMaxLinks',
      value,
    );
  }

  /* #15435
  source: 
    /**
     * Gets or sets where a link should connect from this port.
     * The default value is Spot.None, meaning that the link routing
     * must consider the shape of the port and connect at the closest point.
     *
     * The value of Link#fromSpot, if not Spot.Default, takes precedence over the value at this port
     * when determining the route of the link.
     * A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
     * thereby causing this property and #toSpot on the port element to be ignored.
     * Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
     * TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#fromSpot
     * @see Link#computeSpot
     * @see #toSpot
     * @see #portId
     */
    get fromSpot(): Spot; */
  /// Gets or sets where a link should connect from this port.
  /// The default value is Spot.None, meaning that the link routing
  /// must consider the shape of the port and connect at the closest point.
  ///
  /// The value of Link#fromSpot, if not Spot.Default, takes precedence over the value at this port
  /// when determining the route of the link.
  /// A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
  /// thereby causing this property and #toSpot on the port element to be ignored.
  /// Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
  /// TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i3.Spot get fromSpot => _i5.getProperty(
        this,
        'fromSpot',
      );
  /* #15435
  source: 
    /**
     * Gets or sets where a link should connect from this port.
     * The default value is Spot.None, meaning that the link routing
     * must consider the shape of the port and connect at the closest point.
     *
     * The value of Link#fromSpot, if not Spot.Default, takes precedence over the value at this port
     * when determining the route of the link.
     * A number of the predefined Layouts automatically set Link#fromSpot and Link#toSpot,
     * thereby causing this property and #toSpot on the port element to be ignored.
     * Depending on the layout, you may be able to disable that behavior, such as by setting ForceDirectedLayout#setsPortSpots,
     * TreeLayout#setsPortSpot, TreeLayout#setsChildPortSpot, or LayeredDigraphLayout#setsPortSpots to false.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#fromSpot
     * @see Link#computeSpot
     * @see #toSpot
     * @see #portId
     */
    get fromSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set fromSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'fromSpot',
      value,
    );
  }

  /* #15456
  source: 
    /**
     * Gets or sets the length of the first segment of a link coming from this port.
     * This value is used when the computed "from spot" is not Spot.None.
     * The default value is 10.
     * This value also limits how short the Link#fromShortLength may be drawn.
     *
     * The value of Link#fromEndSegmentLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#fromEndSegmentLength
     * @see Link#computeEndSegmentLength
     * @see #toEndSegmentLength
     * @see #portId
     */
    get fromEndSegmentLength(): number; */
  /// Gets or sets the length of the first segment of a link coming from this port.
  /// This value is used when the computed "from spot" is not Spot.None.
  /// The default value is 10.
  /// This value also limits how short the Link#fromShortLength may be drawn.
  ///
  /// The value of Link#fromEndSegmentLength, if not NaN, takes precedence over the value at this port
  /// when determining the route of the link.
  ///
  /// For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get fromEndSegmentLength => _i5.getProperty(
        this,
        'fromEndSegmentLength',
      );
  /* #15456
  source: 
    /**
     * Gets or sets the length of the first segment of a link coming from this port.
     * This value is used when the computed "from spot" is not Spot.None.
     * The default value is 10.
     * This value also limits how short the Link#fromShortLength may be drawn.
     *
     * The value of Link#fromEndSegmentLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/links.html#EndSegmentLengths">Link End Segment Lengths</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see Link#fromEndSegmentLength
     * @see Link#computeEndSegmentLength
     * @see #toEndSegmentLength
     * @see #portId
     */
    get fromEndSegmentLength(): number; */
  // Type InteropStaticType.number
  set fromEndSegmentLength(_i2.num value) {
    _i5.setProperty(
      this,
      'fromEndSegmentLength',
      value,
    );
  }

  /* #15486
  source: 
    /**
     * Gets or sets how far the end segment of a link coming from this port stops short of the actual port.
     * Positive values are limited by the #fromEndSegmentLength or Link#fromEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is zero.
     *
     * This property is useful when you have a thick link and a pointy arrowhead.
     * Normally the link Shape extends all the way to the end of the arrowhead.
     * If the link Shape is wide, its edges will be seen behind the arrowhead.
     * By setting this property to a small positive value, the link Shape can end within the
     * body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
     *
     * A negative value for this property can also be useful when you want the link Shape to continue
     * into the port, perhaps because a portion of the port is transparent and you want the link to
     * appear to connect visually with a different point on the node.
     *
     * The value of Link#fromShortLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toShortLength
     * @see Link#fromShortLength
     * @see #portId
     */
    get fromShortLength(): number; */
  /// Gets or sets how far the end segment of a link coming from this port stops short of the actual port.
  /// Positive values are limited by the #fromEndSegmentLength or Link#fromEndSegmentLength.
  /// Negative values cause the link to extend into the port.
  /// The default value is zero.
  ///
  /// This property is useful when you have a thick link and a pointy arrowhead.
  /// Normally the link Shape extends all the way to the end of the arrowhead.
  /// If the link Shape is wide, its edges will be seen behind the arrowhead.
  /// By setting this property to a small positive value, the link Shape can end within the
  /// body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
  ///
  /// A negative value for this property can also be useful when you want the link Shape to continue
  /// into the port, perhaps because a portion of the port is transparent and you want the link to
  /// appear to connect visually with a different point on the node.
  ///
  /// The value of Link#fromShortLength, if not NaN, takes precedence over the value at this port
  /// when determining the route of the link.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get fromShortLength => _i5.getProperty(
        this,
        'fromShortLength',
      );
  /* #15486
  source: 
    /**
     * Gets or sets how far the end segment of a link coming from this port stops short of the actual port.
     * Positive values are limited by the #fromEndSegmentLength or Link#fromEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is zero.
     *
     * This property is useful when you have a thick link and a pointy arrowhead.
     * Normally the link Shape extends all the way to the end of the arrowhead.
     * If the link Shape is wide, its edges will be seen behind the arrowhead.
     * By setting this property to a small positive value, the link Shape can end within the
     * body of the arrowhead, leaving only the point of the arrowhead visible at the end of the link.
     *
     * A negative value for this property can also be useful when you want the link Shape to continue
     * into the port, perhaps because a portion of the port is transparent and you want the link to
     * appear to connect visually with a different point on the node.
     *
     * The value of Link#fromShortLength, if not NaN, takes precedence over the value at this port
     * when determining the route of the link.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #toShortLength
     * @see Link#fromShortLength
     * @see #portId
     */
    get fromShortLength(): number; */
  // Type InteropStaticType.number
  set fromShortLength(_i2.num value) {
    _i5.setProperty(
      this,
      'fromShortLength',
      value,
    );
  }

  /* #15505
  source: 
    /**
     * Gets or sets whether the user may draw Links from this port.
     * This property is used by LinkingBaseTool#isValidFrom.
     *
     * The default value is null, which indicates that the real value is inherited from
     * the parent Panel, or false if there is no containing panel.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node,
     * or unless you are disabling the "linkability" of a particular GraphObject
     * inside a Panel whose fromLinkable has been set or bound to true.
     * @see #toLinkable
     * @see #fromMaxLinks
     * @see #portId
     * @see #cursor
     */
    get fromLinkable(): boolean | null; */
  /// Gets or sets whether the user may draw Links from this port.
  /// This property is used by LinkingBaseTool#isValidFrom.
  ///
  /// The default value is null, which indicates that the real value is inherited from
  /// the parent Panel, or false if there is no containing panel.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node,
  /// or unless you are disabling the "linkability" of a particular GraphObject
  /// inside a Panel whose fromLinkable has been set or bound to true.
  _i2.bool? get fromLinkable => _i5.getProperty(
        this,
        'fromLinkable',
      );
  /* #15505
  source: 
    /**
     * Gets or sets whether the user may draw Links from this port.
     * This property is used by LinkingBaseTool#isValidFrom.
     *
     * The default value is null, which indicates that the real value is inherited from
     * the parent Panel, or false if there is no containing panel.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node,
     * or unless you are disabling the "linkability" of a particular GraphObject
     * inside a Panel whose fromLinkable has been set or bound to true.
     * @see #toLinkable
     * @see #fromMaxLinks
     * @see #portId
     * @see #cursor
     */
    get fromLinkable(): boolean | null; */
  // Type InteropUnion#169728313(parent: InteropGetter#928322897(name: fromLinkable))
  set fromLinkable(_i2.bool? value) {
    _i5.setProperty(
      this,
      'fromLinkable',
      value ?? _i4.undefined,
    );
  }

  /* #15521
  source: 
    /**
     * Gets or sets the maximum number of links that may come out of this port.
     * This property is used by LinkingBaseTool#isValidFrom.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #toMaxLinks
     * @see #portId
     */
    get fromMaxLinks(): number; */
  /// Gets or sets the maximum number of links that may come out of this port.
  /// This property is used by LinkingBaseTool#isValidFrom.
  ///
  /// The value must be non-negative.
  /// The default value is Infinity.
  ///
  /// You must set this property on a GraphObject whose #portId is non-null,
  /// unless the whole Node is acting as a single port,
  /// in which case this property should be set on the Node.
  _i2.num get fromMaxLinks => _i5.getProperty(
        this,
        'fromMaxLinks',
      );
  /* #15521
  source: 
    /**
     * Gets or sets the maximum number of links that may come out of this port.
     * This property is used by LinkingBaseTool#isValidFrom.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     *
     * You must set this property on a GraphObject whose #portId is non-null,
     * unless the whole Node is acting as a single port,
     * in which case this property should be set on the Node.
     * @see #fromLinkable
     * @see #toMaxLinks
     * @see #portId
     */
    get fromMaxLinks(): number; */
  // Type InteropStaticType.number
  set fromMaxLinks(_i2.num value) {
    _i5.setProperty(
      this,
      'fromMaxLinks',
      value,
    );
  }

  /* #15541
  source: 
    /**********************************************************
    Event Handling:
    ***********************************************************/
    /**
     * Gets or sets the mouse cursor to use when the mouse is over this object with no mouse buttons pressed.
     * The value is null when no particular cursor is specified for this object;
     * the actual cursor is determined by any containing Panel.
     *
     * The default value is the empty string, which means the
     * current mouse cursor is determined by the Diagram.
     * Other strings should be valid CSS strings that specify a cursor.
     * This provides some more information about cursor syntax:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     *
     * Read more about cursors at Diagram#currentCursor
     * @see Diagram#defaultCursor
     * @see Diagram#currentCursor
     */
    get cursor(): string; */
  /// Gets or sets the mouse cursor to use when the mouse is over this object with no mouse buttons pressed.
  /// The value is null when no particular cursor is specified for this object;
  /// the actual cursor is determined by any containing Panel.
  ///
  /// The default value is the empty string, which means the
  /// current mouse cursor is determined by the Diagram.
  /// Other strings should be valid CSS strings that specify a cursor.
  /// This provides some more information about cursor syntax:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
  ///
  /// Read more about cursors at Diagram#currentCursor
  _i2.String get cursor => _i5.getProperty(
        this,
        'cursor',
      );
  /* #15541
  source: 
    /**********************************************************
    Event Handling:
    ***********************************************************/
    /**
     * Gets or sets the mouse cursor to use when the mouse is over this object with no mouse buttons pressed.
     * The value is null when no particular cursor is specified for this object;
     * the actual cursor is determined by any containing Panel.
     *
     * The default value is the empty string, which means the
     * current mouse cursor is determined by the Diagram.
     * Other strings should be valid CSS strings that specify a cursor.
     * This provides some more information about cursor syntax:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS cursors (mozilla.org)</a>.
     *
     * Read more about cursors at Diagram#currentCursor
     * @see Diagram#defaultCursor
     * @see Diagram#currentCursor
     */
    get cursor(): string; */
  // Type InteropStaticType.string
  set cursor(_i2.String value) {
    _i5.setProperty(
      this,
      'cursor',
      value,
    );
  }

  /* #15577
  source: 
    /**
     * Gets or sets the function to execute when the user single-primary-clicks on this object.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectSingleClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * <p class="boxrun">
     * An example of a click event handler is shown in the
     * <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     * @see #doubleClick
     * @see #contextClick
     * @see Diagram#click
     */
    get click(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user single-primary-clicks on this object.
  /// This typically involves a mouse-down followed by a prompt mouse-up
  /// at approximately the same position using the left (primary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on a GraphObject.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name `"ObjectSingleClicked"`.
  ///
  /// If this property value is a function, it is called with an InputEvent
  /// and this GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  ///
  /// From the second argument, *obj*, you can get to the Node or Link via the #part property.
  /// From there you can access the bound data via the Panel#data property.
  /// So from an event handler you can get the bound data by `obj.part.data`.
  ///
  /// By default this property is null.
  ///
  /// Objects in Layers that are Layer#isTemporary do not receive click events.
  /// If you do want such objects to respond to clicks, set #isActionable to true.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  /// <p class="boxrun">
  /// An example of a click event handler is shown in the
  /// <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get click => _i5.getProperty(
        this,
        'click',
      );
  /* #15577
  source: 
    /**
     * Gets or sets the function to execute when the user single-primary-clicks on this object.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectSingleClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * <p class="boxrun">
     * An example of a click event handler is shown in the
     * <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     * @see #doubleClick
     * @see #contextClick
     * @see Diagram#click
     */
    get click(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#540068150(parent: InteropGetter#737363622(name: click))
  set click(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'click',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15624
  source: 
    /**
     * Gets or sets the function to execute when the user double-primary-clicks on this object.
     * This typically involves a mouse-down/up/down/up in rapid succession
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectDoubleClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * The <a href="../../samples/classHierarchy.html">Class Hierarchy sample</a>
     * demonstrates the definition of a double-click event handler that opens up
     * a web page with the documentation for that class:
     * ```js
     * diagram.nodeTemplate =
     *   $(go.Node, . . .,
     *     {
     *       doubleClick:  // here the second argument is this object, which is this Node
     *         (e, node) => { window.open("../api/symbols/" + node.data.key + ".html"); }
     *     },
     *     . . .
     *     );
     * ```
     * @see #click
     * @see #contextClick
     * @see Diagram#doubleClick
     */
    get doubleClick(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user double-primary-clicks on this object.
  /// This typically involves a mouse-down/up/down/up in rapid succession
  /// at approximately the same position using the left (primary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on a GraphObject.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name `"ObjectDoubleClicked"`.
  ///
  /// If this property value is a function, it is called with an InputEvent
  /// and this GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  ///
  /// From the second argument, *obj*, you can get to the Node or Link via the #part property.
  /// From there you can access the bound data via the Panel#data property.
  /// So from an event handler you can get the bound data by `obj.part.data`.
  ///
  /// By default this property is null.
  ///
  /// Objects in Layers that are Layer#isTemporary do not receive click events.
  /// If you do want such objects to respond to clicks, set #isActionable to true.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  ///
  /// The <a href="../../samples/classHierarchy.html">Class Hierarchy sample</a>
  /// demonstrates the definition of a double-click event handler that opens up
  /// a web page with the documentation for that class:
  /// ```js
  /// diagram.nodeTemplate =
  ///   $(go.Node, . . .,
  ///     {
  ///       doubleClick:  // here the second argument is this object, which is this Node
  ///         (e, node) => { window.open("../api/symbols/" + node.data.key + ".html"); }
  ///     },
  ///     . . .
  ///     );
  /// ```
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get doubleClick => _i5.getProperty(
        this,
        'doubleClick',
      );
  /* #15624
  source: 
    /**
     * Gets or sets the function to execute when the user double-primary-clicks on this object.
     * This typically involves a mouse-down/up/down/up in rapid succession
     * at approximately the same position using the left (primary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectDoubleClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * The <a href="../../samples/classHierarchy.html">Class Hierarchy sample</a>
     * demonstrates the definition of a double-click event handler that opens up
     * a web page with the documentation for that class:
     * ```js
     * diagram.nodeTemplate =
     *   $(go.Node, . . .,
     *     {
     *       doubleClick:  // here the second argument is this object, which is this Node
     *         (e, node) => { window.open("../api/symbols/" + node.data.key + ".html"); }
     *     },
     *     . . .
     *     );
     * ```
     * @see #click
     * @see #contextClick
     * @see Diagram#doubleClick
     */
    get doubleClick(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#719447393(parent: InteropGetter#595510257(name: doubleClick))
  set doubleClick(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'doubleClick',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15657
  source: 
    /**
     * Gets or sets the function to execute when the user single-secondary-clicks on this object.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the right (secondary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectContextClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * @see #click
     * @see #doubleClick
     * @see Diagram#contextClick
     */
    get contextClick(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user single-secondary-clicks on this object.
  /// This typically involves a mouse-down followed by a prompt mouse-up
  /// at approximately the same position using the right (secondary) mouse button.
  /// This property is used by the ClickSelectingTool
  /// when the user clicks on a GraphObject.
  /// The function is called in addition to the DiagramEvent
  /// that is raised with the name `"ObjectContextClicked"`.
  ///
  /// If this property value is a function, it is called with an InputEvent
  /// and this GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  ///
  /// From the second argument, *obj*, you can get to the Node or Link via the #part property.
  /// From there you can access the bound data via the Panel#data property.
  /// So from an event handler you can get the bound data by `obj.part.data`.
  ///
  /// By default this property is null.
  ///
  /// Objects in Layers that are Layer#isTemporary do not receive click events.
  /// If you do want such objects to respond to clicks, set #isActionable to true.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get contextClick => _i5.getProperty(
        this,
        'contextClick',
      );
  /* #15657
  source: 
    /**
     * Gets or sets the function to execute when the user single-secondary-clicks on this object.
     * This typically involves a mouse-down followed by a prompt mouse-up
     * at approximately the same position using the right (secondary) mouse button.
     * This property is used by the ClickSelectingTool
     * when the user clicks on a GraphObject.
     * The function is called in addition to the DiagramEvent
     * that is raised with the name `"ObjectContextClicked"`.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     *
     * From the second argument, *obj*, you can get to the Node or Link via the #part property.
     * From there you can access the bound data via the Panel#data property.
     * So from an event handler you can get the bound data by `obj.part.data`.
     *
     * By default this property is null.
     *
     * Objects in Layers that are Layer#isTemporary do not receive click events.
     * If you do want such objects to respond to clicks, set #isActionable to true.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * @see #click
     * @see #doubleClick
     * @see Diagram#contextClick
     */
    get contextClick(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#215237781(parent: InteropGetter#1035899847(name: contextClick))
  set contextClick(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'contextClick',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15730
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * into this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject that the mouse is now in,
     * and any previous GraphObject that the mouse was in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, consider the situation where one wants to display buttons that the user can click
     * whenever the user passes the mouse over a node, and the buttons automatically disappear when the
     * mouse leaves the node.  This can be implemented by showing an Adornment holding the buttons.
     * ```js
     * var nodeContextMenu =
     *   $(go.Adornment, "Spot",
     *     { background: "transparent" },  // to help detect when the mouse leaves the area
     *     $(go.Placeholder),
     *     $(go.Panel, "Vertical",
     *       { alignment: go.Spot.Right, alignmentFocus: go.Spot.Left },
     *       $("Button",
     *         $(go.TextBlock, "Command 1"),
     *         {
     *           click: (e, obj) => {
     *             var node = obj.part.adornedPart;
     *             alert("Command 1 on " + node.data.text);
     *             node.removeAdornment("ContextMenuOver");
     *           }
     *         }),
     *       $("Button",
     *         $(go.TextBlock, "Command 2"),
     *         {
     *           click: (e, obj) => {
     *             var node = obj.part.adornedPart;
     *             alert("Command 2 on " + node.data.text);
     *             node.removeAdornment("ContextMenuOver");
     *           }
     *         })
     *       ));
     * ```
     * Then in the definition of the Node we can implement a mouseEnter event handler:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     {
     *       mouseEnter: (e, node) => {
     *         nodeContextMenu.adornedObject = node;
     *         nodeContextMenu.mouseLeave = (ev, cm) => {
     *           node.removeAdornment("ContextMenuOver");
     *         }
     *         node.addAdornment("ContextMenuOver", nodeContextMenu);
     *       }
     *     });
     * ```
     * Note how it automatically defines a #mouseLeave event handler too.
     * The context menu Adornment is removed either when the mouse leaves the area of the Adornment
     * or when the user executes a button click event handler.
     * @see #mouseLeave
     * @see #mouseOver
     * @see #mouseHover
     * @see #mouseDragEnter
     */
    get mouseEnter(): ((e: InputEvent, thisObj: GraphObject, prevObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse
  /// into this object without holding down any buttons.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent,
  /// this GraphObject that the mouse is now in,
  /// and any previous GraphObject that the mouse was in.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// By default this property is null.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  /// After calling this function the diagram will be updated immediately.
  ///
  /// For example, consider the situation where one wants to display buttons that the user can click
  /// whenever the user passes the mouse over a node, and the buttons automatically disappear when the
  /// mouse leaves the node.  This can be implemented by showing an Adornment holding the buttons.
  /// ```js
  /// var nodeContextMenu =
  ///   $(go.Adornment, "Spot",
  ///     { background: "transparent" },  // to help detect when the mouse leaves the area
  ///     $(go.Placeholder),
  ///     $(go.Panel, "Vertical",
  ///       { alignment: go.Spot.Right, alignmentFocus: go.Spot.Left },
  ///       $("Button",
  ///         $(go.TextBlock, "Command 1"),
  ///         {
  ///           click: (e, obj) => {
  ///             var node = obj.part.adornedPart;
  ///             alert("Command 1 on " + node.data.text);
  ///             node.removeAdornment("ContextMenuOver");
  ///           }
  ///         }),
  ///       $("Button",
  ///         $(go.TextBlock, "Command 2"),
  ///         {
  ///           click: (e, obj) => {
  ///             var node = obj.part.adornedPart;
  ///             alert("Command 2 on " + node.data.text);
  ///             node.removeAdornment("ContextMenuOver");
  ///           }
  ///         })
  ///       ));
  /// ```
  /// Then in the definition of the Node we can implement a mouseEnter event handler:
  /// ```js
  /// myDiagram.nodeTemplate =
  ///   $(go.Node,
  ///     . . .
  ///     {
  ///       mouseEnter: (e, node) => {
  ///         nodeContextMenu.adornedObject = node;
  ///         nodeContextMenu.mouseLeave = (ev, cm) => {
  ///           node.removeAdornment("ContextMenuOver");
  ///         }
  ///         node.addAdornment("ContextMenuOver", nodeContextMenu);
  ///       }
  ///     });
  /// ```
  /// Note how it automatically defines a #mouseLeave event handler too.
  /// The context menu Adornment is removed either when the mouse leaves the area of the Adornment
  /// or when the user executes a button click event handler.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
    _i3.GraphObject,
  )? get mouseEnter => _i5.getProperty(
        this,
        'mouseEnter',
      );
  /* #15730
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * into this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject that the mouse is now in,
     * and any previous GraphObject that the mouse was in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, consider the situation where one wants to display buttons that the user can click
     * whenever the user passes the mouse over a node, and the buttons automatically disappear when the
     * mouse leaves the node.  This can be implemented by showing an Adornment holding the buttons.
     * ```js
     * var nodeContextMenu =
     *   $(go.Adornment, "Spot",
     *     { background: "transparent" },  // to help detect when the mouse leaves the area
     *     $(go.Placeholder),
     *     $(go.Panel, "Vertical",
     *       { alignment: go.Spot.Right, alignmentFocus: go.Spot.Left },
     *       $("Button",
     *         $(go.TextBlock, "Command 1"),
     *         {
     *           click: (e, obj) => {
     *             var node = obj.part.adornedPart;
     *             alert("Command 1 on " + node.data.text);
     *             node.removeAdornment("ContextMenuOver");
     *           }
     *         }),
     *       $("Button",
     *         $(go.TextBlock, "Command 2"),
     *         {
     *           click: (e, obj) => {
     *             var node = obj.part.adornedPart;
     *             alert("Command 2 on " + node.data.text);
     *             node.removeAdornment("ContextMenuOver");
     *           }
     *         })
     *       ));
     * ```
     * Then in the definition of the Node we can implement a mouseEnter event handler:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     {
     *       mouseEnter: (e, node) => {
     *         nodeContextMenu.adornedObject = node;
     *         nodeContextMenu.mouseLeave = (ev, cm) => {
     *           node.removeAdornment("ContextMenuOver");
     *         }
     *         node.addAdornment("ContextMenuOver", nodeContextMenu);
     *       }
     *     });
     * ```
     * Note how it automatically defines a #mouseLeave event handler too.
     * The context menu Adornment is removed either when the mouse leaves the area of the Adornment
     * or when the user executes a button click event handler.
     * @see #mouseLeave
     * @see #mouseOver
     * @see #mouseHover
     * @see #mouseDragEnter
     */
    get mouseEnter(): ((e: InputEvent, thisObj: GraphObject, prevObj: GraphObject) => void) | null; */
  // Type InteropUnion#672834634(parent: InteropGetter#997445310(name: mouseEnter))
  set mouseEnter(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseEnter',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15772
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * out of this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject that the mouse has left,
     * and any next GraphObject that the mouse is now in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, the <a href="../../samples/flowchart.html">Flow Chart sample</a>
     * automatically shows and hides the ports as the mouse passes over a node.
     * The node template includes the following settings:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     {
     *       . . .
     *       // handle mouse enter/leave events to show/hide the ports
     *       mouseEnter: (e, obj) => showPorts(obj.part, true),
     *       mouseLeave: (e, obj) => showPorts(obj.part, false)
     *       . . .
     *     });
     * ```
     * where the `showPorts` function is defined to set the #visible
     * property of each of the port elements of the node.
     * @see #mouseEnter
     * @see #mouseOver
     * @see #mouseHover
     * @see #mouseDragLeave
     */
    get mouseLeave(): ((e: InputEvent, thisObj: GraphObject, nextObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse
  /// out of this object without holding down any buttons.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent,
  /// this GraphObject that the mouse has left,
  /// and any next GraphObject that the mouse is now in.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// By default this property is null.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  /// After calling this function the diagram will be updated immediately.
  ///
  /// For example, the <a href="../../samples/flowchart.html">Flow Chart sample</a>
  /// automatically shows and hides the ports as the mouse passes over a node.
  /// The node template includes the following settings:
  /// ```js
  /// myDiagram.nodeTemplate =
  ///   $(go.Node,
  ///     . . .
  ///     {
  ///       . . .
  ///       // handle mouse enter/leave events to show/hide the ports
  ///       mouseEnter: (e, obj) => showPorts(obj.part, true),
  ///       mouseLeave: (e, obj) => showPorts(obj.part, false)
  ///       . . .
  ///     });
  /// ```
  /// where the `showPorts` function is defined to set the #visible
  /// property of each of the port elements of the node.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
    _i3.GraphObject,
  )? get mouseLeave => _i5.getProperty(
        this,
        'mouseLeave',
      );
  /* #15772
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * out of this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject that the mouse has left,
     * and any next GraphObject that the mouse is now in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     *
     * For example, the <a href="../../samples/flowchart.html">Flow Chart sample</a>
     * automatically shows and hides the ports as the mouse passes over a node.
     * The node template includes the following settings:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     {
     *       . . .
     *       // handle mouse enter/leave events to show/hide the ports
     *       mouseEnter: (e, obj) => showPorts(obj.part, true),
     *       mouseLeave: (e, obj) => showPorts(obj.part, false)
     *       . . .
     *     });
     * ```
     * where the `showPorts` function is defined to set the #visible
     * property of each of the port elements of the node.
     * @see #mouseEnter
     * @see #mouseOver
     * @see #mouseHover
     * @see #mouseDragLeave
     */
    get mouseLeave(): ((e: InputEvent, thisObj: GraphObject, nextObj: GraphObject) => void) | null; */
  // Type InteropUnion#1045147027(parent: InteropGetter#442276989(name: mouseLeave))
  set mouseLeave(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseLeave',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15796
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * over this object without holding down any buttons.
     * This property is used by the ToolManager.
     * This property is infrequently used -- it is more common to implement #mouseEnter
     * and #mouseLeave functions.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     * @see #mouseHover
     * @see #mouseEnter
     * @see #mouseLeave
     */
    get mouseOver(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse
  /// over this object without holding down any buttons.
  /// This property is used by the ToolManager.
  /// This property is infrequently used -- it is more common to implement #mouseEnter
  /// and #mouseLeave functions.
  ///
  /// If this property value is a function, it is called with an InputEvent
  /// and this GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// By default this property is null.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  /// After calling this function the diagram will be updated immediately.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get mouseOver => _i5.getProperty(
        this,
        'mouseOver',
      );
  /* #15796
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * over this object without holding down any buttons.
     * This property is used by the ToolManager.
     * This property is infrequently used -- it is more common to implement #mouseEnter
     * and #mouseLeave functions.
     *
     * If this property value is a function, it is called with an InputEvent
     * and this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * After calling this function the diagram will be updated immediately.
     * @see #mouseHover
     * @see #mouseEnter
     * @see #mouseLeave
     */
    get mouseOver(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#1009274617(parent: InteropGetter#703165119(name: mouseOver))
  set mouseOver(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseOver',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15825
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse still for a while
     * over this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * You can control how long the user must wait with a motionless mouse before
     * a "mouse hover" event occurs, by setting ToolManager#hoverDelay.
     * For example:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
     * ```
     * @see #mouseOver
     * @see #mouseEnter
     * @see #mouseLeave
     */
    get mouseHover(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user holds the mouse still for a while
  /// over this object without holding down any buttons.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  ///
  /// You can control how long the user must wait with a motionless mouse before
  /// a "mouse hover" event occurs, by setting ToolManager#hoverDelay.
  /// For example:
  /// ```js
  /// myDiagram = new go.Diagram("myDiagramDiv",
  ///     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
  /// ```
  /// or:
  /// ```js
  /// myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
  /// ```
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get mouseHover => _i5.getProperty(
        this,
        'mouseHover',
      );
  /* #15825
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse still for a while
     * over this object without holding down any buttons.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * You can control how long the user must wait with a motionless mouse before
     * a "mouse hover" event occurs, by setting ToolManager#hoverDelay.
     * For example:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
     * ```
     * @see #mouseOver
     * @see #mouseEnter
     * @see #mouseLeave
     */
    get mouseHover(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#915690418(parent: InteropGetter#330348296(name: mouseHover))
  set mouseHover(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseHover',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15854
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse still for a while
     * over this object while holding down a button.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * You can control how long the user must wait during a drag with a motionless mouse before
     * a "mouse hold" event occurs, by setting ToolManager#holdDelay.
     * For example:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.holdDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.holdDelay = 500;  // 500 milliseconds
     * ```
     * @see #mouseDragEnter
     * @see #mouseDragLeave
     * @see #mouseHover
     */
    get mouseHold(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user holds the mouse still for a while
  /// over this object while holding down a button.
  /// This property is used by the ToolManager.
  ///
  /// If this property value is a function, it is called with an InputEvent.
  /// By default this property is null.
  ///
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  ///
  /// You can control how long the user must wait during a drag with a motionless mouse before
  /// a "mouse hold" event occurs, by setting ToolManager#holdDelay.
  /// For example:
  /// ```js
  /// myDiagram = new go.Diagram("myDiagramDiv",
  ///     { "toolManager.holdDelay": 500 });  // 500 milliseconds
  /// ```
  /// or:
  /// ```js
  /// myDiagram.toolManager.holdDelay = 500;  // 500 milliseconds
  /// ```
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get mouseHold => _i5.getProperty(
        this,
        'mouseHold',
      );
  /* #15854
  source: 
    /**
     * Gets or sets the function to execute when the user holds the mouse still for a while
     * over this object while holding down a button.
     * This property is used by the ToolManager.
     *
     * If this property value is a function, it is called with an InputEvent.
     * By default this property is null.
     *
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     *
     * You can control how long the user must wait during a drag with a motionless mouse before
     * a "mouse hold" event occurs, by setting ToolManager#holdDelay.
     * For example:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.holdDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.holdDelay = 500;  // 500 milliseconds
     * ```
     * @see #mouseDragEnter
     * @see #mouseDragLeave
     * @see #mouseHover
     */
    get mouseHold(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#828266877(parent: InteropGetter#120060849(name: mouseHold))
  set mouseHold(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseHold',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15886
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * into this stationary object during a DraggingTool drag;
     * this allows you to provide feedback during a drag based on where it might drop.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject, and any previous GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function,
     * because the DraggingTool will be conducting one already.
     * After calling this function the diagram will be updated immediately.
     *
     * For an example of a mouseDragEnter event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragLeave
     * @see #mouseHold
     * @see #mouseDrop
     * @see #mouseEnter
     * @see Group#handlesDragDropForMembers
     */
    get mouseDragEnter(): ((e: InputEvent, thisObj: GraphObject, prevObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse
  /// into this stationary object during a DraggingTool drag;
  /// this allows you to provide feedback during a drag based on where it might drop.
  ///
  /// If this property value is a function, it is called with an InputEvent,
  /// this GraphObject, and any previous GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// By default this property is null.
  ///
  /// Note that for a drag-and-drop that originates in a different diagram, the target diagram's
  /// selection collection will not be the parts that are being dragged.
  /// Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function,
  /// because the DraggingTool will be conducting one already.
  /// After calling this function the diagram will be updated immediately.
  ///
  /// For an example of a mouseDragEnter event handler, see the node template in the
  /// <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
    _i3.GraphObject,
  )? get mouseDragEnter => _i5.getProperty(
        this,
        'mouseDragEnter',
      );
  /* #15886
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * into this stationary object during a DraggingTool drag;
     * this allows you to provide feedback during a drag based on where it might drop.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject, and any previous GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function,
     * because the DraggingTool will be conducting one already.
     * After calling this function the diagram will be updated immediately.
     *
     * For an example of a mouseDragEnter event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragLeave
     * @see #mouseHold
     * @see #mouseDrop
     * @see #mouseEnter
     * @see Group#handlesDragDropForMembers
     */
    get mouseDragEnter(): ((e: InputEvent, thisObj: GraphObject, prevObj: GraphObject) => void) | null; */
  // Type InteropUnion#942167933(parent: InteropGetter#292845258(name: mouseDragEnter))
  set mouseDragEnter(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseDragEnter',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15918
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * out of this stationary object during a DraggingTool drag;
     * this allows you to provide feedback during a drag based on where it might drop.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject, and any new GraphObject that the mouse is in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function,
     * because the DraggingTool will be conducting one already.
     * After calling this function the diagram will be updated immediately.
     *
     * For an example of a mouseDragLeave event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragEnter
     * @see #mouseHold
     * @see #mouseDrop
     * @see #mouseLeave
     * @see Group#handlesDragDropForMembers
     */
    get mouseDragLeave(): ((e: InputEvent, thisObj: GraphObject, nextObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the user moves the mouse
  /// out of this stationary object during a DraggingTool drag;
  /// this allows you to provide feedback during a drag based on where it might drop.
  ///
  /// If this property value is a function, it is called with an InputEvent,
  /// this GraphObject, and any new GraphObject that the mouse is in.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// By default this property is null.
  ///
  /// Note that for a drag-and-drop that originates in a different diagram, the target diagram's
  /// selection collection will not be the parts that are being dragged.
  /// Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function,
  /// because the DraggingTool will be conducting one already.
  /// After calling this function the diagram will be updated immediately.
  ///
  /// For an example of a mouseDragLeave event handler, see the node template in the
  /// <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
    _i3.GraphObject,
  )? get mouseDragLeave => _i5.getProperty(
        this,
        'mouseDragLeave',
      );
  /* #15918
  source: 
    /**
     * Gets or sets the function to execute when the user moves the mouse
     * out of this stationary object during a DraggingTool drag;
     * this allows you to provide feedback during a drag based on where it might drop.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject, and any new GraphObject that the mouse is in.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * By default this property is null.
     *
     * Note that for a drag-and-drop that originates in a different diagram, the target diagram's
     * selection collection will not be the parts that are being dragged.
     * Instead the temporary parts being dragged can be found as the source diagram's DraggingTool#copiedParts.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function,
     * because the DraggingTool will be conducting one already.
     * After calling this function the diagram will be updated immediately.
     *
     * For an example of a mouseDragLeave event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragEnter
     * @see #mouseHold
     * @see #mouseDrop
     * @see #mouseLeave
     * @see Group#handlesDragDropForMembers
     */
    get mouseDragLeave(): ((e: InputEvent, thisObj: GraphObject, nextObj: GraphObject) => void) | null; */
  // Type InteropUnion#195515847(parent: InteropGetter#622881440(name: mouseDragLeave))
  set mouseDragLeave(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseDragLeave',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15941
  source: 
    /**
     * Gets or sets the function to execute when a user drops the selection on this object
     * at the end of a DraggingTool drag;
     * this allows you to customize the behavior when a drop occurs on an object.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * The function is called within the transaction performed by the DraggingTool,
     * so you do not need to conduct one.
     * By default this property is null.
     *
     * For an example of a mouseDrop event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragEnter
     * @see #mouseDragLeave
     * @see #mouseHold
     * @see Group#handlesDragDropForMembers
     */
    get mouseDrop(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when a user drops the selection on this object
  /// at the end of a DraggingTool drag;
  /// this allows you to customize the behavior when a drop occurs on an object.
  ///
  /// If this property value is a function, it is called with an InputEvent,
  /// this GraphObject.
  /// The InputEvent#targetObject provides the GraphObject that was found
  /// at the mouse point before looking up the visual tree of GraphObject#panels
  /// to get to this object.
  /// The function is called within the transaction performed by the DraggingTool,
  /// so you do not need to conduct one.
  /// By default this property is null.
  ///
  /// For an example of a mouseDrop event handler, see the node template in the
  /// <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get mouseDrop => _i5.getProperty(
        this,
        'mouseDrop',
      );
  /* #15941
  source: 
    /**
     * Gets or sets the function to execute when a user drops the selection on this object
     * at the end of a DraggingTool drag;
     * this allows you to customize the behavior when a drop occurs on an object.
     *
     * If this property value is a function, it is called with an InputEvent,
     * this GraphObject.
     * The InputEvent#targetObject provides the GraphObject that was found
     * at the mouse point before looking up the visual tree of GraphObject#panels
     * to get to this object.
     * The function is called within the transaction performed by the DraggingTool,
     * so you do not need to conduct one.
     * By default this property is null.
     *
     * For an example of a mouseDrop event handler, see the node template in the
     * <a href="../../samples/orgChartEditor.html">Org Chart Editor sample</a>.
     * @see #mouseDragEnter
     * @see #mouseDragLeave
     * @see #mouseHold
     * @see Group#handlesDragDropForMembers
     */
    get mouseDrop(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#219932641(parent: InteropGetter#944233324(name: mouseDrop))
  set mouseDrop(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'mouseDrop',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15958
  source: 
    /**
     * Gets or sets the function to execute on a mouse-down event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionMove
     * @see #actionUp
     * @see #actionCancel
     */
    get actionDown(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute on a mouse-down event when this GraphObject's #isActionable
  /// is set to true.
  /// This property is infrequently set.
  /// By default this property is null.
  ///
  /// This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
  /// in conjunction with ActionTool, pre-empting the normal tool mechanisms.
  ///
  /// The ActionTool does not conduct any transaction, so if this property has a value,
  /// the function will not be called within a transaction.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get actionDown => _i5.getProperty(
        this,
        'actionDown',
      );
  /* #15958
  source: 
    /**
     * Gets or sets the function to execute on a mouse-down event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionMove
     * @see #actionUp
     * @see #actionCancel
     */
    get actionDown(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#902030760(parent: InteropGetter#57332991(name: actionDown))
  set actionDown(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'actionDown',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15975
  source: 
    /**
     * Gets or sets the function to execute on a mouse-move event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionDown
     * @see #actionUp
     * @see #actionCancel
     */
    get actionMove(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute on a mouse-move event when this GraphObject's #isActionable
  /// is set to true.
  /// This property is infrequently set.
  /// By default this property is null.
  ///
  /// This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
  /// in conjunction with ActionTool, pre-empting the normal tool mechanisms.
  ///
  /// The ActionTool does not conduct any transaction, so if this property has a value,
  /// the function will not be called within a transaction.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get actionMove => _i5.getProperty(
        this,
        'actionMove',
      );
  /* #15975
  source: 
    /**
     * Gets or sets the function to execute on a mouse-move event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionDown
     * @see #actionUp
     * @see #actionCancel
     */
    get actionMove(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#631282729(parent: InteropGetter#773311953(name: actionMove))
  set actionMove(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'actionMove',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #15995
  source: 
    /**
     * Gets or sets the function to execute on a mouse-up event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * @see #actionDown
     * @see #actionMove
     * @see #actionCancel
     */
    get actionUp(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute on a mouse-up event when this GraphObject's #isActionable
  /// is set to true.
  /// This property is infrequently set.
  /// By default this property is null.
  ///
  /// This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
  /// in conjunction with ActionTool, pre-empting the normal tool mechanisms.
  ///
  /// The ActionTool does not conduct any transaction, so if this property has a value,
  /// the function will not be called within a transaction.
  /// If you do provide a function that makes changes to the diagram or to its model,
  /// you should do so within a transaction -- call Diagram#startTransaction and
  /// Diagram#commitTransaction.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get actionUp => _i5.getProperty(
        this,
        'actionUp',
      );
  /* #15995
  source: 
    /**
     * Gets or sets the function to execute on a mouse-up event when this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * If you do provide a function that makes changes to the diagram or to its model,
     * you should do so within a transaction -- call Diagram#startTransaction and
     * Diagram#commitTransaction.
     * @see #actionDown
     * @see #actionMove
     * @see #actionCancel
     */
    get actionUp(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#337153235(parent: InteropGetter#645779710(name: actionUp))
  set actionUp(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'actionUp',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #16012
  source: 
    /**
     * Gets or sets the function to execute when the ActionTool is cancelled and this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionDown
     * @see #actionMove
     * @see #actionUp
     */
    get actionCancel(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  /// Gets or sets the function to execute when the ActionTool is cancelled and this GraphObject's #isActionable
  /// is set to true.
  /// This property is infrequently set.
  /// By default this property is null.
  ///
  /// This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
  /// in conjunction with ActionTool, pre-empting the normal tool mechanisms.
  ///
  /// The ActionTool does not conduct any transaction, so if this property has a value,
  /// the function will not be called within a transaction.
  void Function(
    _i3.InputEvent,
    _i3.GraphObject,
  )? get actionCancel => _i5.getProperty(
        this,
        'actionCancel',
      );
  /* #16012
  source: 
    /**
     * Gets or sets the function to execute when the ActionTool is cancelled and this GraphObject's #isActionable
     * is set to true.
     * This property is infrequently set.
     * By default this property is null.
     *
     * This functional property is only set on objects such as buttons, knobs, or sliders that want to handle all events,
     * in conjunction with ActionTool, pre-empting the normal tool mechanisms.
     *
     * The ActionTool does not conduct any transaction, so if this property has a value,
     * the function will not be called within a transaction.
     * @see #actionDown
     * @see #actionMove
     * @see #actionUp
     */
    get actionCancel(): ((e: InputEvent, thisObj: GraphObject) => void) | null; */
  // Type InteropUnion#1019151901(parent: InteropGetter#267832914(name: actionCancel))
  set actionCancel(
      void Function(
        _i3.InputEvent,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'actionCancel',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #16058
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the mouse hovers over this object.
     * The default value is null, which means no tooltip is shown.
     *
     * A typical tooltip is defined in the following manner, as taken from
     * the <a href="../../samples/kittenMonitor.html">Kitten Monitor sample</a>:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     { // this tooltip shows the name and picture of the kitten
     *       toolTip:
     *         $("ToolTip",
     *           $(go.Panel, "Vertical",
     *             $(go.Picture,
     *               new go.Binding("source", "src", s => return "images/" + s + ".png")),
     *             $(go.TextBlock, { margin: 3 },
     *               new go.Binding("text", "key"))))
     *     });
     * ```
     * Note that this Adornment depends on having the same data binding as the adorned Part
     * (i.e. the same value for Panel#data).
     *
     * Tooltips are not copied by #copy, so that tooltips may be shared by all instances of a template.
     *
     * Tooltips are shown after a timed delay given by the ToolManager#hoverDelay.
     * You can change the delay time by:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
     * ```
     *
     * Tooltips are normally positioned by ToolManager#positionToolTip.
     * However, if there is a Placeholder in the tooltip, the tooltip (i.e. an Adornment)
     * will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
     *
     * Replacing this value will not modify or remove any existing tooltip that is being shown for this object.
     *
     * Read more about tooltips at <a href="../../intro/toolTips.html">ToolTips</a>.
     */
    get toolTip(): Adornment | HTMLInfo | null; */
  /// This Adornment or HTMLInfo is shown when the mouse hovers over this object.
  /// The default value is null, which means no tooltip is shown.
  ///
  /// A typical tooltip is defined in the following manner, as taken from
  /// the <a href="../../samples/kittenMonitor.html">Kitten Monitor sample</a>:
  /// ```js
  /// myDiagram.nodeTemplate =
  ///   $(go.Node,
  ///     . . .
  ///     { // this tooltip shows the name and picture of the kitten
  ///       toolTip:
  ///         $("ToolTip",
  ///           $(go.Panel, "Vertical",
  ///             $(go.Picture,
  ///               new go.Binding("source", "src", s => return "images/" + s + ".png")),
  ///             $(go.TextBlock, { margin: 3 },
  ///               new go.Binding("text", "key"))))
  ///     });
  /// ```
  /// Note that this Adornment depends on having the same data binding as the adorned Part
  /// (i.e. the same value for Panel#data).
  ///
  /// Tooltips are not copied by #copy, so that tooltips may be shared by all instances of a template.
  ///
  /// Tooltips are shown after a timed delay given by the ToolManager#hoverDelay.
  /// You can change the delay time by:
  /// ```js
  /// myDiagram = new go.Diagram("myDiagramDiv",
  ///     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
  /// ```
  /// or:
  /// ```js
  /// myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
  /// ```
  ///
  /// Tooltips are normally positioned by ToolManager#positionToolTip.
  /// However, if there is a Placeholder in the tooltip, the tooltip (i.e. an Adornment)
  /// will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
  ///
  /// Replacing this value will not modify or remove any existing tooltip that is being shown for this object.
  ///
  /// Read more about tooltips at <a href="../../intro/toolTips.html">ToolTips</a>.
  _i2.dynamic get toolTip => _i5.getProperty(
        this,
        'toolTip',
      );
  /* #16058
  source: 
    /**
     * This Adornment or HTMLInfo is shown when the mouse hovers over this object.
     * The default value is null, which means no tooltip is shown.
     *
     * A typical tooltip is defined in the following manner, as taken from
     * the <a href="../../samples/kittenMonitor.html">Kitten Monitor sample</a>:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node,
     *     . . .
     *     { // this tooltip shows the name and picture of the kitten
     *       toolTip:
     *         $("ToolTip",
     *           $(go.Panel, "Vertical",
     *             $(go.Picture,
     *               new go.Binding("source", "src", s => return "images/" + s + ".png")),
     *             $(go.TextBlock, { margin: 3 },
     *               new go.Binding("text", "key"))))
     *     });
     * ```
     * Note that this Adornment depends on having the same data binding as the adorned Part
     * (i.e. the same value for Panel#data).
     *
     * Tooltips are not copied by #copy, so that tooltips may be shared by all instances of a template.
     *
     * Tooltips are shown after a timed delay given by the ToolManager#hoverDelay.
     * You can change the delay time by:
     * ```js
     * myDiagram = new go.Diagram("myDiagramDiv",
     *     { "toolManager.hoverDelay": 500 });  // 500 milliseconds
     * ```
     * or:
     * ```js
     * myDiagram.toolManager.hoverDelay = 500;  // 500 milliseconds
     * ```
     *
     * Tooltips are normally positioned by ToolManager#positionToolTip.
     * However, if there is a Placeholder in the tooltip, the tooltip (i.e. an Adornment)
     * will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
     *
     * Replacing this value will not modify or remove any existing tooltip that is being shown for this object.
     *
     * Read more about tooltips at <a href="../../intro/toolTips.html">ToolTips</a>.
     */
    get toolTip(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#648208906(parent: InteropGetter#102818548(name: toolTip))
  set toolTip(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'toolTip',
      value ?? _i4.undefined,
    );
  }

  /* #16111
  source: 
    /**
     * This Adornment or HTMLInfo is shown upon a context click on this object.
     * The default value is null, which means no context menu is shown.
     *
     * Changing this value will not modify or remove any existing menu that is being shown for this object.
     *
     * Context menus may also depend on having the same data binding as the adorned Part
     * (i.e. the same value for Panel#data).
     *
     * Context menus are not copied by #copy, so that context menus may be shared by all instances of a template.
     *
     * A typical context menu is implemented as an Adornment with several buttons in it.
     * For example, this context menu is defined in the
     * <a href="../../samples/dynamicPorts.html">Dynamic Port sample</a>:
     * ```js
     * var nodeMenu =  // context menu for each Node
     *  $("ContextMenu",
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add top port"),
     *       { click: (e, obj) => addPort("top") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add left port"),
     *       { click: (e, obj) => addPort("left") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add right port"),
     *       { click: (e, obj) => addPort("right") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add bottom port"),
     *       { click: (e, obj) => addPort("bottom") }));
     * ```
     * and is used in the node template:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node, "Table",
     *     { . . .
     *       contextMenu: nodeMenu
     *     },
     *     . . .);
     * ```
     *
     * Context menus are normally positioned by ContextMenuTool#positionContextMenu.
     * However, if there is a Placeholder in the context menu, the context menu (i.e. an Adornment)
     * will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
     *
     * The <a href="../../samples/basic.html">Basic sample</a> also shows how
     * to make context menu items invisible when the command is disabled.
     *
     * Replacing this value will not modify or remove any existing context menu that is being shown for this object.
     *
     * Read more about context menus at <a href="../../intro/contextMenus.html">Context Menus</a>.
     */
    get contextMenu(): Adornment | HTMLInfo | null; */
  /// This Adornment or HTMLInfo is shown upon a context click on this object.
  /// The default value is null, which means no context menu is shown.
  ///
  /// Changing this value will not modify or remove any existing menu that is being shown for this object.
  ///
  /// Context menus may also depend on having the same data binding as the adorned Part
  /// (i.e. the same value for Panel#data).
  ///
  /// Context menus are not copied by #copy, so that context menus may be shared by all instances of a template.
  ///
  /// A typical context menu is implemented as an Adornment with several buttons in it.
  /// For example, this context menu is defined in the
  /// <a href="../../samples/dynamicPorts.html">Dynamic Port sample</a>:
  /// ```js
  /// var nodeMenu =  // context menu for each Node
  ///  $("ContextMenu",
  ///     $("ContextMenuButton",
  ///       $(go.TextBlock, "Add top port"),
  ///       { click: (e, obj) => addPort("top") }),
  ///     $("ContextMenuButton",
  ///       $(go.TextBlock, "Add left port"),
  ///       { click: (e, obj) => addPort("left") }),
  ///     $("ContextMenuButton",
  ///       $(go.TextBlock, "Add right port"),
  ///       { click: (e, obj) => addPort("right") }),
  ///     $("ContextMenuButton",
  ///       $(go.TextBlock, "Add bottom port"),
  ///       { click: (e, obj) => addPort("bottom") }));
  /// ```
  /// and is used in the node template:
  /// ```js
  /// myDiagram.nodeTemplate =
  ///   $(go.Node, "Table",
  ///     { . . .
  ///       contextMenu: nodeMenu
  ///     },
  ///     . . .);
  /// ```
  ///
  /// Context menus are normally positioned by ContextMenuTool#positionContextMenu.
  /// However, if there is a Placeholder in the context menu, the context menu (i.e. an Adornment)
  /// will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
  ///
  /// The <a href="../../samples/basic.html">Basic sample</a> also shows how
  /// to make context menu items invisible when the command is disabled.
  ///
  /// Replacing this value will not modify or remove any existing context menu that is being shown for this object.
  ///
  /// Read more about context menus at <a href="../../intro/contextMenus.html">Context Menus</a>.
  _i2.dynamic get contextMenu => _i5.getProperty(
        this,
        'contextMenu',
      );
  /* #16111
  source: 
    /**
     * This Adornment or HTMLInfo is shown upon a context click on this object.
     * The default value is null, which means no context menu is shown.
     *
     * Changing this value will not modify or remove any existing menu that is being shown for this object.
     *
     * Context menus may also depend on having the same data binding as the adorned Part
     * (i.e. the same value for Panel#data).
     *
     * Context menus are not copied by #copy, so that context menus may be shared by all instances of a template.
     *
     * A typical context menu is implemented as an Adornment with several buttons in it.
     * For example, this context menu is defined in the
     * <a href="../../samples/dynamicPorts.html">Dynamic Port sample</a>:
     * ```js
     * var nodeMenu =  // context menu for each Node
     *  $("ContextMenu",
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add top port"),
     *       { click: (e, obj) => addPort("top") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add left port"),
     *       { click: (e, obj) => addPort("left") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add right port"),
     *       { click: (e, obj) => addPort("right") }),
     *     $("ContextMenuButton",
     *       $(go.TextBlock, "Add bottom port"),
     *       { click: (e, obj) => addPort("bottom") }));
     * ```
     * and is used in the node template:
     * ```js
     * myDiagram.nodeTemplate =
     *   $(go.Node, "Table",
     *     { . . .
     *       contextMenu: nodeMenu
     *     },
     *     . . .);
     * ```
     *
     * Context menus are normally positioned by ContextMenuTool#positionContextMenu.
     * However, if there is a Placeholder in the context menu, the context menu (i.e. an Adornment)
     * will be positioned so that the Placeholder is at the same position as this adorned GraphObject.
     *
     * The <a href="../../samples/basic.html">Basic sample</a> also shows how
     * to make context menu items invisible when the command is disabled.
     *
     * Replacing this value will not modify or remove any existing context menu that is being shown for this object.
     *
     * Read more about context menus at <a href="../../intro/contextMenus.html">Context Menus</a>.
     */
    get contextMenu(): Adornment | HTMLInfo | null; */
  // Type InteropUnion#392726169(parent: InteropGetter#549523408(name: contextMenu))
  set contextMenu(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'contextMenu',
      value ?? _i4.undefined,
    );
  }

  void cloneProtected(_i3.GraphObject copy) {
    _i5.callMethod(
      this,
      'cloneProtected',
      [copy],
    );
  }

  _i3.GraphObject copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i3.Point getDocumentPoint(
    _i2.Object local, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'getDocumentPoint',
        [
          local,
          result ?? _i4.undefined,
        ],
      );
  _i3.Rect getDocumentBounds([_i3.Rect? result]) => _i5.callMethod(
        this,
        'getDocumentBounds',
        [result ?? _i4.undefined],
      );
  _i2.num getDocumentAngle() => _i5.callMethod(
        this,
        'getDocumentAngle',
        [],
      );
  _i2.num getDocumentScale() => _i5.callMethod(
        this,
        'getDocumentScale',
        [],
      );
  _i3.Point getLocalPoint(
    _i3.Point p, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'getLocalPoint',
        [
          p,
          result ?? _i4.undefined,
        ],
      );
  _i2.bool isContainedBy(_i3.GraphObject panel) => _i5.callMethod(
        this,
        'isContainedBy',
        [panel],
      );
  _i2.bool isVisibleObject() => _i5.callMethod(
        this,
        'isVisibleObject',
        [],
      );
  _i2.bool isEnabledObject() => _i5.callMethod(
        this,
        'isEnabledObject',
        [],
      );
  _i3.GraphObject _bind$1(_i3.Binding binding) => _i5.callMethod(
        this,
        'bind',
        [binding],
      );
  _i3.GraphObject _bind$2([
    _i2.String? targetprop,
    _i2.String? sourceprop,
    _i3.TargetConversion? conv,
    _i3.BackConversion? backconv,
  ]) =>
      _i5.callMethod(
        this,
        'bind',
        [
          targetprop ?? _i4.undefined,
          sourceprop ?? _i4.undefined,
          conv == null ? _i4.undefined : _i5.allowInterop(conv),
          backconv == null ? _i4.undefined : _i5.allowInterop(backconv),
        ],
      );
  // HEYA bind
  ({
    _i3.GraphObject Function(_i3.Binding binding) $1,
    _i3.GraphObject Function([
      _i2.String? targetprop,
      _i2.String? sourceprop,
      _i3.TargetConversion? conv,
      _i3.BackConversion? backconv,
    ]) $2,
  }) get bind => (
        $1: _bind$1,
        $2: _bind$2,
      );
  _i3.GraphObject set(_i4.Partial config) => _i5.callMethod(
        this,
        'set',
        [config],
      );
  _i3.GraphObject attach(_i2.dynamic config) => _i5.callMethod(
        this,
        'attach',
        [config],
      );
  _i3.GraphObject apply(void Function(_i3.GraphObject) func) => _i5.callMethod(
        this,
        'apply',
        [_i5.allowInterop(func)],
      );
  _i3.GraphObject setProperties(_i2.Object props) => _i5.callMethod(
        this,
        'setProperties',
        [props],
      );
  _i3.Panel? findTemplateBinder() => _i5.callMethod(
        this,
        'findTemplateBinder',
        [],
      );
  _i3.Panel? findBindingPanel() => _i5.callMethod(
        this,
        'findBindingPanel',
        [],
      );
  _i3.GraphObject trigger(_i3.AnimationTrigger trigger) => _i5.callMethod(
        this,
        'trigger',
        [trigger],
      );
}

@_i1.JS()
@_i1.staticInterop
class SGradient {
  factory SGradient(_i2.String aType) => _i5.callConstructor(
        _declaredSGradient,
        [aType],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('SGradient')
external _i2.Object _declaredSGradient;

@_i1.JS()
@_i1.staticInterop
class Brush {
  factory Brush([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredBrush,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  /* #16758
  source: 
    /**
     * For simple, solid color brushes, used as the value for Brush#type.
     * @constant
     */
    static Solid: EnumValue; */
  /// For simple, solid color brushes, used as the value for Brush#type.
  static _i3.EnumValue get solid => _i5.getProperty(
        _declaredBrush,
        'Solid',
      );
  /* #16758
  source: 
    /**
     * For simple, solid color brushes, used as the value for Brush#type.
     * @constant
     */
    static Solid: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set solid(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'Solid',
      value,
    );
  }

  /* #16763
  source: 
    /**
     * For linear gradient brushes, used as the value for Brush#type.
     * @constant
     */
    static Linear: EnumValue; */
  /// For linear gradient brushes, used as the value for Brush#type.
  static _i3.EnumValue get linear => _i5.getProperty(
        _declaredBrush,
        'Linear',
      );
  /* #16763
  source: 
    /**
     * For linear gradient brushes, used as the value for Brush#type.
     * @constant
     */
    static Linear: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set linear(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'Linear',
      value,
    );
  }

  /* #16768
  source: 
    /**
     * For radial gradient brushes, used as the value for Brush#type.
     * @constant
     */
    static Radial: EnumValue; */
  /// For radial gradient brushes, used as the value for Brush#type.
  static _i3.EnumValue get radial => _i5.getProperty(
        _declaredBrush,
        'Radial',
      );
  /* #16768
  source: 
    /**
     * For radial gradient brushes, used as the value for Brush#type.
     * @constant
     */
    static Radial: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set radial(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'Radial',
      value,
    );
  }

  /* #16773
  source: 
    /**
     * For pattern brushes, used as the value for Brush#type.
     * @constant
     */
    static Pattern: EnumValue; */
  /// For pattern brushes, used as the value for Brush#type.
  static _i3.EnumValue get pattern$ => _i5.getProperty(
        _declaredBrush,
        'Pattern',
      );
  /* #16773
  source: 
    /**
     * For pattern brushes, used as the value for Brush#type.
     * @constant
     */
    static Pattern: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set pattern$1(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'Pattern',
      value,
    );
  }

  /* #16778
  source: 
    /**
     * For lightening and darkening, used as a color-space value.
     * @constant
     */
    static Lab: EnumValue; */
  /// For lightening and darkening, used as a color-space value.
  static _i3.EnumValue get lab => _i5.getProperty(
        _declaredBrush,
        'Lab',
      );
  /* #16778
  source: 
    /**
     * For lightening and darkening, used as a color-space value.
     * @constant
     */
    static Lab: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set lab(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'Lab',
      value,
    );
  }

  /* #16783
  source: 
    /**
     * For lightening and darkening, used as a color-space value.
     * @constant
     */
    static HSL: EnumValue; */
  /// For lightening and darkening, used as a color-space value.
  static _i3.EnumValue get hsl => _i5.getProperty(
        _declaredBrush,
        'HSL',
      );
  /* #16783
  source: 
    /**
     * For lightening and darkening, used as a color-space value.
     * @constant
     */
    static HSL: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set hsl(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBrush,
      'HSL',
      value,
    );
  }

  static _i2.String randomColor([
    _i2.num? min,
    _i2.num? max,
  ]) =>
      _i5.callMethod(
        _declaredBrush,
        'randomColor',
        [
          min ?? _i4.undefined,
          max ?? _i4.undefined,
        ],
      );
  static _i2.bool isValidColor(_i2.String color) => _i5.callMethod(
        _declaredBrush,
        'isValidColor',
        [color],
      );
  static _i2.String lighten(_i2.String color) => _i5.callMethod(
        _declaredBrush,
        'lighten',
        [color],
      );
  static _i2.String lightenBy(
    _i2.String color, [
    _i2.num? fraction,
    _i3.EnumValue? mode,
  ]) =>
      _i5.callMethod(
        _declaredBrush,
        'lightenBy',
        [
          color,
          fraction ?? _i4.undefined,
          mode ?? _i4.undefined,
        ],
      );
  static _i2.String darken(_i2.String color) => _i5.callMethod(
        _declaredBrush,
        'darken',
        [color],
      );
  static _i2.String darkenBy(
    _i2.String color, [
    _i2.num? fraction,
    _i3.EnumValue? mode,
  ]) =>
      _i5.callMethod(
        _declaredBrush,
        'darkenBy',
        [
          color,
          fraction ?? _i4.undefined,
          mode ?? _i4.undefined,
        ],
      );
  static _i2.String mix(
    _i2.String color1,
    _i2.String color2, [
    _i2.num? fraction,
  ]) =>
      _i5.callMethod(
        _declaredBrush,
        'mix',
        [
          color1,
          color2,
          fraction ?? _i4.undefined,
        ],
      );
  static _i2.bool isDark(_i3.BrushLike color) => _i5.callMethod(
        _declaredBrush,
        'isDark',
        [color ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Brush')
external _i2.Object _declaredBrush;

extension Brush$Typings on Brush {
  /* #16601
  source: 
    /**
     * Gets or sets the type of brush.
     * The default value is Brush.Solid.
     * The value must be one of: Brush.Solid, Brush.Linear, Brush.Radial, Brush.Pattern.
     * If the new value is a linear or radial brush type,
     * and if the #start or #end spots are not specific spots,
     * they are changed to be specific spots, depending on the type of brush.
     */
    get type(): EnumValue; */
  /// Gets or sets the type of brush.
  /// The default value is Brush.Solid.
  /// The value must be one of: Brush.Solid, Brush.Linear, Brush.Radial, Brush.Pattern.
  /// If the new value is a linear or radial brush type,
  /// and if the #start or #end spots are not specific spots,
  /// they are changed to be specific spots, depending on the type of brush.
  _i3.EnumValue get type => _i5.getProperty(
        this,
        'type',
      );
  /* #16601
  source: 
    /**
     * Gets or sets the type of brush.
     * The default value is Brush.Solid.
     * The value must be one of: Brush.Solid, Brush.Linear, Brush.Radial, Brush.Pattern.
     * If the new value is a linear or radial brush type,
     * and if the #start or #end spots are not specific spots,
     * they are changed to be specific spots, depending on the type of brush.
     */
    get type(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set type(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'type',
      value,
    );
  }

  /* #16608
  source: 
    /**
     * Gets or sets the color of a solid Brush.
     * The default value is 'black'.
     * The value must be a valid CSS color string.
     */
    get color(): string; */
  /// Gets or sets the color of a solid Brush.
  /// The default value is 'black'.
  /// The value must be a valid CSS color string.
  _i2.String get color => _i5.getProperty(
        this,
        'color',
      );
  /* #16608
  source: 
    /**
     * Gets or sets the color of a solid Brush.
     * The default value is 'black'.
     * The value must be a valid CSS color string.
     */
    get color(): string; */
  // Type InteropStaticType.string
  set color(_i2.String value) {
    _i5.setProperty(
      this,
      'color',
      value,
    );
  }

  /* #16615
  source: 
    /**
     * Gets or sets the starting location for a linear or radial gradient.
     * A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
     * The default value is Spot.TopCenter for linear gradients and Spot.Center for radial gradients.
     */
    get start(): Spot; */
  /// Gets or sets the starting location for a linear or radial gradient.
  /// A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
  /// The default value is Spot.TopCenter for linear gradients and Spot.Center for radial gradients.
  _i3.Spot get start => _i5.getProperty(
        this,
        'start',
      );
  /* #16615
  source: 
    /**
     * Gets or sets the starting location for a linear or radial gradient.
     * A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
     * The default value is Spot.TopCenter for linear gradients and Spot.Center for radial gradients.
     */
    get start(): Spot; */
  // Type Instance of 'InteropInterface'
  set start(_i3.Spot value) {
    _i5.setProperty(
      this,
      'start',
      value,
    );
  }

  /* #16622
  source: 
    /**
     * Gets or sets the ending location for a linear or radial gradient.
     * A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
     * The default value is Spot.BottomCenter for linear gradients and Spot.Center for radial gradients.
     */
    get end(): Spot; */
  /// Gets or sets the ending location for a linear or radial gradient.
  /// A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
  /// The default value is Spot.BottomCenter for linear gradients and Spot.Center for radial gradients.
  _i3.Spot get end => _i5.getProperty(
        this,
        'end',
      );
  /* #16622
  source: 
    /**
     * Gets or sets the ending location for a linear or radial gradient.
     * A Spot value specifies a relative point in the object's GraphObject#naturalBounds.
     * The default value is Spot.BottomCenter for linear gradients and Spot.Center for radial gradients.
     */
    get end(): Spot; */
  // Type Instance of 'InteropInterface'
  set end(_i3.Spot value) {
    _i5.setProperty(
      this,
      'end',
      value,
    );
  }

  /* #16628
  source: 
    /**
     * Gets or sets the radius of a radial brush at the start location.
     * The default value is 0.
     */
    get startRadius(): number; */
  /// Gets or sets the radius of a radial brush at the start location.
  /// The default value is 0.
  _i2.num get startRadius => _i5.getProperty(
        this,
        'startRadius',
      );
  /* #16628
  source: 
    /**
     * Gets or sets the radius of a radial brush at the start location.
     * The default value is 0.
     */
    get startRadius(): number; */
  // Type InteropStaticType.number
  set startRadius(_i2.num value) {
    _i5.setProperty(
      this,
      'startRadius',
      value,
    );
  }

  /* #16634
  source: 
    /**
     * Gets or sets the radius of a radial brush at the end location.
     * The default value is NaN.
     */
    get endRadius(): number; */
  /// Gets or sets the radius of a radial brush at the end location.
  /// The default value is NaN.
  _i2.num get endRadius => _i5.getProperty(
        this,
        'endRadius',
      );
  /* #16634
  source: 
    /**
     * Gets or sets the radius of a radial brush at the end location.
     * The default value is NaN.
     */
    get endRadius(): number; */
  // Type InteropStaticType.number
  set endRadius(_i2.num value) {
    _i5.setProperty(
      this,
      'endRadius',
      value,
    );
  }

  /* #16644
  source: 
    /**
     * Gets or sets a Map holding all of the color stops used in this gradient,
     * where the key is a number, the fractional distance between 0 and 1 (inclusive),
     * and where the corresponding value is a color string.
     *
     * Call #addColorStop in order to add color stops to this brush.
     * This property value may be null if no gradient stops have been defined.
     */
    get colorStops(): Map<number, string> | null; */
  /// Gets or sets a Map holding all of the color stops used in this gradient,
  /// where the key is a number, the fractional distance between 0 and 1 (inclusive),
  /// and where the corresponding value is a color string.
  ///
  /// Call #addColorStop in order to add color stops to this brush.
  /// This property value may be null if no gradient stops have been defined.
  _i3.Map<_i2.num, _i2.String>? get colorStops => _i5.getProperty(
        this,
        'colorStops',
      );
  /* #16644
  source: 
    /**
     * Gets or sets a Map holding all of the color stops used in this gradient,
     * where the key is a number, the fractional distance between 0 and 1 (inclusive),
     * and where the corresponding value is a color string.
     *
     * Call #addColorStop in order to add color stops to this brush.
     * This property value may be null if no gradient stops have been defined.
     */
    get colorStops(): Map<number, string> | null; */
  // Type InteropUnion#406233337(parent: InteropGetter#831460184(name: colorStops))
  set colorStops(_i3.Map<_i2.num, _i2.String>? value) {
    _i5.setProperty(
      this,
      'colorStops',
      value ?? _i4.undefined,
    );
  }

  /* #16649
  source: 
    /**
     * Gets or sets the pattern of a brush of type Brush.Pattern.
     */
    get pattern(): HTMLCanvasElement | HTMLImageElement | null; */
  /// Gets or sets the pattern of a brush of type Brush.Pattern.
  _i2.dynamic get pattern => _i5.getProperty(
        this,
        'pattern',
      );
  /* #16649
  source: 
    /**
     * Gets or sets the pattern of a brush of type Brush.Pattern.
     */
    get pattern(): HTMLCanvasElement | HTMLImageElement | null; */
  // Type InteropUnion#579716490(parent: InteropGetter#1039420707(name: pattern))
  set pattern(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'pattern',
      value ?? _i4.undefined,
    );
  }

  _i3.Brush copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i3.Brush addColorStop(
    _i2.num loc,
    _i2.String color,
  ) =>
      _i5.callMethod(
        this,
        'addColorStop',
        [
          loc,
          color,
        ],
      );
  _i3.Brush lightenBy([
    _i2.num? fraction,
    _i3.EnumValue? mode,
  ]) =>
      _i5.callMethod(
        this,
        'lightenBy',
        [
          fraction ?? _i4.undefined,
          mode ?? _i4.undefined,
        ],
      );
  _i3.Brush darkenBy([
    _i2.num? fraction,
    _i3.EnumValue? mode,
  ]) =>
      _i5.callMethod(
        this,
        'darkenBy',
        [
          fraction ?? _i4.undefined,
          mode ?? _i4.undefined,
        ],
      );
  _i2.bool isDark() => _i5.callMethod(
        this,
        'isDark',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class PanelLayout {
  factory PanelLayout() => _i5.callConstructor(
        _declaredPanelLayout,
        [],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('PanelLayout')
external _i2.Object _declaredPanelLayout;

extension PanelLayout$Typings on PanelLayout {
  /* #16835
  source: 
    /**
     * Gets or sets the name of this instance of a particular panel layout.
     */
    get name(): string; */
  /// Gets or sets the name of this instance of a particular panel layout.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #16835
  source: 
    /**
     * Gets or sets the name of this instance of a particular panel layout.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #16844
  source: 
    /**
     * (undocumented)
     */
    get classType(): Function; */
  /// (undocumented)
  _i2.Function get classType => _i5.getProperty(
        this,
        'classType',
      );
  /* #16844
  source: 
    /**
     * (undocumented)
     */
    get classType(): Function; */
  // Type InteropStaticType.function
  set classType(_i2.Function value) {
    _i5.setProperty(
      this,
      'classType',
      value,
    );
  }

  void measure(
    _i3.Panel panel,
    _i2.num width,
    _i2.num height,
    _i4.Array elements,
    _i3.Rect union,
    _i2.num minw,
    _i2.num minh,
  ) {
    _i5.callMethod(
      this,
      'measure',
      [
        panel,
        width,
        height,
        elements,
        union,
        minw,
        minh,
      ],
    );
  }

  void measureElement(
    _i3.GraphObject obj,
    _i2.num width,
    _i2.num height,
    _i2.num minw,
    _i2.num minh,
  ) {
    _i5.callMethod(
      this,
      'measureElement',
      [
        obj,
        width,
        height,
        minw,
        minh,
      ],
    );
  }

  void arrange(
    _i3.Panel panel,
    _i4.Array elements,
    _i3.Rect union,
  ) {
    _i5.callMethod(
      this,
      'arrange',
      [
        panel,
        elements,
        union,
      ],
    );
  }

  void arrangeElement(
    _i3.GraphObject obj,
    _i2.num x,
    _i2.num y,
    _i2.num width,
    _i2.num height, [
    _i3.Rect? clipRect,
  ]) {
    _i5.callMethod(
      this,
      'arrangeElement',
      [
        obj,
        x,
        y,
        width,
        height,
        clipRect ?? _i4.undefined,
      ],
    );
  }

  void remeasureObject(_i3.GraphObject obj) {
    _i5.callMethod(
      this,
      'remeasureObject',
      [obj],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Panel implements _i3.GraphObject {
  factory Panel.$1() => _i5.callConstructor(
        _declaredPanel,
        [],
      );

  factory Panel.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredPanel,
        [init ?? _i4.undefined],
      );

  factory Panel.$3([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredPanel,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  /* #17847
  source: 
    /**
     * The default #type, arranges each element according to their GraphObject#position.
     * @constant
     */
    static get Position(): PanelLayout; */
  /// The default #type, arranges each element according to their GraphObject#position.
  static _i3.PanelLayout get position => _i5.getProperty(
        _declaredPanel,
        'Position',
      );
  /* #17847
  source: 
    /**
     * The default #type, arranges each element according to their GraphObject#position.
     * @constant
     */
    static get Position(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set position(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Position',
      value,
    );
  }

  /* #17853
  source: 
    /**
     * This value for #type lays out the elements horizontally with
     * their GraphObject#alignment property dictating their alignment on the Y-axis.
     * @constant
     */
    static get Horizontal(): PanelLayout; */
  /// This value for #type lays out the elements horizontally with
  /// their GraphObject#alignment property dictating their alignment on the Y-axis.
  static _i3.PanelLayout get horizontal => _i5.getProperty(
        _declaredPanel,
        'Horizontal',
      );
  /* #17853
  source: 
    /**
     * This value for #type lays out the elements horizontally with
     * their GraphObject#alignment property dictating their alignment on the Y-axis.
     * @constant
     */
    static get Horizontal(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set horizontal(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Horizontal',
      value,
    );
  }

  /* #17859
  source: 
    /**
     * This value for #type lays out the elements vertically with
     * their GraphObject#alignment property dictating their alignment on the X-axis.
     * @constant
     */
    static get Vertical(): PanelLayout; */
  /// This value for #type lays out the elements vertically with
  /// their GraphObject#alignment property dictating their alignment on the X-axis.
  static _i3.PanelLayout get vertical => _i5.getProperty(
        _declaredPanel,
        'Vertical',
      );
  /* #17859
  source: 
    /**
     * This value for #type lays out the elements vertically with
     * their GraphObject#alignment property dictating their alignment on the X-axis.
     * @constant
     */
    static get Vertical(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set vertical(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Vertical',
      value,
    );
  }

  /* #17867
  source: 
    /**
     * This value for #type arranges GraphObjects about a main element using the
     * GraphObject#alignment and GraphObject#alignmentFocus properties;
     * the main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     */
    static get Spot(): PanelLayout; */
  /// This value for #type arranges GraphObjects about a main element using the
  /// GraphObject#alignment and GraphObject#alignmentFocus properties;
  /// the main element is the first GraphObject with GraphObject#isPanelMain set to true,
  /// or else the first GraphObject if none have that property set to true.
  static _i3.PanelLayout get spot => _i5.getProperty(
        _declaredPanel,
        'Spot',
      );
  /* #17867
  source: 
    /**
     * This value for #type arranges GraphObjects about a main element using the
     * GraphObject#alignment and GraphObject#alignmentFocus properties;
     * the main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     */
    static get Spot(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set spot(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Spot',
      value,
    );
  }

  /* #17874
  source: 
    /**
     * This value for #type resizes the main element to fit around the other elements;
     * the main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     */
    static get Auto(): PanelLayout; */
  /// This value for #type resizes the main element to fit around the other elements;
  /// the main element is the first GraphObject with GraphObject#isPanelMain set to true,
  /// or else the first GraphObject if none have that property set to true.
  static _i3.PanelLayout get auto => _i5.getProperty(
        _declaredPanel,
        'Auto',
      );
  /* #17874
  source: 
    /**
     * This value for #type resizes the main element to fit around the other elements;
     * the main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     */
    static get Auto(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set auto(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Auto',
      value,
    );
  }

  /* #17880
  source: 
    /**
     * This value for #type arranges GraphObjects into rows and columns;
     * set the GraphObject#row and GraphObject#column properties on each element.
     * @constant
     */
    static get Table(): PanelLayout; */
  /// This value for #type arranges GraphObjects into rows and columns;
  /// set the GraphObject#row and GraphObject#column properties on each element.
  static _i3.PanelLayout get table => _i5.getProperty(
        _declaredPanel,
        'Table',
      );
  /* #17880
  source: 
    /**
     * This value for #type arranges GraphObjects into rows and columns;
     * set the GraphObject#row and GraphObject#column properties on each element.
     * @constant
     */
    static get Table(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set table(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Table',
      value,
    );
  }

  /* #17886
  source: 
    /**
     * This value for #type rescales a single GraphObject to fit inside the panel
     * depending on the panel's Panel#viewboxStretch property.
     * @constant
     */
    static get Viewbox(): PanelLayout; */
  /// This value for #type rescales a single GraphObject to fit inside the panel
  /// depending on the panel's Panel#viewboxStretch property.
  static _i3.PanelLayout get viewbox => _i5.getProperty(
        _declaredPanel,
        'Viewbox',
      );
  /* #17886
  source: 
    /**
     * This value for #type rescales a single GraphObject to fit inside the panel
     * depending on the panel's Panel#viewboxStretch property.
     * @constant
     */
    static get Viewbox(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set viewbox(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Viewbox',
      value,
    );
  }

  /* #17894
  source: 
    /**
     * Organizational Panel type that is only valid inside of a Table panel;
     * This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
     * it is only an organizational container for other elements of a Panel.
     * @constant
     * @since 1.1
     */
    static get TableRow(): PanelLayout; */
  /// Organizational Panel type that is only valid inside of a Table panel;
  /// This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
  /// it is only an organizational container for other elements of a Panel.
  static _i3.PanelLayout get tableRow => _i5.getProperty(
        _declaredPanel,
        'TableRow',
      );
  /* #17894
  source: 
    /**
     * Organizational Panel type that is only valid inside of a Table panel;
     * This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
     * it is only an organizational container for other elements of a Panel.
     * @constant
     * @since 1.1
     */
    static get TableRow(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set tableRow(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'TableRow',
      value,
    );
  }

  /* #17902
  source: 
    /**
     * Organizational Panel type that is only valid inside of a Table panel;
     * This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
     * it is only an organizational container for other elements of a Panel.
     * @constant
     * @since 1.1
     */
    static get TableColumn(): PanelLayout; */
  /// Organizational Panel type that is only valid inside of a Table panel;
  /// This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
  /// it is only an organizational container for other elements of a Panel.
  static _i3.PanelLayout get tableColumn => _i5.getProperty(
        _declaredPanel,
        'TableColumn',
      );
  /* #17902
  source: 
    /**
     * Organizational Panel type that is only valid inside of a Table panel;
     * This Panel ignores its angle and scale, and does not  have a meaningful size on its own,
     * it is only an organizational container for other elements of a Panel.
     * @constant
     * @since 1.1
     */
    static get TableColumn(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set tableColumn(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'TableColumn',
      value,
    );
  }

  /* #17907
  source: 
    /**
     * This value for #type is used for Links and adornments that act as Links.
     * @constant
     */
    static get Link(): PanelLayout; */
  /// This value for #type is used for Links and adornments that act as Links.
  static _i3.PanelLayout get link => _i5.getProperty(
        _declaredPanel,
        'Link',
      );
  /* #17907
  source: 
    /**
     * This value for #type is used for Links and adornments that act as Links.
     * @constant
     */
    static get Link(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set link(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Link',
      value,
    );
  }

  /* #17912
  source: 
    /**
     * This value for #type is used to draw regular patterns of lines.
     * @constant
     */
    static get Grid(): PanelLayout; */
  /// This value for #type is used to draw regular patterns of lines.
  static _i3.PanelLayout get grid => _i5.getProperty(
        _declaredPanel,
        'Grid',
      );
  /* #17912
  source: 
    /**
     * This value for #type is used to draw regular patterns of lines.
     * @constant
     */
    static get Grid(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set grid(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Grid',
      value,
    );
  }

  /* #17920
  source: 
    /**
     * This value for #type is used to draw regular tick marks and labels along some shape.
     * The main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     * @since 1.7
     */
    static get Graduated(): PanelLayout; */
  /// This value for #type is used to draw regular tick marks and labels along some shape.
  /// The main element is the first GraphObject with GraphObject#isPanelMain set to true,
  /// or else the first GraphObject if none have that property set to true.
  static _i3.PanelLayout get graduated => _i5.getProperty(
        _declaredPanel,
        'Graduated',
      );
  /* #17920
  source: 
    /**
     * This value for #type is used to draw regular tick marks and labels along some shape.
     * The main element is the first GraphObject with GraphObject#isPanelMain set to true,
     * or else the first GraphObject if none have that property set to true.
     * @constant
     * @since 1.7
     */
    static get Graduated(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  static set graduated(_i3.PanelLayout value) {
    _i5.setProperty(
      _declaredPanel,
      'Graduated',
      value,
    );
  }

  static void definePanelLayout(
    _i2.String layoutName,
    _i3.PanelLayout layout,
  ) {
    _i5.callMethod(
      _declaredPanel,
      'definePanelLayout',
      [
        layoutName,
        layout,
      ],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Panel')
external _i2.Object _declaredPanel;

extension Panel$Typings on Panel {
  /* #17191
  source: 
    /**
     * Gets or sets the type of the Panel, which controls how the Panel's elements are measured and arranged.
     * The value must be an instance of PanelLayout.
     * The only predefined values are listed as constant properties of Panel, including:
     *   - Panel.Position
     *   - Panel.Vertical
     *   - Panel.Horizontal
     *   - Panel.Auto
     *   - Panel.Spot
     *   - Panel.Table
     *   - Panel.Viewbox
     *   - Panel.Link (see also Links, which are all Panels of type Link)
     *   - Panel.TableRow
     *   - Panel.TableColumn
     *   - Panel.Grid
     *   - Panel.Graduated
     *
     * The default value is Panel.Position.
     *
     * You must not modify this property once the Panel has been measured or the Panel has been added to another Panel.
     */
    get type(): PanelLayout; */
  /// Gets or sets the type of the Panel, which controls how the Panel's elements are measured and arranged.
  /// The value must be an instance of PanelLayout.
  /// The only predefined values are listed as constant properties of Panel, including:
  ///   - Panel.Position
  ///   - Panel.Vertical
  ///   - Panel.Horizontal
  ///   - Panel.Auto
  ///   - Panel.Spot
  ///   - Panel.Table
  ///   - Panel.Viewbox
  ///   - Panel.Link (see also Links, which are all Panels of type Link)
  ///   - Panel.TableRow
  ///   - Panel.TableColumn
  ///   - Panel.Grid
  ///   - Panel.Graduated
  ///
  /// The default value is Panel.Position.
  ///
  /// You must not modify this property once the Panel has been measured or the Panel has been added to another Panel.
  _i3.PanelLayout get type => _i5.getProperty(
        this,
        'type',
      );
  /* #17191
  source: 
    /**
     * Gets or sets the type of the Panel, which controls how the Panel's elements are measured and arranged.
     * The value must be an instance of PanelLayout.
     * The only predefined values are listed as constant properties of Panel, including:
     *   - Panel.Position
     *   - Panel.Vertical
     *   - Panel.Horizontal
     *   - Panel.Auto
     *   - Panel.Spot
     *   - Panel.Table
     *   - Panel.Viewbox
     *   - Panel.Link (see also Links, which are all Panels of type Link)
     *   - Panel.TableRow
     *   - Panel.TableColumn
     *   - Panel.Grid
     *   - Panel.Graduated
     *
     * The default value is Panel.Position.
     *
     * You must not modify this property once the Panel has been measured or the Panel has been added to another Panel.
     */
    get type(): PanelLayout; */
  // Type Instance of 'InteropInterface'
  set type(_i3.PanelLayout value) {
    _i5.setProperty(
      this,
      'type',
      value,
    );
  }

  /* #17200
  source: 
    /**
     * This read-only property returns an iterator over the collection of the GraphObjects that this panel manages.
     *
     * You can change the collection by calling #add, #insertAt, #remove, or #removeAt.
     *
     * You can also get direct access to individual elements by calling #elt.
     */
    get elements(): Iterator<GraphObject>; */
  /// This read-only property returns an iterator over the collection of the GraphObjects that this panel manages.
  ///
  /// You can change the collection by calling #add, #insertAt, #remove, or #removeAt.
  ///
  /// You can also get direct access to individual elements by calling #elt.
  _i3.Iterator<_i3.GraphObject> get elements => _i5.getProperty(
        this,
        'elements',
      );
  /* #17200
  source: 
    /**
     * This read-only property returns an iterator over the collection of the GraphObjects that this panel manages.
     *
     * You can change the collection by calling #add, #insertAt, #remove, or #removeAt.
     *
     * You can also get direct access to individual elements by calling #elt.
     */
    get elements(): Iterator<GraphObject>; */
  // Type Instance of 'InteropInterface'
  set elements(_i3.Iterator<_i3.GraphObject> value) {
    _i5.setProperty(
      this,
      'elements',
      value,
    );
  }

  /* #17214
  source: 
    /**
     * Gets or sets the space between this Panel's border and its content.
     * Unlike GraphObject#margin, padding expands the area inside of the Panel's border.
     * If this Panel's size is unconstrained, this will increase the size of the panel.
     * If this Panel's size is constrained, this will decrease the total area
     * for the Panel elements to arrange themselves.
     *
     * Unlike margin, increases in size due to padding are visually covered by the GraphObject#background.
     *
     * Padding cannot contain negative numbers.
     * The default value is a Margin of zero.
     * @see GraphObject#margin
     */
    get padding(): MarginLike; */
  /// Gets or sets the space between this Panel's border and its content.
  /// Unlike GraphObject#margin, padding expands the area inside of the Panel's border.
  /// If this Panel's size is unconstrained, this will increase the size of the panel.
  /// If this Panel's size is constrained, this will decrease the total area
  /// for the Panel elements to arrange themselves.
  ///
  /// Unlike margin, increases in size due to padding are visually covered by the GraphObject#background.
  ///
  /// Padding cannot contain negative numbers.
  /// The default value is a Margin of zero.
  _i3.MarginLike get padding => _i5.getProperty(
        this,
        'padding',
      );
  /* #17214
  source: 
    /**
     * Gets or sets the space between this Panel's border and its content.
     * Unlike GraphObject#margin, padding expands the area inside of the Panel's border.
     * If this Panel's size is unconstrained, this will increase the size of the panel.
     * If this Panel's size is constrained, this will decrease the total area
     * for the Panel elements to arrange themselves.
     *
     * Unlike margin, increases in size due to padding are visually covered by the GraphObject#background.
     *
     * Padding cannot contain negative numbers.
     * The default value is a Margin of zero.
     * @see GraphObject#margin
     */
    get padding(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set padding(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'padding',
      value,
    );
  }

  /* #17222
  source: 
    /**
     * Gets or sets the default alignment spot of this Panel, used as
     * the alignment for an element when its GraphObject#alignment value is Spot.Default.
     * The default value is Spot.Default, which is interpreted by the Panel in whatever manner seems reasonable,
     * depending on the Panel type.
     */
    get defaultAlignment(): Spot; */
  /// Gets or sets the default alignment spot of this Panel, used as
  /// the alignment for an element when its GraphObject#alignment value is Spot.Default.
  /// The default value is Spot.Default, which is interpreted by the Panel in whatever manner seems reasonable,
  /// depending on the Panel type.
  _i3.Spot get defaultAlignment => _i5.getProperty(
        this,
        'defaultAlignment',
      );
  /* #17222
  source: 
    /**
     * Gets or sets the default alignment spot of this Panel, used as
     * the alignment for an element when its GraphObject#alignment value is Spot.Default.
     * The default value is Spot.Default, which is interpreted by the Panel in whatever manner seems reasonable,
     * depending on the Panel type.
     */
    get defaultAlignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set defaultAlignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'defaultAlignment',
      value,
    );
  }

  /* #17229
  source: 
    /**
     * Gets or sets the default stretch of this Panel, used as
     * the stretch for an element when its GraphObject#stretch value is GraphObject.Default.
     * The default value is GraphObject.Default, which typically resolves to GraphObject.None.
     */
    get defaultStretch(): EnumValue; */
  /// Gets or sets the default stretch of this Panel, used as
  /// the stretch for an element when its GraphObject#stretch value is GraphObject.Default.
  /// The default value is GraphObject.Default, which typically resolves to GraphObject.None.
  _i3.EnumValue get defaultStretch => _i5.getProperty(
        this,
        'defaultStretch',
      );
  /* #17229
  source: 
    /**
     * Gets or sets the default stretch of this Panel, used as
     * the stretch for an element when its GraphObject#stretch value is GraphObject.Default.
     * The default value is GraphObject.Default, which typically resolves to GraphObject.None.
     */
    get defaultStretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set defaultStretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'defaultStretch',
      value,
    );
  }

  /* #17239
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the additional padding for rows and columns.
     * Padding is applied both before and after a row or column's contents.
     * @see RowColumnDefinition#separatorPadding
     * @see #defaultColumnSeparatorStrokeWidth
     * @see #defaultRowSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultSeparatorPadding(): MarginLike; */
  /// For Panel.Table|Table Panels: Gets or sets the additional padding for rows and columns.
  /// Padding is applied both before and after a row or column's contents.
  _i3.MarginLike get defaultSeparatorPadding => _i5.getProperty(
        this,
        'defaultSeparatorPadding',
      );
  /* #17239
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the additional padding for rows and columns.
     * Padding is applied both before and after a row or column's contents.
     * @see RowColumnDefinition#separatorPadding
     * @see #defaultColumnSeparatorStrokeWidth
     * @see #defaultRowSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultSeparatorPadding(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set defaultSeparatorPadding(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'defaultSeparatorPadding',
      value,
    );
  }

  /* #17253
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke (color) for rows
     * provided a given row has a nonzero RowColumnDefinition#separatorStrokeWidth.
     * RowColumnDefinition#separatorStroke can override this default value.
     * The default value is null -- no line is drawn.
     * @TablePanel
     * @see #defaultRowSeparatorStrokeWidth
     * @see #defaultRowSeparatorDashArray
     * @see RowColumnDefinition#separatorStroke
     * @see #defaultColumnSeparatorStroke
     * @since 1.2
     */
    get defaultRowSeparatorStroke(): BrushLike; */
  /// For Panel.Table|Table Panels: Gets or sets the default stroke (color) for rows
  /// provided a given row has a nonzero RowColumnDefinition#separatorStrokeWidth.
  /// RowColumnDefinition#separatorStroke can override this default value.
  /// The default value is null -- no line is drawn.
  _i3.BrushLike get defaultRowSeparatorStroke => _i5.getProperty(
        this,
        'defaultRowSeparatorStroke',
      );
  /* #17253
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke (color) for rows
     * provided a given row has a nonzero RowColumnDefinition#separatorStrokeWidth.
     * RowColumnDefinition#separatorStroke can override this default value.
     * The default value is null -- no line is drawn.
     * @TablePanel
     * @see #defaultRowSeparatorStrokeWidth
     * @see #defaultRowSeparatorDashArray
     * @see RowColumnDefinition#separatorStroke
     * @see #defaultColumnSeparatorStroke
     * @since 1.2
     */
    get defaultRowSeparatorStroke(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set defaultRowSeparatorStroke(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'defaultRowSeparatorStroke',
      value ?? _i4.undefined,
    );
  }

  /* #17263
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke width for a row's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     * The default value is 1.  Any new value must be a real, non-negative number.
     * @see RowColumnDefinition#separatorStrokeWidth
     * @see #defaultColumnSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultRowSeparatorStrokeWidth(): number; */
  /// For Panel.Table|Table Panels: Gets or sets the default stroke width for a row's separator.
  /// RowColumnDefinition#separatorStrokeWidth can override this default value.
  /// The default value is 1.  Any new value must be a real, non-negative number.
  _i2.num get defaultRowSeparatorStrokeWidth => _i5.getProperty(
        this,
        'defaultRowSeparatorStrokeWidth',
      );
  /* #17263
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke width for a row's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     * The default value is 1.  Any new value must be a real, non-negative number.
     * @see RowColumnDefinition#separatorStrokeWidth
     * @see #defaultColumnSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultRowSeparatorStrokeWidth(): number; */
  // Type InteropStaticType.number
  set defaultRowSeparatorStrokeWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultRowSeparatorStrokeWidth',
      value,
    );
  }

  /* #17281
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default dash array for a row's separator.
     * RowColumnDefinition#separatorDashArray can override this default value.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null.
     * @see RowColumnDefinition#separatorDashArray
     * @see #defaultColumnSeparatorDashArray
     * @since 1.2
     */
    get defaultRowSeparatorDashArray(): Array<number> | null; */
  /// For Panel.Table|Table Panels: Gets or sets the default dash array for a row's separator.
  /// RowColumnDefinition#separatorDashArray can override this default value.
  ///
  /// Must be an array of positive numbers and zeroes,
  /// or else null to indicate a solid line.
  ///
  /// For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
  ///
  /// Setting an array with all zeroes will set the value to null.
  ///
  /// Default is null.
  _i4.Array? get defaultRowSeparatorDashArray => _i5.getProperty(
        this,
        'defaultRowSeparatorDashArray',
      );
  /* #17281
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default dash array for a row's separator.
     * RowColumnDefinition#separatorDashArray can override this default value.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null.
     * @see RowColumnDefinition#separatorDashArray
     * @see #defaultColumnSeparatorDashArray
     * @since 1.2
     */
    get defaultRowSeparatorDashArray(): Array<number> | null; */
  // Type InteropUnion#413911225(parent: InteropGetter#390053866(name: defaultRowSeparatorDashArray))
  set defaultRowSeparatorDashArray(_i4.Array? value) {
    _i5.setProperty(
      this,
      'defaultRowSeparatorDashArray',
      value ?? _i4.undefined,
    );
  }

  /* #17294
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke (color) for columns
     * provided a given column has a nonzero RowColumnDefinition#separatorStrokeWidth.
     * RowColumnDefinition#separatorDashArray can override this default value.
     * The default value is null -- no line is drawn.
     * @see #defaultColumnSeparatorStrokeWidth
     * @see #defaultColumnSeparatorDashArray
     * @see RowColumnDefinition#separatorStroke
     * @see #defaultRowSeparatorStroke
     * @since 1.2
     */
    get defaultColumnSeparatorStroke(): BrushLike; */
  /// For Panel.Table|Table Panels: Gets or sets the default stroke (color) for columns
  /// provided a given column has a nonzero RowColumnDefinition#separatorStrokeWidth.
  /// RowColumnDefinition#separatorDashArray can override this default value.
  /// The default value is null -- no line is drawn.
  _i3.BrushLike get defaultColumnSeparatorStroke => _i5.getProperty(
        this,
        'defaultColumnSeparatorStroke',
      );
  /* #17294
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke (color) for columns
     * provided a given column has a nonzero RowColumnDefinition#separatorStrokeWidth.
     * RowColumnDefinition#separatorDashArray can override this default value.
     * The default value is null -- no line is drawn.
     * @see #defaultColumnSeparatorStrokeWidth
     * @see #defaultColumnSeparatorDashArray
     * @see RowColumnDefinition#separatorStroke
     * @see #defaultRowSeparatorStroke
     * @since 1.2
     */
    get defaultColumnSeparatorStroke(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set defaultColumnSeparatorStroke(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'defaultColumnSeparatorStroke',
      value ?? _i4.undefined,
    );
  }

  /* #17304
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke width for a column's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     * The default value is 1.  Any new value must be a real, non-negative number.
     * @see RowColumnDefinition#separatorStrokeWidth
     * @see #defaultRowSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultColumnSeparatorStrokeWidth(): number; */
  /// For Panel.Table|Table Panels: Gets or sets the default stroke width for a column's separator.
  /// RowColumnDefinition#separatorStrokeWidth can override this default value.
  /// The default value is 1.  Any new value must be a real, non-negative number.
  _i2.num get defaultColumnSeparatorStrokeWidth => _i5.getProperty(
        this,
        'defaultColumnSeparatorStrokeWidth',
      );
  /* #17304
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default stroke width for a column's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     * The default value is 1.  Any new value must be a real, non-negative number.
     * @see RowColumnDefinition#separatorStrokeWidth
     * @see #defaultRowSeparatorStrokeWidth
     * @since 1.2
     */
    get defaultColumnSeparatorStrokeWidth(): number; */
  // Type InteropStaticType.number
  set defaultColumnSeparatorStrokeWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultColumnSeparatorStrokeWidth',
      value,
    );
  }

  /* #17322
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default dash array for a column's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null.
     * @see RowColumnDefinition#separatorDashArray
     * @see #defaultRowSeparatorDashArray
     * @since 1.2
     */
    get defaultColumnSeparatorDashArray(): Array<number> | null; */
  /// For Panel.Table|Table Panels: Gets or sets the default dash array for a column's separator.
  /// RowColumnDefinition#separatorStrokeWidth can override this default value.
  ///
  /// Must be an array of positive numbers and zeroes,
  /// or else null to indicate a solid line.
  ///
  /// For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
  ///
  /// Setting an array with all zeroes will set the value to null.
  ///
  /// Default is null.
  _i4.Array? get defaultColumnSeparatorDashArray => _i5.getProperty(
        this,
        'defaultColumnSeparatorDashArray',
      );
  /* #17322
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the default dash array for a column's separator.
     * RowColumnDefinition#separatorStrokeWidth can override this default value.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null.
     * @see RowColumnDefinition#separatorDashArray
     * @see #defaultRowSeparatorDashArray
     * @since 1.2
     */
    get defaultColumnSeparatorDashArray(): Array<number> | null; */
  // Type InteropUnion#827769027(parent: InteropGetter#679589931(name: defaultColumnSeparatorDashArray))
  set defaultColumnSeparatorDashArray(_i4.Array? value) {
    _i5.setProperty(
      this,
      'defaultColumnSeparatorDashArray',
      value ?? _i4.undefined,
    );
  }

  /* #17330
  source: 
    /**
     * For Panel.Viewbox|Viewbox Panels: Gets or sets how the panel will resize its content.
     *
     * Possible values are GraphObject.Uniform and GraphObject.UniformToFill.
     * The default is GraphObject.Uniform.
     */
    get viewboxStretch(): EnumValue; */
  /// For Panel.Viewbox|Viewbox Panels: Gets or sets how the panel will resize its content.
  ///
  /// Possible values are GraphObject.Uniform and GraphObject.UniformToFill.
  /// The default is GraphObject.Uniform.
  _i3.EnumValue get viewboxStretch => _i5.getProperty(
        this,
        'viewboxStretch',
      );
  /* #17330
  source: 
    /**
     * For Panel.Viewbox|Viewbox Panels: Gets or sets how the panel will resize its content.
     *
     * Possible values are GraphObject.Uniform and GraphObject.UniformToFill.
     * The default is GraphObject.Uniform.
     */
    get viewboxStretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set viewboxStretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'viewboxStretch',
      value,
    );
  }

  /* #17337
  source: 
    /**
     * For Panel.Grid|Grid Panels: Gets or sets the distance between lines.
     * The units are in local coordinates.
     * The default is 10x10.  Any new width or height must be a positive real number.
     */
    get gridCellSize(): Size; */
  /// For Panel.Grid|Grid Panels: Gets or sets the distance between lines.
  /// The units are in local coordinates.
  /// The default is 10x10.  Any new width or height must be a positive real number.
  _i3.Size get gridCellSize => _i5.getProperty(
        this,
        'gridCellSize',
      );
  /* #17337
  source: 
    /**
     * For Panel.Grid|Grid Panels: Gets or sets the distance between lines.
     * The units are in local coordinates.
     * The default is 10x10.  Any new width or height must be a positive real number.
     */
    get gridCellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set gridCellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'gridCellSize',
      value,
    );
  }

  /* #17344
  source: 
    /**
     * For Panel.Grid|Grid Panels: Gets or sets an origin point for the grid cells.
     * The units are in local coordinates.
     * The default is (0,0).  Any new value must use real numbers.
     */
    get gridOrigin(): Point; */
  /// For Panel.Grid|Grid Panels: Gets or sets an origin point for the grid cells.
  /// The units are in local coordinates.
  /// The default is (0,0).  Any new value must use real numbers.
  _i3.Point get gridOrigin => _i5.getProperty(
        this,
        'gridOrigin',
      );
  /* #17344
  source: 
    /**
     * For Panel.Grid|Grid Panels: Gets or sets an origin point for the grid cells.
     * The units are in local coordinates.
     * The default is (0,0).  Any new value must use real numbers.
     */
    get gridOrigin(): Point; */
  // Type Instance of 'InteropInterface'
  set gridOrigin(_i3.Point value) {
    _i5.setProperty(
      this,
      'gridOrigin',
      value,
    );
  }

  /* #17351
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the minimum value represented.
     * Must be less than #graduatedMax. The default is 0.
     * @since 1.7
     */
    get graduatedMin(): number; */
  /// For Panel.Graduated|Graduated Panels: Gets or sets the minimum value represented.
  /// Must be less than #graduatedMax. The default is 0.
  _i2.num get graduatedMin => _i5.getProperty(
        this,
        'graduatedMin',
      );
  /* #17351
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the minimum value represented.
     * Must be less than #graduatedMax. The default is 0.
     * @since 1.7
     */
    get graduatedMin(): number; */
  // Type InteropStaticType.number
  set graduatedMin(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedMin',
      value,
    );
  }

  /* #17358
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the maximum value represented.
     * Must be greater than #graduatedMin. The default is 100.
     * @since 1.7
     */
    get graduatedMax(): number; */
  /// For Panel.Graduated|Graduated Panels: Gets or sets the maximum value represented.
  /// Must be greater than #graduatedMin. The default is 100.
  _i2.num get graduatedMax => _i5.getProperty(
        this,
        'graduatedMax',
      );
  /* #17358
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the maximum value represented.
     * Must be greater than #graduatedMin. The default is 100.
     * @since 1.7
     */
    get graduatedMax(): number; */
  // Type InteropStaticType.number
  set graduatedMax(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedMax',
      value,
    );
  }

  /* #17366
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: This read-only property returns the range of values represented by the Panel.
     *
     * For example, a #graduatedMin of 25 and #graduatedMax of 75 would return 50.
     * @since 1.7
     */
    get graduatedRange(): number; */
  /// For Panel.Graduated|Graduated Panels: This read-only property returns the range of values represented by the Panel.
  ///
  /// For example, a #graduatedMin of 25 and #graduatedMax of 75 would return 50.
  _i2.num get graduatedRange => _i5.getProperty(
        this,
        'graduatedRange',
      );
  /* #17366
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: This read-only property returns the range of values represented by the Panel.
     *
     * For example, a #graduatedMin of 25 and #graduatedMax of 75 would return 50.
     * @since 1.7
     */
    get graduatedRange(): number; */
  // Type InteropStaticType.number
  set graduatedRange(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedRange',
      value,
    );
  }

  /* #17372
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the difference between two consecutive values marked by ticks.
     * Must be positive. The default is 10.
     * @since 1.7
     */
    get graduatedTickUnit(): number; */
  /// For Panel.Graduated|Graduated Panels: Gets or sets the difference between two consecutive values marked by ticks.
  /// Must be positive. The default is 10.
  _i2.num get graduatedTickUnit => _i5.getProperty(
        this,
        'graduatedTickUnit',
      );
  /* #17372
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the difference between two consecutive values marked by ticks.
     * Must be positive. The default is 10.
     * @since 1.7
     */
    get graduatedTickUnit(): number; */
  // Type InteropStaticType.number
  set graduatedTickUnit(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedTickUnit',
      value,
    );
  }

  /* #17379
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the base value which is marked with a tick.
     * The default is 0.
     * @since 1.7
     */
    get graduatedTickBase(): number; */
  /// For Panel.Graduated|Graduated Panels: Gets or sets the base value which is marked with a tick.
  /// The default is 0.
  _i2.num get graduatedTickBase => _i5.getProperty(
        this,
        'graduatedTickBase',
      );
  /* #17379
  source: 
    /**
     * For Panel.Graduated|Graduated Panels: Gets or sets the base value which is marked with a tick.
     * The default is 0.
     * @since 1.7
     */
    get graduatedTickBase(): number; */
  // Type InteropStaticType.number
  set graduatedTickBase(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedTickBase',
      value,
    );
  }

  /* #17391
  source: 
    /**
     * Undocumented state for PanelLayouts
    */
    get panelLayoutState(): any | null; */
  /// Undocumented state for PanelLayouts
  _i2.dynamic get panelLayoutState => _i5.getProperty(
        this,
        'panelLayoutState',
      );
  /* #17391
  source: 
    /**
     * Undocumented state for PanelLayouts
    */
    get panelLayoutState(): any | null; */
  // Type InteropUnion#153558990(parent: InteropGetter#295442549(name: panelLayoutState))
  set panelLayoutState(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'panelLayoutState',
      value ?? _i4.undefined,
    );
  }

  /* #17445
  source: 
    /**
     * For Panel.Table|Table Panels: This read-only property returns the number of rows.
     * This value is only valid after the Panel has been measured.
     */
    get rowCount(): number; */
  /// For Panel.Table|Table Panels: This read-only property returns the number of rows.
  /// This value is only valid after the Panel has been measured.
  _i2.num get rowCount => _i5.getProperty(
        this,
        'rowCount',
      );
  /* #17445
  source: 
    /**
     * For Panel.Table|Table Panels: This read-only property returns the number of rows.
     * This value is only valid after the Panel has been measured.
     */
    get rowCount(): number; */
  // Type InteropStaticType.number
  set rowCount(_i2.num value) {
    _i5.setProperty(
      this,
      'rowCount',
      value,
    );
  }

  /* #17468
  source: 
    /**
     * For Panel.Table|Table Panels: This read-only property returns the number of columns.
     * This value is only valid after the Panel has been measured.
     */
    get columnCount(): number; */
  /// For Panel.Table|Table Panels: This read-only property returns the number of columns.
  /// This value is only valid after the Panel has been measured.
  _i2.num get columnCount => _i5.getProperty(
        this,
        'columnCount',
      );
  /* #17468
  source: 
    /**
     * For Panel.Table|Table Panels: This read-only property returns the number of columns.
     * This value is only valid after the Panel has been measured.
     */
    get columnCount(): number; */
  // Type InteropStaticType.number
  set columnCount(_i2.num value) {
    _i5.setProperty(
      this,
      'columnCount',
      value,
    );
  }

  /* #17504
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets how this Panel's rows deal with extra space.
     * Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
     * The default is RowColumnDefinition.ProportionalExtra.
     * @see RowColumnDefinition#sizing
     */
    get rowSizing(): EnumValue; */
  /// For Panel.Table|Table Panels: Gets or sets how this Panel's rows deal with extra space.
  /// Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
  /// The default is RowColumnDefinition.ProportionalExtra.
  _i3.EnumValue get rowSizing => _i5.getProperty(
        this,
        'rowSizing',
      );
  /* #17504
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets how this Panel's rows deal with extra space.
     * Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
     * The default is RowColumnDefinition.ProportionalExtra.
     * @see RowColumnDefinition#sizing
     */
    get rowSizing(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set rowSizing(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'rowSizing',
      value,
    );
  }

  /* #17513
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets how this Panel's columns deal with extra space.
     * Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
     * The default is RowColumnDefinition.ProportionalExtra.
     * @see RowColumnDefinition#sizing
     * @see #rowSizing
     */
    get columnSizing(): EnumValue; */
  /// For Panel.Table|Table Panels: Gets or sets how this Panel's columns deal with extra space.
  /// Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
  /// The default is RowColumnDefinition.ProportionalExtra.
  _i3.EnumValue get columnSizing => _i5.getProperty(
        this,
        'columnSizing',
      );
  /* #17513
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets how this Panel's columns deal with extra space.
     * Valid values are RowColumnDefinition.ProportionalExtra and RowColumnDefinition.None.
     * The default is RowColumnDefinition.ProportionalExtra.
     * @see RowColumnDefinition#sizing
     * @see #rowSizing
     */
    get columnSizing(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set columnSizing(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'columnSizing',
      value,
    );
  }

  /* #17520
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the first row that this Panel displays.
     * The default value is 0.
     * @see #leftIndex
     */
    get topIndex(): number; */
  /// For Panel.Table|Table Panels: Gets or sets the first row that this Panel displays.
  /// The default value is 0.
  _i2.num get topIndex => _i5.getProperty(
        this,
        'topIndex',
      );
  /* #17520
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the first row that this Panel displays.
     * The default value is 0.
     * @see #leftIndex
     */
    get topIndex(): number; */
  // Type InteropStaticType.number
  set topIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'topIndex',
      value,
    );
  }

  /* #17527
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the first column that this Panel displays.
     * The default value is 0.
     * @see #topIndex
     */
    get leftIndex(): number; */
  /// For Panel.Table|Table Panels: Gets or sets the first column that this Panel displays.
  /// The default value is 0.
  _i2.num get leftIndex => _i5.getProperty(
        this,
        'leftIndex',
      );
  /* #17527
  source: 
    /**
     * For Panel.Table|Table Panels: Gets or sets the first column that this Panel displays.
     * The default value is 0.
     * @see #topIndex
     */
    get leftIndex(): number; */
  // Type InteropStaticType.number
  set leftIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'leftIndex',
      value,
    );
  }

  /* #17606
  source: 
    /**
     * Gets or sets the optional model data to which this panel is data-bound.
     * The data must be a JavaScript Object if this is a Part.
     * The data can be any JavaScript value if this is a Panel created for
     * an item in an Array that was data-bound by the #itemArray property.
     * The default value is null.
     *
     * Setting it to a new value automatically calls #updateTargetBindings
     * in order to assign new values to all of the data-bound GraphObject properties.
     *
     * Once you set this property you cannot add, remove, or modify any data bindings
     * on any of the GraphObjects in the visual tree of this Panel, including on
     * this panel itself.
     *
     * You should not modify this property on a Part that is created automatically
     * to represent model data, nor on a Panel that is created automatically for a data item
     * in the containing Panel's Panel#itemArray.
     * Call Model#removeNodeData and Model#addNodeData if you want to replace
     * this Part with another one, or call Model#removeArrayItem and Model#insertArrayItem
     * if you want to replace this Panel with another one.
     *
     * Although you might not be able to replace this data value if this Part was created
     * automatically by the Diagram, you can still modify that data object's properties.
     * Call the appropriate Model method for changing properties that affect the structure of the diagram.
     * Call Model#setDataProperty for changing other properties that may be the sources
     * of Bindings on GraphObject properties that are in the visual tree of this panel/part.
     */
    get data(): any | null; */
  /// Gets or sets the optional model data to which this panel is data-bound.
  /// The data must be a JavaScript Object if this is a Part.
  /// The data can be any JavaScript value if this is a Panel created for
  /// an item in an Array that was data-bound by the #itemArray property.
  /// The default value is null.
  ///
  /// Setting it to a new value automatically calls #updateTargetBindings
  /// in order to assign new values to all of the data-bound GraphObject properties.
  ///
  /// Once you set this property you cannot add, remove, or modify any data bindings
  /// on any of the GraphObjects in the visual tree of this Panel, including on
  /// this panel itself.
  ///
  /// You should not modify this property on a Part that is created automatically
  /// to represent model data, nor on a Panel that is created automatically for a data item
  /// in the containing Panel's Panel#itemArray.
  /// Call Model#removeNodeData and Model#addNodeData if you want to replace
  /// this Part with another one, or call Model#removeArrayItem and Model#insertArrayItem
  /// if you want to replace this Panel with another one.
  ///
  /// Although you might not be able to replace this data value if this Part was created
  /// automatically by the Diagram, you can still modify that data object's properties.
  /// Call the appropriate Model method for changing properties that affect the structure of the diagram.
  /// Call Model#setDataProperty for changing other properties that may be the sources
  /// of Bindings on GraphObject properties that are in the visual tree of this panel/part.
  _i2.dynamic get data => _i5.getProperty(
        this,
        'data',
      );
  /* #17606
  source: 
    /**
     * Gets or sets the optional model data to which this panel is data-bound.
     * The data must be a JavaScript Object if this is a Part.
     * The data can be any JavaScript value if this is a Panel created for
     * an item in an Array that was data-bound by the #itemArray property.
     * The default value is null.
     *
     * Setting it to a new value automatically calls #updateTargetBindings
     * in order to assign new values to all of the data-bound GraphObject properties.
     *
     * Once you set this property you cannot add, remove, or modify any data bindings
     * on any of the GraphObjects in the visual tree of this Panel, including on
     * this panel itself.
     *
     * You should not modify this property on a Part that is created automatically
     * to represent model data, nor on a Panel that is created automatically for a data item
     * in the containing Panel's Panel#itemArray.
     * Call Model#removeNodeData and Model#addNodeData if you want to replace
     * this Part with another one, or call Model#removeArrayItem and Model#insertArrayItem
     * if you want to replace this Panel with another one.
     *
     * Although you might not be able to replace this data value if this Part was created
     * automatically by the Diagram, you can still modify that data object's properties.
     * Call the appropriate Model method for changing properties that affect the structure of the diagram.
     * Call Model#setDataProperty for changing other properties that may be the sources
     * of Bindings on GraphObject properties that are in the visual tree of this panel/part.
     */
    get data(): any | null; */
  // Type InteropUnion#162195604(parent: InteropGetter#483933683(name: data))
  set data(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'data',
      value ?? _i4.undefined,
    );
  }

  /* #17644
  source: 
    /**
     * Gets the index of this Panel's data if it was created to represent an item in its containing Panel's Panel#itemArray.
     * The default value is NaN.
     *
     * This is only set internally by code such as #rebuildItemElements or Model#insertArrayItem
     * when building or shifting Panel representing items
     * in the Panel whose Panel#itemArray was set or bound to an Array of value.
     *
     * This property can be used in data bindings within the item template to produce values
     * that depend on its position in the item Array.
     * For example:
     * ```js
     *  $(go.Panel, // the item Panel
     *    . . .,
     *    new go.Binding("itemArray", "someProperty"),
     *    {
     *      itemTemplate:
     *        $(go.Panel,
     *          // set Panel.background to a color based on the Panel.itemIndex
     *          new go.Binding("background", "itemIndex",
     *                         // using this conversion function
     *                         i => return (i%2 === 0) ? "lightgreen" : "lightyellow")
     *                   // bound to this Panel itself, not to the Panel.data item
     *                   .ofObject(),
     *          $(go.TextBlock,  // a trivial item template, just showing some text
     *            new go.Binding("text"))  // sets TextBlock.text = data.text
     *        )
     *    }
     *  )
     * ```
     *
     * The main element of a Spot or Auto or Link Panel, or the first TableRow or TableColumn element of a Table Panel
     * whose #isPanelMain property is true, will not have this property set to a number,
     * because it will not have been created by #rebuildItemElements.
     * @since 1.4
     */
    get itemIndex(): number; */
  /// Gets the index of this Panel's data if it was created to represent an item in its containing Panel's Panel#itemArray.
  /// The default value is NaN.
  ///
  /// This is only set internally by code such as #rebuildItemElements or Model#insertArrayItem
  /// when building or shifting Panel representing items
  /// in the Panel whose Panel#itemArray was set or bound to an Array of value.
  ///
  /// This property can be used in data bindings within the item template to produce values
  /// that depend on its position in the item Array.
  /// For example:
  /// ```js
  ///  $(go.Panel, // the item Panel
  ///    . . .,
  ///    new go.Binding("itemArray", "someProperty"),
  ///    {
  ///      itemTemplate:
  ///        $(go.Panel,
  ///          // set Panel.background to a color based on the Panel.itemIndex
  ///          new go.Binding("background", "itemIndex",
  ///                         // using this conversion function
  ///                         i => return (i%2 === 0) ? "lightgreen" : "lightyellow")
  ///                   // bound to this Panel itself, not to the Panel.data item
  ///                   .ofObject(),
  ///          $(go.TextBlock,  // a trivial item template, just showing some text
  ///            new go.Binding("text"))  // sets TextBlock.text = data.text
  ///        )
  ///    }
  ///  )
  /// ```
  ///
  /// The main element of a Spot or Auto or Link Panel, or the first TableRow or TableColumn element of a Table Panel
  /// whose #isPanelMain property is true, will not have this property set to a number,
  /// because it will not have been created by #rebuildItemElements.
  _i2.num get itemIndex => _i5.getProperty(
        this,
        'itemIndex',
      );
  /* #17644
  source: 
    /**
     * Gets the index of this Panel's data if it was created to represent an item in its containing Panel's Panel#itemArray.
     * The default value is NaN.
     *
     * This is only set internally by code such as #rebuildItemElements or Model#insertArrayItem
     * when building or shifting Panel representing items
     * in the Panel whose Panel#itemArray was set or bound to an Array of value.
     *
     * This property can be used in data bindings within the item template to produce values
     * that depend on its position in the item Array.
     * For example:
     * ```js
     *  $(go.Panel, // the item Panel
     *    . . .,
     *    new go.Binding("itemArray", "someProperty"),
     *    {
     *      itemTemplate:
     *        $(go.Panel,
     *          // set Panel.background to a color based on the Panel.itemIndex
     *          new go.Binding("background", "itemIndex",
     *                         // using this conversion function
     *                         i => return (i%2 === 0) ? "lightgreen" : "lightyellow")
     *                   // bound to this Panel itself, not to the Panel.data item
     *                   .ofObject(),
     *          $(go.TextBlock,  // a trivial item template, just showing some text
     *            new go.Binding("text"))  // sets TextBlock.text = data.text
     *        )
     *    }
     *  )
     * ```
     *
     * The main element of a Spot or Auto or Link Panel, or the first TableRow or TableColumn element of a Table Panel
     * whose #isPanelMain property is true, will not have this property set to a number,
     * because it will not have been created by #rebuildItemElements.
     * @since 1.4
     */
    get itemIndex(): number; */
  // Type InteropStaticType.number
  set itemIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'itemIndex',
      value,
    );
  }

  /* #17702
  source: 
    /**
     * Gets or sets a JavaScript Array of values or objects, each of which will be represented
     * by a Panel as elements in this Panel.
     * Replacing this array results all of this panel's child objects being replaced with
     * a copy of the Panel found in #itemTemplateMap for each particular
     * item in the Array.
     *
     * Because the software does not receive any notifications when an Array is modified,
     * any insertions or removals or replacements of data in the Array will not be noticed
     * unless you call Model#insertArrayItem or Model#removeArrayItem.
     * You may also reset this property to its current value (the modified Array) or
     * call #updateTargetBindings, if there is a Binding whose target is this property.
     *
     * When binding this property, it is commonplace to set Model#copiesArrays and
     * Model#copiesArrayObjects properties to true, so that when a node is copied,
     * the item Array and its contents are copied, not shared.
     * Or more generally, to customize the model's copying processes, you can supply a custom
     * Model#copyNodeDataFunction and perhaps a GraphLinksModel#copyLinkDataFunction.
     *
     * Any JavaScript Object that is in this Array must only appear once in the array
     * and must not appear in any other Panel#itemArrays.
     * Use #findItemPanelForData to find the data-bound Panel created for an Object in this panel's item Array.
     *
     * Non-Object values in an item Array may appear multiple times.
     * An item Array may be shared by multiple Panels.
     *
     * Item Arrays should not be used with Grid Panels or Graduated Panels as they may not have nested Panels.
     */
    get itemArray(): Array<any> | null; */
  /// Gets or sets a JavaScript Array of values or objects, each of which will be represented
  /// by a Panel as elements in this Panel.
  /// Replacing this array results all of this panel's child objects being replaced with
  /// a copy of the Panel found in #itemTemplateMap for each particular
  /// item in the Array.
  ///
  /// Because the software does not receive any notifications when an Array is modified,
  /// any insertions or removals or replacements of data in the Array will not be noticed
  /// unless you call Model#insertArrayItem or Model#removeArrayItem.
  /// You may also reset this property to its current value (the modified Array) or
  /// call #updateTargetBindings, if there is a Binding whose target is this property.
  ///
  /// When binding this property, it is commonplace to set Model#copiesArrays and
  /// Model#copiesArrayObjects properties to true, so that when a node is copied,
  /// the item Array and its contents are copied, not shared.
  /// Or more generally, to customize the model's copying processes, you can supply a custom
  /// Model#copyNodeDataFunction and perhaps a GraphLinksModel#copyLinkDataFunction.
  ///
  /// Any JavaScript Object that is in this Array must only appear once in the array
  /// and must not appear in any other Panel#itemArrays.
  /// Use #findItemPanelForData to find the data-bound Panel created for an Object in this panel's item Array.
  ///
  /// Non-Object values in an item Array may appear multiple times.
  /// An item Array may be shared by multiple Panels.
  ///
  /// Item Arrays should not be used with Grid Panels or Graduated Panels as they may not have nested Panels.
  _i4.Array? get itemArray => _i5.getProperty(
        this,
        'itemArray',
      );
  /* #17702
  source: 
    /**
     * Gets or sets a JavaScript Array of values or objects, each of which will be represented
     * by a Panel as elements in this Panel.
     * Replacing this array results all of this panel's child objects being replaced with
     * a copy of the Panel found in #itemTemplateMap for each particular
     * item in the Array.
     *
     * Because the software does not receive any notifications when an Array is modified,
     * any insertions or removals or replacements of data in the Array will not be noticed
     * unless you call Model#insertArrayItem or Model#removeArrayItem.
     * You may also reset this property to its current value (the modified Array) or
     * call #updateTargetBindings, if there is a Binding whose target is this property.
     *
     * When binding this property, it is commonplace to set Model#copiesArrays and
     * Model#copiesArrayObjects properties to true, so that when a node is copied,
     * the item Array and its contents are copied, not shared.
     * Or more generally, to customize the model's copying processes, you can supply a custom
     * Model#copyNodeDataFunction and perhaps a GraphLinksModel#copyLinkDataFunction.
     *
     * Any JavaScript Object that is in this Array must only appear once in the array
     * and must not appear in any other Panel#itemArrays.
     * Use #findItemPanelForData to find the data-bound Panel created for an Object in this panel's item Array.
     *
     * Non-Object values in an item Array may appear multiple times.
     * An item Array may be shared by multiple Panels.
     *
     * Item Arrays should not be used with Grid Panels or Graduated Panels as they may not have nested Panels.
     */
    get itemArray(): Array<any> | null; */
  // Type InteropUnion#510149843(parent: InteropGetter#673376473(name: itemArray))
  set itemArray(_i4.Array? value) {
    _i5.setProperty(
      this,
      'itemArray',
      value ?? _i4.undefined,
    );
  }

  /* #17751
  source: 
    /**
     * Gets or sets the default Panel template used as the archetype
     * for item data that are in #itemArray.
     *
     * Setting this property just modifies the #itemTemplateMap
     * by replacing the entry named with the empty string.
     * Any new value must be a Panel but not a Part.
     * By default this property is null.
     *
     * GraphObject#copy when copying a panel will share the #itemTemplateMap
     * between the original panel and the copied panel.
     */
    get itemTemplate(): Panel; */
  /// Gets or sets the default Panel template used as the archetype
  /// for item data that are in #itemArray.
  ///
  /// Setting this property just modifies the #itemTemplateMap
  /// by replacing the entry named with the empty string.
  /// Any new value must be a Panel but not a Part.
  /// By default this property is null.
  ///
  /// GraphObject#copy when copying a panel will share the #itemTemplateMap
  /// between the original panel and the copied panel.
  _i3.Panel get itemTemplate => _i5.getProperty(
        this,
        'itemTemplate',
      );
  /* #17751
  source: 
    /**
     * Gets or sets the default Panel template used as the archetype
     * for item data that are in #itemArray.
     *
     * Setting this property just modifies the #itemTemplateMap
     * by replacing the entry named with the empty string.
     * Any new value must be a Panel but not a Part.
     * By default this property is null.
     *
     * GraphObject#copy when copying a panel will share the #itemTemplateMap
     * between the original panel and the copied panel.
     */
    get itemTemplate(): Panel; */
  // Type Instance of 'InteropInterface'
  set itemTemplate(_i3.Panel value) {
    _i5.setProperty(
      this,
      'itemTemplate',
      value,
    );
  }

  /* #17767
  source: 
    /**
     * Gets or sets a Map mapping template names to Panels.
     * One of these Panels is copied for each item data that is in the #itemArray.
     * Replacing this map will automatically rebuild all of the elements in this Panel.
     *
     * By default this property is null.
     * All values in the Map must be Panels but not Parts.
     *
     * If you modify this Map, by replacing a Panel or by adding or
     * removing a map entry, you need to explicitly call #rebuildItemElements afterwards.
     *
     * GraphObject#copy when copying a panel will share the #itemTemplateMap
     * between the original panel and the copied panel.
     */
    get itemTemplateMap(): Map<string, Panel> | null; */
  /// Gets or sets a Map mapping template names to Panels.
  /// One of these Panels is copied for each item data that is in the #itemArray.
  /// Replacing this map will automatically rebuild all of the elements in this Panel.
  ///
  /// By default this property is null.
  /// All values in the Map must be Panels but not Parts.
  ///
  /// If you modify this Map, by replacing a Panel or by adding or
  /// removing a map entry, you need to explicitly call #rebuildItemElements afterwards.
  ///
  /// GraphObject#copy when copying a panel will share the #itemTemplateMap
  /// between the original panel and the copied panel.
  _i3.Map<_i2.String, _i3.Panel>? get itemTemplateMap => _i5.getProperty(
        this,
        'itemTemplateMap',
      );
  /* #17767
  source: 
    /**
     * Gets or sets a Map mapping template names to Panels.
     * One of these Panels is copied for each item data that is in the #itemArray.
     * Replacing this map will automatically rebuild all of the elements in this Panel.
     *
     * By default this property is null.
     * All values in the Map must be Panels but not Parts.
     *
     * If you modify this Map, by replacing a Panel or by adding or
     * removing a map entry, you need to explicitly call #rebuildItemElements afterwards.
     *
     * GraphObject#copy when copying a panel will share the #itemTemplateMap
     * between the original panel and the copied panel.
     */
    get itemTemplateMap(): Map<string, Panel> | null; */
  // Type InteropUnion#621949381(parent: InteropGetter#10780824(name: itemTemplateMap))
  set itemTemplateMap(_i3.Map<_i2.String, _i3.Panel>? value) {
    _i5.setProperty(
      this,
      'itemTemplateMap',
      value ?? _i4.undefined,
    );
  }

  /* #17781
  source: 
    /**
     * Gets or sets the name of the item data property that returns a string describing that data's category,
     * or a function that takes an item data object and returns that string;
     * the default value is the name 'category'.
     * This is used to distinguish between different
     * kinds of items in the #itemArray.
     *
     * The name must not be null.
     * If the value is an empty string, the category is assumed to be an empty string,
     * the default category name, for all item data objects.
     * You must not change this property when the #itemArray already has a value.
     */
    get itemCategoryProperty(): string | ((a: any) => string); */
  /// Gets or sets the name of the item data property that returns a string describing that data's category,
  /// or a function that takes an item data object and returns that string;
  /// the default value is the name 'category'.
  /// This is used to distinguish between different
  /// kinds of items in the #itemArray.
  ///
  /// The name must not be null.
  /// If the value is an empty string, the category is assumed to be an empty string,
  /// the default category name, for all item data objects.
  /// You must not change this property when the #itemArray already has a value.
  _i2.Object get itemCategoryProperty => _i5.getProperty(
        this,
        'itemCategoryProperty',
      );
  /* #17781
  source: 
    /**
     * Gets or sets the name of the item data property that returns a string describing that data's category,
     * or a function that takes an item data object and returns that string;
     * the default value is the name 'category'.
     * This is used to distinguish between different
     * kinds of items in the #itemArray.
     *
     * The name must not be null.
     * If the value is an empty string, the category is assumed to be an empty string,
     * the default category name, for all item data objects.
     * You must not change this property when the #itemArray already has a value.
     */
    get itemCategoryProperty(): string | ((a: any) => string); */
  // Type InteropUnion#944784155(parent: InteropGetter#756542395(name: itemCategoryProperty))
  set itemCategoryProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'itemCategoryProperty',
      value,
    );
  }

  /* #17796
  source: 
    /**
     * For Spot Panels: Gets or sets whether this Panel's main element clips instead of fills.
     * The main element will not paint its stroke, if it has any.
     * This assumes that the main element is a Shape.
     *
     * Since 2.2: For Groups: Gets or sets whether this Group's Placeholder clips its member nodes.
     * For compatibility, if the Group is a Spot Panel, it will not clip its members.
     *
     * When this property is `true`, the Spot panel will size itself to be the *intersection* of the main element bounds and
     * all other elements' bounds, rather than the union of these bounds.
     * @since 1.7
     */
    get isClipping(): boolean; */
  /// For Spot Panels: Gets or sets whether this Panel's main element clips instead of fills.
  /// The main element will not paint its stroke, if it has any.
  /// This assumes that the main element is a Shape.
  ///
  /// Since 2.2: For Groups: Gets or sets whether this Group's Placeholder clips its member nodes.
  /// For compatibility, if the Group is a Spot Panel, it will not clip its members.
  ///
  /// When this property is `true`, the Spot panel will size itself to be the *intersection* of the main element bounds and
  /// all other elements' bounds, rather than the union of these bounds.
  _i2.bool get isClipping => _i5.getProperty(
        this,
        'isClipping',
      );
  /* #17796
  source: 
    /**
     * For Spot Panels: Gets or sets whether this Panel's main element clips instead of fills.
     * The main element will not paint its stroke, if it has any.
     * This assumes that the main element is a Shape.
     *
     * Since 2.2: For Groups: Gets or sets whether this Group's Placeholder clips its member nodes.
     * For compatibility, if the Group is a Spot Panel, it will not clip its members.
     *
     * When this property is `true`, the Spot panel will size itself to be the *intersection* of the main element bounds and
     * all other elements' bounds, rather than the union of these bounds.
     * @since 1.7
     */
    get isClipping(): boolean; */
  // Type InteropStaticType.boolean
  set isClipping(_i2.bool value) {
    _i5.setProperty(
      this,
      'isClipping',
      value,
    );
  }

  /* #17805
  source: 
    /**
     * For Panel.Horizontal|Horizontal and Panel.Vertical|Vertical Panels: gets or sets whether this Panel arranges its contents from the
     * typical side (left and top, respectively), or the opposite side (right and bottom, respectively).
     *
     * The default value is false.
     * @since 1.7
     */
    get isOpposite(): boolean; */
  /// For Panel.Horizontal|Horizontal and Panel.Vertical|Vertical Panels: gets or sets whether this Panel arranges its contents from the
  /// typical side (left and top, respectively), or the opposite side (right and bottom, respectively).
  ///
  /// The default value is false.
  _i2.bool get isOpposite => _i5.getProperty(
        this,
        'isOpposite',
      );
  /* #17805
  source: 
    /**
     * For Panel.Horizontal|Horizontal and Panel.Vertical|Vertical Panels: gets or sets whether this Panel arranges its contents from the
     * typical side (left and top, respectively), or the opposite side (right and bottom, respectively).
     *
     * The default value is false.
     * @since 1.7
     */
    get isOpposite(): boolean; */
  // Type InteropStaticType.boolean
  set isOpposite(_i2.bool value) {
    _i5.setProperty(
      this,
      'isOpposite',
      value,
    );
  }

  /* #17824
  source: 
    /**
     * Gets or sets whether this Panel or any GraphObject inside the panel actually responds to user click events.
     * It may be used as a Binding target.
     * See how this property is used in <a href="../../extensions/Buttons.js">Buttons.js</a>.
     *
     * This property does not have any effect on picking ("hit-testing") -- that behavior is implemented
     * by the GraphObject#pickable property.
     * When this property is false, non-click events may still occur on this panel or on objects within this panel.
     * This property is normally only used for Panels that are GraphObject#isActionable.
     *
     * Call GraphObject#isEnabledObject to decide whether a particular object can be clicked.
     * @see GraphObject#isEnabledObject
     * @see GraphObject#enabledChanged
     * @see GraphObject#isActionable
     * @see GraphObject#pickable
     * @since 1.7
     */
    get isEnabled(): boolean; */
  /// Gets or sets whether this Panel or any GraphObject inside the panel actually responds to user click events.
  /// It may be used as a Binding target.
  /// See how this property is used in <a href="../../extensions/Buttons.js">Buttons.js</a>.
  ///
  /// This property does not have any effect on picking ("hit-testing") -- that behavior is implemented
  /// by the GraphObject#pickable property.
  /// When this property is false, non-click events may still occur on this panel or on objects within this panel.
  /// This property is normally only used for Panels that are GraphObject#isActionable.
  ///
  /// Call GraphObject#isEnabledObject to decide whether a particular object can be clicked.
  _i2.bool get isEnabled => _i5.getProperty(
        this,
        'isEnabled',
      );
  /* #17824
  source: 
    /**
     * Gets or sets whether this Panel or any GraphObject inside the panel actually responds to user click events.
     * It may be used as a Binding target.
     * See how this property is used in <a href="../../extensions/Buttons.js">Buttons.js</a>.
     *
     * This property does not have any effect on picking ("hit-testing") -- that behavior is implemented
     * by the GraphObject#pickable property.
     * When this property is false, non-click events may still occur on this panel or on objects within this panel.
     * This property is normally only used for Panels that are GraphObject#isActionable.
     *
     * Call GraphObject#isEnabledObject to decide whether a particular object can be clicked.
     * @see GraphObject#isEnabledObject
     * @see GraphObject#enabledChanged
     * @see GraphObject#isActionable
     * @see GraphObject#pickable
     * @since 1.7
     */
    get isEnabled(): boolean; */
  // Type InteropStaticType.boolean
  set isEnabled(_i2.bool value) {
    _i5.setProperty(
      this,
      'isEnabled',
      value,
    );
  }

  /* #17833
  source: 
    /**
     * For Panels which are elements of Spot Panels: Gets or sets the name
     * of this Panel's element that should be used as the alignment object instead of this Panel.
     *
     * This allows Spot Panels to align objects that are nested in the element tree of its own elements.
     * @since 1.7
     */
    get alignmentFocusName(): string; */
  /// For Panels which are elements of Spot Panels: Gets or sets the name
  /// of this Panel's element that should be used as the alignment object instead of this Panel.
  ///
  /// This allows Spot Panels to align objects that are nested in the element tree of its own elements.
  _i2.String get alignmentFocusName => _i5.getProperty(
        this,
        'alignmentFocusName',
      );
  /* #17833
  source: 
    /**
     * For Panels which are elements of Spot Panels: Gets or sets the name
     * of this Panel's element that should be used as the alignment object instead of this Panel.
     *
     * This allows Spot Panels to align objects that are nested in the element tree of its own elements.
     * @since 1.7
     */
    get alignmentFocusName(): string; */
  // Type InteropStaticType.string
  set alignmentFocusName(_i2.String value) {
    _i5.setProperty(
      this,
      'alignmentFocusName',
      value,
    );
  }

  _i3.Panel copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i3.GraphObject? findMainElement() => _i5.callMethod(
        this,
        'findMainElement',
        [],
      );
  _i3.GraphObject? findObject(_i2.String name) => _i5.callMethod(
        this,
        'findObject',
        [name],
      );
  _i3.Panel add([_i2.Iterable<_i2.dynamic>? elements]) => _i5.callMethod(
        this,
        'add',
        [...?elements],
      );
  _i3.GraphObject elt(_i2.num idx) => _i5.callMethod(
        this,
        'elt',
        [idx],
      );
  void insertAt(
    _i2.num index,
    _i3.GraphObject element,
  ) {
    _i5.callMethod(
      this,
      'insertAt',
      [
        index,
        element,
      ],
    );
  }

  void remove(_i3.GraphObject element) {
    _i5.callMethod(
      this,
      'remove',
      [element],
    );
  }

  void removeAt(_i2.num idx) {
    _i5.callMethod(
      this,
      'removeAt',
      [idx],
    );
  }

  _i3.RowColumnDefinition getRowDefinition(_i2.num idx) => _i5.callMethod(
        this,
        'getRowDefinition',
        [idx],
      );
  void removeRowDefinition(_i2.num idx) {
    _i5.callMethod(
      this,
      'removeRowDefinition',
      [idx],
    );
  }

  _i3.RowColumnDefinition getColumnDefinition(_i2.num idx) => _i5.callMethod(
        this,
        'getColumnDefinition',
        [idx],
      );
  void removeColumnDefinition(_i2.num idx) {
    _i5.callMethod(
      this,
      'removeColumnDefinition',
      [idx],
    );
  }

  _i3.Panel addRowColumnDefinition(_i3.RowColumnDefinition rowOrColumnDef) =>
      _i5.callMethod(
        this,
        'addRowColumnDefinition',
        [rowOrColumnDef],
      );
  _i2.num findRowForLocalY(_i2.num y) => _i5.callMethod(
        this,
        'findRowForLocalY',
        [y],
      );
  _i2.num findColumnForLocalX(_i2.num x) => _i5.callMethod(
        this,
        'findColumnForLocalX',
        [x],
      );
  _i3.Point graduatedPointForValue(
    _i2.num val, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'graduatedPointForValue',
        [
          val,
          result ?? _i4.undefined,
        ],
      );
  _i2.num graduatedValueForPoint(_i3.Point pt) => _i5.callMethod(
        this,
        'graduatedValueForPoint',
        [pt],
      );
  _i3.Panel copyTemplate([_i2.bool? freeze]) => _i5.callMethod(
        this,
        'copyTemplate',
        [freeze ?? _i4.undefined],
      );
  void updateTargetBindings([_i2.String? srcprop]) {
    _i5.callMethod(
      this,
      'updateTargetBindings',
      [srcprop ?? _i4.undefined],
    );
  }

  _i3.Panel? findItemPanelForData(_i2.Object data) => _i5.callMethod(
        this,
        'findItemPanelForData',
        [data],
      );
  void rebuildItemElements() {
    _i5.callMethod(
      this,
      'rebuildItemElements',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline11 {}

extension IInline11$Typings on IInline11 {
  /* #17941
  source: 
        row?: number; */
  _i2.num? get row => _i5.getProperty(
        this,
        'row',
      );
  /* #17941
  source: 
        row?: number; */
  // Type InteropStaticType.number
  set row(_i2.num? value) {
    _i5.setProperty(
      this,
      'row',
      value ?? _i4.undefined,
    );
  }

  /* #17942
  source: 
        column?: number; */
  _i2.num? get column => _i5.getProperty(
        this,
        'column',
      );
  /* #17942
  source: 
        column?: number; */
  // Type InteropStaticType.number
  set column(_i2.num? value) {
    _i5.setProperty(
      this,
      'column',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class RowColumnDefinition {
  factory RowColumnDefinition([_i4.Partial? init]) => _i5.callConstructor(
        _declaredRowColumnDefinition,
        [init ?? _i4.undefined],
      );

  /* #17949
  source: 
    /**
     * The default #sizing, which resolves to RowColumnDefinition.None or else
     * the Table Panel's rowSizing and columnSizing if present.
     * @constant
     */
    static Default: EnumValue; */
  /// The default #sizing, which resolves to RowColumnDefinition.None or else
  /// the Table Panel's rowSizing and columnSizing if present.
  static _i3.EnumValue get default$ => _i5.getProperty(
        _declaredRowColumnDefinition,
        'Default',
      );
  /* #17949
  source: 
    /**
     * The default #sizing, which resolves to RowColumnDefinition.None or else
     * the Table Panel's rowSizing and columnSizing if present.
     * @constant
     */
    static Default: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set default$(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredRowColumnDefinition,
      'Default',
      value,
    );
  }

  /* #17954
  source: 
    /**
     * The default #sizing if none is specified on the Table Panel's rowSizing and columnSizing.
     * @constant
     */
    static None: EnumValue; */
  /// The default #sizing if none is specified on the Table Panel's rowSizing and columnSizing.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredRowColumnDefinition,
        'None',
      );
  /* #17954
  source: 
    /**
     * The default #sizing if none is specified on the Table Panel's rowSizing and columnSizing.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredRowColumnDefinition,
      'None',
      value,
    );
  }

  /* #17960
  source: 
    /**
     * If a Table Panel is larger than all the rows then this #sizing
     * grants this row and any others with the same value the extra space, apportioned proportionally between them
     * @constant
     */
    static ProportionalExtra: EnumValue; */
  /// If a Table Panel is larger than all the rows then this #sizing
  /// grants this row and any others with the same value the extra space, apportioned proportionally between them
  static _i3.EnumValue get proportionalExtra => _i5.getProperty(
        _declaredRowColumnDefinition,
        'ProportionalExtra',
      );
  /* #17960
  source: 
    /**
     * If a Table Panel is larger than all the rows then this #sizing
     * grants this row and any others with the same value the extra space, apportioned proportionally between them
     * @constant
     */
    static ProportionalExtra: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set proportionalExtra(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredRowColumnDefinition,
      'ProportionalExtra',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('RowColumnDefinition')
external _i2.Object _declaredRowColumnDefinition;

extension RowColumnDefinition$Typings on RowColumnDefinition {
  /* #17981
  source: 
    /**
     * This read-only property returns the Panel that this row or column definition is in.
     */
    get panel(): Panel | null; */
  /// This read-only property returns the Panel that this row or column definition is in.
  _i3.Panel? get panel => _i5.getProperty(
        this,
        'panel',
      );
  /* #17981
  source: 
    /**
     * This read-only property returns the Panel that this row or column definition is in.
     */
    get panel(): Panel | null; */
  // Type InteropUnion#23249223(parent: InteropGetter#181568562(name: panel))
  set panel(_i3.Panel? value) {
    _i5.setProperty(
      this,
      'panel',
      value ?? _i4.undefined,
    );
  }

  /* #17988
  source: 
    /**
     * This read-only property is true when this describes a row instead of a column in the #panel.
     * When this is true, the #height, #minimum, and #maximum
     * all describe the row height.
     * Otherwise #width and the other two properties describe the column width.
     */
    get isRow(): boolean; */
  /// This read-only property is true when this describes a row instead of a column in the #panel.
  /// When this is true, the #height, #minimum, and #maximum
  /// all describe the row height.
  /// Otherwise #width and the other two properties describe the column width.
  _i2.bool get isRow => _i5.getProperty(
        this,
        'isRow',
      );
  /* #17988
  source: 
    /**
     * This read-only property is true when this describes a row instead of a column in the #panel.
     * When this is true, the #height, #minimum, and #maximum
     * all describe the row height.
     * Otherwise #width and the other two properties describe the column width.
     */
    get isRow(): boolean; */
  // Type InteropStaticType.boolean
  set isRow(_i2.bool value) {
    _i5.setProperty(
      this,
      'isRow',
      value,
    );
  }

  /* #17999
  source: 
    /**
     * This read-only property returns which row or column this RowColumnDefinition describes in the #panel.
     * The value is a zero-based integer.
     * @see Panel#findColumnForLocalX
     * @see Panel#findRowForLocalY
     * @see Panel#leftIndex
     * @see Panel#topIndex
     * @see #position
     */
    get index(): number; */
  /// This read-only property returns which row or column this RowColumnDefinition describes in the #panel.
  /// The value is a zero-based integer.
  _i2.num get index => _i5.getProperty(
        this,
        'index',
      );
  /* #17999
  source: 
    /**
     * This read-only property returns which row or column this RowColumnDefinition describes in the #panel.
     * The value is a zero-based integer.
     * @see Panel#findColumnForLocalX
     * @see Panel#findRowForLocalY
     * @see Panel#leftIndex
     * @see Panel#topIndex
     * @see #position
     */
    get index(): number; */
  // Type InteropStaticType.number
  set index(_i2.num value) {
    _i5.setProperty(
      this,
      'index',
      value,
    );
  }

  /* #18020
  source: 
    /**
     * Gets or sets the row height, in local coordinates.
     * This describes the row height if #isRow is true;
     * otherwise this property is meaningless.
     * The value must be non-negative and finite.
     *
     * The default value is NaN, which means this row will get a height
     * that is just big enough to hold all of the objects in the row.
     *
     * Setting this value to a number will mean that all of the objects
     * of this Panel in this row will be allocated that
     * amount of row height.
     * Whether an object in the row is actually arranged to have that height
     * depends on whether the GraphObject#stretch stretches vertically.
     * @see #width
     * @see #minimum
     * @see #maximum
     * @see #sizing
     */
    get height(): number; */
  /// Gets or sets the row height, in local coordinates.
  /// This describes the row height if #isRow is true;
  /// otherwise this property is meaningless.
  /// The value must be non-negative and finite.
  ///
  /// The default value is NaN, which means this row will get a height
  /// that is just big enough to hold all of the objects in the row.
  ///
  /// Setting this value to a number will mean that all of the objects
  /// of this Panel in this row will be allocated that
  /// amount of row height.
  /// Whether an object in the row is actually arranged to have that height
  /// depends on whether the GraphObject#stretch stretches vertically.
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #18020
  source: 
    /**
     * Gets or sets the row height, in local coordinates.
     * This describes the row height if #isRow is true;
     * otherwise this property is meaningless.
     * The value must be non-negative and finite.
     *
     * The default value is NaN, which means this row will get a height
     * that is just big enough to hold all of the objects in the row.
     *
     * Setting this value to a number will mean that all of the objects
     * of this Panel in this row will be allocated that
     * amount of row height.
     * Whether an object in the row is actually arranged to have that height
     * depends on whether the GraphObject#stretch stretches vertically.
     * @see #width
     * @see #minimum
     * @see #maximum
     * @see #sizing
     */
    get height(): number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  /* #18041
  source: 
    /**
     * Gets or sets the column width, in local coordinates.
     * The size describes the column width if #isRow is false;
     * otherwise this property is meaningless.
     * The value must be non-negative and finite.
     *
     * The default value is NaN, which means this column will get a width
     * that is just big enough to hold all of the objects in the column.
     *
     * Setting this value to a number will mean that all of the objects
     * of this Panel in this column will be allocated that
     * amount of column width.
     * Whether an object in the column is actually arranged to have that width
     * depends on whether the GraphObject#stretch stretches horizontally.
     * @see #height
     * @see #minimum
     * @see #maximum
     * @see #sizing
     */
    get width(): number; */
  /// Gets or sets the column width, in local coordinates.
  /// The size describes the column width if #isRow is false;
  /// otherwise this property is meaningless.
  /// The value must be non-negative and finite.
  ///
  /// The default value is NaN, which means this column will get a width
  /// that is just big enough to hold all of the objects in the column.
  ///
  /// Setting this value to a number will mean that all of the objects
  /// of this Panel in this column will be allocated that
  /// amount of column width.
  /// Whether an object in the column is actually arranged to have that width
  /// depends on whether the GraphObject#stretch stretches horizontally.
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #18041
  source: 
    /**
     * Gets or sets the column width, in local coordinates.
     * The size describes the column width if #isRow is false;
     * otherwise this property is meaningless.
     * The value must be non-negative and finite.
     *
     * The default value is NaN, which means this column will get a width
     * that is just big enough to hold all of the objects in the column.
     *
     * Setting this value to a number will mean that all of the objects
     * of this Panel in this column will be allocated that
     * amount of column width.
     * Whether an object in the column is actually arranged to have that width
     * depends on whether the GraphObject#stretch stretches horizontally.
     * @see #height
     * @see #minimum
     * @see #maximum
     * @see #sizing
     */
    get width(): number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #18058
  source: 
    /**
     * Gets or sets the minimum row height or column width, in local coordinates.
     * The minimum describes the row height if #isRow is true;
     * otherwise this describes the column width.
     *
     * The value must be non-negative and finite.
     * The default value is zero.
     * The arranged height of all objects in this row,
     * or the arranged width of all objects in this column,
     * will be no less than this value.
     * @see #width
     * @see #height
     * @see #maximum
     * @see #sizing
     */
    get minimum(): number; */
  /// Gets or sets the minimum row height or column width, in local coordinates.
  /// The minimum describes the row height if #isRow is true;
  /// otherwise this describes the column width.
  ///
  /// The value must be non-negative and finite.
  /// The default value is zero.
  /// The arranged height of all objects in this row,
  /// or the arranged width of all objects in this column,
  /// will be no less than this value.
  _i2.num get minimum => _i5.getProperty(
        this,
        'minimum',
      );
  /* #18058
  source: 
    /**
     * Gets or sets the minimum row height or column width, in local coordinates.
     * The minimum describes the row height if #isRow is true;
     * otherwise this describes the column width.
     *
     * The value must be non-negative and finite.
     * The default value is zero.
     * The arranged height of all objects in this row,
     * or the arranged width of all objects in this column,
     * will be no less than this value.
     * @see #width
     * @see #height
     * @see #maximum
     * @see #sizing
     */
    get minimum(): number; */
  // Type InteropStaticType.number
  set minimum(_i2.num value) {
    _i5.setProperty(
      this,
      'minimum',
      value,
    );
  }

  /* #18075
  source: 
    /**
     * Gets or sets the maximum row height or column width, in local coordinates.
     * The maximum describes the row height if #isRow is true;
     * otherwise this describes the column width.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     * The arranged height of all objects in this row,
     * or the arranged width of all objects in this column,
     * will be no greater than this value.
     * @see #width
     * @see #height
     * @see #minimum
     * @see #sizing
     */
    get maximum(): number; */
  /// Gets or sets the maximum row height or column width, in local coordinates.
  /// The maximum describes the row height if #isRow is true;
  /// otherwise this describes the column width.
  ///
  /// The value must be non-negative.
  /// The default value is Infinity.
  /// The arranged height of all objects in this row,
  /// or the arranged width of all objects in this column,
  /// will be no greater than this value.
  _i2.num get maximum => _i5.getProperty(
        this,
        'maximum',
      );
  /* #18075
  source: 
    /**
     * Gets or sets the maximum row height or column width, in local coordinates.
     * The maximum describes the row height if #isRow is true;
     * otherwise this describes the column width.
     *
     * The value must be non-negative.
     * The default value is Infinity.
     * The arranged height of all objects in this row,
     * or the arranged width of all objects in this column,
     * will be no greater than this value.
     * @see #width
     * @see #height
     * @see #minimum
     * @see #sizing
     */
    get maximum(): number; */
  // Type InteropStaticType.number
  set maximum(_i2.num value) {
    _i5.setProperty(
      this,
      'maximum',
      value,
    );
  }

  /* #18091
  source: 
    /**
     * Gets or sets a default alignment for elements that are in this row or column.
     * The value must be a Spot.
     * The default value is Spot.Default, so that this RowColumnDefinition
     * does not supply any alignment information for the row or column.
     *
     * When an element's GraphObject#alignment property is Spot.Default,
     * it gets the horizontal alignment from the element's column's RowColumnDefinition
     * and the vertical alignment from the element's row's RowColumnDefinition.
     * When that RowColumnDefinition#alignment property is also Default,
     * it takes the value from the table panel's Panel#defaultAlignment property.
     * @see GraphObject#alignment
     * @see Panel#defaultAlignment
     */
    get alignment(): Spot; */
  /// Gets or sets a default alignment for elements that are in this row or column.
  /// The value must be a Spot.
  /// The default value is Spot.Default, so that this RowColumnDefinition
  /// does not supply any alignment information for the row or column.
  ///
  /// When an element's GraphObject#alignment property is Spot.Default,
  /// it gets the horizontal alignment from the element's column's RowColumnDefinition
  /// and the vertical alignment from the element's row's RowColumnDefinition.
  /// When that RowColumnDefinition#alignment property is also Default,
  /// it takes the value from the table panel's Panel#defaultAlignment property.
  _i3.Spot get alignment => _i5.getProperty(
        this,
        'alignment',
      );
  /* #18091
  source: 
    /**
     * Gets or sets a default alignment for elements that are in this row or column.
     * The value must be a Spot.
     * The default value is Spot.Default, so that this RowColumnDefinition
     * does not supply any alignment information for the row or column.
     *
     * When an element's GraphObject#alignment property is Spot.Default,
     * it gets the horizontal alignment from the element's column's RowColumnDefinition
     * and the vertical alignment from the element's row's RowColumnDefinition.
     * When that RowColumnDefinition#alignment property is also Default,
     * it takes the value from the table panel's Panel#defaultAlignment property.
     * @see GraphObject#alignment
     * @see Panel#defaultAlignment
     */
    get alignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set alignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'alignment',
      value,
    );
  }

  /* #18111
  source: 
    /**
     * Gets or sets the default stretch for elements that are in this row or column.
     * The only accepted values are listed as constant properties of GraphObject:
     * GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, GraphObject.Vertical, or GraphObject.Default.
     * The default value is GraphObject.Default, so that this RowColumnDefinition
     * does not supply any stretch information for the row or column.
     *
     * When an element's GraphObject#stretch property is GraphObject.Default,
     * it gets the horizontal stretch from the element's column's RowColumnDefinition
     * and the vertical stretch from the element's row's RowColumnDefinition.
     * When that RowColumnDefinition#stretch property is also Default,
     * it takes the value from the table panel's Panel#defaultStretch property.
     * @see GraphObject#stretch
     * @see Panel#defaultStretch
     * @see #sizing
     * @see #width
     * @see #height
     */
    get stretch(): EnumValue; */
  /// Gets or sets the default stretch for elements that are in this row or column.
  /// The only accepted values are listed as constant properties of GraphObject:
  /// GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, GraphObject.Vertical, or GraphObject.Default.
  /// The default value is GraphObject.Default, so that this RowColumnDefinition
  /// does not supply any stretch information for the row or column.
  ///
  /// When an element's GraphObject#stretch property is GraphObject.Default,
  /// it gets the horizontal stretch from the element's column's RowColumnDefinition
  /// and the vertical stretch from the element's row's RowColumnDefinition.
  /// When that RowColumnDefinition#stretch property is also Default,
  /// it takes the value from the table panel's Panel#defaultStretch property.
  _i3.EnumValue get stretch => _i5.getProperty(
        this,
        'stretch',
      );
  /* #18111
  source: 
    /**
     * Gets or sets the default stretch for elements that are in this row or column.
     * The only accepted values are listed as constant properties of GraphObject:
     * GraphObject.None, GraphObject.Fill, GraphObject.Horizontal, GraphObject.Vertical, or GraphObject.Default.
     * The default value is GraphObject.Default, so that this RowColumnDefinition
     * does not supply any stretch information for the row or column.
     *
     * When an element's GraphObject#stretch property is GraphObject.Default,
     * it gets the horizontal stretch from the element's column's RowColumnDefinition
     * and the vertical stretch from the element's row's RowColumnDefinition.
     * When that RowColumnDefinition#stretch property is also Default,
     * it takes the value from the table panel's Panel#defaultStretch property.
     * @see GraphObject#stretch
     * @see Panel#defaultStretch
     * @see #sizing
     * @see #width
     * @see #height
     */
    get stretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set stretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'stretch',
      value,
    );
  }

  /* #18128
  source: 
    /**
     * Gets or sets the additional padding for a particular row or column, in local coordinates.
     * Padding is applied on two sides - before and after a row or column's contents.
     * The #separatorStrokeWidth comes before any padding Margin#top or Margin#left.
     *
     * The default value is null, so that this RowColumnDefinition
     * does not supply any padding information for the row or column.
     * There may still be some padding between rows and/or columns if Panel#defaultSeparatorPadding is non-zero.
     * @see Panel#defaultSeparatorPadding
     * @see #separatorStroke
     * @see #separatorStrokeWidth
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorPadding(): MarginLike; */
  /// Gets or sets the additional padding for a particular row or column, in local coordinates.
  /// Padding is applied on two sides - before and after a row or column's contents.
  /// The #separatorStrokeWidth comes before any padding Margin#top or Margin#left.
  ///
  /// The default value is null, so that this RowColumnDefinition
  /// does not supply any padding information for the row or column.
  /// There may still be some padding between rows and/or columns if Panel#defaultSeparatorPadding is non-zero.
  _i3.MarginLike get separatorPadding => _i5.getProperty(
        this,
        'separatorPadding',
      );
  /* #18128
  source: 
    /**
     * Gets or sets the additional padding for a particular row or column, in local coordinates.
     * Padding is applied on two sides - before and after a row or column's contents.
     * The #separatorStrokeWidth comes before any padding Margin#top or Margin#left.
     *
     * The default value is null, so that this RowColumnDefinition
     * does not supply any padding information for the row or column.
     * There may still be some padding between rows and/or columns if Panel#defaultSeparatorPadding is non-zero.
     * @see Panel#defaultSeparatorPadding
     * @see #separatorStroke
     * @see #separatorStrokeWidth
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorPadding(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set separatorPadding(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'separatorPadding',
      value,
    );
  }

  /* #18149
  source: 
    /**
     * Gets or sets the stroke (color) for the separator line that is drawn before a particular row or column,
     * provided that row or column has a nonzero #separatorStrokeWidth.
     *
     * The default value is null, so that this RowColumnDefinition
     * does not specify any brush for the separator line to draw before the row or column.
     * The line may still be drawn if the value of Panel#defaultRowSeparatorStroke or
     * Panel#defaultColumnSeparatorStroke is non-null.
     *
     * However, if no stroke color is specified, then no stroke width will be drawn,
     * even if the #separatorStrokeWidth value is non-zero.
     * @see Panel#defaultColumnSeparatorStroke
     * @see Panel#defaultRowSeparatorStroke
     * @see #separatorPadding
     * @see #separatorStrokeWidth
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorStroke(): BrushLike; */
  /// Gets or sets the stroke (color) for the separator line that is drawn before a particular row or column,
  /// provided that row or column has a nonzero #separatorStrokeWidth.
  ///
  /// The default value is null, so that this RowColumnDefinition
  /// does not specify any brush for the separator line to draw before the row or column.
  /// The line may still be drawn if the value of Panel#defaultRowSeparatorStroke or
  /// Panel#defaultColumnSeparatorStroke is non-null.
  ///
  /// However, if no stroke color is specified, then no stroke width will be drawn,
  /// even if the #separatorStrokeWidth value is non-zero.
  _i3.BrushLike get separatorStroke => _i5.getProperty(
        this,
        'separatorStroke',
      );
  /* #18149
  source: 
    /**
     * Gets or sets the stroke (color) for the separator line that is drawn before a particular row or column,
     * provided that row or column has a nonzero #separatorStrokeWidth.
     *
     * The default value is null, so that this RowColumnDefinition
     * does not specify any brush for the separator line to draw before the row or column.
     * The line may still be drawn if the value of Panel#defaultRowSeparatorStroke or
     * Panel#defaultColumnSeparatorStroke is non-null.
     *
     * However, if no stroke color is specified, then no stroke width will be drawn,
     * even if the #separatorStrokeWidth value is non-zero.
     * @see Panel#defaultColumnSeparatorStroke
     * @see Panel#defaultRowSeparatorStroke
     * @see #separatorPadding
     * @see #separatorStrokeWidth
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorStroke(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set separatorStroke(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'separatorStroke',
      value ?? _i4.undefined,
    );
  }

  /* #18166
  source: 
    /**
     * Gets or sets the stroke width for a particular row or column's separator line, in local coordinates.
     *
     * The default value is NaN, so that this RowColumnDefinition
     * does not supply any stroke width information for what is drawn before the row or column.
     * The separator line may still be drawn if Panel#defaultRowSeparatorStroke
     * or Panel#defaultColumnSeparatorStroke is a real number (they default to 1).
     * @see Panel#defaultColumnSeparatorStrokeWidth
     * @see Panel#defaultRowSeparatorStrokeWidth
     * @see #separatorPadding
     * @see #separatorStroke
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorStrokeWidth(): number; */
  /// Gets or sets the stroke width for a particular row or column's separator line, in local coordinates.
  ///
  /// The default value is NaN, so that this RowColumnDefinition
  /// does not supply any stroke width information for what is drawn before the row or column.
  /// The separator line may still be drawn if Panel#defaultRowSeparatorStroke
  /// or Panel#defaultColumnSeparatorStroke is a real number (they default to 1).
  _i2.num get separatorStrokeWidth => _i5.getProperty(
        this,
        'separatorStrokeWidth',
      );
  /* #18166
  source: 
    /**
     * Gets or sets the stroke width for a particular row or column's separator line, in local coordinates.
     *
     * The default value is NaN, so that this RowColumnDefinition
     * does not supply any stroke width information for what is drawn before the row or column.
     * The separator line may still be drawn if Panel#defaultRowSeparatorStroke
     * or Panel#defaultColumnSeparatorStroke is a real number (they default to 1).
     * @see Panel#defaultColumnSeparatorStrokeWidth
     * @see Panel#defaultRowSeparatorStrokeWidth
     * @see #separatorPadding
     * @see #separatorStroke
     * @see #separatorDashArray
     * @see #background
     * @since 1.2
     */
    get separatorStrokeWidth(): number; */
  // Type InteropStaticType.number
  set separatorStrokeWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'separatorStrokeWidth',
      value,
    );
  }

  /* #18191
  source: 
    /**
     * Gets or sets the dash array for dashing the separator line, provided this
     * row or column has a nonzero RowColumnDefinition#separatorStrokeWidth and non-null RowColumnDefinition#separatorStroke.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null, so that this RowColumnDefinition
     * does not supply any stroke dash array information for what is drawn before the row or column.
     * The separator line may still be drawn using dashes if Panel#defaultRowSeparatorDashArray
     * or Panel#defaultColumnSeparatorDashArray is non-null.
     * @see Panel#defaultColumnSeparatorDashArray
     * @see Panel#defaultRowSeparatorDashArray
     * @see #separatorPadding
     * @see #separatorStroke
     * @see #separatorStrokeWidth
     * @see #background
     * @since 1.2
     */
    get separatorDashArray(): Array<number> | null; */
  /// Gets or sets the dash array for dashing the separator line, provided this
  /// row or column has a nonzero RowColumnDefinition#separatorStrokeWidth and non-null RowColumnDefinition#separatorStroke.
  ///
  /// Must be an array of positive numbers and zeroes,
  /// or else null to indicate a solid line.
  ///
  /// For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
  ///
  /// Setting an array with all zeroes will set the value to null.
  ///
  /// Default is null, so that this RowColumnDefinition
  /// does not supply any stroke dash array information for what is drawn before the row or column.
  /// The separator line may still be drawn using dashes if Panel#defaultRowSeparatorDashArray
  /// or Panel#defaultColumnSeparatorDashArray is non-null.
  _i4.Array? get separatorDashArray => _i5.getProperty(
        this,
        'separatorDashArray',
      );
  /* #18191
  source: 
    /**
     * Gets or sets the dash array for dashing the separator line, provided this
     * row or column has a nonzero RowColumnDefinition#separatorStrokeWidth and non-null RowColumnDefinition#separatorStroke.
     *
     * Must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     *
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     *
     * Setting an array with all zeroes will set the value to null.
     *
     * Default is null, so that this RowColumnDefinition
     * does not supply any stroke dash array information for what is drawn before the row or column.
     * The separator line may still be drawn using dashes if Panel#defaultRowSeparatorDashArray
     * or Panel#defaultColumnSeparatorDashArray is non-null.
     * @see Panel#defaultColumnSeparatorDashArray
     * @see Panel#defaultRowSeparatorDashArray
     * @see #separatorPadding
     * @see #separatorStroke
     * @see #separatorStrokeWidth
     * @see #background
     * @since 1.2
     */
    get separatorDashArray(): Array<number> | null; */
  // Type InteropUnion#461855030(parent: InteropGetter#568151057(name: separatorDashArray))
  set separatorDashArray(_i4.Array? value) {
    _i5.setProperty(
      this,
      'separatorDashArray',
      value ?? _i4.undefined,
    );
  }

  /* #18201
  source: 
    /**
     * Gets or sets the background color for a particular row or column,
     * which fills the entire span of the row or column, including any separatorPadding.
     *
     * The default value is null, which means nothing is drawn in the background of the row or column.
     * @see GraphObject#background
     * @since 1.2
     */
    get background(): BrushLike; */
  /// Gets or sets the background color for a particular row or column,
  /// which fills the entire span of the row or column, including any separatorPadding.
  ///
  /// The default value is null, which means nothing is drawn in the background of the row or column.
  _i3.BrushLike get background => _i5.getProperty(
        this,
        'background',
      );
  /* #18201
  source: 
    /**
     * Gets or sets the background color for a particular row or column,
     * which fills the entire span of the row or column, including any separatorPadding.
     *
     * The default value is null, which means nothing is drawn in the background of the row or column.
     * @see GraphObject#background
     * @since 1.2
     */
    get background(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set background(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'background',
      value ?? _i4.undefined,
    );
  }

  /* #18209
  source: 
    /**
     * Determines whether or not the #background, if there is one, is in front of or behind the separators.
     *
     * The default value is false -- any background is drawn behind any separator lines.
     * @since 1.2
     */
    get coversSeparators(): boolean; */
  /// Determines whether or not the #background, if there is one, is in front of or behind the separators.
  ///
  /// The default value is false -- any background is drawn behind any separator lines.
  _i2.bool get coversSeparators => _i5.getProperty(
        this,
        'coversSeparators',
      );
  /* #18209
  source: 
    /**
     * Determines whether or not the #background, if there is one, is in front of or behind the separators.
     *
     * The default value is false -- any background is drawn behind any separator lines.
     * @since 1.2
     */
    get coversSeparators(): boolean; */
  // Type InteropStaticType.boolean
  set coversSeparators(_i2.bool value) {
    _i5.setProperty(
      this,
      'coversSeparators',
      value,
    );
  }

  /* #18223
  source: 
    /**
     * Gets or sets how this row or column deals with a Table Panel's extra space.
     * The value must be one of: RowColumnDefinition.None, RowColumnDefinition.ProportionalExtra,
     * or RowColumnDefinition.Default.
     * The default value is RowColumnDefinition.Default.
     * @see Panel#columnSizing
     * @see Panel#rowSizing
     * @see #actual
     * @see #total
     * @see #height
     * @see #width
     */
    get sizing(): EnumValue; */
  /// Gets or sets how this row or column deals with a Table Panel's extra space.
  /// The value must be one of: RowColumnDefinition.None, RowColumnDefinition.ProportionalExtra,
  /// or RowColumnDefinition.Default.
  /// The default value is RowColumnDefinition.Default.
  _i3.EnumValue get sizing => _i5.getProperty(
        this,
        'sizing',
      );
  /* #18223
  source: 
    /**
     * Gets or sets how this row or column deals with a Table Panel's extra space.
     * The value must be one of: RowColumnDefinition.None, RowColumnDefinition.ProportionalExtra,
     * or RowColumnDefinition.Default.
     * The default value is RowColumnDefinition.Default.
     * @see Panel#columnSizing
     * @see Panel#rowSizing
     * @see #actual
     * @see #total
     * @see #height
     * @see #width
     */
    get sizing(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set sizing(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'sizing',
      value,
    );
  }

  /* #18239
  source: 
    /**
     * This read-only property returns the usable row height or column width, after arrangement, in local coordinates,
     * that objects in this row or column can be arranged within.
     * This does not include #separatorPadding or #separatorStrokeWidth, as #total does.
     *
     * This value gives the row height if #isRow is true;
     * otherwise this gives the column width.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see #total
     * @see #height
     * @see #width
     * @see #sizing
     */
    get actual(): number; */
  /// This read-only property returns the usable row height or column width, after arrangement, in local coordinates,
  /// that objects in this row or column can be arranged within.
  /// This does not include #separatorPadding or #separatorStrokeWidth, as #total does.
  ///
  /// This value gives the row height if #isRow is true;
  /// otherwise this gives the column width.
  /// The value is meaningless until after the Table Panel using this
  /// RowColumnDefinition has been arranged.
  _i2.num get actual => _i5.getProperty(
        this,
        'actual',
      );
  /* #18239
  source: 
    /**
     * This read-only property returns the usable row height or column width, after arrangement, in local coordinates,
     * that objects in this row or column can be arranged within.
     * This does not include #separatorPadding or #separatorStrokeWidth, as #total does.
     *
     * This value gives the row height if #isRow is true;
     * otherwise this gives the column width.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see #total
     * @see #height
     * @see #width
     * @see #sizing
     */
    get actual(): number; */
  // Type InteropStaticType.number
  set actual(_i2.num value) {
    _i5.setProperty(
      this,
      'actual',
      value,
    );
  }

  /* #18244
  source: 
    /**
     * (undocumented)
     */
    get measured(): number; */
  /// (undocumented)
  _i2.num get measured => _i5.getProperty(
        this,
        'measured',
      );
  /* #18244
  source: 
    /**
     * (undocumented)
     */
    get measured(): number; */
  // Type InteropStaticType.number
  set measured(_i2.num value) {
    _i5.setProperty(
      this,
      'measured',
      value,
    );
  }

  /* #18260
  source: 
    /**
     * This read-only property returns the total arranged row height or column width, after arrangement, in local coordinates.
     * This value gives the #actual size plus the #separatorPadding and #separatorStrokeWidth.
     *
     * This value gives the vertical space occupied by the row if #isRow is true;
     * otherwise this gives the horizontal space occupied by the column.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see #actual
     * @see #height
     * @see #width
     * @see #sizing
     * @since 1.2
     */
    get total(): number; */
  /// This read-only property returns the total arranged row height or column width, after arrangement, in local coordinates.
  /// This value gives the #actual size plus the #separatorPadding and #separatorStrokeWidth.
  ///
  /// This value gives the vertical space occupied by the row if #isRow is true;
  /// otherwise this gives the horizontal space occupied by the column.
  /// The value is meaningless until after the Table Panel using this
  /// RowColumnDefinition has been arranged.
  _i2.num get total => _i5.getProperty(
        this,
        'total',
      );
  /* #18260
  source: 
    /**
     * This read-only property returns the total arranged row height or column width, after arrangement, in local coordinates.
     * This value gives the #actual size plus the #separatorPadding and #separatorStrokeWidth.
     *
     * This value gives the vertical space occupied by the row if #isRow is true;
     * otherwise this gives the horizontal space occupied by the column.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see #actual
     * @see #height
     * @see #width
     * @see #sizing
     * @since 1.2
     */
    get total(): number; */
  // Type InteropStaticType.number
  set total(_i2.num value) {
    _i5.setProperty(
      this,
      'total',
      value,
    );
  }

  /* #18273
  source: 
    /**
     * This read-only property returns the actual arranged row or column starting position, after arrangement, in local coordinates.
     * This value gives the Y position if #isRow is true;
     * otherwise this gives the X position.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see Panel#findColumnForLocalX
     * @see Panel#findRowForLocalY
     * @see Panel#leftIndex
     * @see Panel#topIndex
     * @see #index
     */
    get position(): number; */
  /// This read-only property returns the actual arranged row or column starting position, after arrangement, in local coordinates.
  /// This value gives the Y position if #isRow is true;
  /// otherwise this gives the X position.
  /// The value is meaningless until after the Table Panel using this
  /// RowColumnDefinition has been arranged.
  _i2.num get position => _i5.getProperty(
        this,
        'position',
      );
  /* #18273
  source: 
    /**
     * This read-only property returns the actual arranged row or column starting position, after arrangement, in local coordinates.
     * This value gives the Y position if #isRow is true;
     * otherwise this gives the X position.
     * The value is meaningless until after the Table Panel using this
     * RowColumnDefinition has been arranged.
     * @see Panel#findColumnForLocalX
     * @see Panel#findRowForLocalY
     * @see Panel#leftIndex
     * @see Panel#topIndex
     * @see #index
     */
    get position(): number; */
  // Type InteropStaticType.number
  set position(_i2.num value) {
    _i5.setProperty(
      this,
      'position',
      value,
    );
  }

  _i2.num computeEffectiveSpacingTop(_i2.num first) => _i5.callMethod(
        this,
        'computeEffectiveSpacingTop',
        [first],
      );
  _i2.num computeEffectiveSpacing() => _i5.callMethod(
        this,
        'computeEffectiveSpacing',
        [],
      );
  _i3.RowColumnDefinition _bind$1(_i3.Binding binding) => _i5.callMethod(
        this,
        'bind',
        [binding],
      );
  _i3.RowColumnDefinition _bind$2([
    _i2.String? targetprop,
    _i2.String? sourceprop,
    _i3.TargetConversion? conv,
    _i3.BackConversion? backconv,
  ]) =>
      _i5.callMethod(
        this,
        'bind',
        [
          targetprop ?? _i4.undefined,
          sourceprop ?? _i4.undefined,
          conv == null ? _i4.undefined : _i5.allowInterop(conv),
          backconv == null ? _i4.undefined : _i5.allowInterop(backconv),
        ],
      );
  // HEYA bind
  ({
    _i3.RowColumnDefinition Function(_i3.Binding binding) $1,
    _i3.RowColumnDefinition Function([
      _i2.String? targetprop,
      _i2.String? sourceprop,
      _i3.TargetConversion? conv,
      _i3.BackConversion? backconv,
    ]) $2,
  }) get bind => (
        $1: _bind$1,
        $2: _bind$2,
      );
}

@_i1.JS()
@_i1.staticInterop
class Shape implements _i3.GraphObject {
  factory Shape.$1() => _i5.callConstructor(
        _declaredShape,
        [],
      );

  factory Shape.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredShape,
        [init ?? _i4.undefined],
      );

  factory Shape.$3([
    _i2.String? figure,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredShape,
        [
          figure ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  static _i3.Map<_i2.String, _i2.Object> getFigureGenerators() =>
      _i5.callMethod(
        _declaredShape,
        'getFigureGenerators',
        [],
      );
  static void defineFigureGenerator(
    _i2.String name,
    _i2.Object func,
  ) {
    _i5.callMethod(
      _declaredShape,
      'defineFigureGenerator',
      [
        name,
        func,
      ],
    );
  }

  static _i3.Map<_i2.String, _i3.Geometry> getArrowheadGeometries() =>
      _i5.callMethod(
        _declaredShape,
        'getArrowheadGeometries',
        [],
      );
  static void defineArrowheadGeometry(
    _i2.String name,
    _i2.Object pathstr,
  ) {
    _i5.callMethod(
      _declaredShape,
      'defineArrowheadGeometry',
      [
        name,
        pathstr,
      ],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Shape')
external _i2.Object _declaredShape;

extension Shape$Typings on Shape {
  /* #18444
  source: 
    /**
     * Gets or sets the Shape's Geometry that defines the Shape's figure.
     * Setting a geometry is not necessary if a #figure is specified,
     * as that will construct a geometry instead.
     *
     * Setting this geometry property will freeze the supplied Geometry.
     *
     * Setting this geometry property always overrides any set figure.
     * The default value is null.
     * @see #geometryString
     */
    get geometry(): Geometry | null; */
  /// Gets or sets the Shape's Geometry that defines the Shape's figure.
  /// Setting a geometry is not necessary if a #figure is specified,
  /// as that will construct a geometry instead.
  ///
  /// Setting this geometry property will freeze the supplied Geometry.
  ///
  /// Setting this geometry property always overrides any set figure.
  /// The default value is null.
  _i3.Geometry? get geometry => _i5.getProperty(
        this,
        'geometry',
      );
  /* #18444
  source: 
    /**
     * Gets or sets the Shape's Geometry that defines the Shape's figure.
     * Setting a geometry is not necessary if a #figure is specified,
     * as that will construct a geometry instead.
     *
     * Setting this geometry property will freeze the supplied Geometry.
     *
     * Setting this geometry property always overrides any set figure.
     * The default value is null.
     * @see #geometryString
     */
    get geometry(): Geometry | null; */
  // Type InteropUnion#387356723(parent: InteropGetter#114642330(name: geometry))
  set geometry(_i3.Geometry? value) {
    _i5.setProperty(
      this,
      'geometry',
      value ?? _i4.undefined,
    );
  }

  /* #18456
  source: 
    /**
     * When set, creates a Geometry and normalizes it from a given path string,
     * then sets the #geometry property on this Shape and
     * set the GraphObject#position to the amount computed by normalization.
     * The property getter simply returns the toString value of the #geometry,
     * or the empty string if there is no Geometry value.
     *
     * See the <a href="../../intro/geometry.html">Geometry Path Strings Introduction page</a> for examples.
     * @since 1.1
     */
    get geometryString(): string; */
  /// When set, creates a Geometry and normalizes it from a given path string,
  /// then sets the #geometry property on this Shape and
  /// set the GraphObject#position to the amount computed by normalization.
  /// The property getter simply returns the toString value of the #geometry,
  /// or the empty string if there is no Geometry value.
  ///
  /// See the <a href="../../intro/geometry.html">Geometry Path Strings Introduction page</a> for examples.
  _i2.String get geometryString => _i5.getProperty(
        this,
        'geometryString',
      );
  /* #18456
  source: 
    /**
     * When set, creates a Geometry and normalizes it from a given path string,
     * then sets the #geometry property on this Shape and
     * set the GraphObject#position to the amount computed by normalization.
     * The property getter simply returns the toString value of the #geometry,
     * or the empty string if there is no Geometry value.
     *
     * See the <a href="../../intro/geometry.html">Geometry Path Strings Introduction page</a> for examples.
     * @since 1.1
     */
    get geometryString(): string; */
  // Type InteropStaticType.string
  set geometryString(_i2.String value) {
    _i5.setProperty(
      this,
      'geometryString',
      value,
    );
  }

  /* #18466
  source: 
    /**
     * Gets or sets the whether the GraphObject#position of this shape denotes
     * the top-left corner of this shape in panel coordinates or the origin of this geometry's coordinate system.
     * Basically, this determines whether the #strokeWidth affects the rendered location.
     * A true value allows multiple shapes to be positioned precisely in a "Position" Panel independent of the stroke width.
     * The default is false.
     * @since 1.1
     */
    get isGeometryPositioned(): boolean; */
  /// Gets or sets the whether the GraphObject#position of this shape denotes
  /// the top-left corner of this shape in panel coordinates or the origin of this geometry's coordinate system.
  /// Basically, this determines whether the #strokeWidth affects the rendered location.
  /// A true value allows multiple shapes to be positioned precisely in a "Position" Panel independent of the stroke width.
  /// The default is false.
  _i2.bool get isGeometryPositioned => _i5.getProperty(
        this,
        'isGeometryPositioned',
      );
  /* #18466
  source: 
    /**
     * Gets or sets the whether the GraphObject#position of this shape denotes
     * the top-left corner of this shape in panel coordinates or the origin of this geometry's coordinate system.
     * Basically, this determines whether the #strokeWidth affects the rendered location.
     * A true value allows multiple shapes to be positioned precisely in a "Position" Panel independent of the stroke width.
     * The default is false.
     * @since 1.1
     */
    get isGeometryPositioned(): boolean; */
  // Type InteropStaticType.boolean
  set isGeometryPositioned(_i2.bool value) {
    _i5.setProperty(
      this,
      'isGeometryPositioned',
      value,
    );
  }

  /* #18483
  source: 
    /**
     * Gets or sets the Brush or string that describes how the geometry is filled when drawn.
     *
     * The default value is "black", causing the shape to be filled with solid black.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * A null fill will mean no fill is drawn and the filled portion
     * of the Shape will not be pickable.
     * A "transparent" fill is useful when wanting to allow a shape to be pickable
     * without obscuring any other objects behind it.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     *
     * The geometry is filled before the #stroke is drawn.
     */
    get fill(): BrushLike; */
  /// Gets or sets the Brush or string that describes how the geometry is filled when drawn.
  ///
  /// The default value is "black", causing the shape to be filled with solid black.
  /// Any valid CSS string can specify a solid color, and the Brush
  /// class can be used to specify a gradient or pattern.
  /// A null fill will mean no fill is drawn and the filled portion
  /// of the Shape will not be pickable.
  /// A "transparent" fill is useful when wanting to allow a shape to be pickable
  /// without obscuring any other objects behind it.
  /// More information about the syntax of CSS color strings is available at:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
  ///
  /// The geometry is filled before the #stroke is drawn.
  _i3.BrushLike get fill => _i5.getProperty(
        this,
        'fill',
      );
  /* #18483
  source: 
    /**
     * Gets or sets the Brush or string that describes how the geometry is filled when drawn.
     *
     * The default value is "black", causing the shape to be filled with solid black.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * A null fill will mean no fill is drawn and the filled portion
     * of the Shape will not be pickable.
     * A "transparent" fill is useful when wanting to allow a shape to be pickable
     * without obscuring any other objects behind it.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     *
     * The geometry is filled before the #stroke is drawn.
     */
    get fill(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set fill(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'fill',
      value ?? _i4.undefined,
    );
  }

  /* #18499
  source: 
    /**
     * Gets or sets the Brush or string that describes how the geometry is drawn as if by a pen.
     *
     * The default value is "black", causing the shape to be outlined in black.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * A null stroke will mean no stroke is drawn.
     * A "transparent" stroke is useful when wanting to allow a shape to be pickable
     * without obscuring any other objects behind it.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     *
     * The stroke is drawn after the geometry is filled with the #fill Brush.
     */
    get stroke(): BrushLike; */
  /// Gets or sets the Brush or string that describes how the geometry is drawn as if by a pen.
  ///
  /// The default value is "black", causing the shape to be outlined in black.
  /// Any valid CSS string can specify a solid color, and the Brush
  /// class can be used to specify a gradient or pattern.
  /// A null stroke will mean no stroke is drawn.
  /// A "transparent" stroke is useful when wanting to allow a shape to be pickable
  /// without obscuring any other objects behind it.
  /// More information about the syntax of CSS color strings is available at:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
  ///
  /// The stroke is drawn after the geometry is filled with the #fill Brush.
  _i3.BrushLike get stroke => _i5.getProperty(
        this,
        'stroke',
      );
  /* #18499
  source: 
    /**
     * Gets or sets the Brush or string that describes how the geometry is drawn as if by a pen.
     *
     * The default value is "black", causing the shape to be outlined in black.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * A null stroke will mean no stroke is drawn.
     * A "transparent" stroke is useful when wanting to allow a shape to be pickable
     * without obscuring any other objects behind it.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     *
     * The stroke is drawn after the geometry is filled with the #fill Brush.
     */
    get stroke(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set stroke(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'stroke',
      value ?? _i4.undefined,
    );
  }

  /* #18514
  source: 
    /**
     * Gets or sets the thickness of the stroke's pen.
     *
     * Value must be a real number greater than or equal to zero.
     * The default value is 1.0.
     *
     * A value of zero will cause the stroke not to be drawn.
     * However, Main Shapes of Link Selection Adornments with a strokeWidth of 0
     * will inherit the strokeWidth from the Link's main Shape.
     *
     * The stroke width will affect the GraphObject#measuredBounds and GraphObject#actualBounds of this shape.
     * The stroke is drawn centered on the path of the geometry.
     */
    get strokeWidth(): number; */
  /// Gets or sets the thickness of the stroke's pen.
  ///
  /// Value must be a real number greater than or equal to zero.
  /// The default value is 1.0.
  ///
  /// A value of zero will cause the stroke not to be drawn.
  /// However, Main Shapes of Link Selection Adornments with a strokeWidth of 0
  /// will inherit the strokeWidth from the Link's main Shape.
  ///
  /// The stroke width will affect the GraphObject#measuredBounds and GraphObject#actualBounds of this shape.
  /// The stroke is drawn centered on the path of the geometry.
  _i2.num get strokeWidth => _i5.getProperty(
        this,
        'strokeWidth',
      );
  /* #18514
  source: 
    /**
     * Gets or sets the thickness of the stroke's pen.
     *
     * Value must be a real number greater than or equal to zero.
     * The default value is 1.0.
     *
     * A value of zero will cause the stroke not to be drawn.
     * However, Main Shapes of Link Selection Adornments with a strokeWidth of 0
     * will inherit the strokeWidth from the Link's main Shape.
     *
     * The stroke width will affect the GraphObject#measuredBounds and GraphObject#actualBounds of this shape.
     * The stroke is drawn centered on the path of the geometry.
     */
    get strokeWidth(): number; */
  // Type InteropStaticType.number
  set strokeWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'strokeWidth',
      value,
    );
  }

  /* #18522
  source: 
    /**
     * Gets or sets the style for how the ends of the stroke's line are drawn.
     * The value must be one of "butt", "round", or "square". The default is "butt".
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linecap">Stroke Line Cap (w3.org)</a>.
     */
    get strokeCap(): ('butt' | 'round' | 'square'); */
  /// Gets or sets the style for how the ends of the stroke's line are drawn.
  /// The value must be one of "butt", "round", or "square". The default is "butt".
  ///
  /// For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linecap">Stroke Line Cap (w3.org)</a>.
  StrokeCap get strokeCap => StrokeCap.values.byName(_i5.getProperty(
        this,
        'strokeCap',
      ));
  /* #18522
  source: 
    /**
     * Gets or sets the style for how the ends of the stroke's line are drawn.
     * The value must be one of "butt", "round", or "square". The default is "butt".
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linecap">Stroke Line Cap (w3.org)</a>.
     */
    get strokeCap(): ('butt' | 'round' | 'square'); */
  // Type InteropUnion#73663473(parent: InteropGetter#405072051(name: strokeCap))
  set strokeCap(StrokeCap value) {
    _i5.setProperty(
      this,
      'strokeCap',
      value.name,
    );
  }

  /* #18530
  source: 
    /**
     * Gets or sets the type of corner that will be drawn for a stroke at the intersection of two straight segments of the geometry.
     * The value must be one of "miter", "bevel", or "round". The default is "miter".
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linejoin">Stroke Line Join (w3.org)</a>.
     */
    get strokeJoin(): ('miter' | 'bevel' | 'round'); */
  /// Gets or sets the type of corner that will be drawn for a stroke at the intersection of two straight segments of the geometry.
  /// The value must be one of "miter", "bevel", or "round". The default is "miter".
  ///
  /// For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linejoin">Stroke Line Join (w3.org)</a>.
  StrokeJoin get strokeJoin => StrokeJoin.values.byName(_i5.getProperty(
        this,
        'strokeJoin',
      ));
  /* #18530
  source: 
    /**
     * Gets or sets the type of corner that will be drawn for a stroke at the intersection of two straight segments of the geometry.
     * The value must be one of "miter", "bevel", or "round". The default is "miter".
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linejoin">Stroke Line Join (w3.org)</a>.
     */
    get strokeJoin(): ('miter' | 'bevel' | 'round'); */
  // Type InteropUnion#802523728(parent: InteropGetter#92695927(name: strokeJoin))
  set strokeJoin(StrokeJoin value) {
    _i5.setProperty(
      this,
      'strokeJoin',
      value.name,
    );
  }

  /* #18539
  source: 
    /**
     * Gets or sets the style for the stroke's mitre limit ratio.
     * The value must be a real number greater than or equal to one.
     * The default is 10.0.
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-miterlimit">Stroke Miter Limit (w3.org)</a>.
     */
    get strokeMiterLimit(): number; */
  /// Gets or sets the style for the stroke's mitre limit ratio.
  /// The value must be a real number greater than or equal to one.
  /// The default is 10.0.
  ///
  /// For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-miterlimit">Stroke Miter Limit (w3.org)</a>.
  _i2.num get strokeMiterLimit => _i5.getProperty(
        this,
        'strokeMiterLimit',
      );
  /* #18539
  source: 
    /**
     * Gets or sets the style for the stroke's mitre limit ratio.
     * The value must be a real number greater than or equal to one.
     * The default is 10.0.
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-miterlimit">Stroke Miter Limit (w3.org)</a>.
     */
    get strokeMiterLimit(): number; */
  // Type InteropStaticType.number
  set strokeMiterLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'strokeMiterLimit',
      value,
    );
  }

  /* #18552
  source: 
    /**
     * Gets or sets the dash array for creating dashed or dotted lines.
     * The value must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-setlinedash">Stroke Line Dash Array (w3.org)</a>.
     *
     * The default value is null, resulting in a line without dashes or dots.
     * Setting an array with all zeroes will set the value to null.
     * @since 1.1
     */
    get strokeDashArray(): Array<number> | null; */
  /// Gets or sets the dash array for creating dashed or dotted lines.
  /// The value must be an array of positive numbers and zeroes,
  /// or else null to indicate a solid line.
  /// For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
  /// For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-setlinedash">Stroke Line Dash Array (w3.org)</a>.
  ///
  /// The default value is null, resulting in a line without dashes or dots.
  /// Setting an array with all zeroes will set the value to null.
  _i4.Array? get strokeDashArray => _i5.getProperty(
        this,
        'strokeDashArray',
      );
  /* #18552
  source: 
    /**
     * Gets or sets the dash array for creating dashed or dotted lines.
     * The value must be an array of positive numbers and zeroes,
     * or else null to indicate a solid line.
     * For example, the array [5, 10] would create dashes of 5 pixels and spaces of 10 pixels.
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-setlinedash">Stroke Line Dash Array (w3.org)</a>.
     *
     * The default value is null, resulting in a line without dashes or dots.
     * Setting an array with all zeroes will set the value to null.
     * @since 1.1
     */
    get strokeDashArray(): Array<number> | null; */
  // Type InteropUnion#327504735(parent: InteropGetter#548067030(name: strokeDashArray))
  set strokeDashArray(_i4.Array? value) {
    _i5.setProperty(
      this,
      'strokeDashArray',
      value ?? _i4.undefined,
    );
  }

  /* #18561
  source: 
    /**
     * Gets or sets the offset for dashed lines, used to start the drawing of the dash pattern with some space.
     * The value must be a real non-negative number. The default is zero.
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linedashoffset">Stroke Line Dash Offset (w3.org)</a>.
     * @since 1.1
     */
    get strokeDashOffset(): number; */
  /// Gets or sets the offset for dashed lines, used to start the drawing of the dash pattern with some space.
  /// The value must be a real non-negative number. The default is zero.
  ///
  /// For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linedashoffset">Stroke Line Dash Offset (w3.org)</a>.
  _i2.num get strokeDashOffset => _i5.getProperty(
        this,
        'strokeDashOffset',
      );
  /* #18561
  source: 
    /**
     * Gets or sets the offset for dashed lines, used to start the drawing of the dash pattern with some space.
     * The value must be a real non-negative number. The default is zero.
     *
     * For more information, see <a href="https://www.w3.org/TR/2dcontext/#dom-context-2d-linedashoffset">Stroke Line Dash Offset (w3.org)</a>.
     * @since 1.1
     */
    get strokeDashOffset(): number; */
  // Type InteropStaticType.number
  set strokeDashOffset(_i2.num value) {
    _i5.setProperty(
      this,
      'strokeDashOffset',
      value,
    );
  }

  /* #18576
  source: 
    /**
     * Gets or sets the figure name, used to construct a Geometry.
     * The value must be a string. The default value is "None".
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "roundedrectangle" will set the value of figure to "RoundedRectangle".
     * All of the predefined figures are shown in the <a href="../../samples/shapes.html">Shapes sample</a>.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named figures by calling the static function Shape.defineFigureGenerator.
     */
    get figure(): string; */
  /// Gets or sets the figure name, used to construct a Geometry.
  /// The value must be a string. The default value is "None".
  ///
  /// The name can be any case but will always be canonicalized when set. For instance,
  /// setting "roundedrectangle" will set the value of figure to "RoundedRectangle".
  /// All of the predefined figures are shown in the <a href="../../samples/shapes.html">Shapes sample</a>.
  ///
  /// At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
  /// #figure, #toArrow, #fromArrow.
  ///
  /// You can define your own named figures by calling the static function Shape.defineFigureGenerator.
  _i2.String get figure => _i5.getProperty(
        this,
        'figure',
      );
  /* #18576
  source: 
    /**
     * Gets or sets the figure name, used to construct a Geometry.
     * The value must be a string. The default value is "None".
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "roundedrectangle" will set the value of figure to "RoundedRectangle".
     * All of the predefined figures are shown in the <a href="../../samples/shapes.html">Shapes sample</a>.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named figures by calling the static function Shape.defineFigureGenerator.
     */
    get figure(): string; */
  // Type InteropStaticType.string
  set figure(_i2.String value) {
    _i5.setProperty(
      this,
      'figure',
      value,
    );
  }

  /* #18604
  source: 
    /**
     * Gets or sets the name of the kind of arrowhead that this shape should take
     * when this shape is an element of a Link.
     * Value must be a string.
     *
     * The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
     * If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
     * the GraphObject#visible property, or you can set or bind this "toArrow" property to
     * be the empty string.
     * The arrowhead named "", an empty string, will display as nothing.
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
     * All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     *
     * Setting this property may also set the GraphObject#segmentIndex,
     * GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
     * This shape should be an element of a Link.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
     *
     * You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
     */
    get toArrow(): string; */
  /// Gets or sets the name of the kind of arrowhead that this shape should take
  /// when this shape is an element of a Link.
  /// Value must be a string.
  ///
  /// The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
  /// If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
  /// the GraphObject#visible property, or you can set or bind this "toArrow" property to
  /// be the empty string.
  /// The arrowhead named "", an empty string, will display as nothing.
  ///
  /// The name can be any case but will always be canonicalized when set. For instance,
  /// setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
  /// All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
  ///
  /// Setting this property may also set the GraphObject#segmentIndex,
  /// GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
  /// This shape should be an element of a Link.
  ///
  /// At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
  /// #figure, #toArrow, #fromArrow.
  ///
  /// You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
  ///
  /// You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
  _i2.String get toArrow => _i5.getProperty(
        this,
        'toArrow',
      );
  /* #18604
  source: 
    /**
     * Gets or sets the name of the kind of arrowhead that this shape should take
     * when this shape is an element of a Link.
     * Value must be a string.
     *
     * The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
     * If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
     * the GraphObject#visible property, or you can set or bind this "toArrow" property to
     * be the empty string.
     * The arrowhead named "", an empty string, will display as nothing.
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
     * All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     *
     * Setting this property may also set the GraphObject#segmentIndex,
     * GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
     * This shape should be an element of a Link.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
     *
     * You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
     */
    get toArrow(): string; */
  // Type InteropStaticType.string
  set toArrow(_i2.String value) {
    _i5.setProperty(
      this,
      'toArrow',
      value,
    );
  }

  /* #18633
  source: 
    /**
     * Gets or sets the name of the kind of arrowhead that this shape should take
     * when this shape is an element of a Link.
     * Value must be a string.
     * For bi-directional links the arrowhead name often starts with "Backward...".
     *
     * The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
     * If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
     * the GraphObject#visible property, or you can set or bind this "toArrow" property to
     * be the empty string.
     * The arrowhead named "", an empty string, will display as nothing.
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
     * All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     *
     * Setting this property may also set the GraphObject#segmentIndex,
     * GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
     * This shape should be an element of a Link.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
     *
     * You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
     */
    get fromArrow(): string; */
  /// Gets or sets the name of the kind of arrowhead that this shape should take
  /// when this shape is an element of a Link.
  /// Value must be a string.
  /// For bi-directional links the arrowhead name often starts with "Backward...".
  ///
  /// The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
  /// If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
  /// the GraphObject#visible property, or you can set or bind this "toArrow" property to
  /// be the empty string.
  /// The arrowhead named "", an empty string, will display as nothing.
  ///
  /// The name can be any case but will always be canonicalized when set. For instance,
  /// setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
  /// All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
  ///
  /// Setting this property may also set the GraphObject#segmentIndex,
  /// GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
  /// This shape should be an element of a Link.
  ///
  /// At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
  /// #figure, #toArrow, #fromArrow.
  ///
  /// You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
  ///
  /// You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
  _i2.String get fromArrow => _i5.getProperty(
        this,
        'fromArrow',
      );
  /* #18633
  source: 
    /**
     * Gets or sets the name of the kind of arrowhead that this shape should take
     * when this shape is an element of a Link.
     * Value must be a string.
     * For bi-directional links the arrowhead name often starts with "Backward...".
     *
     * The default is "None", which means that this Shape is not an arrowhead, causing it to be the default Shape, a large filled Rectangle.
     * If you want to have an arrowhead Shape but sometimes not show an arrowhead, you can set or bind
     * the GraphObject#visible property, or you can set or bind this "toArrow" property to
     * be the empty string.
     * The arrowhead named "", an empty string, will display as nothing.
     *
     * The name can be any case but will always be canonicalized when set. For instance,
     * setting "opentriangle" will set the value of the arrowhead to "OpenTriangle".
     * All of the predefined arrowheads are shown in the <a href="../../samples/arrowheads.html">Arrowheads sample</a>.
     *
     * Setting this property may also set the GraphObject#segmentIndex,
     * GraphObject#segmentOrientation, and GraphObject#alignmentFocus properties.
     * This shape should be an element of a Link.
     *
     * At most one of the following three properties may be set to a non-"None" value at the same time on the same shape:
     * #figure, #toArrow, #fromArrow.
     *
     * You can define your own named arrowheads by calling the static function Shape.defineArrowheadGeometry.
     *
     * You can see a copy of all of the built-in arrowhead definitions in this file: <a href="../../extensions/Arrowheads.js">Arrowheads.js</a>.
     */
    get fromArrow(): string; */
  // Type InteropStaticType.string
  set fromArrow(_i2.String value) {
    _i5.setProperty(
      this,
      'fromArrow',
      value,
    );
  }

  /* #18639
  source: 
    /**
     * Gets or sets the top-left Spot used by some Panels for determining where in the shape other objects may be placed.
     * The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
     */
    get spot1(): Spot; */
  /// Gets or sets the top-left Spot used by some Panels for determining where in the shape other objects may be placed.
  /// The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
  _i3.Spot get spot1 => _i5.getProperty(
        this,
        'spot1',
      );
  /* #18639
  source: 
    /**
     * Gets or sets the top-left Spot used by some Panels for determining where in the shape other objects may be placed.
     * The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
     */
    get spot1(): Spot; */
  // Type Instance of 'InteropInterface'
  set spot1(_i3.Spot value) {
    _i5.setProperty(
      this,
      'spot1',
      value,
    );
  }

  /* #18645
  source: 
    /**
     * Gets or sets the bottom-right Spot used by some Panels for determining where in the shape other objects may be placed.
     * The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
     */
    get spot2(): Spot; */
  /// Gets or sets the bottom-right Spot used by some Panels for determining where in the shape other objects may be placed.
  /// The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
  _i3.Spot get spot2 => _i5.getProperty(
        this,
        'spot2',
      );
  /* #18645
  source: 
    /**
     * Gets or sets the bottom-right Spot used by some Panels for determining where in the shape other objects may be placed.
     * The value is normally Spot.Default, but you may want to set it to override the value that many #figures use.
     */
    get spot2(): Spot; */
  // Type Instance of 'InteropInterface'
  set spot2(_i3.Spot value) {
    _i5.setProperty(
      this,
      'spot2',
      value,
    );
  }

  /* #18652
  source: 
    /**
     * Gets or sets a property for parameterizing the construction of a Geometry from a figure.
     * The meaning of this property depends on the particular figure.
     * The value must be a number; the default value is NaN.
     */
    get parameter1(): number; */
  /// Gets or sets a property for parameterizing the construction of a Geometry from a figure.
  /// The meaning of this property depends on the particular figure.
  /// The value must be a number; the default value is NaN.
  _i2.num get parameter1 => _i5.getProperty(
        this,
        'parameter1',
      );
  /* #18652
  source: 
    /**
     * Gets or sets a property for parameterizing the construction of a Geometry from a figure.
     * The meaning of this property depends on the particular figure.
     * The value must be a number; the default value is NaN.
     */
    get parameter1(): number; */
  // Type InteropStaticType.number
  set parameter1(_i2.num value) {
    _i5.setProperty(
      this,
      'parameter1',
      value,
    );
  }

  /* #18659
  source: 
    /**
     * Gets or sets a property for parameterizing the construction of a Geometry from a figure.
     * The meaning of this property depends on the particular figure.
     * The value must be a number; the default value is NaN.
     */
    get parameter2(): number; */
  /// Gets or sets a property for parameterizing the construction of a Geometry from a figure.
  /// The meaning of this property depends on the particular figure.
  /// The value must be a number; the default value is NaN.
  _i2.num get parameter2 => _i5.getProperty(
        this,
        'parameter2',
      );
  /* #18659
  source: 
    /**
     * Gets or sets a property for parameterizing the construction of a Geometry from a figure.
     * The meaning of this property depends on the particular figure.
     * The value must be a number; the default value is NaN.
     */
    get parameter2(): number; */
  // Type InteropStaticType.number
  set parameter2(_i2.num value) {
    _i5.setProperty(
      this,
      'parameter2',
      value,
    );
  }

  /* #18667
  source: 
    /**
     * This read-only property returns the natural bounds of this Shape as determined by its #geometry's bounds.
     * The bounds will always include the (0,0) point.
     * If the #desiredSize is set, it returns a Rect with the #desiredSize. If no geometry is available,
     * and no #desiredSize is set, this may have NaN values for the width and height.
     */
    get naturalBounds(): Rect; */
  /// This read-only property returns the natural bounds of this Shape as determined by its #geometry's bounds.
  /// The bounds will always include the (0,0) point.
  /// If the #desiredSize is set, it returns a Rect with the #desiredSize. If no geometry is available,
  /// and no #desiredSize is set, this may have NaN values for the width and height.
  _i3.Rect get naturalBounds => _i5.getProperty(
        this,
        'naturalBounds',
      );
  /* #18667
  source: 
    /**
     * This read-only property returns the natural bounds of this Shape as determined by its #geometry's bounds.
     * The bounds will always include the (0,0) point.
     * If the #desiredSize is set, it returns a Rect with the #desiredSize. If no geometry is available,
     * and no #desiredSize is set, this may have NaN values for the width and height.
     */
    get naturalBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set naturalBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'naturalBounds',
      value,
    );
  }

  /* #18687
  source: 
    /**
     * Gets or sets a GraphObject that is drawn repeatedly along the path of the stroke of this shape.
     * This property may be set to a shared GraphObject; the GraphObject should not belong to any Panel.
     * Note that data bindings do <em>not</em> work in such shared GraphObjects, because they are not part of the visual tree.
     * The default value is null, causing no object to be drawn repeatedly.
     *
     * Typically the object is a small Shape or a Picture.
     * The larger the object is the worse the results will be, especially if the stroke has short segments or sharp curves.
     * The pathPattern object is not part of the measured bounds of the Shape, it is a cosmetic element only.
     *
     * The stroke is always drawn normally -- having a value for this property will draw the value along the stroke as well,
     * so it is commonplace to set the #stroke to "transparent" and the #strokeWidth to be as wide as
     * the height of the GraphObject being drawn along the stroke.
     *
     * Examples of path patterns can be seen in the <a href="../../samples/relationships.html">Relationships sample</a>.
     *
     * This property is ignored by the Shapes in "Grid" or "Graduated" Panels.
     * @since 1.6
     */
    get pathPattern(): GraphObject | null; */
  /// Gets or sets a GraphObject that is drawn repeatedly along the path of the stroke of this shape.
  /// This property may be set to a shared GraphObject; the GraphObject should not belong to any Panel.
  /// Note that data bindings do <em>not</em> work in such shared GraphObjects, because they are not part of the visual tree.
  /// The default value is null, causing no object to be drawn repeatedly.
  ///
  /// Typically the object is a small Shape or a Picture.
  /// The larger the object is the worse the results will be, especially if the stroke has short segments or sharp curves.
  /// The pathPattern object is not part of the measured bounds of the Shape, it is a cosmetic element only.
  ///
  /// The stroke is always drawn normally -- having a value for this property will draw the value along the stroke as well,
  /// so it is commonplace to set the #stroke to "transparent" and the #strokeWidth to be as wide as
  /// the height of the GraphObject being drawn along the stroke.
  ///
  /// Examples of path patterns can be seen in the <a href="../../samples/relationships.html">Relationships sample</a>.
  ///
  /// This property is ignored by the Shapes in "Grid" or "Graduated" Panels.
  _i3.GraphObject? get pathPattern => _i5.getProperty(
        this,
        'pathPattern',
      );
  /* #18687
  source: 
    /**
     * Gets or sets a GraphObject that is drawn repeatedly along the path of the stroke of this shape.
     * This property may be set to a shared GraphObject; the GraphObject should not belong to any Panel.
     * Note that data bindings do <em>not</em> work in such shared GraphObjects, because they are not part of the visual tree.
     * The default value is null, causing no object to be drawn repeatedly.
     *
     * Typically the object is a small Shape or a Picture.
     * The larger the object is the worse the results will be, especially if the stroke has short segments or sharp curves.
     * The pathPattern object is not part of the measured bounds of the Shape, it is a cosmetic element only.
     *
     * The stroke is always drawn normally -- having a value for this property will draw the value along the stroke as well,
     * so it is commonplace to set the #stroke to "transparent" and the #strokeWidth to be as wide as
     * the height of the GraphObject being drawn along the stroke.
     *
     * Examples of path patterns can be seen in the <a href="../../samples/relationships.html">Relationships sample</a>.
     *
     * This property is ignored by the Shapes in "Grid" or "Graduated" Panels.
     * @since 1.6
     */
    get pathPattern(): GraphObject | null; */
  // Type InteropUnion#408737631(parent: InteropGetter#333461201(name: pathPattern))
  set pathPattern(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'pathPattern',
      value ?? _i4.undefined,
    );
  }

  /* #18695
  source: 
    /**
     * Gets or sets how the shape's geometry is proportionally created given its computed size.
     * Possible values are GraphObject.None, GraphObject.Fill, GraphObject.Uniform, and GraphObject.Default.
     * The default is GraphObject.Default, which resolves to GraphObject.Fill for most figures, though
     * some regular figures such as "Circle" and "Square" default to GraphObject.Uniform.
     */
    get geometryStretch(): EnumValue; */
  /// Gets or sets how the shape's geometry is proportionally created given its computed size.
  /// Possible values are GraphObject.None, GraphObject.Fill, GraphObject.Uniform, and GraphObject.Default.
  /// The default is GraphObject.Default, which resolves to GraphObject.Fill for most figures, though
  /// some regular figures such as "Circle" and "Square" default to GraphObject.Uniform.
  _i3.EnumValue get geometryStretch => _i5.getProperty(
        this,
        'geometryStretch',
      );
  /* #18695
  source: 
    /**
     * Gets or sets how the shape's geometry is proportionally created given its computed size.
     * Possible values are GraphObject.None, GraphObject.Fill, GraphObject.Uniform, and GraphObject.Default.
     * The default is GraphObject.Default, which resolves to GraphObject.Fill for most figures, though
     * some regular figures such as "Circle" and "Square" default to GraphObject.Uniform.
     */
    get geometryStretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set geometryStretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'geometryStretch',
      value,
    );
  }

  /* #18702
  source: 
    /**
     * Gets or sets how frequently this shape should be drawn within a "Grid" or "Graduated" Panel,
     * in multiples of the Panel#gridCellSize or Panel#graduatedTickUnit.
     * The default is 1.  Any new value must be a positive integer.
     */
    get interval(): number; */
  /// Gets or sets how frequently this shape should be drawn within a "Grid" or "Graduated" Panel,
  /// in multiples of the Panel#gridCellSize or Panel#graduatedTickUnit.
  /// The default is 1.  Any new value must be a positive integer.
  _i2.num get interval => _i5.getProperty(
        this,
        'interval',
      );
  /* #18702
  source: 
    /**
     * Gets or sets how frequently this shape should be drawn within a "Grid" or "Graduated" Panel,
     * in multiples of the Panel#gridCellSize or Panel#graduatedTickUnit.
     * The default is 1.  Any new value must be a positive integer.
     */
    get interval(): number; */
  // Type InteropStaticType.number
  set interval(_i2.num value) {
    _i5.setProperty(
      this,
      'interval',
      value,
    );
  }

  /* #18709
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should start.
     * The default is 0. Any new value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedStart(): number; */
  /// Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should start.
  /// The default is 0. Any new value should range from 0 to 1.
  _i2.num get graduatedStart => _i5.getProperty(
        this,
        'graduatedStart',
      );
  /* #18709
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should start.
     * The default is 0. Any new value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedStart(): number; */
  // Type InteropStaticType.number
  set graduatedStart(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedStart',
      value,
    );
  }

  /* #18716
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should end.
     * The default is 1. Any new value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedEnd(): number; */
  /// Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should end.
  /// The default is 1. Any new value should range from 0 to 1.
  _i2.num get graduatedEnd => _i5.getProperty(
        this,
        'graduatedEnd',
      );
  /* #18716
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick should end.
     * The default is 1. Any new value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedEnd(): number; */
  // Type InteropStaticType.number
  set graduatedEnd(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedEnd',
      value,
    );
  }

  /* #18730
  source: 
    /**
     * Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
     * The default is null and doesn't skip any ticks.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this Shape.
     * The function will return a boolean, whether the tick will be skipped at the value of the argument.
     *
     * Note that the second argument is the Shape, *not* a particular tick that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 2.0
     */
    get graduatedSkip(): ((val: number, shape: Shape) => boolean) | null; */
  /// Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
  /// The default is null and doesn't skip any ticks.
  ///
  /// The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
  /// and this Shape.
  /// The function will return a boolean, whether the tick will be skipped at the value of the argument.
  ///
  /// Note that the second argument is the Shape, *not* a particular tick that would be rendered at the given value.
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i2.num,
    _i3.Shape,
  )? get graduatedSkip => _i5.getProperty(
        this,
        'graduatedSkip',
      );
  /* #18730
  source: 
    /**
     * Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
     * The default is null and doesn't skip any ticks.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this Shape.
     * The function will return a boolean, whether the tick will be skipped at the value of the argument.
     *
     * Note that the second argument is the Shape, *not* a particular tick that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 2.0
     */
    get graduatedSkip(): ((val: number, shape: Shape) => boolean) | null; */
  // Type InteropUnion#405700652(parent: InteropGetter#376971354(name: graduatedSkip))
  set graduatedSkip(
      _i2.bool Function(
        _i2.num,
        _i3.Shape,
      )? value) {
    _i5.setProperty(
      this,
      'graduatedSkip',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class TextBlock implements _i3.GraphObject {
  factory TextBlock.$1() => _i5.callConstructor(
        _declaredTextBlock,
        [],
      );

  factory TextBlock.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredTextBlock,
        [init ?? _i4.undefined],
      );

  factory TextBlock.$3([
    _i2.String? text,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredTextBlock,
        [
          text ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  /* #18939
  source: 
    /**
     * Used as a value for TextBlock#wrap, the TextBlock will not wrap its text.
     * @constant
     */
    static None: EnumValue; */
  /// Used as a value for TextBlock#wrap, the TextBlock will not wrap its text.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredTextBlock,
        'None',
      );
  /* #18939
  source: 
    /**
     * Used as a value for TextBlock#wrap, the TextBlock will not wrap its text.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'None',
      value,
    );
  }

  /* #18945
  source: 
    /**
     * Used as a value for TextBlock#wrap, the TextBlock will wrap text, making the width of
     * the TextBlock equal to the width of the longest line.
     * @constant
     */
    static WrapFit: EnumValue; */
  /// Used as a value for TextBlock#wrap, the TextBlock will wrap text, making the width of
  /// the TextBlock equal to the width of the longest line.
  static _i3.EnumValue get wrapFit => _i5.getProperty(
        _declaredTextBlock,
        'WrapFit',
      );
  /* #18945
  source: 
    /**
     * Used as a value for TextBlock#wrap, the TextBlock will wrap text, making the width of
     * the TextBlock equal to the width of the longest line.
     * @constant
     */
    static WrapFit: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wrapFit(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'WrapFit',
      value,
    );
  }

  /* #18951
  source: 
    /**
     * Used as the default value for TextBlock#wrap, the TextBlock will wrap text and the width of
     * the TextBlock will be the desiredSize's width, if any.
     * @constant
     */
    static WrapDesiredSize: EnumValue; */
  /// Used as the default value for TextBlock#wrap, the TextBlock will wrap text and the width of
  /// the TextBlock will be the desiredSize's width, if any.
  static _i3.EnumValue get wrapDesiredSize => _i5.getProperty(
        _declaredTextBlock,
        'WrapDesiredSize',
      );
  /* #18951
  source: 
    /**
     * Used as the default value for TextBlock#wrap, the TextBlock will wrap text and the width of
     * the TextBlock will be the desiredSize's width, if any.
     * @constant
     */
    static WrapDesiredSize: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wrapDesiredSize(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'WrapDesiredSize',
      value,
    );
  }

  /* #18958
  source: 
    /**
     * Used a a value for TextBlock#wrap, the TextBlock will attempt to wrap at each character, allowing
     * breaks within "words."
     * @since 2.0
     * @constant
     */
    static WrapBreakAll: EnumValue; */
  /// Used a a value for TextBlock#wrap, the TextBlock will attempt to wrap at each character, allowing
  /// breaks within "words."
  static _i3.EnumValue get wrapBreakAll => _i5.getProperty(
        _declaredTextBlock,
        'WrapBreakAll',
      );
  /* #18958
  source: 
    /**
     * Used a a value for TextBlock#wrap, the TextBlock will attempt to wrap at each character, allowing
     * breaks within "words."
     * @since 2.0
     * @constant
     */
    static WrapBreakAll: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set wrapBreakAll(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'WrapBreakAll',
      value,
    );
  }

  /* #18965
  source: 
    /**
     * Used as the default value for TextBlock#overflow: if the width is too small to display all text,
     * the TextBlock will clip.
     * @constant
     * @since 1.4
     */
    static OverflowClip: EnumValue; */
  /// Used as the default value for TextBlock#overflow: if the width is too small to display all text,
  /// the TextBlock will clip.
  static _i3.EnumValue get overflowClip => _i5.getProperty(
        _declaredTextBlock,
        'OverflowClip',
      );
  /* #18965
  source: 
    /**
     * Used as the default value for TextBlock#overflow: if the width is too small to display all text,
     * the TextBlock will clip.
     * @constant
     * @since 1.4
     */
    static OverflowClip: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set overflowClip(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'OverflowClip',
      value,
    );
  }

  /* #18972
  source: 
    /**
     * Used as a value for TextBlock#overflow: if the width is too small to display all text,
     * the TextBlock will display an ellipsis.
     * @constant
     * @since 1.4
     */
    static OverflowEllipsis: EnumValue; */
  /// Used as a value for TextBlock#overflow: if the width is too small to display all text,
  /// the TextBlock will display an ellipsis.
  static _i3.EnumValue get overflowEllipsis => _i5.getProperty(
        _declaredTextBlock,
        'OverflowEllipsis',
      );
  /* #18972
  source: 
    /**
     * Used as a value for TextBlock#overflow: if the width is too small to display all text,
     * the TextBlock will display an ellipsis.
     * @constant
     * @since 1.4
     */
    static OverflowEllipsis: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set overflowEllipsis(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'OverflowEllipsis',
      value,
    );
  }

  /* #18979
  source: 
    /**
     * Used as the default value for TextBlock#formatting: the TextBlock will automatically trim any whitespace at the start
     * or end of each line of text.
     * @constant
     * @since 2.2
     */
    static FormatTrim: EnumValue; */
  /// Used as the default value for TextBlock#formatting: the TextBlock will automatically trim any whitespace at the start
  /// or end of each line of text.
  static _i3.EnumValue get formatTrim => _i5.getProperty(
        _declaredTextBlock,
        'FormatTrim',
      );
  /* #18979
  source: 
    /**
     * Used as the default value for TextBlock#formatting: the TextBlock will automatically trim any whitespace at the start
     * or end of each line of text.
     * @constant
     * @since 2.2
     */
    static FormatTrim: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set formatTrim(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'FormatTrim',
      value,
    );
  }

  /* #18986
  source: 
    /**
     * Used as a value for TextBlock#formatting: the TextBlock will *not* trim any whitespace at the start
     * or end of each line of text. This can be useful if your text is preformatted.
     * @constant
     * @since 2.2
     */
    static FormatNone: EnumValue; */
  /// Used as a value for TextBlock#formatting: the TextBlock will *not* trim any whitespace at the start
  /// or end of each line of text. This can be useful if your text is preformatted.
  static _i3.EnumValue get formatNone => _i5.getProperty(
        _declaredTextBlock,
        'FormatNone',
      );
  /* #18986
  source: 
    /**
     * Used as a value for TextBlock#formatting: the TextBlock will *not* trim any whitespace at the start
     * or end of each line of text. This can be useful if your text is preformatted.
     * @constant
     * @since 2.2
     */
    static FormatNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set formatNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTextBlock,
      'FormatNone',
      value,
    );
  }

  static _i2.String getEllipsis() => _i5.callMethod(
        _declaredTextBlock,
        'getEllipsis',
        [],
      );
  static void setEllipsis(_i2.String val) {
    _i5.callMethod(
      _declaredTextBlock,
      'setEllipsis',
      [val],
    );
  }

  static _i2.num Function(
    _i3.TextBlock,
    _i2.num,
  )? getBaseline() => _i5.callMethod(
        _declaredTextBlock,
        'getBaseline',
        [],
      );
  static void setBaseline(
      [_i2.num Function(
        _i3.TextBlock,
        _i2.num,
      )? value]) {
    _i5.callMethod(
      _declaredTextBlock,
      'setBaseline',
      [value == null ? _i4.undefined : _i5.allowInterop(value)],
    );
  }

  static _i2.num Function(
    _i3.TextBlock,
    _i2.num,
  )? getUnderline() => _i5.callMethod(
        _declaredTextBlock,
        'getUnderline',
        [],
      );
  static void setUnderline(
      [_i2.num Function(
        _i3.TextBlock,
        _i2.num,
      )? value]) {
    _i5.callMethod(
      _declaredTextBlock,
      'setUnderline',
      [value == null ? _i4.undefined : _i5.allowInterop(value)],
    );
  }

  static _i2.bool isValidFont(_i2.String font) => _i5.callMethod(
        _declaredTextBlock,
        'isValidFont',
        [font],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('TextBlock')
external _i2.Object _declaredTextBlock;

extension TextBlock$Typings on TextBlock {
  /* #19004
  source: 
    /**
     * Gets or sets the current font settings.
     * The font property must be a valid CSS string describing a font.
     * The font string can accept several CSS properties but they must be
     * in a specific order in order to render correctly across all browsers:
     *
     * `"font-style font-variant font-weight font-size font-family"`
     *
     * For example, `"Italic small-caps bold 32px Georgia, Serif"` is a valid font string
     * using every CSS font property. Not every browser can render every font option.
     * For more information about CSS font syntax, see <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font">CSS fonts (mozilla.org)</a>.
     *
     * If your Node sizes depend on TextBlocks, it is best to ensure any custom fonts you are using are finished loading before you load your Diagram.
     * This will ensure nodes are sized appropriately for the initial Diagram layout.
     *
     * The default font is "13px sans-serif".
     */
    get font(): string; */
  /// Gets or sets the current font settings.
  /// The font property must be a valid CSS string describing a font.
  /// The font string can accept several CSS properties but they must be
  /// in a specific order in order to render correctly across all browsers:
  ///
  /// `"font-style font-variant font-weight font-size font-family"`
  ///
  /// For example, `"Italic small-caps bold 32px Georgia, Serif"` is a valid font string
  /// using every CSS font property. Not every browser can render every font option.
  /// For more information about CSS font syntax, see <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font">CSS fonts (mozilla.org)</a>.
  ///
  /// If your Node sizes depend on TextBlocks, it is best to ensure any custom fonts you are using are finished loading before you load your Diagram.
  /// This will ensure nodes are sized appropriately for the initial Diagram layout.
  ///
  /// The default font is "13px sans-serif".
  _i2.String get font => _i5.getProperty(
        this,
        'font',
      );
  /* #19004
  source: 
    /**
     * Gets or sets the current font settings.
     * The font property must be a valid CSS string describing a font.
     * The font string can accept several CSS properties but they must be
     * in a specific order in order to render correctly across all browsers:
     *
     * `"font-style font-variant font-weight font-size font-family"`
     *
     * For example, `"Italic small-caps bold 32px Georgia, Serif"` is a valid font string
     * using every CSS font property. Not every browser can render every font option.
     * For more information about CSS font syntax, see <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font">CSS fonts (mozilla.org)</a>.
     *
     * If your Node sizes depend on TextBlocks, it is best to ensure any custom fonts you are using are finished loading before you load your Diagram.
     * This will ensure nodes are sized appropriately for the initial Diagram layout.
     *
     * The default font is "13px sans-serif".
     */
    get font(): string; */
  // Type InteropStaticType.string
  set font(_i2.String value) {
    _i5.setProperty(
      this,
      'font',
      value,
    );
  }

  /* #19025
  source: 
    /**
     * Gets or sets the TextBlock's text string. The default is an empty string.
     * The text of a TextBlock, along with the values of #font, #wrap,
     * #isMultiline and sizing restrictions are what naturally determine
     * the size of the TextBlock.
     *
     * The text in textblocks can include manual line-breaks by using the character escape, `\n`.
     *
     * Leading and trailing whitespace is eliminated in each line of TextBlock text.
     *
     * If #editable is set to true, users can edit textblocks with the TextEditingTool.
     */
    get text(): string; */
  /// Gets or sets the TextBlock's text string. The default is an empty string.
  /// The text of a TextBlock, along with the values of #font, #wrap,
  /// #isMultiline and sizing restrictions are what naturally determine
  /// the size of the TextBlock.
  ///
  /// The text in textblocks can include manual line-breaks by using the character escape, `\n`.
  ///
  /// Leading and trailing whitespace is eliminated in each line of TextBlock text.
  ///
  /// If #editable is set to true, users can edit textblocks with the TextEditingTool.
  _i2.String get text => _i5.getProperty(
        this,
        'text',
      );
  /* #19025
  source: 
    /**
     * Gets or sets the TextBlock's text string. The default is an empty string.
     * The text of a TextBlock, along with the values of #font, #wrap,
     * #isMultiline and sizing restrictions are what naturally determine
     * the size of the TextBlock.
     *
     * The text in textblocks can include manual line-breaks by using the character escape, `\n`.
     *
     * Leading and trailing whitespace is eliminated in each line of TextBlock text.
     *
     * If #editable is set to true, users can edit textblocks with the TextEditingTool.
     */
    get text(): string; */
  // Type InteropStaticType.string
  set text(_i2.String value) {
    _i5.setProperty(
      this,
      'text',
      value,
    );
  }

  /* #19040
  source: 
    /**
     * Gets or sets the alignment location in the TextBlock's given space.
     * The only possible values are `"start"`, `"end"`, `"left"`, `"right"`, and `"center"`.
     * Any other value is invalid.
     *
     * This property is most pertinent when the TextBlock has multiple lines of text,
     * or when the TextBlock is given a size that differs from the text's natural size (such as with #desiredSize).
     *
     * In left-to-right writing systems, `"start"` and `"left"` are synonymous, as are `"end"` and `"right"`.
     *
     * The default is `"start"`.
     * @see #verticalAlignment
     */
    get textAlign(): ('start' | 'end' | 'left' | 'right' | 'center'); */
  /// Gets or sets the alignment location in the TextBlock's given space.
  /// The only possible values are `"start"`, `"end"`, `"left"`, `"right"`, and `"center"`.
  /// Any other value is invalid.
  ///
  /// This property is most pertinent when the TextBlock has multiple lines of text,
  /// or when the TextBlock is given a size that differs from the text's natural size (such as with #desiredSize).
  ///
  /// In left-to-right writing systems, `"start"` and `"left"` are synonymous, as are `"end"` and `"right"`.
  ///
  /// The default is `"start"`.
  TextAlign get textAlign => TextAlign.values.byName(_i5.getProperty(
        this,
        'textAlign',
      ));
  /* #19040
  source: 
    /**
     * Gets or sets the alignment location in the TextBlock's given space.
     * The only possible values are `"start"`, `"end"`, `"left"`, `"right"`, and `"center"`.
     * Any other value is invalid.
     *
     * This property is most pertinent when the TextBlock has multiple lines of text,
     * or when the TextBlock is given a size that differs from the text's natural size (such as with #desiredSize).
     *
     * In left-to-right writing systems, `"start"` and `"left"` are synonymous, as are `"end"` and `"right"`.
     *
     * The default is `"start"`.
     * @see #verticalAlignment
     */
    get textAlign(): ('start' | 'end' | 'left' | 'right' | 'center'); */
  // Type InteropUnion#115691497(parent: InteropGetter#696171398(name: textAlign))
  set textAlign(TextAlign value) {
    _i5.setProperty(
      this,
      'textAlign',
      value.name,
    );
  }

  /* #19049
  source: 
    /**
     * Gets or sets how the TextBlock is displayed: Either normally or with a Horizontal or Vertical flip or both.
     *
     * Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
     * The default is GraphObject.None.
     * @since 2.0
     */
    get flip(): EnumValue; */
  /// Gets or sets how the TextBlock is displayed: Either normally or with a Horizontal or Vertical flip or both.
  ///
  /// Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
  /// The default is GraphObject.None.
  _i3.EnumValue get flip => _i5.getProperty(
        this,
        'flip',
      );
  /* #19049
  source: 
    /**
     * Gets or sets how the TextBlock is displayed: Either normally or with a Horizontal or Vertical flip or both.
     *
     * Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
     * The default is GraphObject.None.
     * @since 2.0
     */
    get flip(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set flip(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'flip',
      value,
    );
  }

  /* #19064
  source: 
    /**
     * Gets or sets the vertical alignment Spot of this TextBlock, used when
     * the TextBlock has more available vertical space than it needs to draw all lines.
     *
     * The default value is Spot.Top, which aligns the TextBlock to the top of its available space.
     *
     * The #textAlign is often used along with this property to specify
     * where the should be positioned in its available space.
     *
     * This does not affect TextBlock coordinates or bounds, it only affects where text is drawn within the given area.
     * @see #textAlign
     * @since 1.7
     */
    get verticalAlignment(): Spot; */
  /// Gets or sets the vertical alignment Spot of this TextBlock, used when
  /// the TextBlock has more available vertical space than it needs to draw all lines.
  ///
  /// The default value is Spot.Top, which aligns the TextBlock to the top of its available space.
  ///
  /// The #textAlign is often used along with this property to specify
  /// where the should be positioned in its available space.
  ///
  /// This does not affect TextBlock coordinates or bounds, it only affects where text is drawn within the given area.
  _i3.Spot get verticalAlignment => _i5.getProperty(
        this,
        'verticalAlignment',
      );
  /* #19064
  source: 
    /**
     * Gets or sets the vertical alignment Spot of this TextBlock, used when
     * the TextBlock has more available vertical space than it needs to draw all lines.
     *
     * The default value is Spot.Top, which aligns the TextBlock to the top of its available space.
     *
     * The #textAlign is often used along with this property to specify
     * where the should be positioned in its available space.
     *
     * This does not affect TextBlock coordinates or bounds, it only affects where text is drawn within the given area.
     * @see #textAlign
     * @since 1.7
     */
    get verticalAlignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set verticalAlignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'verticalAlignment',
      value,
    );
  }

  /* #19070
  source: 
    /**
     * This read-only property returns the natural bounds of this TextBlock in local coordinates,
     * as determined by its #font and #text string, and optionally its #desiredSize.
     */
    get naturalBounds(): Rect; */
  /// This read-only property returns the natural bounds of this TextBlock in local coordinates,
  /// as determined by its #font and #text string, and optionally its #desiredSize.
  _i3.Rect get naturalBounds => _i5.getProperty(
        this,
        'naturalBounds',
      );
  /* #19070
  source: 
    /**
     * This read-only property returns the natural bounds of this TextBlock in local coordinates,
     * as determined by its #font and #text string, and optionally its #desiredSize.
     */
    get naturalBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set naturalBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'naturalBounds',
      value,
    );
  }

  /* #19077
  source: 
    /**
     * Gets or sets whether or not the text displays multiple lines or embedded newlines.
     * If this is false, all characters including and after the first newline will be omitted.
     * The default is true.
     * @see #maxLines
     */
    get isMultiline(): boolean; */
  /// Gets or sets whether or not the text displays multiple lines or embedded newlines.
  /// If this is false, all characters including and after the first newline will be omitted.
  /// The default is true.
  _i2.bool get isMultiline => _i5.getProperty(
        this,
        'isMultiline',
      );
  /* #19077
  source: 
    /**
     * Gets or sets whether or not the text displays multiple lines or embedded newlines.
     * If this is false, all characters including and after the first newline will be omitted.
     * The default is true.
     * @see #maxLines
     */
    get isMultiline(): boolean; */
  // Type InteropStaticType.boolean
  set isMultiline(_i2.bool value) {
    _i5.setProperty(
      this,
      'isMultiline',
      value,
    );
  }

  /* #19085
  source: 
    /**
     * Gets or sets whether or not the text is underlined.
     * The default is false.
     * @see #isStrikethrough
     * @since 1.2
     */
    get isUnderline(): boolean; */
  /// Gets or sets whether or not the text is underlined.
  /// The default is false.
  _i2.bool get isUnderline => _i5.getProperty(
        this,
        'isUnderline',
      );
  /* #19085
  source: 
    /**
     * Gets or sets whether or not the text is underlined.
     * The default is false.
     * @see #isStrikethrough
     * @since 1.2
     */
    get isUnderline(): boolean; */
  // Type InteropStaticType.boolean
  set isUnderline(_i2.bool value) {
    _i5.setProperty(
      this,
      'isUnderline',
      value,
    );
  }

  /* #19093
  source: 
    /**
     * Gets or sets whether or not the text has a strikethrough line (line-through).
     * The default is false.
     * @see #isUnderline
     * @since 1.2
     */
    get isStrikethrough(): boolean; */
  /// Gets or sets whether or not the text has a strikethrough line (line-through).
  /// The default is false.
  _i2.bool get isStrikethrough => _i5.getProperty(
        this,
        'isStrikethrough',
      );
  /* #19093
  source: 
    /**
     * Gets or sets whether or not the text has a strikethrough line (line-through).
     * The default is false.
     * @see #isUnderline
     * @since 1.2
     */
    get isStrikethrough(): boolean; */
  // Type InteropStaticType.boolean
  set isStrikethrough(_i2.bool value) {
    _i5.setProperty(
      this,
      'isStrikethrough',
      value,
    );
  }

  /* #19104
  source: 
    /**
     * Gets or sets whether the text should be wrapped if it is too long to fit on one line.
     *
     * Possible values are TextBlock.WrapDesiredSize, TextBlock.WrapFit, TextBlock.WrapBreakAll,
     * and TextBlock.None.
     *
     * The default value is TextBlock.WrapDesiredSize.
     * @see #overflow
     */
    get wrap(): EnumValue; */
  /// Gets or sets whether the text should be wrapped if it is too long to fit on one line.
  ///
  /// Possible values are TextBlock.WrapDesiredSize, TextBlock.WrapFit, TextBlock.WrapBreakAll,
  /// and TextBlock.None.
  ///
  /// The default value is TextBlock.WrapDesiredSize.
  _i3.EnumValue get wrap => _i5.getProperty(
        this,
        'wrap',
      );
  /* #19104
  source: 
    /**
     * Gets or sets whether the text should be wrapped if it is too long to fit on one line.
     *
     * Possible values are TextBlock.WrapDesiredSize, TextBlock.WrapFit, TextBlock.WrapBreakAll,
     * and TextBlock.None.
     *
     * The default value is TextBlock.WrapDesiredSize.
     * @see #overflow
     */
    get wrap(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set wrap(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'wrap',
      value,
    );
  }

  /* #19118
  source: 
    /**
     * Gets or sets how text that is too long to display should be handled.
     *
     * Possible values are TextBlock.OverflowClip and TextBlock.OverflowEllipsis.
     * For OverflowEllipsis to work, you must constrain the available size of the TextBlock in some way,
     * such as setting #wrap to TextBlock.None,
     * or limiting the number of lines with #maxLines or a height constraint.
     *
     * The default value is TextBlock.OverflowClip.
     * @see #wrap
     * @since 1.4
     */
    get overflow(): EnumValue; */
  /// Gets or sets how text that is too long to display should be handled.
  ///
  /// Possible values are TextBlock.OverflowClip and TextBlock.OverflowEllipsis.
  /// For OverflowEllipsis to work, you must constrain the available size of the TextBlock in some way,
  /// such as setting #wrap to TextBlock.None,
  /// or limiting the number of lines with #maxLines or a height constraint.
  ///
  /// The default value is TextBlock.OverflowClip.
  _i3.EnumValue get overflow => _i5.getProperty(
        this,
        'overflow',
      );
  /* #19118
  source: 
    /**
     * Gets or sets how text that is too long to display should be handled.
     *
     * Possible values are TextBlock.OverflowClip and TextBlock.OverflowEllipsis.
     * For OverflowEllipsis to work, you must constrain the available size of the TextBlock in some way,
     * such as setting #wrap to TextBlock.None,
     * or limiting the number of lines with #maxLines or a height constraint.
     *
     * The default value is TextBlock.OverflowClip.
     * @see #wrap
     * @since 1.4
     */
    get overflow(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set overflow(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'overflow',
      value,
    );
  }

  /* #19129
  source: 
    /**
     * Gets or sets the Brush or string that describes the stroke (color) of the text that is drawn.
     *
     * The default value is `"black"`.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     */
    get stroke(): BrushLike; */
  /// Gets or sets the Brush or string that describes the stroke (color) of the text that is drawn.
  ///
  /// The default value is `"black"`.
  /// Any valid CSS string can specify a solid color, and the Brush
  /// class can be used to specify a gradient or pattern.
  /// More information about the syntax of CSS color strings is available at:
  /// <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
  _i3.BrushLike get stroke => _i5.getProperty(
        this,
        'stroke',
      );
  /* #19129
  source: 
    /**
     * Gets or sets the Brush or string that describes the stroke (color) of the text that is drawn.
     *
     * The default value is `"black"`.
     * Any valid CSS string can specify a solid color, and the Brush
     * class can be used to specify a gradient or pattern.
     * More information about the syntax of CSS color strings is available at:
     * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color">CSS colors (mozilla.org)</a>.
     */
    get stroke(): BrushLike; */
  // Type InteropTypedef#450957626(name: BrushLike)
  set stroke(_i3.BrushLike value) {
    _i5.setProperty(
      this,
      'stroke',
      value ?? _i4.undefined,
    );
  }

  /* #19138
  source: 
    /**
     * This read-only property returns the computed number of lines in this TextBlock, including lines created
     * from embedded newlines (`\n`), #wrapping, and #maxLines.
     *
     * This value may be meaningless before the TextBlock is measured.
     * @see #lineHeight
     */
    get lineCount(): number; */
  /// This read-only property returns the computed number of lines in this TextBlock, including lines created
  /// from embedded newlines (`\n`), #wrapping, and #maxLines.
  ///
  /// This value may be meaningless before the TextBlock is measured.
  _i2.num get lineCount => _i5.getProperty(
        this,
        'lineCount',
      );
  /* #19138
  source: 
    /**
     * This read-only property returns the computed number of lines in this TextBlock, including lines created
     * from embedded newlines (`\n`), #wrapping, and #maxLines.
     *
     * This value may be meaningless before the TextBlock is measured.
     * @see #lineHeight
     */
    get lineCount(): number; */
  // Type InteropStaticType.number
  set lineCount(_i2.num value) {
    _i5.setProperty(
      this,
      'lineCount',
      value,
    );
  }

  /* #19146
  source: 
    /**
     * This read-only property returns the height of a line of text in this TextBlock, not including any #spacingAbove or #spacingBelow.
     *
     * This value may be meaningless before the TextBlock is measured.
     * @since 2.2
     * @see #lineCount
     */
    get lineHeight(): number; */
  /// This read-only property returns the height of a line of text in this TextBlock, not including any #spacingAbove or #spacingBelow.
  ///
  /// This value may be meaningless before the TextBlock is measured.
  _i2.num get lineHeight => _i5.getProperty(
        this,
        'lineHeight',
      );
  /* #19146
  source: 
    /**
     * This read-only property returns the height of a line of text in this TextBlock, not including any #spacingAbove or #spacingBelow.
     *
     * This value may be meaningless before the TextBlock is measured.
     * @since 2.2
     * @see #lineCount
     */
    get lineHeight(): number; */
  // Type InteropStaticType.number
  set lineHeight(_i2.num value) {
    _i5.setProperty(
      this,
      'lineHeight',
      value,
    );
  }

  /* #19154
  source: 
    /**
     * Gets or sets whether or not this TextBlock allows in-place editing of the #text
     * string by the user with the help of the TextEditingTool.
     * The default is false.
     *
     * See also Part#textEditable.
     */
    get editable(): boolean; */
  /// Gets or sets whether or not this TextBlock allows in-place editing of the #text
  /// string by the user with the help of the TextEditingTool.
  /// The default is false.
  ///
  /// See also Part#textEditable.
  _i2.bool get editable => _i5.getProperty(
        this,
        'editable',
      );
  /* #19154
  source: 
    /**
     * Gets or sets whether or not this TextBlock allows in-place editing of the #text
     * string by the user with the help of the TextEditingTool.
     * The default is false.
     *
     * See also Part#textEditable.
     */
    get editable(): boolean; */
  // Type InteropStaticType.boolean
  set editable(_i2.bool value) {
    _i5.setProperty(
      this,
      'editable',
      value,
    );
  }

  /* #19167
  source: 
    /**
     * Gets or sets the HTMLInfo that this TextBlock uses as its text editor in the TextEditingTool.
     * If null, the TextBlock will use the default text editor of the TextEditingTool.
     * The default is null.
     * The value should be set to an instance of HTMLInfo.
     * Setting this property might not affect any ongoing text editing operation.
     *
     * As of 2.0 setting this to an HTML Element is no longer supported.
     *
     * For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
     */
    get textEditor(): HTMLInfo | null; */
  /// Gets or sets the HTMLInfo that this TextBlock uses as its text editor in the TextEditingTool.
  /// If null, the TextBlock will use the default text editor of the TextEditingTool.
  /// The default is null.
  /// The value should be set to an instance of HTMLInfo.
  /// Setting this property might not affect any ongoing text editing operation.
  ///
  /// As of 2.0 setting this to an HTML Element is no longer supported.
  ///
  /// For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
  _i3.HTMLInfo? get textEditor => _i5.getProperty(
        this,
        'textEditor',
      );
  /* #19167
  source: 
    /**
     * Gets or sets the HTMLInfo that this TextBlock uses as its text editor in the TextEditingTool.
     * If null, the TextBlock will use the default text editor of the TextEditingTool.
     * The default is null.
     * The value should be set to an instance of HTMLInfo.
     * Setting this property might not affect any ongoing text editing operation.
     *
     * As of 2.0 setting this to an HTML Element is no longer supported.
     *
     * For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
     */
    get textEditor(): HTMLInfo | null; */
  // Type InteropUnion#806640756(parent: InteropGetter#461138218(name: textEditor))
  set textEditor(_i3.HTMLInfo? value) {
    _i5.setProperty(
      this,
      'textEditor',
      value ?? _i4.undefined,
    );
  }

  /* #19173
  source: 
    /**
     * Gets or sets the function to call if a text edit made with the TextEditingTool is invalid.
     * The default is null.
     */
    get errorFunction(): ((tool: TextEditingTool, oldString: string, newString: string) => void) | null; */
  /// Gets or sets the function to call if a text edit made with the TextEditingTool is invalid.
  /// The default is null.
  void Function(
    _i3.TextEditingTool,
    _i2.String,
    _i2.String,
  )? get errorFunction => _i5.getProperty(
        this,
        'errorFunction',
      );
  /* #19173
  source: 
    /**
     * Gets or sets the function to call if a text edit made with the TextEditingTool is invalid.
     * The default is null.
     */
    get errorFunction(): ((tool: TextEditingTool, oldString: string, newString: string) => void) | null; */
  // Type InteropUnion#580643046(parent: InteropGetter#335378142(name: errorFunction))
  set errorFunction(
      void Function(
        _i3.TextEditingTool,
        _i2.String,
        _i2.String,
      )? value) {
    _i5.setProperty(
      this,
      'errorFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19181
  source: 
    /**
     * Gets or sets how frequently this text should be drawn within a "Graduated" Panel,
     * in multiples of the Panel#graduatedTickUnit.
     * The default is 1.  Any new value must be a positive integer.
     * @since 1.7
     */
    get interval(): number; */
  /// Gets or sets how frequently this text should be drawn within a "Graduated" Panel,
  /// in multiples of the Panel#graduatedTickUnit.
  /// The default is 1.  Any new value must be a positive integer.
  _i2.num get interval => _i5.getProperty(
        this,
        'interval',
      );
  /* #19181
  source: 
    /**
     * Gets or sets how frequently this text should be drawn within a "Graduated" Panel,
     * in multiples of the Panel#graduatedTickUnit.
     * The default is 1.  Any new value must be a positive integer.
     * @since 1.7
     */
    get interval(): number; */
  // Type InteropStaticType.number
  set interval(_i2.num value) {
    _i5.setProperty(
      this,
      'interval',
      value,
    );
  }

  /* #19188
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this text should start.
     * The default is 0; the value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedStart(): number; */
  /// Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this text should start.
  /// The default is 0; the value should range from 0 to 1.
  _i2.num get graduatedStart => _i5.getProperty(
        this,
        'graduatedStart',
      );
  /* #19188
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this text should start.
     * The default is 0; the value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedStart(): number; */
  // Type InteropStaticType.number
  set graduatedStart(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedStart',
      value,
    );
  }

  /* #19195
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick text should end.
     * The default is 1; the value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedEnd(): number; */
  /// Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick text should end.
  /// The default is 1; the value should range from 0 to 1.
  _i2.num get graduatedEnd => _i5.getProperty(
        this,
        'graduatedEnd',
      );
  /* #19195
  source: 
    /**
     * Gets or sets the fractional distance along the main shape of a "Graduated" Panel at which this kind of tick text should end.
     * The default is 1; the value should range from 0 to 1.
     * @since 1.7
     */
    get graduatedEnd(): number; */
  // Type InteropStaticType.number
  set graduatedEnd(_i2.num value) {
    _i5.setProperty(
      this,
      'graduatedEnd',
      value,
    );
  }

  /* #19209
  source: 
    /**
     * Gets or sets the function to convert from a value along a "Graduated" Panel to a string.
     * The default returns a string representing the value rounded to at most 2 decimals.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this TextBlock.
     * The function will return a string, the text that will appear at the value of the argument.
     *
     * Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 1.7
     */
    get graduatedFunction(): ((val: number, tb: TextBlock) => string) | null; */
  /// Gets or sets the function to convert from a value along a "Graduated" Panel to a string.
  /// The default returns a string representing the value rounded to at most 2 decimals.
  ///
  /// The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
  /// and this TextBlock.
  /// The function will return a string, the text that will appear at the value of the argument.
  ///
  /// Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
  /// The function, if supplied, must not have any side-effects.
  _i2.String Function(
    _i2.num,
    _i3.TextBlock,
  )? get graduatedFunction => _i5.getProperty(
        this,
        'graduatedFunction',
      );
  /* #19209
  source: 
    /**
     * Gets or sets the function to convert from a value along a "Graduated" Panel to a string.
     * The default returns a string representing the value rounded to at most 2 decimals.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this TextBlock.
     * The function will return a string, the text that will appear at the value of the argument.
     *
     * Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 1.7
     */
    get graduatedFunction(): ((val: number, tb: TextBlock) => string) | null; */
  // Type InteropUnion#369157918(parent: InteropGetter#134641173(name: graduatedFunction))
  set graduatedFunction(
      _i2.String Function(
        _i2.num,
        _i3.TextBlock,
      )? value) {
    _i5.setProperty(
      this,
      'graduatedFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19223
  source: 
    /**
     * Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
     * The default is null and doesn't skip any text labels.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this TextBlock.
     * The function will return a boolean, whether the text label will be skipped at the value of the argument.
     *
     * Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 2.0
     */
    get graduatedSkip(): ((val: number, tb: TextBlock) => boolean) | null; */
  /// Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
  /// The default is null and doesn't skip any text labels.
  ///
  /// The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
  /// and this TextBlock.
  /// The function will return a boolean, whether the text label will be skipped at the value of the argument.
  ///
  /// Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i2.num,
    _i3.TextBlock,
  )? get graduatedSkip => _i5.getProperty(
        this,
        'graduatedSkip',
      );
  /* #19223
  source: 
    /**
     * Gets or sets the function to determine which values along a "Graduated" Panel will be skipped.
     * The default is null and doesn't skip any text labels.
     *
     * The function takes a number argument, a value between Panel#graduatedMin and Panel#graduatedMax,
     * and this TextBlock.
     * The function will return a boolean, whether the text label will be skipped at the value of the argument.
     *
     * Note that the second argument is the TextBlock, *not* a particular label that would be rendered at the given value.
     * The function, if supplied, must not have any side-effects.
     * @since 2.0
     */
    get graduatedSkip(): ((val: number, tb: TextBlock) => boolean) | null; */
  // Type InteropUnion#720140912(parent: InteropGetter#829698031(name: graduatedSkip))
  set graduatedSkip(
      _i2.bool Function(
        _i2.num,
        _i3.TextBlock,
      )? value) {
    _i5.setProperty(
      this,
      'graduatedSkip',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19239
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a user-edited string of text is valid.
     * If this is non-null, the predicate is called in addition to any TextEditingTool#textValidation predicate.
     * See TextEditingTool#isValidText for more details.
     *
     * ```js
     * function(textBlock, oldString, newString)
     * ```
     *
     * The default predicate is null, which is equivalent to simply returning true.
     *
     * The function, if supplied, must not have any side-effects, and must return true or false.
     * @see TextEditingTool#textValidation
     */
    get textValidation(): ((thisTextBlock: TextBlock, oldString: string, newString: string) => boolean) | null; */
  /// Gets or sets the predicate that determines whether or not a user-edited string of text is valid.
  /// If this is non-null, the predicate is called in addition to any TextEditingTool#textValidation predicate.
  /// See TextEditingTool#isValidText for more details.
  ///
  /// ```js
  /// function(textBlock, oldString, newString)
  /// ```
  ///
  /// The default predicate is null, which is equivalent to simply returning true.
  ///
  /// The function, if supplied, must not have any side-effects, and must return true or false.
  _i2.bool Function(
    _i3.TextBlock,
    _i2.String,
    _i2.String,
  )? get textValidation => _i5.getProperty(
        this,
        'textValidation',
      );
  /* #19239
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a user-edited string of text is valid.
     * If this is non-null, the predicate is called in addition to any TextEditingTool#textValidation predicate.
     * See TextEditingTool#isValidText for more details.
     *
     * ```js
     * function(textBlock, oldString, newString)
     * ```
     *
     * The default predicate is null, which is equivalent to simply returning true.
     *
     * The function, if supplied, must not have any side-effects, and must return true or false.
     * @see TextEditingTool#textValidation
     */
    get textValidation(): ((thisTextBlock: TextBlock, oldString: string, newString: string) => boolean) | null; */
  // Type InteropUnion#685052128(parent: InteropGetter#162410835(name: textValidation))
  set textValidation(
      _i2.bool Function(
        _i3.TextBlock,
        _i2.String,
        _i2.String,
      )? value) {
    _i5.setProperty(
      this,
      'textValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19254
  source: 
    /**
     * Gets or sets the function that is called after the TextBlock's text has been edited by the TextEditingTool.
     *   - The first argument is a reference to this TextBlock.
     *   - The second argument is the previous text, before editing.
     *   - The third argument is the current text, which is also TextBlock.text.
     *
     * ```js
     * function(textBlock, previousText, currentText)
     * ```
     *
     * The default value is null -- no function is called.
     * @since 1.7
     */
    get textEdited(): ((thisTextBlock: TextBlock, oldString: string, newString: string) => void) | null; */
  /// Gets or sets the function that is called after the TextBlock's text has been edited by the TextEditingTool.
  ///   - The first argument is a reference to this TextBlock.
  ///   - The second argument is the previous text, before editing.
  ///   - The third argument is the current text, which is also TextBlock.text.
  ///
  /// ```js
  /// function(textBlock, previousText, currentText)
  /// ```
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.TextBlock,
    _i2.String,
    _i2.String,
  )? get textEdited => _i5.getProperty(
        this,
        'textEdited',
      );
  /* #19254
  source: 
    /**
     * Gets or sets the function that is called after the TextBlock's text has been edited by the TextEditingTool.
     *   - The first argument is a reference to this TextBlock.
     *   - The second argument is the previous text, before editing.
     *   - The third argument is the current text, which is also TextBlock.text.
     *
     * ```js
     * function(textBlock, previousText, currentText)
     * ```
     *
     * The default value is null -- no function is called.
     * @since 1.7
     */
    get textEdited(): ((thisTextBlock: TextBlock, oldString: string, newString: string) => void) | null; */
  // Type InteropUnion#948129052(parent: InteropGetter#905718964(name: textEdited))
  set textEdited(
      void Function(
        _i3.TextBlock,
        _i2.String,
        _i2.String,
      )? value) {
    _i5.setProperty(
      this,
      'textEdited',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19265
  source: 
    /**
     * Gets or sets additional spacing above each line of text.
     * The default is zero. The value may be negative.
     *
     * This can be useful when you need to adjust the font spacing on
     * custom fonts or monospace fonts to suit your needs.
     *
     * @since 2.2
     */
    get spacingAbove(): number; */
  /// Gets or sets additional spacing above each line of text.
  /// The default is zero. The value may be negative.
  ///
  /// This can be useful when you need to adjust the font spacing on
  /// custom fonts or monospace fonts to suit your needs.
  _i2.num get spacingAbove => _i5.getProperty(
        this,
        'spacingAbove',
      );
  /* #19265
  source: 
    /**
     * Gets or sets additional spacing above each line of text.
     * The default is zero. The value may be negative.
     *
     * This can be useful when you need to adjust the font spacing on
     * custom fonts or monospace fonts to suit your needs.
     *
     * @since 2.2
     */
    get spacingAbove(): number; */
  // Type InteropStaticType.number
  set spacingAbove(_i2.num value) {
    _i5.setProperty(
      this,
      'spacingAbove',
      value,
    );
  }

  /* #19276
  source: 
    /**
     * Gets or sets additional spacing below each line of text.
     * The default is zero. The value may be negative.
     *
     * This can be useful when you need to adjust the font spacing on
     * custom fonts or monospace fonts to suit your needs.
     *
     * @since 2.2
     */
    get spacingBelow(): number; */
  /// Gets or sets additional spacing below each line of text.
  /// The default is zero. The value may be negative.
  ///
  /// This can be useful when you need to adjust the font spacing on
  /// custom fonts or monospace fonts to suit your needs.
  _i2.num get spacingBelow => _i5.getProperty(
        this,
        'spacingBelow',
      );
  /* #19276
  source: 
    /**
     * Gets or sets additional spacing below each line of text.
     * The default is zero. The value may be negative.
     *
     * This can be useful when you need to adjust the font spacing on
     * custom fonts or monospace fonts to suit your needs.
     *
     * @since 2.2
     */
    get spacingBelow(): number; */
  // Type InteropStaticType.number
  set spacingBelow(_i2.num value) {
    _i5.setProperty(
      this,
      'spacingBelow',
      value,
    );
  }

  /* #19286
  source: 
    /**
     * Gets or sets the policy for trimming whitespace on each line of text.
     *
     * Possible values are TextBlock#FormatTrim, which trims whitespace before and after every line of text,
     * or TextBlock#FormatNone, which will not trim any whitespace and may be useful for preformatted text.
     * The default is TextBlock#FormatTrim.
     * @since 2.2
     */
    get formatting(): EnumValue; */
  /// Gets or sets the policy for trimming whitespace on each line of text.
  ///
  /// Possible values are TextBlock#FormatTrim, which trims whitespace before and after every line of text,
  /// or TextBlock#FormatNone, which will not trim any whitespace and may be useful for preformatted text.
  /// The default is TextBlock#FormatTrim.
  _i3.EnumValue get formatting => _i5.getProperty(
        this,
        'formatting',
      );
  /* #19286
  source: 
    /**
     * Gets or sets the policy for trimming whitespace on each line of text.
     *
     * Possible values are TextBlock#FormatTrim, which trims whitespace before and after every line of text,
     * or TextBlock#FormatNone, which will not trim any whitespace and may be useful for preformatted text.
     * The default is TextBlock#FormatTrim.
     * @since 2.2
     */
    get formatting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set formatting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'formatting',
      value,
    );
  }

  /* #19298
  source: 
    /**
     * Gets or sets the maximum number of lines that this TextBlock can display.
     * Value must be a greater than zero whole number or `Infinity`.
     * The default is `Infinity`.
     *
     * Modifying this value may modify the computed height of the TextBlock.
     * If maxLines is set, the value of #lineCount will never be larger than maxLines.
     * @see #isMultiline
     * @since 1.5
     */
    get maxLines(): number; */
  /// Gets or sets the maximum number of lines that this TextBlock can display.
  /// Value must be a greater than zero whole number or `Infinity`.
  /// The default is `Infinity`.
  ///
  /// Modifying this value may modify the computed height of the TextBlock.
  /// If maxLines is set, the value of #lineCount will never be larger than maxLines.
  _i2.num get maxLines => _i5.getProperty(
        this,
        'maxLines',
      );
  /* #19298
  source: 
    /**
     * Gets or sets the maximum number of lines that this TextBlock can display.
     * Value must be a greater than zero whole number or `Infinity`.
     * The default is `Infinity`.
     *
     * Modifying this value may modify the computed height of the TextBlock.
     * If maxLines is set, the value of #lineCount will never be larger than maxLines.
     * @see #isMultiline
     * @since 1.5
     */
    get maxLines(): number; */
  // Type InteropStaticType.number
  set maxLines(_i2.num value) {
    _i5.setProperty(
      this,
      'maxLines',
      value,
    );
  }

  /* #19308
  source: 
    /**
     * Gets or sets the an array of possible choices for a custom TextEditingTool.
     * The value must be an array of strings.
     *
     * The default value is null.
     * For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
     * @since 1.7
     */
    get choices(): Array<string> | null; */
  /// Gets or sets the an array of possible choices for a custom TextEditingTool.
  /// The value must be an array of strings.
  ///
  /// The default value is null.
  /// For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
  _i4.Array? get choices => _i5.getProperty(
        this,
        'choices',
      );
  /* #19308
  source: 
    /**
     * Gets or sets the an array of possible choices for a custom TextEditingTool.
     * The value must be an array of strings.
     *
     * The default value is null.
     * For example usage, see the <a href="../../samples/customTextEditingTool.html">Custom TextEditingTool Sample</a>.
     * @since 1.7
     */
    get choices(): Array<string> | null; */
  // Type InteropUnion#1047362818(parent: InteropGetter#485109023(name: choices))
  set choices(_i4.Array? value) {
    _i5.setProperty(
      this,
      'choices',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Picture implements _i3.GraphObject {
  factory Picture.$1() => _i5.callConstructor(
        _declaredPicture,
        [],
      );

  factory Picture.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredPicture,
        [init ?? _i4.undefined],
      );

  factory Picture.$3([
    _i2.String? source,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredPicture,
        [
          source ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  static void clearCache([_i2.String? url]) {
    _i5.callMethod(
      _declaredPicture,
      'clearCache',
      [url ?? _i4.undefined],
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Picture')
external _i2.Object _declaredPicture;

extension Picture$Typings on Picture {
  /* #19416
  source: 
    /**
     * Gets or sets the Picture's HTML element that provides some kind of visual image.
     *
     * The default value is null.
     * This can be a HTMLImageElement, HTMLVideoElement, or HTMLCanvasElement.
     * If an image, this element must have its source (src) attribute defined.
     * Setting this does not set the Picture#source attribute and that attribute may be unknowable.
     *
     * If this property is set to an HTMLImageElement, and that element is not yet loaded before it is used,
     * the Diagrams using that Element will not redraw on their own.
     * You must call #redraw after the image is finished loading if you wish for the Diagram to be updated immediately.
     */
    get element(): HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null; */
  /// Gets or sets the Picture's HTML element that provides some kind of visual image.
  ///
  /// The default value is null.
  /// This can be a HTMLImageElement, HTMLVideoElement, or HTMLCanvasElement.
  /// If an image, this element must have its source (src) attribute defined.
  /// Setting this does not set the Picture#source attribute and that attribute may be unknowable.
  ///
  /// If this property is set to an HTMLImageElement, and that element is not yet loaded before it is used,
  /// the Diagrams using that Element will not redraw on their own.
  /// You must call #redraw after the image is finished loading if you wish for the Diagram to be updated immediately.
  _i2.dynamic get element => _i5.getProperty(
        this,
        'element',
      );
  /* #19416
  source: 
    /**
     * Gets or sets the Picture's HTML element that provides some kind of visual image.
     *
     * The default value is null.
     * This can be a HTMLImageElement, HTMLVideoElement, or HTMLCanvasElement.
     * If an image, this element must have its source (src) attribute defined.
     * Setting this does not set the Picture#source attribute and that attribute may be unknowable.
     *
     * If this property is set to an HTMLImageElement, and that element is not yet loaded before it is used,
     * the Diagrams using that Element will not redraw on their own.
     * You must call #redraw after the image is finished loading if you wish for the Diagram to be updated immediately.
     */
    get element(): HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | null; */
  // Type InteropUnion#813033773(parent: InteropGetter#955962604(name: element))
  set element(_i2.dynamic value) {
    _i5.setProperty(
      this,
      'element',
      value ?? _i4.undefined,
    );
  }

  /* #19438
  source: 
    /**
     * Gets or sets the Picture's source URL, which can be any valid image (png, jpg, gif, etc) URL.
     *
     * The default value is the empty string, which specifies no image source.
     * Setting this attribute creates an HTMLImageElement and sets the Picture#element
     * attribute to that element. When the element loads, this Picture may remeasure if no GraphObject#desiredSize was set,
     * and Diagrams using the picture will redraw.
     *
     * To avoid remeasuring and rearranging Parts as images load asynchronously,
     * be sure to set the GraphObject#desiredSize
     * (or GraphObject#width and GraphObject#height) to fixed values.
     *
     * Setting the source of multiple Pictures to the same URL will cause only one HTMLImageElement
     * to be created and shared. Setting the source to the empty string will set Picture#element to null.
     * It is commonplace to either specify a constant URL or to data bind this property to some data property,
     * perhaps using a conversion function in order to produce a proper URL.
     *
     * For cross-browser support of SVG sources additional care is needed.
     * See the final section of the <a href="../../intro/pictures.html">Introduction page on Pictures</a>.
     */
    get source(): string; */
  /// Gets or sets the Picture's source URL, which can be any valid image (png, jpg, gif, etc) URL.
  ///
  /// The default value is the empty string, which specifies no image source.
  /// Setting this attribute creates an HTMLImageElement and sets the Picture#element
  /// attribute to that element. When the element loads, this Picture may remeasure if no GraphObject#desiredSize was set,
  /// and Diagrams using the picture will redraw.
  ///
  /// To avoid remeasuring and rearranging Parts as images load asynchronously,
  /// be sure to set the GraphObject#desiredSize
  /// (or GraphObject#width and GraphObject#height) to fixed values.
  ///
  /// Setting the source of multiple Pictures to the same URL will cause only one HTMLImageElement
  /// to be created and shared. Setting the source to the empty string will set Picture#element to null.
  /// It is commonplace to either specify a constant URL or to data bind this property to some data property,
  /// perhaps using a conversion function in order to produce a proper URL.
  ///
  /// For cross-browser support of SVG sources additional care is needed.
  /// See the final section of the <a href="../../intro/pictures.html">Introduction page on Pictures</a>.
  _i2.String get source => _i5.getProperty(
        this,
        'source',
      );
  /* #19438
  source: 
    /**
     * Gets or sets the Picture's source URL, which can be any valid image (png, jpg, gif, etc) URL.
     *
     * The default value is the empty string, which specifies no image source.
     * Setting this attribute creates an HTMLImageElement and sets the Picture#element
     * attribute to that element. When the element loads, this Picture may remeasure if no GraphObject#desiredSize was set,
     * and Diagrams using the picture will redraw.
     *
     * To avoid remeasuring and rearranging Parts as images load asynchronously,
     * be sure to set the GraphObject#desiredSize
     * (or GraphObject#width and GraphObject#height) to fixed values.
     *
     * Setting the source of multiple Pictures to the same URL will cause only one HTMLImageElement
     * to be created and shared. Setting the source to the empty string will set Picture#element to null.
     * It is commonplace to either specify a constant URL or to data bind this property to some data property,
     * perhaps using a conversion function in order to produce a proper URL.
     *
     * For cross-browser support of SVG sources additional care is needed.
     * See the final section of the <a href="../../intro/pictures.html">Introduction page on Pictures</a>.
     */
    get source(): string; */
  // Type InteropStaticType.string
  set source(_i2.String value) {
    _i5.setProperty(
      this,
      'source',
      value,
    );
  }

  /* #19478
  source: 
    /**
     * Gets or sets a function that returns a value for image.crossOrigin.
     *
     * The default value is null, which will not set a value for image.crossOrigin.
     * Set this property to a function that returns "anonymous" or "use-credentials"
     * if you want images to complete a cross-origin request.
     * Example:
     * ```js
     *    $(go.Picture,
     *      { width: 64, height: 64 },
     *      { sourceCrossOrigin: pict => "use-credentials" },
     *      new go.Binding("source", "path"))
     * ```
     * @since 1.5
     */
    get sourceCrossOrigin(): ((a: Picture) => string) | null; */
  /// Gets or sets a function that returns a value for image.crossOrigin.
  ///
  /// The default value is null, which will not set a value for image.crossOrigin.
  /// Set this property to a function that returns "anonymous" or "use-credentials"
  /// if you want images to complete a cross-origin request.
  /// Example:
  /// ```js
  ///    $(go.Picture,
  ///      { width: 64, height: 64 },
  ///      { sourceCrossOrigin: pict => "use-credentials" },
  ///      new go.Binding("source", "path"))
  /// ```
  _i2.String Function(_i3.Picture)? get sourceCrossOrigin => _i5.getProperty(
        this,
        'sourceCrossOrigin',
      );
  /* #19478
  source: 
    /**
     * Gets or sets a function that returns a value for image.crossOrigin.
     *
     * The default value is null, which will not set a value for image.crossOrigin.
     * Set this property to a function that returns "anonymous" or "use-credentials"
     * if you want images to complete a cross-origin request.
     * Example:
     * ```js
     *    $(go.Picture,
     *      { width: 64, height: 64 },
     *      { sourceCrossOrigin: pict => "use-credentials" },
     *      new go.Binding("source", "path"))
     * ```
     * @since 1.5
     */
    get sourceCrossOrigin(): ((a: Picture) => string) | null; */
  // Type InteropUnion#199586986(parent: InteropGetter#731560847(name: sourceCrossOrigin))
  set sourceCrossOrigin(_i2.String Function(_i3.Picture)? value) {
    _i5.setProperty(
      this,
      'sourceCrossOrigin',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19487
  source: 
    /**
     * Gets or sets the rectangular area of the source image that this picture should display.
     * This is only common with sprite maps and image tables.
     *
     * The value must be of type Rect.
     * The default value is Rect(NaN, NaN, NaN, NaN), which means the whole source image should be used.
     */
    get sourceRect(): Rect; */
  /// Gets or sets the rectangular area of the source image that this picture should display.
  /// This is only common with sprite maps and image tables.
  ///
  /// The value must be of type Rect.
  /// The default value is Rect(NaN, NaN, NaN, NaN), which means the whole source image should be used.
  _i3.Rect get sourceRect => _i5.getProperty(
        this,
        'sourceRect',
      );
  /* #19487
  source: 
    /**
     * Gets or sets the rectangular area of the source image that this picture should display.
     * This is only common with sprite maps and image tables.
     *
     * The value must be of type Rect.
     * The default value is Rect(NaN, NaN, NaN, NaN), which means the whole source image should be used.
     */
    get sourceRect(): Rect; */
  // Type Instance of 'InteropInterface'
  set sourceRect(_i3.Rect value) {
    _i5.setProperty(
      this,
      'sourceRect',
      value,
    );
  }

  /* #19500
  source: 
    /**
     * Gets or sets how the Picture's image is stretched within its bounding box.
     * Some images will be a different aspect ratio than their given size or #desiredSize.
     * This property will never change the size of the Picture itself,
     * only the size of the image that is drawn in the Picture's #actualBounds.
     *
     * Possible values are GraphObject.Fill, GraphObject.Uniform,
     * GraphObject.UniformToFill, and GraphObject.None.
     * The default is GraphObject.Fill.
     * @see #imageAlignment
     */
    get imageStretch(): EnumValue; */
  /// Gets or sets how the Picture's image is stretched within its bounding box.
  /// Some images will be a different aspect ratio than their given size or #desiredSize.
  /// This property will never change the size of the Picture itself,
  /// only the size of the image that is drawn in the Picture's #actualBounds.
  ///
  /// Possible values are GraphObject.Fill, GraphObject.Uniform,
  /// GraphObject.UniformToFill, and GraphObject.None.
  /// The default is GraphObject.Fill.
  _i3.EnumValue get imageStretch => _i5.getProperty(
        this,
        'imageStretch',
      );
  /* #19500
  source: 
    /**
     * Gets or sets how the Picture's image is stretched within its bounding box.
     * Some images will be a different aspect ratio than their given size or #desiredSize.
     * This property will never change the size of the Picture itself,
     * only the size of the image that is drawn in the Picture's #actualBounds.
     *
     * Possible values are GraphObject.Fill, GraphObject.Uniform,
     * GraphObject.UniformToFill, and GraphObject.None.
     * The default is GraphObject.Fill.
     * @see #imageAlignment
     */
    get imageStretch(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set imageStretch(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'imageStretch',
      value,
    );
  }

  /* #19509
  source: 
    /**
     * Gets or sets how the Picture is displayed: Either normally or with a Horizontal or Vertical flip or both.
     *
     * Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
     * The default is GraphObject.None.
     * @since 2.0
     */
    get flip(): EnumValue; */
  /// Gets or sets how the Picture is displayed: Either normally or with a Horizontal or Vertical flip or both.
  ///
  /// Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
  /// The default is GraphObject.None.
  _i3.EnumValue get flip => _i5.getProperty(
        this,
        'flip',
      );
  /* #19509
  source: 
    /**
     * Gets or sets how the Picture is displayed: Either normally or with a Horizontal or Vertical flip or both.
     *
     * Possible values are GraphObject.None, GraphObject.FlipHorizontal, GraphObject.FlipVertical, or GraphObject.FlipBoth.
     * The default is GraphObject.None.
     * @since 2.0
     */
    get flip(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set flip(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'flip',
      value,
    );
  }

  /* #19521
  source: 
    /**
     * Gets or sets the Spot to align the source image to, when the source image
     * is smaller than the Picture. This is only relevant when
     * the #imageStretch property value is not go.GraphObject.Fill.
     *
     * This does not affect Picture coordinates or bounds, it only affects what is drawn within the given area.
     * The default value is Spot.Center.
     * @see #imageStretch
     * @since 1.7
     */
    get imageAlignment(): Spot; */
  /// Gets or sets the Spot to align the source image to, when the source image
  /// is smaller than the Picture. This is only relevant when
  /// the #imageStretch property value is not go.GraphObject.Fill.
  ///
  /// This does not affect Picture coordinates or bounds, it only affects what is drawn within the given area.
  /// The default value is Spot.Center.
  _i3.Spot get imageAlignment => _i5.getProperty(
        this,
        'imageAlignment',
      );
  /* #19521
  source: 
    /**
     * Gets or sets the Spot to align the source image to, when the source image
     * is smaller than the Picture. This is only relevant when
     * the #imageStretch property value is not go.GraphObject.Fill.
     *
     * This does not affect Picture coordinates or bounds, it only affects what is drawn within the given area.
     * The default value is Spot.Center.
     * @see #imageStretch
     * @since 1.7
     */
    get imageAlignment(): Spot; */
  // Type Instance of 'InteropInterface'
  set imageAlignment(_i3.Spot value) {
    _i5.setProperty(
      this,
      'imageAlignment',
      value,
    );
  }

  /* #19533
  source: 
    /**
     * Gets or sets the function to call if an image set by #source fails to load.
     * The arguments to this function are this Picture and the HTMLImageElement's "error" Event.
     *
     * This is called once per Picture, for every Picture that is using the same #source that failed to load.
     * This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
     *
     * The default value is null, meaning that no specific action occurs when there is an error loading an image.
     * @see #successFunction
     */
    get errorFunction(): ((a: Picture, b: Event) => void) | null; */
  /// Gets or sets the function to call if an image set by #source fails to load.
  /// The arguments to this function are this Picture and the HTMLImageElement's "error" Event.
  ///
  /// This is called once per Picture, for every Picture that is using the same #source that failed to load.
  /// This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
  ///
  /// The default value is null, meaning that no specific action occurs when there is an error loading an image.
  void Function(
    _i3.Picture,
    _i4.Event,
  )? get errorFunction => _i5.getProperty(
        this,
        'errorFunction',
      );
  /* #19533
  source: 
    /**
     * Gets or sets the function to call if an image set by #source fails to load.
     * The arguments to this function are this Picture and the HTMLImageElement's "error" Event.
     *
     * This is called once per Picture, for every Picture that is using the same #source that failed to load.
     * This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
     *
     * The default value is null, meaning that no specific action occurs when there is an error loading an image.
     * @see #successFunction
     */
    get errorFunction(): ((a: Picture, b: Event) => void) | null; */
  // Type InteropUnion#430915762(parent: InteropGetter#594005144(name: errorFunction))
  set errorFunction(
      void Function(
        _i3.Picture,
        _i4.Event,
      )? value) {
    _i5.setProperty(
      this,
      'errorFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19548
  source: 
    /**
     * Gets or sets the function to call when an image set by #source loads successfully.
     * The arguments to this function are this Picture and the HTMLImageElement's "load" Event.
     *
     * This is called once per Picture, for every Picture that is using the same #source that loaded successfully.
     * This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
     * It is even called for a Picture source that has already loaded, so that creating copies of a Picture with this property set will
     * call it once for each newly created Picture.
     *
     * The default value is null, meaning that no specific action occurs when an image finishes loading.
     * @see #errorFunction
     * @since 1.7
     */
    get successFunction(): ((a: Picture, b: Event) => void) | null; */
  /// Gets or sets the function to call when an image set by #source loads successfully.
  /// The arguments to this function are this Picture and the HTMLImageElement's "load" Event.
  ///
  /// This is called once per Picture, for every Picture that is using the same #source that loaded successfully.
  /// This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
  /// It is even called for a Picture source that has already loaded, so that creating copies of a Picture with this property set will
  /// call it once for each newly created Picture.
  ///
  /// The default value is null, meaning that no specific action occurs when an image finishes loading.
  void Function(
    _i3.Picture,
    _i4.Event,
  )? get successFunction => _i5.getProperty(
        this,
        'successFunction',
      );
  /* #19548
  source: 
    /**
     * Gets or sets the function to call when an image set by #source loads successfully.
     * The arguments to this function are this Picture and the HTMLImageElement's "load" Event.
     *
     * This is called once per Picture, for every Picture that is using the same #source that loaded successfully.
     * This will never be called if the #source is never set, and is not called with Pictures that use #element instead.
     * It is even called for a Picture source that has already loaded, so that creating copies of a Picture with this property set will
     * call it once for each newly created Picture.
     *
     * The default value is null, meaning that no specific action occurs when an image finishes loading.
     * @see #errorFunction
     * @since 1.7
     */
    get successFunction(): ((a: Picture, b: Event) => void) | null; */
  // Type InteropUnion#463803980(parent: InteropGetter#463855457(name: successFunction))
  set successFunction(
      void Function(
        _i3.Picture,
        _i4.Event,
      )? value) {
    _i5.setProperty(
      this,
      'successFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19555
  source: 
    /**
     * This read-only property returns the natural size of this picture as determined by its source's width and height.
     * The value is initially NaN x NaN until the picture has been measured.
     * It will use the #element's `naturalWidth` and `naturalHeight` if available.
     */
    get naturalBounds(): Rect; */
  /// This read-only property returns the natural size of this picture as determined by its source's width and height.
  /// The value is initially NaN x NaN until the picture has been measured.
  /// It will use the #element's `naturalWidth` and `naturalHeight` if available.
  _i3.Rect get naturalBounds => _i5.getProperty(
        this,
        'naturalBounds',
      );
  /* #19555
  source: 
    /**
     * This read-only property returns the natural size of this picture as determined by its source's width and height.
     * The value is initially NaN x NaN until the picture has been measured.
     * It will use the #element's `naturalWidth` and `naturalHeight` if available.
     */
    get naturalBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set naturalBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'naturalBounds',
      value,
    );
  }

  void reloadSource() {
    _i5.callMethod(
      this,
      'reloadSource',
      [],
    );
  }

  void redraw() {
    _i5.callMethod(
      this,
      'redraw',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Part implements _i3.Panel {
  factory Part.$1() => _i5.callConstructor(
        _declaredPart,
        [],
      );

  factory Part.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredPart,
        [init ?? _i4.undefined],
      );

  factory Part.$3([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredPart,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  /* #19767
  source: 
    /**
     * This value may be used as the value of the Part#layoutConditions property to indicate that
     * no operation on this Part causes invalidation of the Layout responsible for this Part.
     * @constant
     */
    static LayoutNone: number; */
  /// This value may be used as the value of the Part#layoutConditions property to indicate that
  /// no operation on this Part causes invalidation of the Layout responsible for this Part.
  static _i2.num get layoutNone => _i5.getProperty(
        _declaredPart,
        'LayoutNone',
      );
  /* #19767
  source: 
    /**
     * This value may be used as the value of the Part#layoutConditions property to indicate that
     * no operation on this Part causes invalidation of the Layout responsible for this Part.
     * @constant
     */
    static LayoutNone: number; */
  // Type InteropStaticType.number
  static set layoutNone(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutNone',
      value,
    );
  }

  /* #19773
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part is added to a Diagram or Group, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutAdded: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Part is added to a Diagram or Group, it invalidates the Layout responsible for the Part.
  static _i2.num get layoutAdded => _i5.getProperty(
        _declaredPart,
        'LayoutAdded',
      );
  /* #19773
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part is added to a Diagram or Group, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutAdded: number; */
  // Type InteropStaticType.number
  static set layoutAdded(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutAdded',
      value,
    );
  }

  /* #19779
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part is removed from a Diagram or Group, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutRemoved: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Part is removed from a Diagram or Group, it invalidates the Layout responsible for the Part.
  static _i2.num get layoutRemoved => _i5.getProperty(
        _declaredPart,
        'LayoutRemoved',
      );
  /* #19779
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part is removed from a Diagram or Group, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutRemoved: number; */
  // Type InteropStaticType.number
  static set layoutRemoved(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutRemoved',
      value,
    );
  }

  /* #19785
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part's GraphObject#visible becomes true, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutShown: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Part's GraphObject#visible becomes true, it invalidates the Layout responsible for the Part.
  static _i2.num get layoutShown => _i5.getProperty(
        _declaredPart,
        'LayoutShown',
      );
  /* #19785
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part's GraphObject#visible becomes true, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutShown: number; */
  // Type InteropStaticType.number
  static set layoutShown(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutShown',
      value,
    );
  }

  /* #19791
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part's GraphObject#visible becomes false, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutHidden: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Part's GraphObject#visible becomes false, it invalidates the Layout responsible for the Part.
  static _i2.num get layoutHidden => _i5.getProperty(
        _declaredPart,
        'LayoutHidden',
      );
  /* #19791
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Part's GraphObject#visible becomes false, it invalidates the Layout responsible for the Part.
     * @constant
     */
    static LayoutHidden: number; */
  // Type InteropStaticType.number
  static set layoutHidden(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutHidden',
      value,
    );
  }

  /* #19798
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Node or simple Part's GraphObject#actualBounds changes size, it invalidates the Layout responsible for the Part;
     * this flag is ignored for Parts that are Links.
     * @constant
     */
    static LayoutNodeSized: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Node or simple Part's GraphObject#actualBounds changes size, it invalidates the Layout responsible for the Part;
  /// this flag is ignored for Parts that are Links.
  static _i2.num get layoutNodeSized => _i5.getProperty(
        _declaredPart,
        'LayoutNodeSized',
      );
  /* #19798
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Node or simple Part's GraphObject#actualBounds changes size, it invalidates the Layout responsible for the Part;
     * this flag is ignored for Parts that are Links.
     * @constant
     */
    static LayoutNodeSized: number; */
  // Type InteropStaticType.number
  static set layoutNodeSized(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutNodeSized',
      value,
    );
  }

  /* #19805
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Group has been laid out, it invalidates the Layout responsible for that Group;
     * this flag is ignored for Parts that are not Groups.
     * @constant
     */
    static LayoutGroupLayout: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Group has been laid out, it invalidates the Layout responsible for that Group;
  /// this flag is ignored for Parts that are not Groups.
  static _i2.num get layoutGroupLayout => _i5.getProperty(
        _declaredPart,
        'LayoutGroupLayout',
      );
  /* #19805
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Group has been laid out, it invalidates the Layout responsible for that Group;
     * this flag is ignored for Parts that are not Groups.
     * @constant
     */
    static LayoutGroupLayout: number; */
  // Type InteropStaticType.number
  static set layoutGroupLayout(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutGroupLayout',
      value,
    );
  }

  /* #19812
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Node or simple Part's #category changes, it invalidates the Layout responsible for the Part;
     * this flag is ignored for Parts that are Links.
     * @constant
     */
    static LayoutNodeReplaced: number; */
  /// This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
  /// when a Node or simple Part's #category changes, it invalidates the Layout responsible for the Part;
  /// this flag is ignored for Parts that are Links.
  static _i2.num get layoutNodeReplaced => _i5.getProperty(
        _declaredPart,
        'LayoutNodeReplaced',
      );
  /* #19812
  source: 
    /**
     * This flag may be combined with other "Layout" flags as the value of the Part#layoutConditions property to indicate that
     * when a Node or simple Part's #category changes, it invalidates the Layout responsible for the Part;
     * this flag is ignored for Parts that are Links.
     * @constant
     */
    static LayoutNodeReplaced: number; */
  // Type InteropStaticType.number
  static set layoutNodeReplaced(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutNodeReplaced',
      value,
    );
  }

  /* #19819
  source: 
    /**
     * This is the default value for the Part#layoutConditions property, basically a combination of all of the conditions:
     * the Layout responsible for the Part is invalidated when the Part is added or removed or replaced
     * from the Diagram or Group, or when it changes visibility or size, or when a Group's layout has been performed.
     * @constant
     */
    static LayoutStandard: number; */
  /// This is the default value for the Part#layoutConditions property, basically a combination of all of the conditions:
  /// the Layout responsible for the Part is invalidated when the Part is added or removed or replaced
  /// from the Diagram or Group, or when it changes visibility or size, or when a Group's layout has been performed.
  static _i2.num get layoutStandard => _i5.getProperty(
        _declaredPart,
        'LayoutStandard',
      );
  /* #19819
  source: 
    /**
     * This is the default value for the Part#layoutConditions property, basically a combination of all of the conditions:
     * the Layout responsible for the Part is invalidated when the Part is added or removed or replaced
     * from the Diagram or Group, or when it changes visibility or size, or when a Group's layout has been performed.
     * @constant
     */
    static LayoutStandard: number; */
  // Type InteropStaticType.number
  static set layoutStandard(_i2.num value) {
    _i5.setProperty(
      _declaredPart,
      'LayoutStandard',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Part')
external _i2.Object _declaredPart;

extension Part$Typings on Part {
  /* #19860
  source: 
    /**
     * This read-only property returns the Part's Model data key if it is in a Diagram and is backed by Model data.
     * Otherwise this returns undefined.
     * @since 1.8
     * @see Model#getKeyForNodeData
     */
    get key(): Key; */
  /// This read-only property returns the Part's Model data key if it is in a Diagram and is backed by Model data.
  /// Otherwise this returns undefined.
  _i3.Key get key => _i5.getProperty(
        this,
        'key',
      );
  /* #19860
  source: 
    /**
     * This read-only property returns the Part's Model data key if it is in a Diagram and is backed by Model data.
     * Otherwise this returns undefined.
     * @since 1.8
     * @see Model#getKeyForNodeData
     */
    get key(): Key; */
  // Type InteropTypedef#911623829(name: Key)
  set key(_i3.Key value) {
    _i5.setProperty(
      this,
      'key',
      value ?? _i4.undefined,
    );
  }

  /* #19869
  source: 
    /**
     * This read-only property returns an iterator over all of the Adornments associated with this part.
     * After each call to the iterator's next() method that returns true,
     * the iterator's key will be the category and the iterator's value will
     * be an Adornment.
     *
     * Templates should not have any adornments.
     */
    get adornments(): Iterator<Adornment>; */
  /// This read-only property returns an iterator over all of the Adornments associated with this part.
  /// After each call to the iterator's next() method that returns true,
  /// the iterator's key will be the category and the iterator's value will
  /// be an Adornment.
  ///
  /// Templates should not have any adornments.
  _i3.Iterator<_i3.Adornment> get adornments => _i5.getProperty(
        this,
        'adornments',
      );
  /* #19869
  source: 
    /**
     * This read-only property returns an iterator over all of the Adornments associated with this part.
     * After each call to the iterator's next() method that returns true,
     * the iterator's key will be the category and the iterator's value will
     * be an Adornment.
     *
     * Templates should not have any adornments.
     */
    get adornments(): Iterator<Adornment>; */
  // Type Instance of 'InteropInterface'
  set adornments(_i3.Iterator<_i3.Adornment> value) {
    _i5.setProperty(
      this,
      'adornments',
      value,
    );
  }

  /* #19919
  source: 
    /**
     * This read-only property returns the Layer that this Part is in.
     * The value is the Layer that is named with the value of #layerName.
     * If you want to change what Layer this Part is in, change the value of #layerName to refer to a different Layer.
     *
     * This will be null if it has not yet been added to a Diagram,
     * or if it has already been removed from a Diagram.
     * @see #layerName
     */
    get layer(): Layer | null; */
  /// This read-only property returns the Layer that this Part is in.
  /// The value is the Layer that is named with the value of #layerName.
  /// If you want to change what Layer this Part is in, change the value of #layerName to refer to a different Layer.
  ///
  /// This will be null if it has not yet been added to a Diagram,
  /// or if it has already been removed from a Diagram.
  _i3.Layer? get layer => _i5.getProperty(
        this,
        'layer',
      );
  /* #19919
  source: 
    /**
     * This read-only property returns the Layer that this Part is in.
     * The value is the Layer that is named with the value of #layerName.
     * If you want to change what Layer this Part is in, change the value of #layerName to refer to a different Layer.
     *
     * This will be null if it has not yet been added to a Diagram,
     * or if it has already been removed from a Diagram.
     * @see #layerName
     */
    get layer(): Layer | null; */
  // Type InteropUnion#601644942(parent: InteropGetter#380060464(name: layer))
  set layer(_i3.Layer? value) {
    _i5.setProperty(
      this,
      'layer',
      value ?? _i4.undefined,
    );
  }

  /* #19925
  source: 
    /**
     * This read-only property returns the Diagram that this Part is in.
     *
     * This will be null if it is not in a Layer.
     */
    get diagram(): Diagram | null; */
  /// This read-only property returns the Diagram that this Part is in.
  ///
  /// This will be null if it is not in a Layer.
  _i3.Diagram? get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #19925
  source: 
    /**
     * This read-only property returns the Diagram that this Part is in.
     *
     * This will be null if it is not in a Layer.
     */
    get diagram(): Diagram | null; */
  // Type InteropUnion#625190418(parent: InteropGetter#715292846(name: diagram))
  set diagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'diagram',
      value ?? _i4.undefined,
    );
  }

  /* #19940
  source: 
    /**
     * Gets or sets the layer name for this part.
     * The initial value is an empty string, which is the name of the default layer.
     * The value of this property determines the value of #layer.
     *
     * If this part is not yet in a Diagram,
     * this value is used by Diagram#add
     * to determine which Layer this part should go in.
     * If no layer can be found with this name, it uses the default layer.
     *
     * Changing the value of this property while it is already in a layer
     * causes it to change layers if needed.
     * @see #layerChanged
     */
    get layerName(): string; */
  /// Gets or sets the layer name for this part.
  /// The initial value is an empty string, which is the name of the default layer.
  /// The value of this property determines the value of #layer.
  ///
  /// If this part is not yet in a Diagram,
  /// this value is used by Diagram#add
  /// to determine which Layer this part should go in.
  /// If no layer can be found with this name, it uses the default layer.
  ///
  /// Changing the value of this property while it is already in a layer
  /// causes it to change layers if needed.
  _i2.String get layerName => _i5.getProperty(
        this,
        'layerName',
      );
  /* #19940
  source: 
    /**
     * Gets or sets the layer name for this part.
     * The initial value is an empty string, which is the name of the default layer.
     * The value of this property determines the value of #layer.
     *
     * If this part is not yet in a Diagram,
     * this value is used by Diagram#add
     * to determine which Layer this part should go in.
     * If no layer can be found with this name, it uses the default layer.
     *
     * Changing the value of this property while it is already in a layer
     * causes it to change layers if needed.
     * @see #layerChanged
     */
    get layerName(): string; */
  // Type InteropStaticType.string
  set layerName(_i2.String value) {
    _i5.setProperty(
      this,
      'layerName',
      value,
    );
  }

  /* #19952
  source: 
    /**
     * Gets or sets the function to execute when this part changes layers.
     * It is typically used to modify the appearance of the part.
     * This function must not change the layer of this part by setting #layerName.
     *
     * If this property value is a function, it is called with three arguments,
     * this Part, the old Layer (may be null), and the new Layer (may be null).
     * By default this property is null -- no function is called.
     * @see #layerName
     */
    get layerChanged(): ((thisPart: Part, oldLayer: Layer | null, newLayer: Layer | null) => void) | null; */
  /// Gets or sets the function to execute when this part changes layers.
  /// It is typically used to modify the appearance of the part.
  /// This function must not change the layer of this part by setting #layerName.
  ///
  /// If this property value is a function, it is called with three arguments,
  /// this Part, the old Layer (may be null), and the new Layer (may be null).
  /// By default this property is null -- no function is called.
  void Function(
    _i3.Part,
    _i3.Layer?,
    _i3.Layer?,
  )? get layerChanged => _i5.getProperty(
        this,
        'layerChanged',
      );
  /* #19952
  source: 
    /**
     * Gets or sets the function to execute when this part changes layers.
     * It is typically used to modify the appearance of the part.
     * This function must not change the layer of this part by setting #layerName.
     *
     * If this property value is a function, it is called with three arguments,
     * this Part, the old Layer (may be null), and the new Layer (may be null).
     * By default this property is null -- no function is called.
     * @see #layerName
     */
    get layerChanged(): ((thisPart: Part, oldLayer: Layer | null, newLayer: Layer | null) => void) | null; */
  // Type InteropUnion#767331974(parent: InteropGetter#32282416(name: layerChanged))
  set layerChanged(
      void Function(
        _i3.Part,
        _i3.Layer?,
        _i3.Layer?,
      )? value) {
    _i5.setProperty(
      this,
      'layerChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #19968
  source: 
    /**
     * Gets or sets the Z-ordering position of this Part within its Layer.
     *
     * Within the same layer, nodes with larger zOrder values are placed in front of nodes with smaller zOrder values.
     * When the value is NaN the ordering is not specified.
     * The default value is NaN.
     *
     * When a Group has a zOrder value of NaN, it is automatically placed behind its member nodes and links
     * that also have no zOrder.
     * Such automatic ordering is not guaranteed if any nodes including the groups have a numeric zOrder.
     * If you do want to specify the zOrder of nodes, you should also specify the zOrder of their containing groups
     * unless those groups are in different layers.
     * @since 1.6
     */
    get zOrder(): number; */
  /// Gets or sets the Z-ordering position of this Part within its Layer.
  ///
  /// Within the same layer, nodes with larger zOrder values are placed in front of nodes with smaller zOrder values.
  /// When the value is NaN the ordering is not specified.
  /// The default value is NaN.
  ///
  /// When a Group has a zOrder value of NaN, it is automatically placed behind its member nodes and links
  /// that also have no zOrder.
  /// Such automatic ordering is not guaranteed if any nodes including the groups have a numeric zOrder.
  /// If you do want to specify the zOrder of nodes, you should also specify the zOrder of their containing groups
  /// unless those groups are in different layers.
  _i2.num get zOrder => _i5.getProperty(
        this,
        'zOrder',
      );
  /* #19968
  source: 
    /**
     * Gets or sets the Z-ordering position of this Part within its Layer.
     *
     * Within the same layer, nodes with larger zOrder values are placed in front of nodes with smaller zOrder values.
     * When the value is NaN the ordering is not specified.
     * The default value is NaN.
     *
     * When a Group has a zOrder value of NaN, it is automatically placed behind its member nodes and links
     * that also have no zOrder.
     * Such automatic ordering is not guaranteed if any nodes including the groups have a numeric zOrder.
     * If you do want to specify the zOrder of nodes, you should also specify the zOrder of their containing groups
     * unless those groups are in different layers.
     * @since 1.6
     */
    get zOrder(): number; */
  // Type InteropStaticType.number
  set zOrder(_i2.num value) {
    _i5.setProperty(
      this,
      'zOrder',
      value,
    );
  }

  /* #19975
  source: 
    /**
     * This read-only property returns the GraphObject that determines the location of this Part.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #locationObjectName.
     */
    get locationObject(): GraphObject; */
  /// This read-only property returns the GraphObject that determines the location of this Part.
  /// The value will be in the visual tree of this Part and is usually named with
  /// the value of #locationObjectName.
  _i3.GraphObject get locationObject => _i5.getProperty(
        this,
        'locationObject',
      );
  /* #19975
  source: 
    /**
     * This read-only property returns the GraphObject that determines the location of this Part.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #locationObjectName.
     */
    get locationObject(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set locationObject(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'locationObject',
      value,
    );
  }

  /* #19988
  source: 
    /**
     * Gets or sets the minimum location of this Part to which the user may drag using the DraggingTool.
     *
     * Value must be of type Point.
     * The initial value is (-Infinity, -Infinity), which imposes no position constraint.
     * A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the minimum,
     * and similarly for NaN as the Y value.
     * @see #location
     * @see #maxLocation
     * @see #dragComputation
     * @see #movable
     */
    get minLocation(): Point; */
  /// Gets or sets the minimum location of this Part to which the user may drag using the DraggingTool.
  ///
  /// Value must be of type Point.
  /// The initial value is (-Infinity, -Infinity), which imposes no position constraint.
  /// A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the minimum,
  /// and similarly for NaN as the Y value.
  _i3.Point get minLocation => _i5.getProperty(
        this,
        'minLocation',
      );
  /* #19988
  source: 
    /**
     * Gets or sets the minimum location of this Part to which the user may drag using the DraggingTool.
     *
     * Value must be of type Point.
     * The initial value is (-Infinity, -Infinity), which imposes no position constraint.
     * A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the minimum,
     * and similarly for NaN as the Y value.
     * @see #location
     * @see #maxLocation
     * @see #dragComputation
     * @see #movable
     */
    get minLocation(): Point; */
  // Type Instance of 'InteropInterface'
  set minLocation(_i3.Point value) {
    _i5.setProperty(
      this,
      'minLocation',
      value,
    );
  }

  /* #20002
  source: 
    /**
     * Gets or sets the maximum location of this Part to which the user may drag using the DraggingTool.
     *
     * Value must be of type Point.
     * The initial value is (Infinity, Infinity), which imposes no position constraint.
     * A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the maximum,
     * and similarly for NaN as the Y value.
     * @see #location
     * @see #minLocation
     * @see #dragComputation
     * @see #movable
     */
    get maxLocation(): Point; */
  /// Gets or sets the maximum location of this Part to which the user may drag using the DraggingTool.
  ///
  /// Value must be of type Point.
  /// The initial value is (Infinity, Infinity), which imposes no position constraint.
  /// A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the maximum,
  /// and similarly for NaN as the Y value.
  _i3.Point get maxLocation => _i5.getProperty(
        this,
        'maxLocation',
      );
  /* #20002
  source: 
    /**
     * Gets or sets the maximum location of this Part to which the user may drag using the DraggingTool.
     *
     * Value must be of type Point.
     * The initial value is (Infinity, Infinity), which imposes no position constraint.
     * A X value of NaN causes Diagram#computeMove to use the part's current location's X value as the maximum,
     * and similarly for NaN as the Y value.
     * @see #location
     * @see #minLocation
     * @see #dragComputation
     * @see #movable
     */
    get maxLocation(): Point; */
  // Type Instance of 'InteropInterface'
  set maxLocation(_i3.Point value) {
    _i5.setProperty(
      this,
      'maxLocation',
      value,
    );
  }

  /* #20015
  source: 
    /**
     * Gets or sets the name of the GraphObject that provides the location of this Part.
     * This name determines the value of #locationObject.
     * The actual #location also depends on the #locationSpot.
     *
     * The initial value is an empty string, meaning the whole Part itself determines the location.
     * If you want to use a particular GraphObject in the visual tree of this Part,
     * set this property to be the GraphObject#name of the element that you want to be the #locationObject.
     * @see #location
     * @see #locationSpot
     */
    get locationObjectName(): string; */
  /// Gets or sets the name of the GraphObject that provides the location of this Part.
  /// This name determines the value of #locationObject.
  /// The actual #location also depends on the #locationSpot.
  ///
  /// The initial value is an empty string, meaning the whole Part itself determines the location.
  /// If you want to use a particular GraphObject in the visual tree of this Part,
  /// set this property to be the GraphObject#name of the element that you want to be the #locationObject.
  _i2.String get locationObjectName => _i5.getProperty(
        this,
        'locationObjectName',
      );
  /* #20015
  source: 
    /**
     * Gets or sets the name of the GraphObject that provides the location of this Part.
     * This name determines the value of #locationObject.
     * The actual #location also depends on the #locationSpot.
     *
     * The initial value is an empty string, meaning the whole Part itself determines the location.
     * If you want to use a particular GraphObject in the visual tree of this Part,
     * set this property to be the GraphObject#name of the element that you want to be the #locationObject.
     * @see #location
     * @see #locationSpot
     */
    get locationObjectName(): string; */
  // Type InteropStaticType.string
  set locationObjectName(_i2.String value) {
    _i5.setProperty(
      this,
      'locationObjectName',
      value,
    );
  }

  /* #20032
  source: 
    /**
     * Gets or sets the location Spot of this Node, the spot on the #locationObject
     * that is used in positioning this part in the diagram.
     *
     * Value must be of the type Spot.
     * The initial value is `Spot.TopLeft`.
     * The value must be a specific spot -- i.e. one for which Spot#isSpot is true.
     *
     * It is commonplace to set this property to `Spot.Center`, so that the #location
     * has a value corresponding to the point at the center of this Part's #locationObject element.
     * But the GraphObject#position of a Part is always at the top-left corner
     * point of the GraphObject#actualBounds.
     * @see #location
     * @see #locationObjectName
     */
    get locationSpot(): Spot; */
  /// Gets or sets the location Spot of this Node, the spot on the #locationObject
  /// that is used in positioning this part in the diagram.
  ///
  /// Value must be of the type Spot.
  /// The initial value is `Spot.TopLeft`.
  /// The value must be a specific spot -- i.e. one for which Spot#isSpot is true.
  ///
  /// It is commonplace to set this property to `Spot.Center`, so that the #location
  /// has a value corresponding to the point at the center of this Part's #locationObject element.
  /// But the GraphObject#position of a Part is always at the top-left corner
  /// point of the GraphObject#actualBounds.
  _i3.Spot get locationSpot => _i5.getProperty(
        this,
        'locationSpot',
      );
  /* #20032
  source: 
    /**
     * Gets or sets the location Spot of this Node, the spot on the #locationObject
     * that is used in positioning this part in the diagram.
     *
     * Value must be of the type Spot.
     * The initial value is `Spot.TopLeft`.
     * The value must be a specific spot -- i.e. one for which Spot#isSpot is true.
     *
     * It is commonplace to set this property to `Spot.Center`, so that the #location
     * has a value corresponding to the point at the center of this Part's #locationObject element.
     * But the GraphObject#position of a Part is always at the top-left corner
     * point of the GraphObject#actualBounds.
     * @see #location
     * @see #locationObjectName
     */
    get locationSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set locationSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'locationSpot',
      value,
    );
  }

  /* #20139
  source: 
    /**
     * Gets or sets the position of this part in document coordinates,
     * based on the #locationSpot in this part's #locationObject.
     *
     * Value must be of type Point.
     * The initial value is Point(NaN, NaN).
     * It is commonplace to data bind this property to some property on your model node data.
     *
     * The value is related to the GraphObject#position.
     * For Parts, both are in document coordinates; setting one property will set the other property.
     * By default both will have the same value.
     * However, by setting either or both of #locationSpot and #locationObjectName,
     * the location will be determined by a spot in the #locationObject,
     * a GraphObject that is in the visual tree of this Part.
     * The GraphObject#position will always refer to the point at the top-left corner of the whole part.
     *
     * The #minLocation and #maxLocation limit the location of a part, not its position.
     * Grid snapping will normally locate the location to be on grid points.
     * @see #locationObjectName
     * @see #locationSpot
     * @see #movable
     * @see #maxLocation
     * @see #minLocation
     * @see #dragComputation
     */
    get location(): Point; */
  /// Gets or sets the position of this part in document coordinates,
  /// based on the #locationSpot in this part's #locationObject.
  ///
  /// Value must be of type Point.
  /// The initial value is Point(NaN, NaN).
  /// It is commonplace to data bind this property to some property on your model node data.
  ///
  /// The value is related to the GraphObject#position.
  /// For Parts, both are in document coordinates; setting one property will set the other property.
  /// By default both will have the same value.
  /// However, by setting either or both of #locationSpot and #locationObjectName,
  /// the location will be determined by a spot in the #locationObject,
  /// a GraphObject that is in the visual tree of this Part.
  /// The GraphObject#position will always refer to the point at the top-left corner of the whole part.
  ///
  /// The #minLocation and #maxLocation limit the location of a part, not its position.
  /// Grid snapping will normally locate the location to be on grid points.
  _i3.Point get location => _i5.getProperty(
        this,
        'location',
      );
  /* #20139
  source: 
    /**
     * Gets or sets the position of this part in document coordinates,
     * based on the #locationSpot in this part's #locationObject.
     *
     * Value must be of type Point.
     * The initial value is Point(NaN, NaN).
     * It is commonplace to data bind this property to some property on your model node data.
     *
     * The value is related to the GraphObject#position.
     * For Parts, both are in document coordinates; setting one property will set the other property.
     * By default both will have the same value.
     * However, by setting either or both of #locationSpot and #locationObjectName,
     * the location will be determined by a spot in the #locationObject,
     * a GraphObject that is in the visual tree of this Part.
     * The GraphObject#position will always refer to the point at the top-left corner of the whole part.
     *
     * The #minLocation and #maxLocation limit the location of a part, not its position.
     * Grid snapping will normally locate the location to be on grid points.
     * @see #locationObjectName
     * @see #locationSpot
     * @see #movable
     * @see #maxLocation
     * @see #minLocation
     * @see #dragComputation
     */
    get location(): Point; */
  // Type Instance of 'InteropInterface'
  set location(_i3.Point value) {
    _i5.setProperty(
      this,
      'location',
      value,
    );
  }

  /* #20171
  source: 
    /**
     * Gets or sets the category of this part,
     * typically used to distinguish different kinds of nodes or links.
     *
     * The initial value is an empty string, which is the default category.
     * Any new value must be a string.
     * This should not be set in templates.
     *
     * When building Parts for node data or link data in a model,
     * the Diagram will call Model#getCategoryForNodeData or
     * GraphLinksModel#getCategoryForLinkData to get the category string for the data object.
     * The diagram uses this value to look up a template in Diagram#nodeTemplateMap,
     * Diagram#linkTemplateMap or Diagram#groupTemplateMap.
     * That template is copied to create the actual Part that is added to the diagram.
     * The diagram will set this property to remember the category it used.
     *
     * Note that the class of the new Part must be the same as the class of the original Part.
     * For example, a Node cannot be replaced by a simple Part or vice-versa.
     * Nor can a Link be replaced by a subclass of Link or vice-versa.
     *
     * To change the category for a Part created for model data, call Model#setCategoryForNodeData or
     * GraphLinksModel#setCategoryForLinkData.
     *
     * This property is also used to distinguish Adornments on a Part.
     * In this scenario you create the Adornment, often indirectly by specifying a template,
     * and set this property explicitly.
     * For example, ResizingTool#updateAdornments creates a resizing Adornment from the
     * Part#resizeAdornmentTemplate and sets its category to be "Resizing".
     * Changing the category of an existing Adornment will update any adorned part's association.
     */
    get category(): string; */
  /// Gets or sets the category of this part,
  /// typically used to distinguish different kinds of nodes or links.
  ///
  /// The initial value is an empty string, which is the default category.
  /// Any new value must be a string.
  /// This should not be set in templates.
  ///
  /// When building Parts for node data or link data in a model,
  /// the Diagram will call Model#getCategoryForNodeData or
  /// GraphLinksModel#getCategoryForLinkData to get the category string for the data object.
  /// The diagram uses this value to look up a template in Diagram#nodeTemplateMap,
  /// Diagram#linkTemplateMap or Diagram#groupTemplateMap.
  /// That template is copied to create the actual Part that is added to the diagram.
  /// The diagram will set this property to remember the category it used.
  ///
  /// Note that the class of the new Part must be the same as the class of the original Part.
  /// For example, a Node cannot be replaced by a simple Part or vice-versa.
  /// Nor can a Link be replaced by a subclass of Link or vice-versa.
  ///
  /// To change the category for a Part created for model data, call Model#setCategoryForNodeData or
  /// GraphLinksModel#setCategoryForLinkData.
  ///
  /// This property is also used to distinguish Adornments on a Part.
  /// In this scenario you create the Adornment, often indirectly by specifying a template,
  /// and set this property explicitly.
  /// For example, ResizingTool#updateAdornments creates a resizing Adornment from the
  /// Part#resizeAdornmentTemplate and sets its category to be "Resizing".
  /// Changing the category of an existing Adornment will update any adorned part's association.
  _i2.String get category => _i5.getProperty(
        this,
        'category',
      );
  /* #20171
  source: 
    /**
     * Gets or sets the category of this part,
     * typically used to distinguish different kinds of nodes or links.
     *
     * The initial value is an empty string, which is the default category.
     * Any new value must be a string.
     * This should not be set in templates.
     *
     * When building Parts for node data or link data in a model,
     * the Diagram will call Model#getCategoryForNodeData or
     * GraphLinksModel#getCategoryForLinkData to get the category string for the data object.
     * The diagram uses this value to look up a template in Diagram#nodeTemplateMap,
     * Diagram#linkTemplateMap or Diagram#groupTemplateMap.
     * That template is copied to create the actual Part that is added to the diagram.
     * The diagram will set this property to remember the category it used.
     *
     * Note that the class of the new Part must be the same as the class of the original Part.
     * For example, a Node cannot be replaced by a simple Part or vice-versa.
     * Nor can a Link be replaced by a subclass of Link or vice-versa.
     *
     * To change the category for a Part created for model data, call Model#setCategoryForNodeData or
     * GraphLinksModel#setCategoryForLinkData.
     *
     * This property is also used to distinguish Adornments on a Part.
     * In this scenario you create the Adornment, often indirectly by specifying a template,
     * and set this property explicitly.
     * For example, ResizingTool#updateAdornments creates a resizing Adornment from the
     * Part#resizeAdornmentTemplate and sets its category to be "Resizing".
     * Changing the category of an existing Adornment will update any adorned part's association.
     */
    get category(): string; */
  // Type InteropStaticType.string
  set category(_i2.String value) {
    _i5.setProperty(
      this,
      'category',
      value,
    );
  }

  /* #20278
  source: 
    /**
     * Gets or sets whether the user may copy this part.
     * The initial value is true.
     * @see #canCopy
     */
    get copyable(): boolean; */
  /// Gets or sets whether the user may copy this part.
  /// The initial value is true.
  _i2.bool get copyable => _i5.getProperty(
        this,
        'copyable',
      );
  /* #20278
  source: 
    /**
     * Gets or sets whether the user may copy this part.
     * The initial value is true.
     * @see #canCopy
     */
    get copyable(): boolean; */
  // Type InteropStaticType.boolean
  set copyable(_i2.bool value) {
    _i5.setProperty(
      this,
      'copyable',
      value,
    );
  }

  /* #20285
  source: 
    /**
     * Gets or sets whether the user may delete this part.
     * The initial value is true.
     * @see #canDelete
     */
    get deletable(): boolean; */
  /// Gets or sets whether the user may delete this part.
  /// The initial value is true.
  _i2.bool get deletable => _i5.getProperty(
        this,
        'deletable',
      );
  /* #20285
  source: 
    /**
     * Gets or sets whether the user may delete this part.
     * The initial value is true.
     * @see #canDelete
     */
    get deletable(): boolean; */
  // Type InteropStaticType.boolean
  set deletable(_i2.bool value) {
    _i5.setProperty(
      this,
      'deletable',
      value,
    );
  }

  /* #20294
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing on TextBlocks in this part
     * that have TextBlock#editable set to true.
     * The initial value is true.
     * @see #canEdit
     * @see TextBlock#editable
     */
    get textEditable(): boolean; */
  /// Gets or sets whether the user may do in-place text editing on TextBlocks in this part
  /// that have TextBlock#editable set to true.
  /// The initial value is true.
  _i2.bool get textEditable => _i5.getProperty(
        this,
        'textEditable',
      );
  /* #20294
  source: 
    /**
     * Gets or sets whether the user may do in-place text editing on TextBlocks in this part
     * that have TextBlock#editable set to true.
     * The initial value is true.
     * @see #canEdit
     * @see TextBlock#editable
     */
    get textEditable(): boolean; */
  // Type InteropStaticType.boolean
  set textEditable(_i2.bool value) {
    _i5.setProperty(
      this,
      'textEditable',
      value,
    );
  }

  /* #20305
  source: 
    /**
     * Gets or sets whether the user may group this part to be a member of a new Group.
     * The initial value is true.
     *
     * The grouping command is implemented by CommandHandler#groupSelection
     * and depends on CommandHandler#archetypeGroupData having been set to a node data object.
     * A Group can be ungrouped by the user if you set Group#ungroupable to true.
     * @see #canGroup
     */
    get groupable(): boolean; */
  /// Gets or sets whether the user may group this part to be a member of a new Group.
  /// The initial value is true.
  ///
  /// The grouping command is implemented by CommandHandler#groupSelection
  /// and depends on CommandHandler#archetypeGroupData having been set to a node data object.
  /// A Group can be ungrouped by the user if you set Group#ungroupable to true.
  _i2.bool get groupable => _i5.getProperty(
        this,
        'groupable',
      );
  /* #20305
  source: 
    /**
     * Gets or sets whether the user may group this part to be a member of a new Group.
     * The initial value is true.
     *
     * The grouping command is implemented by CommandHandler#groupSelection
     * and depends on CommandHandler#archetypeGroupData having been set to a node data object.
     * A Group can be ungrouped by the user if you set Group#ungroupable to true.
     * @see #canGroup
     */
    get groupable(): boolean; */
  // Type InteropStaticType.boolean
  set groupable(_i2.bool value) {
    _i5.setProperty(
      this,
      'groupable',
      value,
    );
  }

  /* #20315
  source: 
    /**
     * Gets or sets whether the user may move this part.
     * The initial value is true.
     * @see #canMove
     * @see #dragComputation
     * @see #maxLocation
     * @see #minLocation
     */
    get movable(): boolean; */
  /// Gets or sets whether the user may move this part.
  /// The initial value is true.
  _i2.bool get movable => _i5.getProperty(
        this,
        'movable',
      );
  /* #20315
  source: 
    /**
     * Gets or sets whether the user may move this part.
     * The initial value is true.
     * @see #canMove
     * @see #dragComputation
     * @see #maxLocation
     * @see #minLocation
     */
    get movable(): boolean; */
  // Type InteropStaticType.boolean
  set movable(_i2.bool value) {
    _i5.setProperty(
      this,
      'movable',
      value,
    );
  }

  /* #20323
  source: 
    /**
     * Gets or sets whether a selection adornment is shown for this part when it is selected.
     * The initial value is true.
     * @see #selectionChanged
     * @see #selectionAdornmentTemplate
     */
    get selectionAdorned(): boolean; */
  /// Gets or sets whether a selection adornment is shown for this part when it is selected.
  /// The initial value is true.
  _i2.bool get selectionAdorned => _i5.getProperty(
        this,
        'selectionAdorned',
      );
  /* #20323
  source: 
    /**
     * Gets or sets whether a selection adornment is shown for this part when it is selected.
     * The initial value is true.
     * @see #selectionChanged
     * @see #selectionAdornmentTemplate
     */
    get selectionAdorned(): boolean; */
  // Type InteropStaticType.boolean
  set selectionAdorned(_i2.bool value) {
    _i5.setProperty(
      this,
      'selectionAdorned',
      value,
    );
  }

  /* #20333
  source: 
    /**
     * Gets or sets whether this Part is part of the document bounds.
     *
     * The initial value is true.
     * A value of false causes Diagram#computeBounds to ignore this part.
     * If the value is false, it is possible that user will not be able to scroll far enough to see this part,
     * if the part's GraphObject#actualBounds are outside of the Diagram#documentBounds.
     */
    get isInDocumentBounds(): boolean; */
  /// Gets or sets whether this Part is part of the document bounds.
  ///
  /// The initial value is true.
  /// A value of false causes Diagram#computeBounds to ignore this part.
  /// If the value is false, it is possible that user will not be able to scroll far enough to see this part,
  /// if the part's GraphObject#actualBounds are outside of the Diagram#documentBounds.
  _i2.bool get isInDocumentBounds => _i5.getProperty(
        this,
        'isInDocumentBounds',
      );
  /* #20333
  source: 
    /**
     * Gets or sets whether this Part is part of the document bounds.
     *
     * The initial value is true.
     * A value of false causes Diagram#computeBounds to ignore this part.
     * If the value is false, it is possible that user will not be able to scroll far enough to see this part,
     * if the part's GraphObject#actualBounds are outside of the Diagram#documentBounds.
     */
    get isInDocumentBounds(): boolean; */
  // Type InteropStaticType.boolean
  set isInDocumentBounds(_i2.bool value) {
    _i5.setProperty(
      this,
      'isInDocumentBounds',
      value,
    );
  }

  /* #20351
  source: 
    /**
     * Gets or sets whether a Layout positions this Node or routes this Link.
     * This property affects the value of #canLayout.
     *
     * The initial value is true, meaning that this part is laid out by the layout responsible for this Part.
     * If this part is a member of a Group, it is the Group#layout,
     * otherwise it is the Diagram#layout.
     *
     * A value of false means that this part is not affected by and does not affect any automatic layout,
     * so the #layoutConditions property is ignored.
     * You will need to make sure that it has a real #location or GraphObject#position value,
     * or else the Part might not be visible anywhere in the diagram.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#layoutConditions or Layout#isInitial or Layout#isOngoing.
     */
    get isLayoutPositioned(): boolean; */
  /// Gets or sets whether a Layout positions this Node or routes this Link.
  /// This property affects the value of #canLayout.
  ///
  /// The initial value is true, meaning that this part is laid out by the layout responsible for this Part.
  /// If this part is a member of a Group, it is the Group#layout,
  /// otherwise it is the Diagram#layout.
  ///
  /// A value of false means that this part is not affected by and does not affect any automatic layout,
  /// so the #layoutConditions property is ignored.
  /// You will need to make sure that it has a real #location or GraphObject#position value,
  /// or else the Part might not be visible anywhere in the diagram.
  ///
  /// Another way of controlling when layouts are invalidated is by setting
  /// Part#layoutConditions or Layout#isInitial or Layout#isOngoing.
  _i2.bool get isLayoutPositioned => _i5.getProperty(
        this,
        'isLayoutPositioned',
      );
  /* #20351
  source: 
    /**
     * Gets or sets whether a Layout positions this Node or routes this Link.
     * This property affects the value of #canLayout.
     *
     * The initial value is true, meaning that this part is laid out by the layout responsible for this Part.
     * If this part is a member of a Group, it is the Group#layout,
     * otherwise it is the Diagram#layout.
     *
     * A value of false means that this part is not affected by and does not affect any automatic layout,
     * so the #layoutConditions property is ignored.
     * You will need to make sure that it has a real #location or GraphObject#position value,
     * or else the Part might not be visible anywhere in the diagram.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#layoutConditions or Layout#isInitial or Layout#isOngoing.
     */
    get isLayoutPositioned(): boolean; */
  // Type InteropStaticType.boolean
  set isLayoutPositioned(_i2.bool value) {
    _i5.setProperty(
      this,
      'isLayoutPositioned',
      value,
    );
  }

  /* #20367
  source: 
    /**
     * Gets or sets whether the user may select this part.
     * The initial value is true.
     *
     * If you set this to true you may also want to set #selectionObjectName
     * to the GraphObject#named element that you want to be adorned
     * when the Part is selected.
     * @see #canSelect
     * @see #isSelected
     * @see #selectionAdorned
     * @see #selectionObjectName
     * @see #selectionAdornmentTemplate
     * @see #selectionChanged
     */
    get selectable(): boolean; */
  /// Gets or sets whether the user may select this part.
  /// The initial value is true.
  ///
  /// If you set this to true you may also want to set #selectionObjectName
  /// to the GraphObject#named element that you want to be adorned
  /// when the Part is selected.
  _i2.bool get selectable => _i5.getProperty(
        this,
        'selectable',
      );
  /* #20367
  source: 
    /**
     * Gets or sets whether the user may select this part.
     * The initial value is true.
     *
     * If you set this to true you may also want to set #selectionObjectName
     * to the GraphObject#named element that you want to be adorned
     * when the Part is selected.
     * @see #canSelect
     * @see #isSelected
     * @see #selectionAdorned
     * @see #selectionObjectName
     * @see #selectionAdornmentTemplate
     * @see #selectionChanged
     */
    get selectable(): boolean; */
  // Type InteropStaticType.boolean
  set selectable(_i2.bool value) {
    _i5.setProperty(
      this,
      'selectable',
      value,
    );
  }

  /* #20375
  source: 
    /**
     * Gets or sets whether the user may reshape this part.
     * The initial value is false.
     * @see #canReshape
     * @see LinkReshapingTool
     */
    get reshapable(): boolean; */
  /// Gets or sets whether the user may reshape this part.
  /// The initial value is false.
  _i2.bool get reshapable => _i5.getProperty(
        this,
        'reshapable',
      );
  /* #20375
  source: 
    /**
     * Gets or sets whether the user may reshape this part.
     * The initial value is false.
     * @see #canReshape
     * @see LinkReshapingTool
     */
    get reshapable(): boolean; */
  // Type InteropStaticType.boolean
  set reshapable(_i2.bool value) {
    _i5.setProperty(
      this,
      'reshapable',
      value,
    );
  }

  /* #20391
  source: 
    /**
     * Gets or sets whether the user may resize this part.
     * The initial value is false.
     *
     * If you set this to true you may also want to set #resizeObjectName
     * to the GraphObject#named element that you want the user to resize.
     * It is also commonplace to add a TwoWay Binding of that named element's
     * GraphObject#desiredSize in order to save to the model data the value that the user
     * set via the ResizingTool.
     * @see #canResize
     * @see #resizeObjectName
     * @see #resizeCellSize
     * @see #resizeAdornmentTemplate
     */
    get resizable(): boolean; */
  /// Gets or sets whether the user may resize this part.
  /// The initial value is false.
  ///
  /// If you set this to true you may also want to set #resizeObjectName
  /// to the GraphObject#named element that you want the user to resize.
  /// It is also commonplace to add a TwoWay Binding of that named element's
  /// GraphObject#desiredSize in order to save to the model data the value that the user
  /// set via the ResizingTool.
  _i2.bool get resizable => _i5.getProperty(
        this,
        'resizable',
      );
  /* #20391
  source: 
    /**
     * Gets or sets whether the user may resize this part.
     * The initial value is false.
     *
     * If you set this to true you may also want to set #resizeObjectName
     * to the GraphObject#named element that you want the user to resize.
     * It is also commonplace to add a TwoWay Binding of that named element's
     * GraphObject#desiredSize in order to save to the model data the value that the user
     * set via the ResizingTool.
     * @see #canResize
     * @see #resizeObjectName
     * @see #resizeCellSize
     * @see #resizeAdornmentTemplate
     */
    get resizable(): boolean; */
  // Type InteropStaticType.boolean
  set resizable(_i2.bool value) {
    _i5.setProperty(
      this,
      'resizable',
      value,
    );
  }

  /* #20406
  source: 
    /**
     * Gets or sets whether the user may rotate this part.
     * The initial value is false.
     *
     * If you set this to true you may also want to set #rotateObjectName
     * to the GraphObject#named element that you want the user to rotate.
     * It is also commonplace to add a TwoWay Binding of that named element's
     * GraphObject#angle in order to save to the model data the value that the user
     * set via the RotatingTool.
     * @see #canRotate
     * @see #rotateObjectName
     * @see #rotateAdornmentTemplate
     */
    get rotatable(): boolean; */
  /// Gets or sets whether the user may rotate this part.
  /// The initial value is false.
  ///
  /// If you set this to true you may also want to set #rotateObjectName
  /// to the GraphObject#named element that you want the user to rotate.
  /// It is also commonplace to add a TwoWay Binding of that named element's
  /// GraphObject#angle in order to save to the model data the value that the user
  /// set via the RotatingTool.
  _i2.bool get rotatable => _i5.getProperty(
        this,
        'rotatable',
      );
  /* #20406
  source: 
    /**
     * Gets or sets whether the user may rotate this part.
     * The initial value is false.
     *
     * If you set this to true you may also want to set #rotateObjectName
     * to the GraphObject#named element that you want the user to rotate.
     * It is also commonplace to add a TwoWay Binding of that named element's
     * GraphObject#angle in order to save to the model data the value that the user
     * set via the RotatingTool.
     * @see #canRotate
     * @see #rotateObjectName
     * @see #rotateAdornmentTemplate
     */
    get rotatable(): boolean; */
  // Type InteropStaticType.boolean
  set rotatable(_i2.bool value) {
    _i5.setProperty(
      this,
      'rotatable',
      value,
    );
  }

  /* #20425
  source: 
    /**
     * Gets or sets whether this Part is selected.
     * The initial value is false.
     *
     * Selected parts typically are shown either with an Adornment
     * or with a different appearance by changing the brush or visibility of one or
     * more of the GraphObjects within the part.
     *
     * Changing this value does not by itself raise any "ChangingSelection" and "ChangedSelection" DiagramEvents.
     * Tools and the CommandHandler and methods such as Diagram#select do raise those DiagramEvents
     * because they want to surround changes to this property with a single "ChangingSelection" DiagramEvent beforehand and a single "ChangedSelection" afterwards.
     * @see #selectable
     * @see #selectionAdorned
     * @see #selectionChanged
     * @see #selectionObjectName
     * @see #selectionAdornmentTemplate
     */
    get isSelected(): boolean; */
  /// Gets or sets whether this Part is selected.
  /// The initial value is false.
  ///
  /// Selected parts typically are shown either with an Adornment
  /// or with a different appearance by changing the brush or visibility of one or
  /// more of the GraphObjects within the part.
  ///
  /// Changing this value does not by itself raise any "ChangingSelection" and "ChangedSelection" DiagramEvents.
  /// Tools and the CommandHandler and methods such as Diagram#select do raise those DiagramEvents
  /// because they want to surround changes to this property with a single "ChangingSelection" DiagramEvent beforehand and a single "ChangedSelection" afterwards.
  _i2.bool get isSelected => _i5.getProperty(
        this,
        'isSelected',
      );
  /* #20425
  source: 
    /**
     * Gets or sets whether this Part is selected.
     * The initial value is false.
     *
     * Selected parts typically are shown either with an Adornment
     * or with a different appearance by changing the brush or visibility of one or
     * more of the GraphObjects within the part.
     *
     * Changing this value does not by itself raise any "ChangingSelection" and "ChangedSelection" DiagramEvents.
     * Tools and the CommandHandler and methods such as Diagram#select do raise those DiagramEvents
     * because they want to surround changes to this property with a single "ChangingSelection" DiagramEvent beforehand and a single "ChangedSelection" afterwards.
     * @see #selectable
     * @see #selectionAdorned
     * @see #selectionChanged
     * @see #selectionObjectName
     * @see #selectionAdornmentTemplate
     */
    get isSelected(): boolean; */
  // Type InteropStaticType.boolean
  set isSelected(_i2.bool value) {
    _i5.setProperty(
      this,
      'isSelected',
      value,
    );
  }

  /* #20452
  source: 
    /**
     * Gets or sets whether this Part is highlighted.
     * The initial value is false.
     *
     * Highlighted parts may be shown with a different appearance by changing the brush or visibility of one or
     * more of the GraphObjects within the part.
     * One way of doing that is by using binding.
     * Consider part of the definition of a Node template:
     * ```js
     * new go.Shape({
     *     // ... shape properties
     *   })
     *   // Shape.fill is bound to Node.data.color
     *   .bind("fill", "color")
     *   // Shape.stroke is red when Node.isHighlighted is true, black otherwise
     *   .bind(new go.Binding("stroke", "isHighlighted",
     *                        h => h ? "red" : "black").ofObject())
     * ```
     * @see #highlightedChanged
     * @see Diagram#highlighteds
     * @see Diagram#highlight
     * @see Diagram#highlightCollection
     * @see Diagram#clearHighlighteds
     * @since 1.4
     */
    get isHighlighted(): boolean; */
  /// Gets or sets whether this Part is highlighted.
  /// The initial value is false.
  ///
  /// Highlighted parts may be shown with a different appearance by changing the brush or visibility of one or
  /// more of the GraphObjects within the part.
  /// One way of doing that is by using binding.
  /// Consider part of the definition of a Node template:
  /// ```js
  /// new go.Shape({
  ///     // ... shape properties
  ///   })
  ///   // Shape.fill is bound to Node.data.color
  ///   .bind("fill", "color")
  ///   // Shape.stroke is red when Node.isHighlighted is true, black otherwise
  ///   .bind(new go.Binding("stroke", "isHighlighted",
  ///                        h => h ? "red" : "black").ofObject())
  /// ```
  _i2.bool get isHighlighted => _i5.getProperty(
        this,
        'isHighlighted',
      );
  /* #20452
  source: 
    /**
     * Gets or sets whether this Part is highlighted.
     * The initial value is false.
     *
     * Highlighted parts may be shown with a different appearance by changing the brush or visibility of one or
     * more of the GraphObjects within the part.
     * One way of doing that is by using binding.
     * Consider part of the definition of a Node template:
     * ```js
     * new go.Shape({
     *     // ... shape properties
     *   })
     *   // Shape.fill is bound to Node.data.color
     *   .bind("fill", "color")
     *   // Shape.stroke is red when Node.isHighlighted is true, black otherwise
     *   .bind(new go.Binding("stroke", "isHighlighted",
     *                        h => h ? "red" : "black").ofObject())
     * ```
     * @see #highlightedChanged
     * @see Diagram#highlighteds
     * @see Diagram#highlight
     * @see Diagram#highlightCollection
     * @see Diagram#clearHighlighteds
     * @since 1.4
     */
    get isHighlighted(): boolean; */
  // Type InteropStaticType.boolean
  set isHighlighted(_i2.bool value) {
    _i5.setProperty(
      this,
      'isHighlighted',
      value,
    );
  }

  /* #20478
  source: 
    /**
     * Gets or sets whether this part will draw shadows.
     * The initial value is false.
     *
     * By default, setting this property to true will attempt to draw shadows only
     * on the GraphObjects in this Part that appear to act as background objects, and
     * not on GraphObjects that appear to be in front of other GraphObjects in the Part.
     *
     * To finely control shadows, you may need to set GraphObject#shadowVisible on
     * elements of this Part, so that they explicitly do or do not get shadowed accordingly.
     *
     * The color of the shadow is determined by #shadowColor.
     * The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
     * So, for example, if you have a Panel with a GraphObject#background
     * that is "transparent", the shadow that is drawn for the panel will also be transparent.
     *
     * The direction of the shadow that is cast is controlled by #shadowOffset,
     * and is independent of the Diagram#scale.
     * The sharpness of the shadow is controlled by #shadowBlur.
     * @see #shadowOffset
     * @see #shadowColor
     * @see #shadowBlur
     * @see GraphObject#shadowVisible
     */
    get isShadowed(): boolean; */
  /// Gets or sets whether this part will draw shadows.
  /// The initial value is false.
  ///
  /// By default, setting this property to true will attempt to draw shadows only
  /// on the GraphObjects in this Part that appear to act as background objects, and
  /// not on GraphObjects that appear to be in front of other GraphObjects in the Part.
  ///
  /// To finely control shadows, you may need to set GraphObject#shadowVisible on
  /// elements of this Part, so that they explicitly do or do not get shadowed accordingly.
  ///
  /// The color of the shadow is determined by #shadowColor.
  /// The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
  /// So, for example, if you have a Panel with a GraphObject#background
  /// that is "transparent", the shadow that is drawn for the panel will also be transparent.
  ///
  /// The direction of the shadow that is cast is controlled by #shadowOffset,
  /// and is independent of the Diagram#scale.
  /// The sharpness of the shadow is controlled by #shadowBlur.
  _i2.bool get isShadowed => _i5.getProperty(
        this,
        'isShadowed',
      );
  /* #20478
  source: 
    /**
     * Gets or sets whether this part will draw shadows.
     * The initial value is false.
     *
     * By default, setting this property to true will attempt to draw shadows only
     * on the GraphObjects in this Part that appear to act as background objects, and
     * not on GraphObjects that appear to be in front of other GraphObjects in the Part.
     *
     * To finely control shadows, you may need to set GraphObject#shadowVisible on
     * elements of this Part, so that they explicitly do or do not get shadowed accordingly.
     *
     * The color of the shadow is determined by #shadowColor.
     * The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
     * So, for example, if you have a Panel with a GraphObject#background
     * that is "transparent", the shadow that is drawn for the panel will also be transparent.
     *
     * The direction of the shadow that is cast is controlled by #shadowOffset,
     * and is independent of the Diagram#scale.
     * The sharpness of the shadow is controlled by #shadowBlur.
     * @see #shadowOffset
     * @see #shadowColor
     * @see #shadowBlur
     * @see GraphObject#shadowVisible
     */
    get isShadowed(): boolean; */
  // Type InteropStaticType.boolean
  set isShadowed(_i2.bool value) {
    _i5.setProperty(
      this,
      'isShadowed',
      value,
    );
  }

  /* #20485
  source: 
    /**
     * Gets or sets whether this part may be animated.
     * The initial value is true.
     * @since 1.4
     */
    get isAnimated(): boolean; */
  /// Gets or sets whether this part may be animated.
  /// The initial value is true.
  _i2.bool get isAnimated => _i5.getProperty(
        this,
        'isAnimated',
      );
  /* #20485
  source: 
    /**
     * Gets or sets whether this part may be animated.
     * The initial value is true.
     * @since 1.4
     */
    get isAnimated(): boolean; */
  // Type InteropStaticType.boolean
  set isAnimated(_i2.bool value) {
    _i5.setProperty(
      this,
      'isAnimated',
      value,
    );
  }

  /* #20498
  source: 
    /**
     * Gets or sets the function to execute when this #isHighlighted changes.
     * It is typically used to modify the appearance of the part.
     * This function must not highlight or unhighlight any parts.
     *
     * If this property value is a function, it is called with one argument,
     * this Part that whose #isHighlighted value changed.
     * By default this property is null.
     * @see #isHighlighted
     * @since 1.7
     */
    get highlightedChanged(): ((thisPart: Part) => void) | null; */
  /// Gets or sets the function to execute when this #isHighlighted changes.
  /// It is typically used to modify the appearance of the part.
  /// This function must not highlight or unhighlight any parts.
  ///
  /// If this property value is a function, it is called with one argument,
  /// this Part that whose #isHighlighted value changed.
  /// By default this property is null.
  void Function(_i3.Part)? get highlightedChanged => _i5.getProperty(
        this,
        'highlightedChanged',
      );
  /* #20498
  source: 
    /**
     * Gets or sets the function to execute when this #isHighlighted changes.
     * It is typically used to modify the appearance of the part.
     * This function must not highlight or unhighlight any parts.
     *
     * If this property value is a function, it is called with one argument,
     * this Part that whose #isHighlighted value changed.
     * By default this property is null.
     * @see #isHighlighted
     * @since 1.7
     */
    get highlightedChanged(): ((thisPart: Part) => void) | null; */
  // Type InteropUnion#166768893(parent: InteropGetter#198837749(name: highlightedChanged))
  set highlightedChanged(void Function(_i3.Part)? value) {
    _i5.setProperty(
      this,
      'highlightedChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #20510
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a selection handle
     * when this part is selected.
     * The value of this property affects the value of #selectionObject.
     * The initial value is an empty string, meaning the whole Part itself gets any selection handle.
     *
     * If no GraphObject has a GraphObject#name that is this name, #selectionObject returns the whole Part.
     * @see #selectable
     * @see #selectionObject
     */
    get selectionObjectName(): string; */
  /// Gets or sets the name of the GraphObject that should get a selection handle
  /// when this part is selected.
  /// The value of this property affects the value of #selectionObject.
  /// The initial value is an empty string, meaning the whole Part itself gets any selection handle.
  ///
  /// If no GraphObject has a GraphObject#name that is this name, #selectionObject returns the whole Part.
  _i2.String get selectionObjectName => _i5.getProperty(
        this,
        'selectionObjectName',
      );
  /* #20510
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a selection handle
     * when this part is selected.
     * The value of this property affects the value of #selectionObject.
     * The initial value is an empty string, meaning the whole Part itself gets any selection handle.
     *
     * If no GraphObject has a GraphObject#name that is this name, #selectionObject returns the whole Part.
     * @see #selectable
     * @see #selectionObject
     */
    get selectionObjectName(): string; */
  // Type InteropStaticType.string
  set selectionObjectName(_i2.String value) {
    _i5.setProperty(
      this,
      'selectionObjectName',
      value,
    );
  }

  /* #20524
  source: 
    /**
     * Gets or sets the Adornment template used to create a selection handle for this Part.
     *
     * If this is null, depending on the class of this Part, the value of Diagram#nodeSelectionAdornmentTemplate, Diagram#groupSelectionAdornmentTemplate,
     * or Diagram#linkSelectionAdornmentTemplate is used instead.
     *
     * It is commonplace to make use of a Placeholder in an Adornment for a Node, Group, or simple Part.
     * The Placeholder represents the Adornment#adornedObject of the adorned Part.
     * For Links, the Adornment must be of Panel#type Panel.Link.
     * @see #selectable
     * @see #selectionObjectName
     */
    get selectionAdornmentTemplate(): Adornment | null; */
  /// Gets or sets the Adornment template used to create a selection handle for this Part.
  ///
  /// If this is null, depending on the class of this Part, the value of Diagram#nodeSelectionAdornmentTemplate, Diagram#groupSelectionAdornmentTemplate,
  /// or Diagram#linkSelectionAdornmentTemplate is used instead.
  ///
  /// It is commonplace to make use of a Placeholder in an Adornment for a Node, Group, or simple Part.
  /// The Placeholder represents the Adornment#adornedObject of the adorned Part.
  /// For Links, the Adornment must be of Panel#type Panel.Link.
  _i3.Adornment? get selectionAdornmentTemplate => _i5.getProperty(
        this,
        'selectionAdornmentTemplate',
      );
  /* #20524
  source: 
    /**
     * Gets or sets the Adornment template used to create a selection handle for this Part.
     *
     * If this is null, depending on the class of this Part, the value of Diagram#nodeSelectionAdornmentTemplate, Diagram#groupSelectionAdornmentTemplate,
     * or Diagram#linkSelectionAdornmentTemplate is used instead.
     *
     * It is commonplace to make use of a Placeholder in an Adornment for a Node, Group, or simple Part.
     * The Placeholder represents the Adornment#adornedObject of the adorned Part.
     * For Links, the Adornment must be of Panel#type Panel.Link.
     * @see #selectable
     * @see #selectionObjectName
     */
    get selectionAdornmentTemplate(): Adornment | null; */
  // Type InteropUnion#715819508(parent: InteropGetter#637400436(name: selectionAdornmentTemplate))
  set selectionAdornmentTemplate(_i3.Adornment? value) {
    _i5.setProperty(
      this,
      'selectionAdornmentTemplate',
      value ?? _i4.undefined,
    );
  }

  /* #20534
  source: 
    /**
     * This read-only property returns the GraphObject that should get a selection handle when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #selectionObjectName.
     * When the #selectionObjectName is unspecified, this whole Part is used as the "selection object".
     * @see #selectable
     * @see #selectionObjectName
     */
    get selectionObject(): GraphObject; */
  /// This read-only property returns the GraphObject that should get a selection handle when this part is selected.
  /// The value will be in the visual tree of this Part and is usually named with
  /// the value of #selectionObjectName.
  /// When the #selectionObjectName is unspecified, this whole Part is used as the "selection object".
  _i3.GraphObject get selectionObject => _i5.getProperty(
        this,
        'selectionObject',
      );
  /* #20534
  source: 
    /**
     * This read-only property returns the GraphObject that should get a selection handle when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #selectionObjectName.
     * When the #selectionObjectName is unspecified, this whole Part is used as the "selection object".
     * @see #selectable
     * @see #selectionObjectName
     */
    get selectionObject(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set selectionObject(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'selectionObject',
      value,
    );
  }

  /* #20552
  source: 
    /**
     * Gets or sets the function to execute when this part is selected or deselected.
     * It is typically used to modify the appearance of the part.
     * This function must not select or deselect any parts.
     *
     * If this property value is a function, it is called with one argument,
     * this Part that was selected or that became unselected.
     * When it is called, the value of Diagram#skipsUndoManager is temporarily set to true.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * @see #isSelected
     * @see #selectionAdorned
     * @see #selectionAdornmentTemplate
     */
    get selectionChanged(): ((thisPart: Part) => void) | null; */
  /// Gets or sets the function to execute when this part is selected or deselected.
  /// It is typically used to modify the appearance of the part.
  /// This function must not select or deselect any parts.
  ///
  /// If this property value is a function, it is called with one argument,
  /// this Part that was selected or that became unselected.
  /// When it is called, the value of Diagram#skipsUndoManager is temporarily set to true.
  /// By default this property is null.
  ///
  /// This function is called with Diagram#skipsUndoManager temporarily set to true,
  /// so that any changes to GraphObjects are not recorded in the UndoManager.
  /// You do not need to start and commit any transaction in this function.
  void Function(_i3.Part)? get selectionChanged => _i5.getProperty(
        this,
        'selectionChanged',
      );
  /* #20552
  source: 
    /**
     * Gets or sets the function to execute when this part is selected or deselected.
     * It is typically used to modify the appearance of the part.
     * This function must not select or deselect any parts.
     *
     * If this property value is a function, it is called with one argument,
     * this Part that was selected or that became unselected.
     * When it is called, the value of Diagram#skipsUndoManager is temporarily set to true.
     * By default this property is null.
     *
     * This function is called with Diagram#skipsUndoManager temporarily set to true,
     * so that any changes to GraphObjects are not recorded in the UndoManager.
     * You do not need to start and commit any transaction in this function.
     * @see #isSelected
     * @see #selectionAdorned
     * @see #selectionAdornmentTemplate
     */
    get selectionChanged(): ((thisPart: Part) => void) | null; */
  // Type InteropUnion#494226595(parent: InteropGetter#638563538(name: selectionChanged))
  set selectionChanged(void Function(_i3.Part)? value) {
    _i5.setProperty(
      this,
      'selectionChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #20564
  source: 
    /**
     * Gets or sets the adornment template used to create a resize handle Adornment for this part.
     * This is used by the ResizingTool, ToolManager#resizingTool.
     *
     * If an Adornment is supplied, it is normally a Panel.Spot panel that contains a Placeholder
     * with some number of resize handles at the four corners or at the four side midpoints.
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeAdornmentTemplate(): Adornment | null; */
  /// Gets or sets the adornment template used to create a resize handle Adornment for this part.
  /// This is used by the ResizingTool, ToolManager#resizingTool.
  ///
  /// If an Adornment is supplied, it is normally a Panel.Spot panel that contains a Placeholder
  /// with some number of resize handles at the four corners or at the four side midpoints.
  _i3.Adornment? get resizeAdornmentTemplate => _i5.getProperty(
        this,
        'resizeAdornmentTemplate',
      );
  /* #20564
  source: 
    /**
     * Gets or sets the adornment template used to create a resize handle Adornment for this part.
     * This is used by the ResizingTool, ToolManager#resizingTool.
     *
     * If an Adornment is supplied, it is normally a Panel.Spot panel that contains a Placeholder
     * with some number of resize handles at the four corners or at the four side midpoints.
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeAdornmentTemplate(): Adornment | null; */
  // Type InteropUnion#881956473(parent: InteropGetter#887335491(name: resizeAdornmentTemplate))
  set resizeAdornmentTemplate(_i3.Adornment? value) {
    _i5.setProperty(
      this,
      'resizeAdornmentTemplate',
      value ?? _i4.undefined,
    );
  }

  /* #20575
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a resize handle
     * when this part is selected.
     * The value of this property affects the value of #resizeObject.
     * The initial value is an empty string, meaning the whole Part itself gets any resize handle.
     * @see #resizable
     * @see #resizeObject
     * @see ResizingTool
     */
    get resizeObjectName(): string; */
  /// Gets or sets the name of the GraphObject that should get a resize handle
  /// when this part is selected.
  /// The value of this property affects the value of #resizeObject.
  /// The initial value is an empty string, meaning the whole Part itself gets any resize handle.
  _i2.String get resizeObjectName => _i5.getProperty(
        this,
        'resizeObjectName',
      );
  /* #20575
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a resize handle
     * when this part is selected.
     * The value of this property affects the value of #resizeObject.
     * The initial value is an empty string, meaning the whole Part itself gets any resize handle.
     * @see #resizable
     * @see #resizeObject
     * @see ResizingTool
     */
    get resizeObjectName(): string; */
  // Type InteropStaticType.string
  set resizeObjectName(_i2.String value) {
    _i5.setProperty(
      this,
      'resizeObjectName',
      value,
    );
  }

  /* #20585
  source: 
    /**
     * This read-only property returns the GraphObject that should get resize handles when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #resizeObjectName.
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeObject(): GraphObject; */
  /// This read-only property returns the GraphObject that should get resize handles when this part is selected.
  /// The value will be in the visual tree of this Part and is usually named with
  /// the value of #resizeObjectName.
  _i3.GraphObject get resizeObject => _i5.getProperty(
        this,
        'resizeObject',
      );
  /* #20585
  source: 
    /**
     * This read-only property returns the GraphObject that should get resize handles when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #resizeObjectName.
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeObject(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set resizeObject(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'resizeObject',
      value,
    );
  }

  /* #20593
  source: 
    /**
     * Gets or sets the width and height multiples used when resizing.
     * By default this property is the Size(NaN, NaN).
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeCellSize(): Size; */
  /// Gets or sets the width and height multiples used when resizing.
  /// By default this property is the Size(NaN, NaN).
  _i3.Size get resizeCellSize => _i5.getProperty(
        this,
        'resizeCellSize',
      );
  /* #20593
  source: 
    /**
     * Gets or sets the width and height multiples used when resizing.
     * By default this property is the Size(NaN, NaN).
     * @see #resizable
     * @see #resizeObjectName
     * @see ResizingTool
     */
    get resizeCellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set resizeCellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'resizeCellSize',
      value,
    );
  }

  /* #20605
  source: 
    /**
     * Gets or sets the adornment template used to create a rotation handle Adornment for this part.
     * This is used by the RotatingTool, ToolManager#rotatingTool.
     *
     * This Adornment should not have a Placeholder in it, because the RotatingTool will position it away from the
     * #rotateObject at its GraphObject#angle.
     * @see #rotatable
     * @see #rotateObjectName
     * @see RotatingTool
     */
    get rotateAdornmentTemplate(): Adornment | null; */
  /// Gets or sets the adornment template used to create a rotation handle Adornment for this part.
  /// This is used by the RotatingTool, ToolManager#rotatingTool.
  ///
  /// This Adornment should not have a Placeholder in it, because the RotatingTool will position it away from the
  /// #rotateObject at its GraphObject#angle.
  _i3.Adornment? get rotateAdornmentTemplate => _i5.getProperty(
        this,
        'rotateAdornmentTemplate',
      );
  /* #20605
  source: 
    /**
     * Gets or sets the adornment template used to create a rotation handle Adornment for this part.
     * This is used by the RotatingTool, ToolManager#rotatingTool.
     *
     * This Adornment should not have a Placeholder in it, because the RotatingTool will position it away from the
     * #rotateObject at its GraphObject#angle.
     * @see #rotatable
     * @see #rotateObjectName
     * @see RotatingTool
     */
    get rotateAdornmentTemplate(): Adornment | null; */
  // Type InteropUnion#865010667(parent: InteropGetter#58665401(name: rotateAdornmentTemplate))
  set rotateAdornmentTemplate(_i3.Adornment? value) {
    _i5.setProperty(
      this,
      'rotateAdornmentTemplate',
      value ?? _i4.undefined,
    );
  }

  /* #20616
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a rotate handle
     * when this part is selected.
     * The value of this property affects the value of #rotateObject.
     * The initial value is an empty string, meaning the whole Part itself gets any rotate handle.
     * @see #rotatable
     * @see #rotateObject
     * @see RotatingTool
     */
    get rotateObjectName(): string; */
  /// Gets or sets the name of the GraphObject that should get a rotate handle
  /// when this part is selected.
  /// The value of this property affects the value of #rotateObject.
  /// The initial value is an empty string, meaning the whole Part itself gets any rotate handle.
  _i2.String get rotateObjectName => _i5.getProperty(
        this,
        'rotateObjectName',
      );
  /* #20616
  source: 
    /**
     * Gets or sets the name of the GraphObject that should get a rotate handle
     * when this part is selected.
     * The value of this property affects the value of #rotateObject.
     * The initial value is an empty string, meaning the whole Part itself gets any rotate handle.
     * @see #rotatable
     * @see #rotateObject
     * @see RotatingTool
     */
    get rotateObjectName(): string; */
  // Type InteropStaticType.string
  set rotateObjectName(_i2.String value) {
    _i5.setProperty(
      this,
      'rotateObjectName',
      value,
    );
  }

  /* #20626
  source: 
    /**
     * This read-only property returns the GraphObject that should get rotate handles when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #rotateObjectName.
     * @see #rotatable
     * @see #rotateObjectName
     * @see RotatingTool
     */
    get rotateObject(): GraphObject; */
  /// This read-only property returns the GraphObject that should get rotate handles when this part is selected.
  /// The value will be in the visual tree of this Part and is usually named with
  /// the value of #rotateObjectName.
  _i3.GraphObject get rotateObject => _i5.getProperty(
        this,
        'rotateObject',
      );
  /* #20626
  source: 
    /**
     * This read-only property returns the GraphObject that should get rotate handles when this part is selected.
     * The value will be in the visual tree of this Part and is usually named with
     * the value of #rotateObjectName.
     * @see #rotatable
     * @see #rotateObjectName
     * @see RotatingTool
     */
    get rotateObject(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set rotateObject(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'rotateObject',
      value,
    );
  }

  /* #20643
  source: 
    /**
     * Gets or sets the spot on the #rotateObject
     * that is used in rotating this part with the RotatingTool.
     *
     * Value must be of the type Spot.
     * The value must be a specific spot -- i.e. one for which Spot#isSpot is true, or else `Spot.Default`.
     *
     * If the value is `Spot.Default`, the RotatingTool uses
     * the locationSpot if the #rotateObject is equal to the #locationObject, otherwise
     * it uses `Spot.Center`.
     *
     * The initial value is `Spot.Default`.
     *
     * @see #rotateObjectName
     * @since 2.0
     */
    get rotationSpot(): Spot; */
  /// Gets or sets the spot on the #rotateObject
  /// that is used in rotating this part with the RotatingTool.
  ///
  /// Value must be of the type Spot.
  /// The value must be a specific spot -- i.e. one for which Spot#isSpot is true, or else `Spot.Default`.
  ///
  /// If the value is `Spot.Default`, the RotatingTool uses
  /// the locationSpot if the #rotateObject is equal to the #locationObject, otherwise
  /// it uses `Spot.Center`.
  ///
  /// The initial value is `Spot.Default`.
  _i3.Spot get rotationSpot => _i5.getProperty(
        this,
        'rotationSpot',
      );
  /* #20643
  source: 
    /**
     * Gets or sets the spot on the #rotateObject
     * that is used in rotating this part with the RotatingTool.
     *
     * Value must be of the type Spot.
     * The value must be a specific spot -- i.e. one for which Spot#isSpot is true, or else `Spot.Default`.
     *
     * If the value is `Spot.Default`, the RotatingTool uses
     * the locationSpot if the #rotateObject is equal to the #locationObject, otherwise
     * it uses `Spot.Center`.
     *
     * The initial value is `Spot.Default`.
     *
     * @see #rotateObjectName
     * @since 2.0
     */
    get rotationSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set rotationSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'rotationSpot',
      value,
    );
  }

  /* #20651
  source: 
    /**
     * Gets or sets a text string that is associated with this part.
     *
     * The initial value is an empty string.
     * This value is often used for sorting.
     */
    get text(): string; */
  /// Gets or sets a text string that is associated with this part.
  ///
  /// The initial value is an empty string.
  /// This value is often used for sorting.
  _i2.String get text => _i5.getProperty(
        this,
        'text',
      );
  /* #20651
  source: 
    /**
     * Gets or sets a text string that is associated with this part.
     *
     * The initial value is an empty string.
     * This value is often used for sorting.
     */
    get text(): string; */
  // Type InteropStaticType.string
  set text(_i2.String value) {
    _i5.setProperty(
      this,
      'text',
      value,
    );
  }

  /* #20666
  source: 
    /**
     * Gets or sets the Group of which this Part or Node is a member.
     * This will be null if this is a top-level part.
     *
     * You cannot set this property on a Link; it is set for you automatically
     * based on the group memberships of the connected nodes.
     * You cannot set this property on an Adornment at all.
     *
     * A template should not be a member of any group.
     * @see Group#memberParts
     * @see #findTopLevelPart
     * @see #isTopLevel
     */
    get containingGroup(): Group | null; */
  /// Gets or sets the Group of which this Part or Node is a member.
  /// This will be null if this is a top-level part.
  ///
  /// You cannot set this property on a Link; it is set for you automatically
  /// based on the group memberships of the connected nodes.
  /// You cannot set this property on an Adornment at all.
  ///
  /// A template should not be a member of any group.
  _i3.Group? get containingGroup => _i5.getProperty(
        this,
        'containingGroup',
      );
  /* #20666
  source: 
    /**
     * Gets or sets the Group of which this Part or Node is a member.
     * This will be null if this is a top-level part.
     *
     * You cannot set this property on a Link; it is set for you automatically
     * based on the group memberships of the connected nodes.
     * You cannot set this property on an Adornment at all.
     *
     * A template should not be a member of any group.
     * @see Group#memberParts
     * @see #findTopLevelPart
     * @see #isTopLevel
     */
    get containingGroup(): Group | null; */
  // Type InteropUnion#646726305(parent: InteropGetter#213938023(name: containingGroup))
  set containingGroup(_i3.Group? value) {
    _i5.setProperty(
      this,
      'containingGroup',
      value ?? _i4.undefined,
    );
  }

  /* #20680
  source: 
    /**
     * Gets or sets the function that is called after this Part has changed which Group it belongs to, if any.
     * It is typically used to modify the appearance of the part.
     * The first argument will be this Part.
     * The second argument will be the old Group, or null if it had been a top-level part.
     * The third argument will be the new Group, or null if it is now a top-level part.
     *
     * If the value is a function, that function must not modify the part's containing Group.
     * The containing Group has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The initial value is null -- no function is called.
     */
    get containingGroupChanged(): ((thisPart: Part, oldGroup: Group | null, newGroup: Group | null) => void) | null; */
  /// Gets or sets the function that is called after this Part has changed which Group it belongs to, if any.
  /// It is typically used to modify the appearance of the part.
  /// The first argument will be this Part.
  /// The second argument will be the old Group, or null if it had been a top-level part.
  /// The third argument will be the new Group, or null if it is now a top-level part.
  ///
  /// If the value is a function, that function must not modify the part's containing Group.
  /// The containing Group has already been changed -- trying to change it again may produce undefined behavior.
  ///
  /// The initial value is null -- no function is called.
  void Function(
    _i3.Part,
    _i3.Group?,
    _i3.Group?,
  )? get containingGroupChanged => _i5.getProperty(
        this,
        'containingGroupChanged',
      );
  /* #20680
  source: 
    /**
     * Gets or sets the function that is called after this Part has changed which Group it belongs to, if any.
     * It is typically used to modify the appearance of the part.
     * The first argument will be this Part.
     * The second argument will be the old Group, or null if it had been a top-level part.
     * The third argument will be the new Group, or null if it is now a top-level part.
     *
     * If the value is a function, that function must not modify the part's containing Group.
     * The containing Group has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The initial value is null -- no function is called.
     */
    get containingGroupChanged(): ((thisPart: Part, oldGroup: Group | null, newGroup: Group | null) => void) | null; */
  // Type InteropUnion#720180782(parent: InteropGetter#525001918(name: containingGroupChanged))
  set containingGroupChanged(
      void Function(
        _i3.Part,
        _i3.Group?,
        _i3.Group?,
      )? value) {
    _i5.setProperty(
      this,
      'containingGroupChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #20707
  source: 
    /**
     * This read-only property is true when this part is not member of any Group node
     * nor is it a label node for a Link.
     * @see #containingGroup
     * @see Node#labeledLink
     */
    get isTopLevel(): boolean; */
  /// This read-only property is true when this part is not member of any Group node
  /// nor is it a label node for a Link.
  _i2.bool get isTopLevel => _i5.getProperty(
        this,
        'isTopLevel',
      );
  /* #20707
  source: 
    /**
     * This read-only property is true when this part is not member of any Group node
     * nor is it a label node for a Link.
     * @see #containingGroup
     * @see Node#labeledLink
     */
    get isTopLevel(): boolean; */
  // Type InteropStaticType.boolean
  set isTopLevel(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTopLevel',
      value,
    );
  }

  /* #20750
  source: 
    /**
     * Gets or sets flags that control when the Layout that is responsible for this Part is invalidated.
     * The initial value is Part.LayoutStandard,
     * which causes the layout for this part to be invalidated when the part is added or removed or changes visibility or size.
     *
     * Individual layout conditions include: Part.LayoutAdded, Part.LayoutRemoved,
     * Part.LayoutShown, Part.LayoutHidden, and Part.LayoutNodeSized.
     *
     * This property is ignored when #isLayoutPositioned is false -- no operation on this Part
     * will by itself cause the responsible Layout to be invalidated.
     *
     * You can also control when layouts are invalidated is by setting Layout#isInitial or Layout#isOngoing.
     */
    get layoutConditions(): number; */
  /// Gets or sets flags that control when the Layout that is responsible for this Part is invalidated.
  /// The initial value is Part.LayoutStandard,
  /// which causes the layout for this part to be invalidated when the part is added or removed or changes visibility or size.
  ///
  /// Individual layout conditions include: Part.LayoutAdded, Part.LayoutRemoved,
  /// Part.LayoutShown, Part.LayoutHidden, and Part.LayoutNodeSized.
  ///
  /// This property is ignored when #isLayoutPositioned is false -- no operation on this Part
  /// will by itself cause the responsible Layout to be invalidated.
  ///
  /// You can also control when layouts are invalidated is by setting Layout#isInitial or Layout#isOngoing.
  _i2.num get layoutConditions => _i5.getProperty(
        this,
        'layoutConditions',
      );
  /* #20750
  source: 
    /**
     * Gets or sets flags that control when the Layout that is responsible for this Part is invalidated.
     * The initial value is Part.LayoutStandard,
     * which causes the layout for this part to be invalidated when the part is added or removed or changes visibility or size.
     *
     * Individual layout conditions include: Part.LayoutAdded, Part.LayoutRemoved,
     * Part.LayoutShown, Part.LayoutHidden, and Part.LayoutNodeSized.
     *
     * This property is ignored when #isLayoutPositioned is false -- no operation on this Part
     * will by itself cause the responsible Layout to be invalidated.
     *
     * You can also control when layouts are invalidated is by setting Layout#isInitial or Layout#isOngoing.
     */
    get layoutConditions(): number; */
  // Type InteropStaticType.number
  set layoutConditions(_i2.num value) {
    _i5.setProperty(
      this,
      'layoutConditions',
      value,
    );
  }

  /* #20840
  source: 
    /**
     * Gets or sets the function used to determine the location that this Part can be dragged to.
     * The first argument is a reference to the Part being dragged, the second argument is a Point describing
     * the proposed location, and the third argument is a snapped location, if one was determined during dragging.
     * It should return a Point that is the proposed new location.
     *
     * By default this function is null and the DraggingTool uses the snapped location,
     * if one was determined and if DraggingTool#isGridSnapEnabled is true,
     * or the proposed location (the second argument) if not snapping to a grid.
     *
     * In either case the DraggingTool will limit the proposed new location by #minLocation and #maxLocation.
     *
     * The function, if supplied, must not have any side-effects.
     *
     * An example that limits moving a Node to the current viewport:
     * ```js
     *   function stayInViewport(part, pt, gridpt) {
     *     var diagram = part.diagram;
     *     if (diagram === null) return pt;
     *     // compute the area inside the viewport
     *     var v = diagram.viewportBounds.copy();
     *     v.subtractMargin(diagram.padding);
     *     // get the bounds of the part being dragged
     *     var bnd = part.actualBounds;
     *     var loc = part.location;
     *     // now limit the location appropriately
     *     var l = v.x + (loc.x - bnd.x);
     *     var r = v.right - (bnd.right - loc.x);
     *     var t = v.y + (loc.y - bnd.y);
     *     var b = v.bottom - (bnd.bottom - loc.y);
     *     if (l <= gridpt.x && gridpt.x <= r && t <= gridpt.y && gridpt.y <= b) return gridpt;
     *     var p = gridpt.copy();
     *     if (diagram.toolManager.draggingTool.isGridSnapEnabled) {
     *       // find a location that is inside V but also keeps the part's bounds within V
     *       var cw = diagram.grid.gridCellSize.width;
     *       if (cw > 0) {
     *         while (p.x > r) p.x -= cw;
     *         while (p.x < l) p.x += cw;
     *       }
     *       var ch = diagram.grid.gridCellSize.height;
     *       if (ch > 0) {
     *         while (p.y > b) p.y -= ch;
     *         while (p.y < t) p.y += ch;
     *       }
     *       return p;
     *     } else {
     *       p.x = Math.max(l, Math.min(p.x, r));
     *       p.y = Math.max(t, Math.min(p.y, b));
     *       return p;
     *     }
     *   }
     * ```
     * Note that for this functionality you will also probably want to set Diagram#autoScrollRegion to be a zero margin.
     * ```js
     *   myDiagram.nodeTemplate =
     *     new go.Node(. . .,
     *       { dragComputation: stayInViewport },
     *       . . .
     *     )
     * ```
     * @see #maxLocation
     * @see #minLocation
     */
    get dragComputation(): ((thisPart: Part, newLoc: Point, snappedLoc: Point) => Point) | null; */
  /// Gets or sets the function used to determine the location that this Part can be dragged to.
  /// The first argument is a reference to the Part being dragged, the second argument is a Point describing
  /// the proposed location, and the third argument is a snapped location, if one was determined during dragging.
  /// It should return a Point that is the proposed new location.
  ///
  /// By default this function is null and the DraggingTool uses the snapped location,
  /// if one was determined and if DraggingTool#isGridSnapEnabled is true,
  /// or the proposed location (the second argument) if not snapping to a grid.
  ///
  /// In either case the DraggingTool will limit the proposed new location by #minLocation and #maxLocation.
  ///
  /// The function, if supplied, must not have any side-effects.
  ///
  /// An example that limits moving a Node to the current viewport:
  /// ```js
  ///   function stayInViewport(part, pt, gridpt) {
  ///     var diagram = part.diagram;
  ///     if (diagram === null) return pt;
  ///     // compute the area inside the viewport
  ///     var v = diagram.viewportBounds.copy();
  ///     v.subtractMargin(diagram.padding);
  ///     // get the bounds of the part being dragged
  ///     var bnd = part.actualBounds;
  ///     var loc = part.location;
  ///     // now limit the location appropriately
  ///     var l = v.x + (loc.x - bnd.x);
  ///     var r = v.right - (bnd.right - loc.x);
  ///     var t = v.y + (loc.y - bnd.y);
  ///     var b = v.bottom - (bnd.bottom - loc.y);
  ///     if (l <= gridpt.x && gridpt.x <= r && t <= gridpt.y && gridpt.y <= b) return gridpt;
  ///     var p = gridpt.copy();
  ///     if (diagram.toolManager.draggingTool.isGridSnapEnabled) {
  ///       // find a location that is inside V but also keeps the part's bounds within V
  ///       var cw = diagram.grid.gridCellSize.width;
  ///       if (cw > 0) {
  ///         while (p.x > r) p.x -= cw;
  ///         while (p.x < l) p.x += cw;
  ///       }
  ///       var ch = diagram.grid.gridCellSize.height;
  ///       if (ch > 0) {
  ///         while (p.y > b) p.y -= ch;
  ///         while (p.y < t) p.y += ch;
  ///       }
  ///       return p;
  ///     } else {
  ///       p.x = Math.max(l, Math.min(p.x, r));
  ///       p.y = Math.max(t, Math.min(p.y, b));
  ///       return p;
  ///     }
  ///   }
  /// ```
  /// Note that for this functionality you will also probably want to set Diagram#autoScrollRegion to be a zero margin.
  /// ```js
  ///   myDiagram.nodeTemplate =
  ///     new go.Node(. . .,
  ///       { dragComputation: stayInViewport },
  ///       . . .
  ///     )
  /// ```
  _i3.Point Function(
    _i3.Part,
    _i3.Point,
    _i3.Point,
  )? get dragComputation => _i5.getProperty(
        this,
        'dragComputation',
      );
  /* #20840
  source: 
    /**
     * Gets or sets the function used to determine the location that this Part can be dragged to.
     * The first argument is a reference to the Part being dragged, the second argument is a Point describing
     * the proposed location, and the third argument is a snapped location, if one was determined during dragging.
     * It should return a Point that is the proposed new location.
     *
     * By default this function is null and the DraggingTool uses the snapped location,
     * if one was determined and if DraggingTool#isGridSnapEnabled is true,
     * or the proposed location (the second argument) if not snapping to a grid.
     *
     * In either case the DraggingTool will limit the proposed new location by #minLocation and #maxLocation.
     *
     * The function, if supplied, must not have any side-effects.
     *
     * An example that limits moving a Node to the current viewport:
     * ```js
     *   function stayInViewport(part, pt, gridpt) {
     *     var diagram = part.diagram;
     *     if (diagram === null) return pt;
     *     // compute the area inside the viewport
     *     var v = diagram.viewportBounds.copy();
     *     v.subtractMargin(diagram.padding);
     *     // get the bounds of the part being dragged
     *     var bnd = part.actualBounds;
     *     var loc = part.location;
     *     // now limit the location appropriately
     *     var l = v.x + (loc.x - bnd.x);
     *     var r = v.right - (bnd.right - loc.x);
     *     var t = v.y + (loc.y - bnd.y);
     *     var b = v.bottom - (bnd.bottom - loc.y);
     *     if (l <= gridpt.x && gridpt.x <= r && t <= gridpt.y && gridpt.y <= b) return gridpt;
     *     var p = gridpt.copy();
     *     if (diagram.toolManager.draggingTool.isGridSnapEnabled) {
     *       // find a location that is inside V but also keeps the part's bounds within V
     *       var cw = diagram.grid.gridCellSize.width;
     *       if (cw > 0) {
     *         while (p.x > r) p.x -= cw;
     *         while (p.x < l) p.x += cw;
     *       }
     *       var ch = diagram.grid.gridCellSize.height;
     *       if (ch > 0) {
     *         while (p.y > b) p.y -= ch;
     *         while (p.y < t) p.y += ch;
     *       }
     *       return p;
     *     } else {
     *       p.x = Math.max(l, Math.min(p.x, r));
     *       p.y = Math.max(t, Math.min(p.y, b));
     *       return p;
     *     }
     *   }
     * ```
     * Note that for this functionality you will also probably want to set Diagram#autoScrollRegion to be a zero margin.
     * ```js
     *   myDiagram.nodeTemplate =
     *     new go.Node(. . .,
     *       { dragComputation: stayInViewport },
     *       . . .
     *     )
     * ```
     * @see #maxLocation
     * @see #minLocation
     */
    get dragComputation(): ((thisPart: Part, newLoc: Point, snappedLoc: Point) => Point) | null; */
  // Type InteropUnion#676951310(parent: InteropGetter#567287051(name: dragComputation))
  set dragComputation(
      _i3.Point Function(
        _i3.Part,
        _i3.Point,
        _i3.Point,
      )? value) {
    _i5.setProperty(
      this,
      'dragComputation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #20849
  source: 
    /**
     * Gets or sets the X and Y offset of this part's shadow. This is only relevant if #isShadowed is true.
     * The initial value is (6, 6).
     * @see #isShadowed
     * @see #shadowColor
     * @see #shadowBlur
     */
    get shadowOffset(): Point; */
  /// Gets or sets the X and Y offset of this part's shadow. This is only relevant if #isShadowed is true.
  /// The initial value is (6, 6).
  _i3.Point get shadowOffset => _i5.getProperty(
        this,
        'shadowOffset',
      );
  /* #20849
  source: 
    /**
     * Gets or sets the X and Y offset of this part's shadow. This is only relevant if #isShadowed is true.
     * The initial value is (6, 6).
     * @see #isShadowed
     * @see #shadowColor
     * @see #shadowBlur
     */
    get shadowOffset(): Point; */
  // Type Instance of 'InteropInterface'
  set shadowOffset(_i3.Point value) {
    _i5.setProperty(
      this,
      'shadowOffset',
      value,
    );
  }

  /* #20862
  source: 
    /**
     * Gets or sets the CSS string that describes a shadow color. Default is 'gray'.
     * Brushes cannot be used for this property -- only strings.
     *
     * The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
     * So, for example, if you have a Panel with a GraphObject#background
     * that is "transparent", the shadow that is drawn for the panel will also be transparent.
     * @see #isShadowed
     * @see #shadowOffset
     * @see #shadowBlur
     */
    get shadowColor(): string; */
  /// Gets or sets the CSS string that describes a shadow color. Default is 'gray'.
  /// Brushes cannot be used for this property -- only strings.
  ///
  /// The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
  /// So, for example, if you have a Panel with a GraphObject#background
  /// that is "transparent", the shadow that is drawn for the panel will also be transparent.
  _i2.String get shadowColor => _i5.getProperty(
        this,
        'shadowColor',
      );
  /* #20862
  source: 
    /**
     * Gets or sets the CSS string that describes a shadow color. Default is 'gray'.
     * Brushes cannot be used for this property -- only strings.
     *
     * The opacity of the shadow color is multiplied by the opacity of the shadowed object's brush.
     * So, for example, if you have a Panel with a GraphObject#background
     * that is "transparent", the shadow that is drawn for the panel will also be transparent.
     * @see #isShadowed
     * @see #shadowOffset
     * @see #shadowBlur
     */
    get shadowColor(): string; */
  // Type InteropStaticType.string
  set shadowColor(_i2.String value) {
    _i5.setProperty(
      this,
      'shadowColor',
      value,
    );
  }

  /* #20874
  source: 
    /**
     * Gets or sets the numerical value that describes the shadow's blur. Number must be non-negative and non-infinity.
     * A value of 0 would mean the shadow does not blur and larger numbers represent increasingly more blur.
     * The total blur area is independent of the Part's area and can become quite large as this number is increased.
     *
     * This value is not affected by scale. Default value is 4.
     * @see #isShadowed
     * @see #shadowOffset
     * @see #shadowColor
     */
    get shadowBlur(): number; */
  /// Gets or sets the numerical value that describes the shadow's blur. Number must be non-negative and non-infinity.
  /// A value of 0 would mean the shadow does not blur and larger numbers represent increasingly more blur.
  /// The total blur area is independent of the Part's area and can become quite large as this number is increased.
  ///
  /// This value is not affected by scale. Default value is 4.
  _i2.num get shadowBlur => _i5.getProperty(
        this,
        'shadowBlur',
      );
  /* #20874
  source: 
    /**
     * Gets or sets the numerical value that describes the shadow's blur. Number must be non-negative and non-infinity.
     * A value of 0 would mean the shadow does not blur and larger numbers represent increasingly more blur.
     * The total blur area is independent of the Part's area and can become quite large as this number is increased.
     *
     * This value is not affected by scale. Default value is 4.
     * @see #isShadowed
     * @see #shadowOffset
     * @see #shadowColor
     */
    get shadowBlur(): number; */
  // Type InteropStaticType.number
  set shadowBlur(_i2.num value) {
    _i5.setProperty(
      this,
      'shadowBlur',
      value,
    );
  }

  void updateTargetBindings([_i2.String? srcprop]) {
    _i5.callMethod(
      this,
      'updateTargetBindings',
      [srcprop ?? _i4.undefined],
    );
  }

  void updateRelationshipsFromData() {
    _i5.callMethod(
      this,
      'updateRelationshipsFromData',
      [],
    );
  }

  _i3.Adornment? findAdornment(_i2.String category) => _i5.callMethod(
        this,
        'findAdornment',
        [category],
      );
  void addAdornment(
    _i2.String category,
    _i3.Adornment ad,
  ) {
    _i5.callMethod(
      this,
      'addAdornment',
      [
        category,
        ad,
      ],
    );
  }

  void removeAdornment(_i2.String category) {
    _i5.callMethod(
      this,
      'removeAdornment',
      [category],
    );
  }

  void clearAdornments() {
    _i5.callMethod(
      this,
      'clearAdornments',
      [],
    );
  }

  void updateAdornments() {
    _i5.callMethod(
      this,
      'updateAdornments',
      [],
    );
  }

  void invalidateAdornments() {
    _i5.callMethod(
      this,
      'invalidateAdornments',
      [],
    );
  }

  void move(
    _i3.Point newpos, [
    _i2.bool? useLocation,
  ]) {
    _i5.callMethod(
      this,
      'move',
      [
        newpos,
        useLocation ?? _i4.undefined,
      ],
    );
  }

  void moveTo(
    _i2.num newx,
    _i2.num newy, [
    _i2.bool? useLocation,
  ]) {
    _i5.callMethod(
      this,
      'moveTo',
      [
        newx,
        newy,
        useLocation ?? _i4.undefined,
      ],
    );
  }

  _i2.bool isVisible() => _i5.callMethod(
        this,
        'isVisible',
        [],
      );
  _i3.Rect getDocumentBounds([_i3.Rect? result]) => _i5.callMethod(
        this,
        'getDocumentBounds',
        [result ?? _i4.undefined],
      );
  void ensureBounds() {
    _i5.callMethod(
      this,
      'ensureBounds',
      [],
    );
  }

  _i2.bool canCopy() => _i5.callMethod(
        this,
        'canCopy',
        [],
      );
  _i2.bool canDelete() => _i5.callMethod(
        this,
        'canDelete',
        [],
      );
  _i2.bool canEdit() => _i5.callMethod(
        this,
        'canEdit',
        [],
      );
  _i2.bool canGroup() => _i5.callMethod(
        this,
        'canGroup',
        [],
      );
  _i2.bool canMove() => _i5.callMethod(
        this,
        'canMove',
        [],
      );
  _i2.bool canReshape() => _i5.callMethod(
        this,
        'canReshape',
        [],
      );
  _i2.bool canResize() => _i5.callMethod(
        this,
        'canResize',
        [],
      );
  _i2.bool canRotate() => _i5.callMethod(
        this,
        'canRotate',
        [],
      );
  _i2.bool canSelect() => _i5.callMethod(
        this,
        'canSelect',
        [],
      );
  _i2.num findSubGraphLevel() => _i5.callMethod(
        this,
        'findSubGraphLevel',
        [],
      );
  _i3.Part findTopLevelPart() => _i5.callMethod(
        this,
        'findTopLevelPart',
        [],
      );
  _i2.bool isMemberOf(_i3.Part part) => _i5.callMethod(
        this,
        'isMemberOf',
        [part],
      );
  _i3.Group? findCommonContainingGroup(_i3.Part other) => _i5.callMethod(
        this,
        'findCommonContainingGroup',
        [other],
      );
  _i2.bool canLayout() => _i5.callMethod(
        this,
        'canLayout',
        [],
      );
  void invalidateLayout([_i2.num? condition]) {
    _i5.callMethod(
      this,
      'invalidateLayout',
      [condition ?? _i4.undefined],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Adornment implements _i3.Part {
  factory Adornment.$1() => _i5.callConstructor(
        _declaredAdornment,
        [],
      );

  factory Adornment.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredAdornment,
        [init ?? _i4.undefined],
      );

  factory Adornment.$3([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredAdornment,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Adornment')
external _i2.Object _declaredAdornment;

extension Adornment$Typings on Adornment {
  /* #20956
  source: 
    /**
     * This read-only property returns a Placeholder that this Adornment may contain in its visual tree.
     * This may be null if there is no such placeholder object.
     */
    get placeholder(): Placeholder | null; */
  /// This read-only property returns a Placeholder that this Adornment may contain in its visual tree.
  /// This may be null if there is no such placeholder object.
  _i3.Placeholder? get placeholder => _i5.getProperty(
        this,
        'placeholder',
      );
  /* #20956
  source: 
    /**
     * This read-only property returns a Placeholder that this Adornment may contain in its visual tree.
     * This may be null if there is no such placeholder object.
     */
    get placeholder(): Placeholder | null; */
  // Type InteropUnion#333757307(parent: InteropGetter#933675895(name: placeholder))
  set placeholder(_i3.Placeholder? value) {
    _i5.setProperty(
      this,
      'placeholder',
      value ?? _i4.undefined,
    );
  }

  /* #20962
  source: 
    /**
     * Gets or sets the GraphObject that is adorned.
     * Setting this property updates the adorned object's Part by calling Part#addAdornment.
     * This may be null if the Adornment does not adorn a particular object.
     */
    get adornedObject(): GraphObject | null; */
  /// Gets or sets the GraphObject that is adorned.
  /// Setting this property updates the adorned object's Part by calling Part#addAdornment.
  /// This may be null if the Adornment does not adorn a particular object.
  _i3.GraphObject? get adornedObject => _i5.getProperty(
        this,
        'adornedObject',
      );
  /* #20962
  source: 
    /**
     * Gets or sets the GraphObject that is adorned.
     * Setting this property updates the adorned object's Part by calling Part#addAdornment.
     * This may be null if the Adornment does not adorn a particular object.
     */
    get adornedObject(): GraphObject | null; */
  // Type InteropUnion#688985406(parent: InteropGetter#1039696120(name: adornedObject))
  set adornedObject(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'adornedObject',
      value ?? _i4.undefined,
    );
  }

  /* #20968
  source: 
    /**
     * This read-only property returns the Part that contains the adorned object.
     * This will be null if the #adornedObject is null.
     */
    get adornedPart(): Part | null; */
  /// This read-only property returns the Part that contains the adorned object.
  /// This will be null if the #adornedObject is null.
  _i3.Part? get adornedPart => _i5.getProperty(
        this,
        'adornedPart',
      );
  /* #20968
  source: 
    /**
     * This read-only property returns the Part that contains the adorned object.
     * This will be null if the #adornedObject is null.
     */
    get adornedPart(): Part | null; */
  // Type InteropUnion#18160941(parent: InteropGetter#77841690(name: adornedPart))
  set adornedPart(_i3.Part? value) {
    _i5.setProperty(
      this,
      'adornedPart',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Node implements _i3.Part {
  factory Node.$1() => _i5.callConstructor(
        _declaredNode,
        [],
      );

  factory Node.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredNode,
        [init ?? _i4.undefined],
      );

  factory Node.$3([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredNode,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  /* #21199
  source: 
    /**
     * This value for Node#portSpreading indicates that links connecting with a port
     * should all connect at a single point on the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingNone: EnumValue; */
  /// This value for Node#portSpreading indicates that links connecting with a port
  /// should all connect at a single point on the side(s) indicated by a Spot that is Spot#isSide.
  static _i3.EnumValue get spreadingNone => _i5.getProperty(
        _declaredNode,
        'SpreadingNone',
      );
  /* #21199
  source: 
    /**
     * This value for Node#portSpreading indicates that links connecting with a port
     * should all connect at a single point on the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set spreadingNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredNode,
      'SpreadingNone',
      value,
    );
  }

  /* #21205
  source: 
    /**
     * This default value for Node#portSpreading indicates that links connecting with a port
     * should be distributed evenly along the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingEvenly: EnumValue; */
  /// This default value for Node#portSpreading indicates that links connecting with a port
  /// should be distributed evenly along the side(s) indicated by a Spot that is Spot#isSide.
  static _i3.EnumValue get spreadingEvenly => _i5.getProperty(
        _declaredNode,
        'SpreadingEvenly',
      );
  /* #21205
  source: 
    /**
     * This default value for Node#portSpreading indicates that links connecting with a port
     * should be distributed evenly along the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingEvenly: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set spreadingEvenly(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredNode,
      'SpreadingEvenly',
      value,
    );
  }

  /* #21212
  source: 
    /**
     * This value for Node#portSpreading indicates that links connecting with a port
     * should packed together based on the link's shape's width
     * on the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingPacked: EnumValue; */
  /// This value for Node#portSpreading indicates that links connecting with a port
  /// should packed together based on the link's shape's width
  /// on the side(s) indicated by a Spot that is Spot#isSide.
  static _i3.EnumValue get spreadingPacked => _i5.getProperty(
        _declaredNode,
        'SpreadingPacked',
      );
  /* #21212
  source: 
    /**
     * This value for Node#portSpreading indicates that links connecting with a port
     * should packed together based on the link's shape's width
     * on the side(s) indicated by a Spot that is Spot#isSide.
     * @constant
     */
    static SpreadingPacked: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set spreadingPacked(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredNode,
      'SpreadingPacked',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Node')
external _i2.Object _declaredNode;

extension Node$Typings on Node {
  /* #21235
  source: 
    /**
     * Gets or sets how link points are computed when the port spot is a "side" spot.
     * The value must be one of Node.SpreadingNone|SpreadingNone,
     * Node.SpreadingEvenly|SpreadingEvenly, Node.SpreadingPacked|SpreadingPacked.
     * The default value is Node.SpreadingEvenly.
     * @since 1.5
     */
    get portSpreading(): EnumValue; */
  /// Gets or sets how link points are computed when the port spot is a "side" spot.
  /// The value must be one of Node.SpreadingNone|SpreadingNone,
  /// Node.SpreadingEvenly|SpreadingEvenly, Node.SpreadingPacked|SpreadingPacked.
  /// The default value is Node.SpreadingEvenly.
  _i3.EnumValue get portSpreading => _i5.getProperty(
        this,
        'portSpreading',
      );
  /* #21235
  source: 
    /**
     * Gets or sets how link points are computed when the port spot is a "side" spot.
     * The value must be one of Node.SpreadingNone|SpreadingNone,
     * Node.SpreadingEvenly|SpreadingEvenly, Node.SpreadingPacked|SpreadingPacked.
     * The default value is Node.SpreadingEvenly.
     * @since 1.5
     */
    get portSpreading(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set portSpreading(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'portSpreading',
      value,
    );
  }

  /* #21243
  source: 
    /**
     * Gets or sets whether this Node is to be avoided by Links
     * whose Link#routing is Link.AvoidsNodes.
     *
     * The default value is true.
     */
    get avoidable(): boolean; */
  /// Gets or sets whether this Node is to be avoided by Links
  /// whose Link#routing is Link.AvoidsNodes.
  ///
  /// The default value is true.
  _i2.bool get avoidable => _i5.getProperty(
        this,
        'avoidable',
      );
  /* #21243
  source: 
    /**
     * Gets or sets whether this Node is to be avoided by Links
     * whose Link#routing is Link.AvoidsNodes.
     *
     * The default value is true.
     */
    get avoidable(): boolean; */
  // Type InteropStaticType.boolean
  set avoidable(_i2.bool value) {
    _i5.setProperty(
      this,
      'avoidable',
      value,
    );
  }

  /* #21254
  source: 
    /**
     * Gets or sets the margin around this Node in which avoidable links will not be routed.
     *
     * You may need to increase the #fromEndSegmentLength and #toEndSegmentLength in
     * order to prevent link routes from turning within the avoidable area around the Node.
     *
     * Value must be of type Margin.
     * The default margin is Margin(2,2,2,2)
     */
    get avoidableMargin(): MarginLike; */
  /// Gets or sets the margin around this Node in which avoidable links will not be routed.
  ///
  /// You may need to increase the #fromEndSegmentLength and #toEndSegmentLength in
  /// order to prevent link routes from turning within the avoidable area around the Node.
  ///
  /// Value must be of type Margin.
  /// The default margin is Margin(2,2,2,2)
  _i3.MarginLike get avoidableMargin => _i5.getProperty(
        this,
        'avoidableMargin',
      );
  /* #21254
  source: 
    /**
     * Gets or sets the margin around this Node in which avoidable links will not be routed.
     *
     * You may need to increase the #fromEndSegmentLength and #toEndSegmentLength in
     * order to prevent link routes from turning within the avoidable area around the Node.
     *
     * Value must be of type Margin.
     * The default margin is Margin(2,2,2,2)
     */
    get avoidableMargin(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set avoidableMargin(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'avoidableMargin',
      value,
    );
  }

  /* #21285
  source: 
    /**
     * This read-only property returns an iterator over all of the Links that are connected with this node.
     * This includes both links that are coming out of this node as well as links that are going into this node.
     * Setting Link#fromNode or Link#toNode to refer to this Node
     * will add that Link to this collection.
     *
     * Use the #findLinksConnected, #findLinksOutOf, or #findLinksInto methods
     * to get different subsets of the links, depending on direction or depending on connecting to a particular port.
     *
     * A template should not have any links connected with it.
     */
    get linksConnected(): Iterator<Link>; */
  /// This read-only property returns an iterator over all of the Links that are connected with this node.
  /// This includes both links that are coming out of this node as well as links that are going into this node.
  /// Setting Link#fromNode or Link#toNode to refer to this Node
  /// will add that Link to this collection.
  ///
  /// Use the #findLinksConnected, #findLinksOutOf, or #findLinksInto methods
  /// to get different subsets of the links, depending on direction or depending on connecting to a particular port.
  ///
  /// A template should not have any links connected with it.
  _i3.Iterator<_i3.Link> get linksConnected => _i5.getProperty(
        this,
        'linksConnected',
      );
  /* #21285
  source: 
    /**
     * This read-only property returns an iterator over all of the Links that are connected with this node.
     * This includes both links that are coming out of this node as well as links that are going into this node.
     * Setting Link#fromNode or Link#toNode to refer to this Node
     * will add that Link to this collection.
     *
     * Use the #findLinksConnected, #findLinksOutOf, or #findLinksInto methods
     * to get different subsets of the links, depending on direction or depending on connecting to a particular port.
     *
     * A template should not have any links connected with it.
     */
    get linksConnected(): Iterator<Link>; */
  // Type Instance of 'InteropInterface'
  set linksConnected(_i3.Iterator<_i3.Link> value) {
    _i5.setProperty(
      this,
      'linksConnected',
      value,
    );
  }

  /* #21376
  source: 
    /**
     * Gets or sets the function that is called after a Link has been connected with this Node.
     * It is typically used to modify the appearance of the node.
     * The first argument will be this Node.
     * The second argument will be a Link that is now connected with this node.
     * The third argument will be a GraphObject port indicating which port the link was connected with.
     *
     * If the value is a function, that function must not modify what this Node is connected with.
     * The Link has already been added -- trying to remove it or another link may produce undefined behavior.
     * However, the other end of the link may not yet have been connected with a node (and might never be),
     * so you cannot depend on looking at what the link connects with.
     *
     * The default value is null -- no function is called.
     */
    get linkConnected(): ((thisNode: Node, newLink: Link, thisPort: GraphObject) => void) | null; */
  /// Gets or sets the function that is called after a Link has been connected with this Node.
  /// It is typically used to modify the appearance of the node.
  /// The first argument will be this Node.
  /// The second argument will be a Link that is now connected with this node.
  /// The third argument will be a GraphObject port indicating which port the link was connected with.
  ///
  /// If the value is a function, that function must not modify what this Node is connected with.
  /// The Link has already been added -- trying to remove it or another link may produce undefined behavior.
  /// However, the other end of the link may not yet have been connected with a node (and might never be),
  /// so you cannot depend on looking at what the link connects with.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Node,
    _i3.Link,
    _i3.GraphObject,
  )? get linkConnected => _i5.getProperty(
        this,
        'linkConnected',
      );
  /* #21376
  source: 
    /**
     * Gets or sets the function that is called after a Link has been connected with this Node.
     * It is typically used to modify the appearance of the node.
     * The first argument will be this Node.
     * The second argument will be a Link that is now connected with this node.
     * The third argument will be a GraphObject port indicating which port the link was connected with.
     *
     * If the value is a function, that function must not modify what this Node is connected with.
     * The Link has already been added -- trying to remove it or another link may produce undefined behavior.
     * However, the other end of the link may not yet have been connected with a node (and might never be),
     * so you cannot depend on looking at what the link connects with.
     *
     * The default value is null -- no function is called.
     */
    get linkConnected(): ((thisNode: Node, newLink: Link, thisPort: GraphObject) => void) | null; */
  // Type InteropUnion#870377079(parent: InteropGetter#178611226(name: linkConnected))
  set linkConnected(
      void Function(
        _i3.Node,
        _i3.Link,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'linkConnected',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21392
  source: 
    /**
     * Gets or sets the function that is called after a Link has been disconnected from this Node.
     * It is typically used to modify the appearance of the node.
     * The first argument will be this Node.
     * The second argument will be a Link that had been connected with this node.
     * The third argument will be a GraphObject port indicating which port the link had been connected with.
     *
     * If the value is a function, that function must not modify what this Node is connected with.
     * The Link has already been removed -- trying to add it or another link may produce undefined behavior.
     * The other end of the link may not yet have been disconnected from a node (and might never be),
     * so you cannot depend on looking at what the link connects with.
     *
     * The default value is null -- no function is called.
     */
    get linkDisconnected(): ((thisNode: Node, oldLink: Link, thisPort: GraphObject) => void) | null; */
  /// Gets or sets the function that is called after a Link has been disconnected from this Node.
  /// It is typically used to modify the appearance of the node.
  /// The first argument will be this Node.
  /// The second argument will be a Link that had been connected with this node.
  /// The third argument will be a GraphObject port indicating which port the link had been connected with.
  ///
  /// If the value is a function, that function must not modify what this Node is connected with.
  /// The Link has already been removed -- trying to add it or another link may produce undefined behavior.
  /// The other end of the link may not yet have been disconnected from a node (and might never be),
  /// so you cannot depend on looking at what the link connects with.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Node,
    _i3.Link,
    _i3.GraphObject,
  )? get linkDisconnected => _i5.getProperty(
        this,
        'linkDisconnected',
      );
  /* #21392
  source: 
    /**
     * Gets or sets the function that is called after a Link has been disconnected from this Node.
     * It is typically used to modify the appearance of the node.
     * The first argument will be this Node.
     * The second argument will be a Link that had been connected with this node.
     * The third argument will be a GraphObject port indicating which port the link had been connected with.
     *
     * If the value is a function, that function must not modify what this Node is connected with.
     * The Link has already been removed -- trying to add it or another link may produce undefined behavior.
     * The other end of the link may not yet have been disconnected from a node (and might never be),
     * so you cannot depend on looking at what the link connects with.
     *
     * The default value is null -- no function is called.
     */
    get linkDisconnected(): ((thisNode: Node, oldLink: Link, thisPort: GraphObject) => void) | null; */
  // Type InteropUnion#800052346(parent: InteropGetter#45793116(name: linkDisconnected))
  set linkDisconnected(
      void Function(
        _i3.Node,
        _i3.Link,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'linkDisconnected',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21411
  source: 
    /**
     * Gets or sets a predicate that determines whether or not a Link may be connected with this node.
     * If this is non-null, the predicate is called in addition to the predicate that is LinkingBaseTool#linkValidation
     * on the LinkingTool and RelinkingTool.
     * See LinkingBaseTool#isValidLink for more details.
     *
     * The default predicate is null, which is equivalent to simply returning true.
     * The first argument will be the proposed "from" Node (may be null).
     * The second argument will be the proposed "from" GraphObject port (may be null).
     * The third argument will be the proposed "to" Node (may be null).
     * The fourth argument will be the proposed "to" GraphObject port (may be null).
     * The fifth argument may be null when asking about creating a new link,
     * or may be a Link when asking about reconnecting an existing link.
     *
     * The function, if supplied, must not have any side-effects.
     * @since 1.3
     */
    get linkValidation(): ((fromNode: Node, fromPort: GraphObject, toNode: Node, toPort: GraphObject, link: Link) => boolean) | null; */
  /// Gets or sets a predicate that determines whether or not a Link may be connected with this node.
  /// If this is non-null, the predicate is called in addition to the predicate that is LinkingBaseTool#linkValidation
  /// on the LinkingTool and RelinkingTool.
  /// See LinkingBaseTool#isValidLink for more details.
  ///
  /// The default predicate is null, which is equivalent to simply returning true.
  /// The first argument will be the proposed "from" Node (may be null).
  /// The second argument will be the proposed "from" GraphObject port (may be null).
  /// The third argument will be the proposed "to" Node (may be null).
  /// The fourth argument will be the proposed "to" GraphObject port (may be null).
  /// The fifth argument may be null when asking about creating a new link,
  /// or may be a Link when asking about reconnecting an existing link.
  ///
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i3.Node,
    _i3.GraphObject,
    _i3.Node,
    _i3.GraphObject,
    _i3.Link,
  )? get linkValidation => _i5.getProperty(
        this,
        'linkValidation',
      );
  /* #21411
  source: 
    /**
     * Gets or sets a predicate that determines whether or not a Link may be connected with this node.
     * If this is non-null, the predicate is called in addition to the predicate that is LinkingBaseTool#linkValidation
     * on the LinkingTool and RelinkingTool.
     * See LinkingBaseTool#isValidLink for more details.
     *
     * The default predicate is null, which is equivalent to simply returning true.
     * The first argument will be the proposed "from" Node (may be null).
     * The second argument will be the proposed "from" GraphObject port (may be null).
     * The third argument will be the proposed "to" Node (may be null).
     * The fourth argument will be the proposed "to" GraphObject port (may be null).
     * The fifth argument may be null when asking about creating a new link,
     * or may be a Link when asking about reconnecting an existing link.
     *
     * The function, if supplied, must not have any side-effects.
     * @since 1.3
     */
    get linkValidation(): ((fromNode: Node, fromPort: GraphObject, toNode: Node, toPort: GraphObject, link: Link) => boolean) | null; */
  // Type InteropUnion#693380(parent: InteropGetter#884035778(name: linkValidation))
  set linkValidation(
      _i2.bool Function(
        _i3.Node,
        _i3.GraphObject,
        _i3.Node,
        _i3.GraphObject,
        _i3.Link,
      )? value) {
    _i5.setProperty(
      this,
      'linkValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21419
  source: 
    /**
     * This read-only property is true when this Node is a label node for a Link.
     *
     * If this is true, then `n.labeledLink` will be a Link and `n.labeledLink.isLabeledLink` will be true.
     * @see #labeledLink
     */
    get isLinkLabel(): boolean; */
  /// This read-only property is true when this Node is a label node for a Link.
  ///
  /// If this is true, then `n.labeledLink` will be a Link and `n.labeledLink.isLabeledLink` will be true.
  _i2.bool get isLinkLabel => _i5.getProperty(
        this,
        'isLinkLabel',
      );
  /* #21419
  source: 
    /**
     * This read-only property is true when this Node is a label node for a Link.
     *
     * If this is true, then `n.labeledLink` will be a Link and `n.labeledLink.isLabeledLink` will be true.
     * @see #labeledLink
     */
    get isLinkLabel(): boolean; */
  // Type InteropStaticType.boolean
  set isLinkLabel(_i2.bool value) {
    _i5.setProperty(
      this,
      'isLinkLabel',
      value,
    );
  }

  /* #21427
  source: 
    /**
     * Gets or sets the Link for which this Node is acting as a smart label.
     * Most nodes do not act as link labels, so this property will be null.
     *
     * A template should not be a label node for a link.
     * @see #isLinkLabel
     */
    get labeledLink(): Link | null; */
  /// Gets or sets the Link for which this Node is acting as a smart label.
  /// Most nodes do not act as link labels, so this property will be null.
  ///
  /// A template should not be a label node for a link.
  _i3.Link? get labeledLink => _i5.getProperty(
        this,
        'labeledLink',
      );
  /* #21427
  source: 
    /**
     * Gets or sets the Link for which this Node is acting as a smart label.
     * Most nodes do not act as link labels, so this property will be null.
     *
     * A template should not be a label node for a link.
     * @see #isLinkLabel
     */
    get labeledLink(): Link | null; */
  // Type InteropUnion#624772557(parent: InteropGetter#948711802(name: labeledLink))
  set labeledLink(_i3.Link? value) {
    _i5.setProperty(
      this,
      'labeledLink',
      value ?? _i4.undefined,
    );
  }

  /* #21443
  source: 
    /**
     * This read-only property returns the primary GraphObject representing a port in this node.
     * If there is a GraphObject whose GraphObject#portId is the empty string, return it.
     * If there is no such element, just return this whole Node.
     */
    get port(): GraphObject; */
  /// This read-only property returns the primary GraphObject representing a port in this node.
  /// If there is a GraphObject whose GraphObject#portId is the empty string, return it.
  /// If there is no such element, just return this whole Node.
  _i3.GraphObject get port => _i5.getProperty(
        this,
        'port',
      );
  /* #21443
  source: 
    /**
     * This read-only property returns the primary GraphObject representing a port in this node.
     * If there is a GraphObject whose GraphObject#portId is the empty string, return it.
     * If there is no such element, just return this whole Node.
     */
    get port(): GraphObject; */
  // Type Instance of 'InteropInterface'
  set port(_i3.GraphObject value) {
    _i5.setProperty(
      this,
      'port',
      value,
    );
  }

  /* #21447
  source: 
    /**
     * This read-only property returns an iterator over all of the GraphObjects in this node that act as ports.
     */
    get ports(): Iterator<GraphObject>; */
  /// This read-only property returns an iterator over all of the GraphObjects in this node that act as ports.
  _i3.Iterator<_i3.GraphObject> get ports => _i5.getProperty(
        this,
        'ports',
      );
  /* #21447
  source: 
    /**
     * This read-only property returns an iterator over all of the GraphObjects in this node that act as ports.
     */
    get ports(): Iterator<GraphObject>; */
  // Type Instance of 'InteropInterface'
  set ports(_i3.Iterator<_i3.GraphObject> value) {
    _i5.setProperty(
      this,
      'ports',
      value,
    );
  }

  /* #21669
  source: 
    /**
     * Gets or sets whether the subtree graph starting at this node is expanded.
     * Changing this property's value will call #collapseTree or #expandTree,
     * and also will call the value of #treeExpandedChanged if it is a function.
     *
     * The initial value is true -- "tree-child" nodes, and the links to them, are shown.
     *
     * There is an analogous property for expanded/collapsed Groups: Group#isSubGraphExpanded.
     */
    get isTreeExpanded(): boolean; */
  /// Gets or sets whether the subtree graph starting at this node is expanded.
  /// Changing this property's value will call #collapseTree or #expandTree,
  /// and also will call the value of #treeExpandedChanged if it is a function.
  ///
  /// The initial value is true -- "tree-child" nodes, and the links to them, are shown.
  ///
  /// There is an analogous property for expanded/collapsed Groups: Group#isSubGraphExpanded.
  _i2.bool get isTreeExpanded => _i5.getProperty(
        this,
        'isTreeExpanded',
      );
  /* #21669
  source: 
    /**
     * Gets or sets whether the subtree graph starting at this node is expanded.
     * Changing this property's value will call #collapseTree or #expandTree,
     * and also will call the value of #treeExpandedChanged if it is a function.
     *
     * The initial value is true -- "tree-child" nodes, and the links to them, are shown.
     *
     * There is an analogous property for expanded/collapsed Groups: Group#isSubGraphExpanded.
     */
    get isTreeExpanded(): boolean; */
  // Type InteropStaticType.boolean
  set isTreeExpanded(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTreeExpanded',
      value,
    );
  }

  /* #21677
  source: 
    /**
     * Gets or sets whether the subtree graph starting at this node
     * had been collapsed by a call to #expandTree on the parent node.
     * The initial value is false.
     * @see #isTreeExpanded
     */
    get wasTreeExpanded(): boolean; */
  /// Gets or sets whether the subtree graph starting at this node
  /// had been collapsed by a call to #expandTree on the parent node.
  /// The initial value is false.
  _i2.bool get wasTreeExpanded => _i5.getProperty(
        this,
        'wasTreeExpanded',
      );
  /* #21677
  source: 
    /**
     * Gets or sets whether the subtree graph starting at this node
     * had been collapsed by a call to #expandTree on the parent node.
     * The initial value is false.
     * @see #isTreeExpanded
     */
    get wasTreeExpanded(): boolean; */
  // Type InteropStaticType.boolean
  set wasTreeExpanded(_i2.bool value) {
    _i5.setProperty(
      this,
      'wasTreeExpanded',
      value,
    );
  }

  /* #21688
  source: 
    /**
     * Gets or sets the function that is called when #isTreeExpanded has changed value.
     * The argument to that function will be this Node.
     *
     * If the value is a function, that function must not expand or collapse any trees of nodes and links.
     * The Node has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get treeExpandedChanged(): ((thisNode: Node) => void) | null; */
  /// Gets or sets the function that is called when #isTreeExpanded has changed value.
  /// The argument to that function will be this Node.
  ///
  /// If the value is a function, that function must not expand or collapse any trees of nodes and links.
  /// The Node has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(_i3.Node)? get treeExpandedChanged => _i5.getProperty(
        this,
        'treeExpandedChanged',
      );
  /* #21688
  source: 
    /**
     * Gets or sets the function that is called when #isTreeExpanded has changed value.
     * The argument to that function will be this Node.
     *
     * If the value is a function, that function must not expand or collapse any trees of nodes and links.
     * The Node has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get treeExpandedChanged(): ((thisNode: Node) => void) | null; */
  // Type InteropUnion#50586510(parent: InteropGetter#155070913(name: treeExpandedChanged))
  set treeExpandedChanged(void Function(_i3.Node)? value) {
    _i5.setProperty(
      this,
      'treeExpandedChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21698
  source: 
    /**
     * Gets whether this node has no tree children.
     *
     * The initial value is true, meaning that there are no links connected with child nodes
     * in the direction given by Diagram#isTreePathToChildren.
     * This value changes automatically as link connections are added to or removed from this node.
     * Links for which Link#isTreeLink is false are ignored.
     */
    get isTreeLeaf(): boolean; */
  /// Gets whether this node has no tree children.
  ///
  /// The initial value is true, meaning that there are no links connected with child nodes
  /// in the direction given by Diagram#isTreePathToChildren.
  /// This value changes automatically as link connections are added to or removed from this node.
  /// Links for which Link#isTreeLink is false are ignored.
  _i2.bool get isTreeLeaf => _i5.getProperty(
        this,
        'isTreeLeaf',
      );
  /* #21698
  source: 
    /**
     * Gets whether this node has no tree children.
     *
     * The initial value is true, meaning that there are no links connected with child nodes
     * in the direction given by Diagram#isTreePathToChildren.
     * This value changes automatically as link connections are added to or removed from this node.
     * Links for which Link#isTreeLink is false are ignored.
     */
    get isTreeLeaf(): boolean; */
  // Type InteropStaticType.boolean
  set isTreeLeaf(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTreeLeaf',
      value,
    );
  }

  void invalidateLinkBundle(
    _i3.Node other, [
    _i2.String? thisportid,
    _i2.String? otherportid,
  ]) {
    _i5.callMethod(
      this,
      'invalidateLinkBundle',
      [
        other,
        thisportid ?? _i4.undefined,
        otherportid ?? _i4.undefined,
      ],
    );
  }

  void invalidateConnectedLinks([_i3.Set<_i3.Part>? ignore]) {
    _i5.callMethod(
      this,
      'invalidateConnectedLinks',
      [ignore ?? _i4.undefined],
    );
  }

  _i3.Rect getAvoidableRect(_i3.Rect result) => _i5.callMethod(
        this,
        'getAvoidableRect',
        [result],
      );
  _i3.Node? findVisibleNode() => _i5.callMethod(
        this,
        'findVisibleNode',
        [],
      );
  _i3.Iterator<_i3.Link> findExternalTreeLinksConnected() => _i5.callMethod(
        this,
        'findExternalTreeLinksConnected',
        [],
      );
  _i3.Iterator<_i3.Link> findLinksConnected([_i2.String? pid]) =>
      _i5.callMethod(
        this,
        'findLinksConnected',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Link> findLinksOutOf([_i2.String? pid]) => _i5.callMethod(
        this,
        'findLinksOutOf',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Link> findLinksInto([_i2.String? pid]) => _i5.callMethod(
        this,
        'findLinksInto',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Node> findNodesConnected([_i2.String? pid]) =>
      _i5.callMethod(
        this,
        'findNodesConnected',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Node> findNodesOutOf([_i2.String? pid]) => _i5.callMethod(
        this,
        'findNodesOutOf',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Node> findNodesInto([_i2.String? pid]) => _i5.callMethod(
        this,
        'findNodesInto',
        [pid ?? _i4.undefined],
      );
  _i3.Iterator<_i3.Link> findLinksBetween(
    _i3.Node othernode, [
    _i2.String? pid,
    _i2.String? otherpid,
  ]) =>
      _i5.callMethod(
        this,
        'findLinksBetween',
        [
          othernode,
          pid ?? _i4.undefined,
          otherpid ?? _i4.undefined,
        ],
      );
  _i3.Iterator<_i3.Link> findLinksTo(
    _i3.Node othernode, [
    _i2.String? pid,
    _i2.String? otherpid,
  ]) =>
      _i5.callMethod(
        this,
        'findLinksTo',
        [
          othernode,
          pid ?? _i4.undefined,
          otherpid ?? _i4.undefined,
        ],
      );
  _i3.GraphObject findPort(_i2.String pid) => _i5.callMethod(
        this,
        'findPort',
        [pid],
      );
  _i2.bool isInTreeOf(_i3.Node node) => _i5.callMethod(
        this,
        'isInTreeOf',
        [node],
      );
  _i3.Node findTreeRoot() => _i5.callMethod(
        this,
        'findTreeRoot',
        [],
      );
  _i3.Node? findCommonTreeParent(_i3.Node other) => _i5.callMethod(
        this,
        'findCommonTreeParent',
        [other],
      );
  _i3.Link? findTreeParentLink() => _i5.callMethod(
        this,
        'findTreeParentLink',
        [],
      );
  _i3.Node? findTreeParentNode() => _i5.callMethod(
        this,
        'findTreeParentNode',
        [],
      );
  _i3.Set<_i3.Part> findTreeParentChain() => _i5.callMethod(
        this,
        'findTreeParentChain',
        [],
      );
  _i2.num findTreeLevel() => _i5.callMethod(
        this,
        'findTreeLevel',
        [],
      );
  _i3.Iterator<_i3.Link> findTreeChildrenLinks() => _i5.callMethod(
        this,
        'findTreeChildrenLinks',
        [],
      );
  _i3.Iterator<_i3.Node> findTreeChildrenNodes() => _i5.callMethod(
        this,
        'findTreeChildrenNodes',
        [],
      );
  _i3.Set<_i3.Part> findTreeParts([_i2.num? level]) => _i5.callMethod(
        this,
        'findTreeParts',
        [level ?? _i4.undefined],
      );
  void collapseTree([_i2.num? level]) {
    _i5.callMethod(
      this,
      'collapseTree',
      [level ?? _i4.undefined],
    );
  }

  void expandTree([_i2.num? level]) {
    _i5.callMethod(
      this,
      'expandTree',
      [level ?? _i4.undefined],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Group implements _i3.Node {
  factory Group.$1() => _i5.callConstructor(
        _declaredGroup,
        [],
      );

  factory Group.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredGroup,
        [init ?? _i4.undefined],
      );

  factory Group.$3([
    _i2.Object? type,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredGroup,
        [
          type ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Group')
external _i2.Object _declaredGroup;

extension Group$Typings on Group {
  /* #21848
  source: 
    /**
     * This read-only property returns a Placeholder that this group may contain in its visual tree.
     */
    get placeholder(): Placeholder | null; */
  /// This read-only property returns a Placeholder that this group may contain in its visual tree.
  _i3.Placeholder? get placeholder => _i5.getProperty(
        this,
        'placeholder',
      );
  /* #21848
  source: 
    /**
     * This read-only property returns a Placeholder that this group may contain in its visual tree.
     */
    get placeholder(): Placeholder | null; */
  // Type InteropUnion#137495663(parent: InteropGetter#931751028(name: placeholder))
  set placeholder(_i3.Placeholder? value) {
    _i5.setProperty(
      this,
      'placeholder',
      value ?? _i4.undefined,
    );
  }

  /* #21859
  source: 
    /**
     * Gets or sets whether the size of the area of the Group's #placeholder
     * should remain the same during a DraggingTool move until a drop occurs.
     * Groups within temporary layers (such as new Groups during a drag-copy) are unaffected by this property.
     *
     * In other words, when the value is true, re-computing the bounds of the
     * members is suspended until a drop occurs, at which time the border is recomputed,
     * perhaps not including some members that had been dragged out and reparented.
     * The initial value is false.
     */
    get computesBoundsAfterDrag(): boolean; */
  /// Gets or sets whether the size of the area of the Group's #placeholder
  /// should remain the same during a DraggingTool move until a drop occurs.
  /// Groups within temporary layers (such as new Groups during a drag-copy) are unaffected by this property.
  ///
  /// In other words, when the value is true, re-computing the bounds of the
  /// members is suspended until a drop occurs, at which time the border is recomputed,
  /// perhaps not including some members that had been dragged out and reparented.
  /// The initial value is false.
  _i2.bool get computesBoundsAfterDrag => _i5.getProperty(
        this,
        'computesBoundsAfterDrag',
      );
  /* #21859
  source: 
    /**
     * Gets or sets whether the size of the area of the Group's #placeholder
     * should remain the same during a DraggingTool move until a drop occurs.
     * Groups within temporary layers (such as new Groups during a drag-copy) are unaffected by this property.
     *
     * In other words, when the value is true, re-computing the bounds of the
     * members is suspended until a drop occurs, at which time the border is recomputed,
     * perhaps not including some members that had been dragged out and reparented.
     * The initial value is false.
     */
    get computesBoundsAfterDrag(): boolean; */
  // Type InteropStaticType.boolean
  set computesBoundsAfterDrag(_i2.bool value) {
    _i5.setProperty(
      this,
      'computesBoundsAfterDrag',
      value,
    );
  }

  /* #21866
  source: 
    /**
     * Gets or sets whether a #placeholder's bounds includes the bounds of member Links.
     * The default value is true.
     * If this is false, only non-Link member Parts are used to compute the Placeholder's bounds in document coordinates.
     */
    get computesBoundsIncludingLinks(): boolean; */
  /// Gets or sets whether a #placeholder's bounds includes the bounds of member Links.
  /// The default value is true.
  /// If this is false, only non-Link member Parts are used to compute the Placeholder's bounds in document coordinates.
  _i2.bool get computesBoundsIncludingLinks => _i5.getProperty(
        this,
        'computesBoundsIncludingLinks',
      );
  /* #21866
  source: 
    /**
     * Gets or sets whether a #placeholder's bounds includes the bounds of member Links.
     * The default value is true.
     * If this is false, only non-Link member Parts are used to compute the Placeholder's bounds in document coordinates.
     */
    get computesBoundsIncludingLinks(): boolean; */
  // Type InteropStaticType.boolean
  set computesBoundsIncludingLinks(_i2.bool value) {
    _i5.setProperty(
      this,
      'computesBoundsIncludingLinks',
      value,
    );
  }

  /* #21872
  source: 
    /**
     * Gets or sets whether a #placeholder's bounds includes the previous Group.location.
     * The default value is false.
     */
    get computesBoundsIncludingLocation(): boolean; */
  /// Gets or sets whether a #placeholder's bounds includes the previous Group.location.
  /// The default value is false.
  _i2.bool get computesBoundsIncludingLocation => _i5.getProperty(
        this,
        'computesBoundsIncludingLocation',
      );
  /* #21872
  source: 
    /**
     * Gets or sets whether a #placeholder's bounds includes the previous Group.location.
     * The default value is false.
     */
    get computesBoundsIncludingLocation(): boolean; */
  // Type InteropStaticType.boolean
  set computesBoundsIncludingLocation(_i2.bool value) {
    _i5.setProperty(
      this,
      'computesBoundsIncludingLocation',
      value,
    );
  }

  /* #21884
  source: 
    /**
     * Gets or sets whether drag-and-drop events may be bubbled up to this Group if not handled by member Parts.
     * The default value is false -- each Node or Link that is a member of the Group needs to define
     * its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
     * event handlers if you want dragging/dropping on a member part to act as if the user were acting on the group.
     *
     * This is currently restricted to only call the mouseDragEnter, mouseDragLeave, and mouseDrop event handlers
     * defined on the whole Group, not on any element inside the Group's visual tree.
     * @since 1.5
     */
    get handlesDragDropForMembers(): boolean; */
  /// Gets or sets whether drag-and-drop events may be bubbled up to this Group if not handled by member Parts.
  /// The default value is false -- each Node or Link that is a member of the Group needs to define
  /// its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
  /// event handlers if you want dragging/dropping on a member part to act as if the user were acting on the group.
  ///
  /// This is currently restricted to only call the mouseDragEnter, mouseDragLeave, and mouseDrop event handlers
  /// defined on the whole Group, not on any element inside the Group's visual tree.
  _i2.bool get handlesDragDropForMembers => _i5.getProperty(
        this,
        'handlesDragDropForMembers',
      );
  /* #21884
  source: 
    /**
     * Gets or sets whether drag-and-drop events may be bubbled up to this Group if not handled by member Parts.
     * The default value is false -- each Node or Link that is a member of the Group needs to define
     * its own GraphObject#mouseDragEnter, GraphObject#mouseDragLeave, and GraphObject#mouseDrop
     * event handlers if you want dragging/dropping on a member part to act as if the user were acting on the group.
     *
     * This is currently restricted to only call the mouseDragEnter, mouseDragLeave, and mouseDrop event handlers
     * defined on the whole Group, not on any element inside the Group's visual tree.
     * @since 1.5
     */
    get handlesDragDropForMembers(): boolean; */
  // Type InteropStaticType.boolean
  set handlesDragDropForMembers(_i2.bool value) {
    _i5.setProperty(
      this,
      'handlesDragDropForMembers',
      value,
    );
  }

  /* #21894
  source: 
    /**
     * This read-only property returns an iterator over the member Parts of this Group.
     * Setting Part#containingGroup to refer to this Group
     * will add that part to this collection.
     * The Parts can be Nodes, Links, Groups, or simple Parts.
     *
     * A template should not have any member parts.
     */
    get memberParts(): Iterator<Part>; */
  /// This read-only property returns an iterator over the member Parts of this Group.
  /// Setting Part#containingGroup to refer to this Group
  /// will add that part to this collection.
  /// The Parts can be Nodes, Links, Groups, or simple Parts.
  ///
  /// A template should not have any member parts.
  _i3.Iterator<_i3.Part> get memberParts => _i5.getProperty(
        this,
        'memberParts',
      );
  /* #21894
  source: 
    /**
     * This read-only property returns an iterator over the member Parts of this Group.
     * Setting Part#containingGroup to refer to this Group
     * will add that part to this collection.
     * The Parts can be Nodes, Links, Groups, or simple Parts.
     *
     * A template should not have any member parts.
     */
    get memberParts(): Iterator<Part>; */
  // Type Instance of 'InteropInterface'
  set memberParts(_i3.Iterator<_i3.Part> value) {
    _i5.setProperty(
      this,
      'memberParts',
      value,
    );
  }

  /* #21902
  source: 
    /**
     * Gets or sets the Layout used to position all of the immediate member nodes and links in this group.
     * By default this property is an instance of Layout -- no special layout is used, which just makes
     * sure each member node has a valid location.
     *
     * A group layout must not be shared with any Diagram#layout.
     */
    get layout(): Layout | null; */
  /// Gets or sets the Layout used to position all of the immediate member nodes and links in this group.
  /// By default this property is an instance of Layout -- no special layout is used, which just makes
  /// sure each member node has a valid location.
  ///
  /// A group layout must not be shared with any Diagram#layout.
  _i3.Layout? get layout => _i5.getProperty(
        this,
        'layout',
      );
  /* #21902
  source: 
    /**
     * Gets or sets the Layout used to position all of the immediate member nodes and links in this group.
     * By default this property is an instance of Layout -- no special layout is used, which just makes
     * sure each member node has a valid location.
     *
     * A group layout must not be shared with any Diagram#layout.
     */
    get layout(): Layout | null; */
  // Type InteropUnion#777502455(parent: InteropGetter#7341178(name: layout))
  set layout(_i3.Layout? value) {
    _i5.setProperty(
      this,
      'layout',
      value ?? _i4.undefined,
    );
  }

  /* #21915
  source: 
    /**
     * Gets or sets the function that is called after a member Part has been added to this Group.
     * It is typically used to modify the appearance of the group.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
     *
     * If the value is a function, that function must not modify any membership relationships.
     * The member Part has already been added -- trying to remove it or adding or removing another member or the Group itself may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get memberAdded(): ((thisGroup: Group, newPart: Part) => void) | null; */
  /// Gets or sets the function that is called after a member Part has been added to this Group.
  /// It is typically used to modify the appearance of the group.
  /// The first argument will be this Group.
  /// The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
  ///
  /// If the value is a function, that function must not modify any membership relationships.
  /// The member Part has already been added -- trying to remove it or adding or removing another member or the Group itself may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Group,
    _i3.Part,
  )? get memberAdded => _i5.getProperty(
        this,
        'memberAdded',
      );
  /* #21915
  source: 
    /**
     * Gets or sets the function that is called after a member Part has been added to this Group.
     * It is typically used to modify the appearance of the group.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
     *
     * If the value is a function, that function must not modify any membership relationships.
     * The member Part has already been added -- trying to remove it or adding or removing another member or the Group itself may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get memberAdded(): ((thisGroup: Group, newPart: Part) => void) | null; */
  // Type InteropUnion#941570962(parent: InteropGetter#560846828(name: memberAdded))
  set memberAdded(
      void Function(
        _i3.Group,
        _i3.Part,
      )? value) {
    _i5.setProperty(
      this,
      'memberAdded',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21928
  source: 
    /**
     * Gets or sets the function that is called after a member Part has been removed from this Group.
     * It is typically used to modify the appearance of the group.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
     *
     * If the value is a function, that function must not modify any membership relationships.
     * The member Part has already been removed -- trying to add it or adding or removing another member or the Group itself may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get memberRemoved(): ((thisGroup: Group, oldPart: Part) => void) | null; */
  /// Gets or sets the function that is called after a member Part has been removed from this Group.
  /// It is typically used to modify the appearance of the group.
  /// The first argument will be this Group.
  /// The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
  ///
  /// If the value is a function, that function must not modify any membership relationships.
  /// The member Part has already been removed -- trying to add it or adding or removing another member or the Group itself may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Group,
    _i3.Part,
  )? get memberRemoved => _i5.getProperty(
        this,
        'memberRemoved',
      );
  /* #21928
  source: 
    /**
     * Gets or sets the function that is called after a member Part has been removed from this Group.
     * It is typically used to modify the appearance of the group.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but may be a simple Part or a Link.
     *
     * If the value is a function, that function must not modify any membership relationships.
     * The member Part has already been removed -- trying to add it or adding or removing another member or the Group itself may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get memberRemoved(): ((thisGroup: Group, oldPart: Part) => void) | null; */
  // Type InteropUnion#347138287(parent: InteropGetter#904038594(name: memberRemoved))
  set memberRemoved(
      void Function(
        _i3.Group,
        _i3.Part,
      )? value) {
    _i5.setProperty(
      this,
      'memberRemoved',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21940
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a Part may become a member of this group.
     * If this is non-null, the predicate is called in addition to any CommandHandler#memberValidation predicate.
     *
     * The default predicate is null, which is equivalent to simply returning true.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but will not be a Link or an Adornment.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get memberValidation(): ((thisGroup: Group, part: Part) => boolean) | null; */
  /// Gets or sets the predicate that determines whether or not a Part may become a member of this group.
  /// If this is non-null, the predicate is called in addition to any CommandHandler#memberValidation predicate.
  ///
  /// The default predicate is null, which is equivalent to simply returning true.
  /// The first argument will be this Group.
  /// The second argument will be a Part, typically a Node, but will not be a Link or an Adornment.
  ///
  /// The function, if supplied, must not have any side-effects.
  _i2.bool Function(
    _i3.Group,
    _i3.Part,
  )? get memberValidation => _i5.getProperty(
        this,
        'memberValidation',
      );
  /* #21940
  source: 
    /**
     * Gets or sets the predicate that determines whether or not a Part may become a member of this group.
     * If this is non-null, the predicate is called in addition to any CommandHandler#memberValidation predicate.
     *
     * The default predicate is null, which is equivalent to simply returning true.
     * The first argument will be this Group.
     * The second argument will be a Part, typically a Node, but will not be a Link or an Adornment.
     *
     * The function, if supplied, must not have any side-effects.
     */
    get memberValidation(): ((thisGroup: Group, part: Part) => boolean) | null; */
  // Type InteropUnion#523884695(parent: InteropGetter#883365182(name: memberValidation))
  set memberValidation(
      _i2.bool Function(
        _i3.Group,
        _i3.Part,
      )? value) {
    _i5.setProperty(
      this,
      'memberValidation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #21979
  source: 
    /**
     * Gets or sets whether the user may ungroup this group.
     * The initial value is false.
     * @see #canUngroup
     */
    get ungroupable(): boolean; */
  /// Gets or sets whether the user may ungroup this group.
  /// The initial value is false.
  _i2.bool get ungroupable => _i5.getProperty(
        this,
        'ungroupable',
      );
  /* #21979
  source: 
    /**
     * Gets or sets whether the user may ungroup this group.
     * The initial value is false.
     * @see #canUngroup
     */
    get ungroupable(): boolean; */
  // Type InteropStaticType.boolean
  set ungroupable(_i2.bool value) {
    _i5.setProperty(
      this,
      'ungroupable',
      value,
    );
  }

  /* #22066
  source: 
    /**
     * Gets or sets whether the subgraph contained by this group is expanded.
     * Changing this property's value will call #collapseSubGraph or #expandSubGraph,
     * and also will call the value of #subGraphExpandedChanged if it is a function.
     *
     * The initial value is true -- this group's member parts are shown.
     *
     * There is an analogous property for expanded/collapsed trees of Nodes and Links: Node#isTreeExpanded.
     */
    get isSubGraphExpanded(): boolean; */
  /// Gets or sets whether the subgraph contained by this group is expanded.
  /// Changing this property's value will call #collapseSubGraph or #expandSubGraph,
  /// and also will call the value of #subGraphExpandedChanged if it is a function.
  ///
  /// The initial value is true -- this group's member parts are shown.
  ///
  /// There is an analogous property for expanded/collapsed trees of Nodes and Links: Node#isTreeExpanded.
  _i2.bool get isSubGraphExpanded => _i5.getProperty(
        this,
        'isSubGraphExpanded',
      );
  /* #22066
  source: 
    /**
     * Gets or sets whether the subgraph contained by this group is expanded.
     * Changing this property's value will call #collapseSubGraph or #expandSubGraph,
     * and also will call the value of #subGraphExpandedChanged if it is a function.
     *
     * The initial value is true -- this group's member parts are shown.
     *
     * There is an analogous property for expanded/collapsed trees of Nodes and Links: Node#isTreeExpanded.
     */
    get isSubGraphExpanded(): boolean; */
  // Type InteropStaticType.boolean
  set isSubGraphExpanded(_i2.bool value) {
    _i5.setProperty(
      this,
      'isSubGraphExpanded',
      value,
    );
  }

  /* #22074
  source: 
    /**
     * Gets or sets whether the subgraph starting at this group
     * had been collapsed by a call to #expandSubGraph on the containing Group.
     * The initial value is false.
     * @see #isSubGraphExpanded
     */
    get wasSubGraphExpanded(): boolean; */
  /// Gets or sets whether the subgraph starting at this group
  /// had been collapsed by a call to #expandSubGraph on the containing Group.
  /// The initial value is false.
  _i2.bool get wasSubGraphExpanded => _i5.getProperty(
        this,
        'wasSubGraphExpanded',
      );
  /* #22074
  source: 
    /**
     * Gets or sets whether the subgraph starting at this group
     * had been collapsed by a call to #expandSubGraph on the containing Group.
     * The initial value is false.
     * @see #isSubGraphExpanded
     */
    get wasSubGraphExpanded(): boolean; */
  // Type InteropStaticType.boolean
  set wasSubGraphExpanded(_i2.bool value) {
    _i5.setProperty(
      this,
      'wasSubGraphExpanded',
      value,
    );
  }

  /* #22085
  source: 
    /**
     * Gets or sets the function that is called when #isSubGraphExpanded has changed value.
     * The argument to that function will be this Group.
     *
     * If the value is a function, that function must not expand or collapse any groups.
     * The Group has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get subGraphExpandedChanged(): ((thisGroup: Group) => void) | null; */
  /// Gets or sets the function that is called when #isSubGraphExpanded has changed value.
  /// The argument to that function will be this Group.
  ///
  /// If the value is a function, that function must not expand or collapse any groups.
  /// The Group has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(_i3.Group)? get subGraphExpandedChanged => _i5.getProperty(
        this,
        'subGraphExpandedChanged',
      );
  /* #22085
  source: 
    /**
     * Gets or sets the function that is called when #isSubGraphExpanded has changed value.
     * The argument to that function will be this Group.
     *
     * If the value is a function, that function must not expand or collapse any groups.
     * The Group has already been expanded or collapsed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get subGraphExpandedChanged(): ((thisGroup: Group) => void) | null; */
  // Type InteropUnion#90280007(parent: InteropGetter#53746585(name: subGraphExpandedChanged))
  set subGraphExpandedChanged(void Function(_i3.Group)? value) {
    _i5.setProperty(
      this,
      'subGraphExpandedChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  _i2.bool canAddMembers(_i3.Iterable<_i3.Part> coll) => _i5.callMethod(
        this,
        'canAddMembers',
        [coll],
      );
  _i2.bool addMembers(
    _i3.Iterable<_i3.Part> coll, [
    _i2.bool? check,
  ]) =>
      _i5.callMethod(
        this,
        'addMembers',
        [
          coll,
          check ?? _i4.undefined,
        ],
      );
  _i2.bool canUngroup() => _i5.callMethod(
        this,
        'canUngroup',
        [],
      );
  _i3.Iterator<_i3.Link> findExternalLinksConnected() => _i5.callMethod(
        this,
        'findExternalLinksConnected',
        [],
      );
  _i3.Iterator<_i3.Node> findExternalNodesConnected() => _i5.callMethod(
        this,
        'findExternalNodesConnected',
        [],
      );
  _i3.Set<_i3.Part> findSubGraphParts() => _i5.callMethod(
        this,
        'findSubGraphParts',
        [],
      );
  void collapseSubGraph() {
    _i5.callMethod(
      this,
      'collapseSubGraph',
      [],
    );
  }

  void expandSubGraph() {
    _i5.callMethod(
      this,
      'expandSubGraph',
      [],
    );
  }

  void move(
    _i3.Point newpos, [
    _i2.bool? useLocation,
  ]) {
    _i5.callMethod(
      this,
      'move',
      [
        newpos,
        useLocation ?? _i4.undefined,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Placeholder implements _i3.GraphObject {
  factory Placeholder([_i4.Partial? init]) => _i5.callConstructor(
        _declaredPlaceholder,
        [init ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Placeholder')
external _i2.Object _declaredPlaceholder;

extension Placeholder$Typings on Placeholder {
  /* #22144
  source: 
    /**
     * Gets or sets the padding around the members of the Group or around the Adornment#adornedObject GraphObject.
     * The initial value is a Margin of zero on all sides.
     */
    get padding(): MarginLike; */
  /// Gets or sets the padding around the members of the Group or around the Adornment#adornedObject GraphObject.
  /// The initial value is a Margin of zero on all sides.
  _i3.MarginLike get padding => _i5.getProperty(
        this,
        'padding',
      );
  /* #22144
  source: 
    /**
     * Gets or sets the padding around the members of the Group or around the Adornment#adornedObject GraphObject.
     * The initial value is a Margin of zero on all sides.
     */
    get padding(): MarginLike; */
  // Type InteropTypedef#88783230(name: MarginLike)
  set padding(_i3.MarginLike value) {
    _i5.setProperty(
      this,
      'padding',
      value,
    );
  }

  _i3.Rect computeBorder(_i3.Rect result) => _i5.callMethod(
        this,
        'computeBorder',
        [result],
      );
  _i3.Rect computeMemberBounds(_i3.Rect result) => _i5.callMethod(
        this,
        'computeMemberBounds',
        [result],
      );
}

@_i1.JS()
@_i1.staticInterop
class Link implements _i3.Part {
  factory Link([_i4.Partial? init]) => _i5.callConstructor(
        _declaredLink,
        [init ?? _i4.undefined],
      );

  /* #22309
  source: 
    /**
     * Used as the default value for Link#routing:
     * the route goes fairly straight between ports.
     * @constant
     */
    static Normal: EnumValue; */
  /// Used as the default value for Link#routing:
  /// the route goes fairly straight between ports.
  static _i3.EnumValue get normal => _i5.getProperty(
        _declaredLink,
        'Normal',
      );
  /* #22309
  source: 
    /**
     * Used as the default value for Link#routing:
     * the route goes fairly straight between ports.
     * @constant
     */
    static Normal: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set normal(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'Normal',
      value,
    );
  }

  /* #22315
  source: 
    /**
     * Used as a value for Link#routing:
     * each segment is horizontal or vertical.
     * @constant
     */
    static Orthogonal: EnumValue; */
  /// Used as a value for Link#routing:
  /// each segment is horizontal or vertical.
  static _i3.EnumValue get orthogonal => _i5.getProperty(
        _declaredLink,
        'Orthogonal',
      );
  /* #22315
  source: 
    /**
     * Used as a value for Link#routing:
     * each segment is horizontal or vertical.
     * @constant
     */
    static Orthogonal: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orthogonal(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'Orthogonal',
      value,
    );
  }

  /* #22321
  source: 
    /**
     * Used as a value for Link#routing:
     * each segment is horizontal or vertical, but the route tries to avoid crossing over nodes.
     * @constant
     */
    static AvoidsNodes: EnumValue; */
  /// Used as a value for Link#routing:
  /// each segment is horizontal or vertical, but the route tries to avoid crossing over nodes.
  static _i3.EnumValue get avoidsNodes => _i5.getProperty(
        _declaredLink,
        'AvoidsNodes',
      );
  /* #22321
  source: 
    /**
     * Used as a value for Link#routing:
     * each segment is horizontal or vertical, but the route tries to avoid crossing over nodes.
     * @constant
     */
    static AvoidsNodes: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set avoidsNodes(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'AvoidsNodes',
      value,
    );
  }

  /* #22330
  source: 
    /**
     * This is the default value for Link#curve and Link#adjusting,
     * to indicate that the path geometry consists of straight line segments and
     * to indicate that the link route computation does not depend on any previous route points;
     * this can also be used as a value for GraphObject#segmentOrientation
     * to indicate that the object is never rotated along the link route -- its angle is unchanged.
     * @constant
     */
    static None: EnumValue; */
  /// This is the default value for Link#curve and Link#adjusting,
  /// to indicate that the path geometry consists of straight line segments and
  /// to indicate that the link route computation does not depend on any previous route points;
  /// this can also be used as a value for GraphObject#segmentOrientation
  /// to indicate that the object is never rotated along the link route -- its angle is unchanged.
  static _i3.EnumValue get none => _i5.getProperty(
        _declaredLink,
        'None',
      );
  /* #22330
  source: 
    /**
     * This is the default value for Link#curve and Link#adjusting,
     * to indicate that the path geometry consists of straight line segments and
     * to indicate that the link route computation does not depend on any previous route points;
     * this can also be used as a value for GraphObject#segmentOrientation
     * to indicate that the object is never rotated along the link route -- its angle is unchanged.
     * @constant
     */
    static None: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set none(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'None',
      value,
    );
  }

  /* #22336
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * the link path uses Bezier curve segments.
     * @constant
     */
    static Bezier: EnumValue; */
  /// Used as a value for Link#curve, to indicate that
  /// the link path uses Bezier curve segments.
  static _i3.EnumValue get bezier => _i5.getProperty(
        _declaredLink,
        'Bezier',
      );
  /* #22336
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * the link path uses Bezier curve segments.
     * @constant
     */
    static Bezier: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set bezier(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'Bezier',
      value,
    );
  }

  /* #22343
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * orthogonal link segments will be discontinuous where they cross over
     * other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
     * @constant
     */
    static JumpGap: EnumValue; */
  /// Used as a value for Link#curve, to indicate that
  /// orthogonal link segments will be discontinuous where they cross over
  /// other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
  static _i3.EnumValue get jumpGap => _i5.getProperty(
        _declaredLink,
        'JumpGap',
      );
  /* #22343
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * orthogonal link segments will be discontinuous where they cross over
     * other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
     * @constant
     */
    static JumpGap: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set jumpGap(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'JumpGap',
      value,
    );
  }

  /* #22350
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * orthogonal link segments will veer around where they cross over
     * other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
     * @constant
     */
    static JumpOver: EnumValue; */
  /// Used as a value for Link#curve, to indicate that
  /// orthogonal link segments will veer around where they cross over
  /// other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
  static _i3.EnumValue get jumpOver => _i5.getProperty(
        _declaredLink,
        'JumpOver',
      );
  /* #22350
  source: 
    /**
     * Used as a value for Link#curve, to indicate that
     * orthogonal link segments will veer around where they cross over
     * other orthogonal link segments that have a Link#curve of JumpOver or JumpGap.
     * @constant
     */
    static JumpOver: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set jumpOver(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'JumpOver',
      value,
    );
  }

  /* #22358
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should keep the
     * intermediate points of the previous route, just modifying the first and/or last points;
     * if the routing is orthogonal, it will only modify the first two and/or last two points.
     * @constant
     */
    static End: EnumValue; */
  /// Used as a value for Link#adjusting,
  /// to indicate that the link route computation should keep the
  /// intermediate points of the previous route, just modifying the first and/or last points;
  /// if the routing is orthogonal, it will only modify the first two and/or last two points.
  static _i3.EnumValue get end => _i5.getProperty(
        _declaredLink,
        'End',
      );
  /* #22358
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should keep the
     * intermediate points of the previous route, just modifying the first and/or last points;
     * if the routing is orthogonal, it will only modify the first two and/or last two points.
     * @constant
     */
    static End: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set end(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'End',
      value,
    );
  }

  /* #22366
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should scale and rotate the intermediate points
     * so that the link's shape looks approximately the same;
     * if the routing is orthogonal, this value is treated as if it were Link.End.
     * @constant
     */
    static Scale: EnumValue; */
  /// Used as a value for Link#adjusting,
  /// to indicate that the link route computation should scale and rotate the intermediate points
  /// so that the link's shape looks approximately the same;
  /// if the routing is orthogonal, this value is treated as if it were Link.End.
  static _i3.EnumValue get scale => _i5.getProperty(
        _declaredLink,
        'Scale',
      );
  /* #22366
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should scale and rotate the intermediate points
     * so that the link's shape looks approximately the same;
     * if the routing is orthogonal, this value is treated as if it were Link.End.
     * @constant
     */
    static Scale: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set scale(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'Scale',
      value,
    );
  }

  /* #22374
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should linearly interpolate the intermediate points
     * so that the link's shape looks stretched;
     * if the routing is orthogonal, this value is treated as if it were Link.End.
     * @constant
     */
    static Stretch: EnumValue; */
  /// Used as a value for Link#adjusting,
  /// to indicate that the link route computation should linearly interpolate the intermediate points
  /// so that the link's shape looks stretched;
  /// if the routing is orthogonal, this value is treated as if it were Link.End.
  static _i3.EnumValue get stretch => _i5.getProperty(
        _declaredLink,
        'Stretch',
      );
  /* #22374
  source: 
    /**
     * Used as a value for Link#adjusting,
     * to indicate that the link route computation should linearly interpolate the intermediate points
     * so that the link's shape looks stretched;
     * if the routing is orthogonal, this value is treated as if it were Link.End.
     * @constant
     */
    static Stretch: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set stretch(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'Stretch',
      value,
    );
  }

  /* #22383
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned to have the same angle as the route:
     * the GraphObject's angle is always the same as the angle of the link's route
     * at the segment where the GraphObject is attached;
     * use this orientation for arrow heads.
     * @constant
     */
    static OrientAlong: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject turned to have the same angle as the route:
  /// the GraphObject's angle is always the same as the angle of the link's route
  /// at the segment where the GraphObject is attached;
  /// use this orientation for arrow heads.
  static _i3.EnumValue get orientAlong => _i5.getProperty(
        _declaredLink,
        'OrientAlong',
      );
  /* #22383
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned to have the same angle as the route:
     * the GraphObject's angle is always the same as the angle of the link's route
     * at the segment where the GraphObject is attached;
     * use this orientation for arrow heads.
     * @constant
     */
    static OrientAlong: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientAlong(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientAlong',
      value,
    );
  }

  /* #22391
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject is turned clockwise to be perpendicular to the route:
     * the GraphObject's angle is always 90 degrees more than the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientPlus90: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject is turned clockwise to be perpendicular to the route:
  /// the GraphObject's angle is always 90 degrees more than the angle of the link's route
  /// at the segment where the GraphObject is attached.
  static _i3.EnumValue get orientPlus90 => _i5.getProperty(
        _declaredLink,
        'OrientPlus90',
      );
  /* #22391
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject is turned clockwise to be perpendicular to the route:
     * the GraphObject's angle is always 90 degrees more than the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientPlus90: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientPlus90(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientPlus90',
      value,
    );
  }

  /* #22399
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject being turned counter-clockwise to be perpendicular to the route:
     * the GraphObject's angle is always 90 degrees less than the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientMinus90: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject being turned counter-clockwise to be perpendicular to the route:
  /// the GraphObject's angle is always 90 degrees less than the angle of the link's route
  /// at the segment where the GraphObject is attached.
  static _i3.EnumValue get orientMinus90 => _i5.getProperty(
        _declaredLink,
        'OrientMinus90',
      );
  /* #22399
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject being turned counter-clockwise to be perpendicular to the route:
     * the GraphObject's angle is always 90 degrees less than the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientMinus90: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientMinus90(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientMinus90',
      value,
    );
  }

  /* #22406
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject's angle always being 180 degrees opposite from the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientOpposite: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject's angle always being 180 degrees opposite from the angle of the link's route
  /// at the segment where the GraphObject is attached.
  static _i3.EnumValue get orientOpposite => _i5.getProperty(
        _declaredLink,
        'OrientOpposite',
      );
  /* #22406
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject's angle always being 180 degrees opposite from the angle of the link's route
     * at the segment where the GraphObject is attached.
     * @constant
     */
    static OrientOpposite: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientOpposite(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientOpposite',
      value,
    );
  }

  /* #22415
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned to have the same angle as the route, just like Link.OrientAlong, but is never upside down:
     * the GraphObject's angle always following the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientUpright: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject turned to have the same angle as the route, just like Link.OrientAlong, but is never upside down:
  /// the GraphObject's angle always following the angle of the link's route
  /// at the segment where the GraphObject is attached;
  /// this is typically only used for TextBlocks or Panels that contain text.
  static _i3.EnumValue get orientUpright => _i5.getProperty(
        _declaredLink,
        'OrientUpright',
      );
  /* #22415
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned to have the same angle as the route, just like Link.OrientAlong, but is never upside down:
     * the GraphObject's angle always following the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientUpright: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientUpright(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientUpright',
      value,
    );
  }

  /* #22424
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned clockwise to be perpendicular to the route, just like Link.OrientPlus90, but is never upside down:
     * the GraphObject's angle always being 90 degrees more than the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientPlus90Upright: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject turned clockwise to be perpendicular to the route, just like Link.OrientPlus90, but is never upside down:
  /// the GraphObject's angle always being 90 degrees more than the angle of the link's route
  /// at the segment where the GraphObject is attached;
  /// this is typically only used for TextBlocks or Panels that contain text.
  static _i3.EnumValue get orientPlus90Upright => _i5.getProperty(
        _declaredLink,
        'OrientPlus90Upright',
      );
  /* #22424
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned clockwise to be perpendicular to the route, just like Link.OrientPlus90, but is never upside down:
     * the GraphObject's angle always being 90 degrees more than the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientPlus90Upright: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientPlus90Upright(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientPlus90Upright',
      value,
    );
  }

  /* #22433
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned counter-clockwise to be perpendicular to the route, just like Link.OrientMinus90, but is never upside down:
     * the GraphObject's angle always being 90 degrees less than the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientMinus90Upright: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject turned counter-clockwise to be perpendicular to the route, just like Link.OrientMinus90, but is never upside down:
  /// the GraphObject's angle always being 90 degrees less than the angle of the link's route
  /// at the segment where the GraphObject is attached;
  /// this is typically only used for TextBlocks or Panels that contain text.
  static _i3.EnumValue get orientMinus90Upright => _i5.getProperty(
        _declaredLink,
        'OrientMinus90Upright',
      );
  /* #22433
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject turned counter-clockwise to be perpendicular to the route, just like Link.OrientMinus90, but is never upside down:
     * the GraphObject's angle always being 90 degrees less than the angle of the link's route
     * at the segment where the GraphObject is attached;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientMinus90Upright: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientMinus90Upright(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientMinus90Upright',
      value,
    );
  }

  /* #22444
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject's angle always following the angle of the link's route
     * at the segment where the GraphObject is attached, but never upside down
     * and never angled more than +/- 45 degrees:
     * when the route's angle is within 45 degrees of vertical (90 or 270 degrees),
     * the GraphObject's angle is set to zero;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientUpright45: EnumValue; */
  /// This value for GraphObject#segmentOrientation results in
  /// the GraphObject's angle always following the angle of the link's route
  /// at the segment where the GraphObject is attached, but never upside down
  /// and never angled more than +/- 45 degrees:
  /// when the route's angle is within 45 degrees of vertical (90 or 270 degrees),
  /// the GraphObject's angle is set to zero;
  /// this is typically only used for TextBlocks or Panels that contain text.
  static _i3.EnumValue get orientUpright45 => _i5.getProperty(
        _declaredLink,
        'OrientUpright45',
      );
  /* #22444
  source: 
    /**
     * This value for GraphObject#segmentOrientation results in
     * the GraphObject's angle always following the angle of the link's route
     * at the segment where the GraphObject is attached, but never upside down
     * and never angled more than +/- 45 degrees:
     * when the route's angle is within 45 degrees of vertical (90 or 270 degrees),
     * the GraphObject's angle is set to zero;
     * this is typically only used for TextBlocks or Panels that contain text.
     * @constant
     */
    static OrientUpright45: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set orientUpright45(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLink,
      'OrientUpright45',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('Link')
external _i2.Object _declaredLink;

extension Link$Typings on Link {
  /* #22452
  source: 
    /**
     * Gets or sets the Node that this link comes from.
     * The #fromPortId specifies which port the link comes from.
     * The default value is null -- this link is not coming from any node.
     *
     * A template should not be connected with any node.
     */
    get fromNode(): Node | null; */
  /// Gets or sets the Node that this link comes from.
  /// The #fromPortId specifies which port the link comes from.
  /// The default value is null -- this link is not coming from any node.
  ///
  /// A template should not be connected with any node.
  _i3.Node? get fromNode => _i5.getProperty(
        this,
        'fromNode',
      );
  /* #22452
  source: 
    /**
     * Gets or sets the Node that this link comes from.
     * The #fromPortId specifies which port the link comes from.
     * The default value is null -- this link is not coming from any node.
     *
     * A template should not be connected with any node.
     */
    get fromNode(): Node | null; */
  // Type InteropUnion#474022(parent: InteropGetter#857142479(name: fromNode))
  set fromNode(_i3.Node? value) {
    _i5.setProperty(
      this,
      'fromNode',
      value ?? _i4.undefined,
    );
  }

  /* #22458
  source: 
    /**
     * Gets or sets the identifier of the port that this link comes from.
     * The default value is the empty string.
     */
    get fromPortId(): string; */
  /// Gets or sets the identifier of the port that this link comes from.
  /// The default value is the empty string.
  _i2.String get fromPortId => _i5.getProperty(
        this,
        'fromPortId',
      );
  /* #22458
  source: 
    /**
     * Gets or sets the identifier of the port that this link comes from.
     * The default value is the empty string.
     */
    get fromPortId(): string; */
  // Type InteropStaticType.string
  set fromPortId(_i2.String value) {
    _i5.setProperty(
      this,
      'fromPortId',
      value,
    );
  }

  /* #22467
  source: 
    /**
     * This read-only property returns a GraphObject that is the "from" port that this link is connected from.
     * The #fromNode provides the node that the link is coming from.
     * The #fromPortId provides the identifier for which port this link is coming from;
     * you can set that property in order to change the value of this property.
     * This method may return null.
     */
    get fromPort(): GraphObject | null; */
  /// This read-only property returns a GraphObject that is the "from" port that this link is connected from.
  /// The #fromNode provides the node that the link is coming from.
  /// The #fromPortId provides the identifier for which port this link is coming from;
  /// you can set that property in order to change the value of this property.
  /// This method may return null.
  _i3.GraphObject? get fromPort => _i5.getProperty(
        this,
        'fromPort',
      );
  /* #22467
  source: 
    /**
     * This read-only property returns a GraphObject that is the "from" port that this link is connected from.
     * The #fromNode provides the node that the link is coming from.
     * The #fromPortId provides the identifier for which port this link is coming from;
     * you can set that property in order to change the value of this property.
     * This method may return null.
     */
    get fromPort(): GraphObject | null; */
  // Type InteropUnion#862136285(parent: InteropGetter#868102306(name: fromPort))
  set fromPort(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'fromPort',
      value ?? _i4.undefined,
    );
  }

  /* #22479
  source: 
    /**
     * Gets or sets the function that is called after this Link changes which Node or port it connects from.
     * The first argument will be this Link.
     * The second argument will be the old GraphObject port.
     * The third argument will be the new GraphObject port.
     *
     * If the value is a function, that function must not modify which nodes or links this link connects with.
     * The "from" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get fromPortChanged(): ((thisLink: Link, oldPort: GraphObject | null, newPort: GraphObject | null) => void) | null; */
  /// Gets or sets the function that is called after this Link changes which Node or port it connects from.
  /// The first argument will be this Link.
  /// The second argument will be the old GraphObject port.
  /// The third argument will be the new GraphObject port.
  ///
  /// If the value is a function, that function must not modify which nodes or links this link connects with.
  /// The "from" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Link,
    _i3.GraphObject?,
    _i3.GraphObject?,
  )? get fromPortChanged => _i5.getProperty(
        this,
        'fromPortChanged',
      );
  /* #22479
  source: 
    /**
     * Gets or sets the function that is called after this Link changes which Node or port it connects from.
     * The first argument will be this Link.
     * The second argument will be the old GraphObject port.
     * The third argument will be the new GraphObject port.
     *
     * If the value is a function, that function must not modify which nodes or links this link connects with.
     * The "from" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get fromPortChanged(): ((thisLink: Link, oldPort: GraphObject | null, newPort: GraphObject | null) => void) | null; */
  // Type InteropUnion#322659706(parent: InteropGetter#741303307(name: fromPortChanged))
  set fromPortChanged(
      void Function(
        _i3.Link,
        _i3.GraphObject?,
        _i3.GraphObject?,
      )? value) {
    _i5.setProperty(
      this,
      'fromPortChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #22488
  source: 
    /**
     * Gets or sets the Node that this link goes to.
     * The #toPortId specifies which port the link goes to.
     * The default value is null -- this link is not going to any node.
     *
     * A template should not be connected with any node.
     */
    get toNode(): Node | null; */
  /// Gets or sets the Node that this link goes to.
  /// The #toPortId specifies which port the link goes to.
  /// The default value is null -- this link is not going to any node.
  ///
  /// A template should not be connected with any node.
  _i3.Node? get toNode => _i5.getProperty(
        this,
        'toNode',
      );
  /* #22488
  source: 
    /**
     * Gets or sets the Node that this link goes to.
     * The #toPortId specifies which port the link goes to.
     * The default value is null -- this link is not going to any node.
     *
     * A template should not be connected with any node.
     */
    get toNode(): Node | null; */
  // Type InteropUnion#139897042(parent: InteropGetter#938876855(name: toNode))
  set toNode(_i3.Node? value) {
    _i5.setProperty(
      this,
      'toNode',
      value ?? _i4.undefined,
    );
  }

  /* #22494
  source: 
    /**
     * Gets or sets the identifier of the port that this link goes to.
     * The default value is the empty string.
     */
    get toPortId(): string; */
  /// Gets or sets the identifier of the port that this link goes to.
  /// The default value is the empty string.
  _i2.String get toPortId => _i5.getProperty(
        this,
        'toPortId',
      );
  /* #22494
  source: 
    /**
     * Gets or sets the identifier of the port that this link goes to.
     * The default value is the empty string.
     */
    get toPortId(): string; */
  // Type InteropStaticType.string
  set toPortId(_i2.String value) {
    _i5.setProperty(
      this,
      'toPortId',
      value,
    );
  }

  /* #22503
  source: 
    /**
     * This read-only property returns a GraphObject that is the "to" port that this link is connected to.
     * The #toNode provides the node that the link is going to.
     * The #toPortId provides the identifier for which port this link is going to;
     * you can set that property in order to change the value of this property.
     * This method may return null.
     */
    get toPort(): GraphObject | null; */
  /// This read-only property returns a GraphObject that is the "to" port that this link is connected to.
  /// The #toNode provides the node that the link is going to.
  /// The #toPortId provides the identifier for which port this link is going to;
  /// you can set that property in order to change the value of this property.
  /// This method may return null.
  _i3.GraphObject? get toPort => _i5.getProperty(
        this,
        'toPort',
      );
  /* #22503
  source: 
    /**
     * This read-only property returns a GraphObject that is the "to" port that this link is connected to.
     * The #toNode provides the node that the link is going to.
     * The #toPortId provides the identifier for which port this link is going to;
     * you can set that property in order to change the value of this property.
     * This method may return null.
     */
    get toPort(): GraphObject | null; */
  // Type InteropUnion#870547951(parent: InteropGetter#467715645(name: toPort))
  set toPort(_i3.GraphObject? value) {
    _i5.setProperty(
      this,
      'toPort',
      value ?? _i4.undefined,
    );
  }

  /* #22515
  source: 
    /**
     * Gets or sets the function that is called after this Link changes which Node or port it connects to.
     * The first argument will be this Link.
     * The second argument will be the old GraphObject port.
     * The third argument will be the new GraphObject port.
     *
     * If the value is a function, that function must not modify which nodes or links this link connects with.
     * The "to" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get toPortChanged(): ((thisLink: Link, oldPort: GraphObject | null, newPort: GraphObject) => void) | null; */
  /// Gets or sets the function that is called after this Link changes which Node or port it connects to.
  /// The first argument will be this Link.
  /// The second argument will be the old GraphObject port.
  /// The third argument will be the new GraphObject port.
  ///
  /// If the value is a function, that function must not modify which nodes or links this link connects with.
  /// The "to" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
  ///
  /// The default value is null -- no function is called.
  void Function(
    _i3.Link,
    _i3.GraphObject?,
    _i3.GraphObject,
  )? get toPortChanged => _i5.getProperty(
        this,
        'toPortChanged',
      );
  /* #22515
  source: 
    /**
     * Gets or sets the function that is called after this Link changes which Node or port it connects to.
     * The first argument will be this Link.
     * The second argument will be the old GraphObject port.
     * The third argument will be the new GraphObject port.
     *
     * If the value is a function, that function must not modify which nodes or links this link connects with.
     * The "to" node and/or port has already been changed -- trying to change it again may produce undefined behavior.
     *
     * The default value is null -- no function is called.
     */
    get toPortChanged(): ((thisLink: Link, oldPort: GraphObject | null, newPort: GraphObject) => void) | null; */
  // Type InteropUnion#648120684(parent: InteropGetter#78625088(name: toPortChanged))
  set toPortChanged(
      void Function(
        _i3.Link,
        _i3.GraphObject?,
        _i3.GraphObject,
      )? value) {
    _i5.setProperty(
      this,
      'toPortChanged',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #22531
  source: 
    /**
     * Gets or sets where this link should connect at the #fromPort.
     * The default value is Spot.Default, meaning that the value
     * actually comes from the GraphObject#fromSpot property of the #fromPort.
     *
     * This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
     * LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
     * TreeLayout#setsChildPortSpot is true.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #toSpot
     * @see GraphObject#fromSpot
     * @see #computeSpot
     */
    get fromSpot(): Spot; */
  /// Gets or sets where this link should connect at the #fromPort.
  /// The default value is Spot.Default, meaning that the value
  /// actually comes from the GraphObject#fromSpot property of the #fromPort.
  ///
  /// This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
  /// LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
  /// TreeLayout#setsChildPortSpot is true.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  _i3.Spot get fromSpot => _i5.getProperty(
        this,
        'fromSpot',
      );
  /* #22531
  source: 
    /**
     * Gets or sets where this link should connect at the #fromPort.
     * The default value is Spot.Default, meaning that the value
     * actually comes from the GraphObject#fromSpot property of the #fromPort.
     *
     * This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
     * LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
     * TreeLayout#setsChildPortSpot is true.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #toSpot
     * @see GraphObject#fromSpot
     * @see #computeSpot
     */
    get fromSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set fromSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'fromSpot',
      value,
    );
  }

  /* #22545
  source: 
    /**
     * Gets or sets the length of the first segment, when the computed "from spot" at the #fromPort is not Spot.None.
     * The default value is NaN, meaning that the value
     * actually comes from the GraphObject#fromEndSegmentLength property of the #fromPort.
     * This value also limits how short the #fromShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #toEndSegmentLength
     * @see #computeEndSegmentLength
     * @see GraphObject#fromEndSegmentLength
     * @see #fromShortLength
     */
    get fromEndSegmentLength(): number; */
  /// Gets or sets the length of the first segment, when the computed "from spot" at the #fromPort is not Spot.None.
  /// The default value is NaN, meaning that the value
  /// actually comes from the GraphObject#fromEndSegmentLength property of the #fromPort.
  /// This value also limits how short the #fromShortLength may be drawn.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  _i2.num get fromEndSegmentLength => _i5.getProperty(
        this,
        'fromEndSegmentLength',
      );
  /* #22545
  source: 
    /**
     * Gets or sets the length of the first segment, when the computed "from spot" at the #fromPort is not Spot.None.
     * The default value is NaN, meaning that the value
     * actually comes from the GraphObject#fromEndSegmentLength property of the #fromPort.
     * This value also limits how short the #fromShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #toEndSegmentLength
     * @see #computeEndSegmentLength
     * @see GraphObject#fromEndSegmentLength
     * @see #fromShortLength
     */
    get fromEndSegmentLength(): number; */
  // Type InteropStaticType.number
  set fromEndSegmentLength(_i2.num value) {
    _i5.setProperty(
      this,
      'fromEndSegmentLength',
      value,
    );
  }

  /* #22561
  source: 
    /**
     * Gets or sets how far the end segment stops short of the actual port.
     * Positive values are limited by the #fromEndSegmentLength or GraphObject#fromEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is NaN -- the value actually comes from the
     * GraphObject#fromShortLength property of the #fromPort.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * If you want to move an arrowhead away from the start of the link route,
     * set the arrowhead Shape's GraphObject#segmentOffset.
     * @see #toShortLength
     * @see GraphObject#fromShortLength
     * @see #fromEndSegmentLength
     */
    get fromShortLength(): number; */
  /// Gets or sets how far the end segment stops short of the actual port.
  /// Positive values are limited by the #fromEndSegmentLength or GraphObject#fromEndSegmentLength.
  /// Negative values cause the link to extend into the port.
  /// The default value is NaN -- the value actually comes from the
  /// GraphObject#fromShortLength property of the #fromPort.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  /// If you want to move an arrowhead away from the start of the link route,
  /// set the arrowhead Shape's GraphObject#segmentOffset.
  _i2.num get fromShortLength => _i5.getProperty(
        this,
        'fromShortLength',
      );
  /* #22561
  source: 
    /**
     * Gets or sets how far the end segment stops short of the actual port.
     * Positive values are limited by the #fromEndSegmentLength or GraphObject#fromEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is NaN -- the value actually comes from the
     * GraphObject#fromShortLength property of the #fromPort.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * If you want to move an arrowhead away from the start of the link route,
     * set the arrowhead Shape's GraphObject#segmentOffset.
     * @see #toShortLength
     * @see GraphObject#fromShortLength
     * @see #fromEndSegmentLength
     */
    get fromShortLength(): number; */
  // Type InteropStaticType.number
  set fromShortLength(_i2.num value) {
    _i5.setProperty(
      this,
      'fromShortLength',
      value,
    );
  }

  /* #22577
  source: 
    /**
     * Gets or sets where this link should connect at the #toPort.
     * The default value is Spot.Default, meaning that the value
     * actually comes from the GraphObject#toSpot property of the #toPort.
     *
     * This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
     * LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
     * TreeLayout#setsChildPortSpot is true.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #fromSpot
     * @see GraphObject#toSpot
     * @see #computeSpot
     */
    get toSpot(): Spot; */
  /// Gets or sets where this link should connect at the #toPort.
  /// The default value is Spot.Default, meaning that the value
  /// actually comes from the GraphObject#toSpot property of the #toPort.
  ///
  /// This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
  /// LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
  /// TreeLayout#setsChildPortSpot is true.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  _i3.Spot get toSpot => _i5.getProperty(
        this,
        'toSpot',
      );
  /* #22577
  source: 
    /**
     * Gets or sets where this link should connect at the #toPort.
     * The default value is Spot.Default, meaning that the value
     * actually comes from the GraphObject#toSpot property of the #toPort.
     *
     * This property is set by some layouts, if ForceDirectedLayout#setsPortSpots or
     * LayeredDigraphLayout#setsPortSpots or TreeLayout#setsPortSpot or
     * TreeLayout#setsChildPortSpot is true.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #fromSpot
     * @see GraphObject#toSpot
     * @see #computeSpot
     */
    get toSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set toSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'toSpot',
      value,
    );
  }

  /* #22591
  source: 
    /**
     * Gets or sets the length of the last segment.
     * The default value is NaN, meaning that the value
     * actually comes from the GraphObject#toEndSegmentLength property of the #toPort.
     * This value also limits how short the #toShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #fromEndSegmentLength
     * @see #computeEndSegmentLength
     * @see GraphObject#toEndSegmentLength
     * @see #toShortLength
     */
    get toEndSegmentLength(): number; */
  /// Gets or sets the length of the last segment.
  /// The default value is NaN, meaning that the value
  /// actually comes from the GraphObject#toEndSegmentLength property of the #toPort.
  /// This value also limits how short the #toShortLength may be drawn.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  _i2.num get toEndSegmentLength => _i5.getProperty(
        this,
        'toEndSegmentLength',
      );
  /* #22591
  source: 
    /**
     * Gets or sets the length of the last segment.
     * The default value is NaN, meaning that the value
     * actually comes from the GraphObject#toEndSegmentLength property of the #toPort.
     * This value also limits how short the #toShortLength may be drawn.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * @see #fromEndSegmentLength
     * @see #computeEndSegmentLength
     * @see GraphObject#toEndSegmentLength
     * @see #toShortLength
     */
    get toEndSegmentLength(): number; */
  // Type InteropStaticType.number
  set toEndSegmentLength(_i2.num value) {
    _i5.setProperty(
      this,
      'toEndSegmentLength',
      value,
    );
  }

  /* #22607
  source: 
    /**
     * Gets or sets how far the end segment stops short of the actual port.
     * Positive values are limited by the #toEndSegmentLength or GraphObject#toEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is NaN -- the value actually comes from the
     * GraphObject#toShortLength property of the #toPort.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * If you want to move an arrowhead away from the end of the link route,
     * set the arrowhead Shape's GraphObject#segmentOffset.
     * @see #fromShortLength
     * @see GraphObject#toShortLength
     * @see #toEndSegmentLength
     */
    get toShortLength(): number; */
  /// Gets or sets how far the end segment stops short of the actual port.
  /// Positive values are limited by the #toEndSegmentLength or GraphObject#toEndSegmentLength.
  /// Negative values cause the link to extend into the port.
  /// The default value is NaN -- the value actually comes from the
  /// GraphObject#toShortLength property of the #toPort.
  ///
  /// For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
  /// If you want to move an arrowhead away from the end of the link route,
  /// set the arrowhead Shape's GraphObject#segmentOffset.
  _i2.num get toShortLength => _i5.getProperty(
        this,
        'toShortLength',
      );
  /* #22607
  source: 
    /**
     * Gets or sets how far the end segment stops short of the actual port.
     * Positive values are limited by the #toEndSegmentLength or GraphObject#toEndSegmentLength.
     * Negative values cause the link to extend into the port.
     * The default value is NaN -- the value actually comes from the
     * GraphObject#toShortLength property of the #toPort.
     *
     * For examples of how to use this property, see <a href="../../intro/connectionPoints.html">Link Connection Points</a>.
     * If you want to move an arrowhead away from the end of the link route,
     * set the arrowhead Shape's GraphObject#segmentOffset.
     * @see #fromShortLength
     * @see GraphObject#toShortLength
     * @see #toEndSegmentLength
     */
    get toShortLength(): number; */
  // Type InteropStaticType.number
  set toShortLength(_i2.num value) {
    _i5.setProperty(
      this,
      'toShortLength',
      value,
    );
  }

  /* #22627
  source: 
    /**
     * This read-only property is true when this Link has any label Nodes, Nodes that are owned by this Link
     * and are arranged along its path in the same manner as elements of the Link Panel.
     * @see #labelNodes
     * @since 1.1
     */
    get isLabeledLink(): boolean; */
  /// This read-only property is true when this Link has any label Nodes, Nodes that are owned by this Link
  /// and are arranged along its path in the same manner as elements of the Link Panel.
  _i2.bool get isLabeledLink => _i5.getProperty(
        this,
        'isLabeledLink',
      );
  /* #22627
  source: 
    /**
     * This read-only property is true when this Link has any label Nodes, Nodes that are owned by this Link
     * and are arranged along its path in the same manner as elements of the Link Panel.
     * @see #labelNodes
     * @since 1.1
     */
    get isLabeledLink(): boolean; */
  // Type InteropStaticType.boolean
  set isLabeledLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'isLabeledLink',
      value,
    );
  }

  /* #22642
  source: 
    /**
     * This read-only property returns an iterator over the Nodes that act as labels on this Link.
     * Setting Node#labeledLink to refer to this Link
     * will add that Node to this collection.
     *
     * Do not confuse these Nodes with the GraphObjects that
     * are part of this Link Panel.
     * Those objects can also be used as "labels", but not as objects to which
     * there can be link connections, because those panel elements cannot be Nodes.
     * Those panel objects can be used for other purposes too, such as arrowheads.
     *
     * A template should not have any label nodes.
     * @see #isLabeledLink
     */
    get labelNodes(): Iterator<Node>; */
  /// This read-only property returns an iterator over the Nodes that act as labels on this Link.
  /// Setting Node#labeledLink to refer to this Link
  /// will add that Node to this collection.
  ///
  /// Do not confuse these Nodes with the GraphObjects that
  /// are part of this Link Panel.
  /// Those objects can also be used as "labels", but not as objects to which
  /// there can be link connections, because those panel elements cannot be Nodes.
  /// Those panel objects can be used for other purposes too, such as arrowheads.
  ///
  /// A template should not have any label nodes.
  _i3.Iterator<_i3.Node> get labelNodes => _i5.getProperty(
        this,
        'labelNodes',
      );
  /* #22642
  source: 
    /**
     * This read-only property returns an iterator over the Nodes that act as labels on this Link.
     * Setting Node#labeledLink to refer to this Link
     * will add that Node to this collection.
     *
     * Do not confuse these Nodes with the GraphObjects that
     * are part of this Link Panel.
     * Those objects can also be used as "labels", but not as objects to which
     * there can be link connections, because those panel elements cannot be Nodes.
     * Those panel objects can be used for other purposes too, such as arrowheads.
     *
     * A template should not have any label nodes.
     * @see #isLabeledLink
     */
    get labelNodes(): Iterator<Node>; */
  // Type Instance of 'InteropInterface'
  set labelNodes(_i3.Iterator<_i3.Node> value) {
    _i5.setProperty(
      this,
      'labelNodes',
      value,
    );
  }

  /* #22657
  source: 
    /**
     * Gets or sets whether the user may reconnect an existing link at the "from" end.
     * This affects the behavior of the RelinkingTool.
     *
     * The initial value is false.
     */
    get relinkableFrom(): boolean; */
  /// Gets or sets whether the user may reconnect an existing link at the "from" end.
  /// This affects the behavior of the RelinkingTool.
  ///
  /// The initial value is false.
  _i2.bool get relinkableFrom => _i5.getProperty(
        this,
        'relinkableFrom',
      );
  /* #22657
  source: 
    /**
     * Gets or sets whether the user may reconnect an existing link at the "from" end.
     * This affects the behavior of the RelinkingTool.
     *
     * The initial value is false.
     */
    get relinkableFrom(): boolean; */
  // Type InteropStaticType.boolean
  set relinkableFrom(_i2.bool value) {
    _i5.setProperty(
      this,
      'relinkableFrom',
      value,
    );
  }

  /* #22665
  source: 
    /**
     * Gets or sets whether the user may reconnect an existing link at the "to" end.
     * This affects the behavior of the RelinkingTool.
     *
     * The initial value is false.
     */
    get relinkableTo(): boolean; */
  /// Gets or sets whether the user may reconnect an existing link at the "to" end.
  /// This affects the behavior of the RelinkingTool.
  ///
  /// The initial value is false.
  _i2.bool get relinkableTo => _i5.getProperty(
        this,
        'relinkableTo',
      );
  /* #22665
  source: 
    /**
     * Gets or sets whether the user may reconnect an existing link at the "to" end.
     * This affects the behavior of the RelinkingTool.
     *
     * The initial value is false.
     */
    get relinkableTo(): boolean; */
  // Type InteropStaticType.boolean
  set relinkableTo(_i2.bool value) {
    _i5.setProperty(
      this,
      'relinkableTo',
      value,
    );
  }

  /* #22697
  source: 
    /**
     * Gets or sets whether the user may change the number of segments in this Link,
     * if the link has straight segments.
     * This affects the behavior of the LinkReshapingTool when #curve is not Link.Bezier.
     *
     * The initial value is false.
     * @since 1.2
     */
    get resegmentable(): boolean; */
  /// Gets or sets whether the user may change the number of segments in this Link,
  /// if the link has straight segments.
  /// This affects the behavior of the LinkReshapingTool when #curve is not Link.Bezier.
  ///
  /// The initial value is false.
  _i2.bool get resegmentable => _i5.getProperty(
        this,
        'resegmentable',
      );
  /* #22697
  source: 
    /**
     * Gets or sets whether the user may change the number of segments in this Link,
     * if the link has straight segments.
     * This affects the behavior of the LinkReshapingTool when #curve is not Link.Bezier.
     *
     * The initial value is false.
     * @since 1.2
     */
    get resegmentable(): boolean; */
  // Type InteropStaticType.boolean
  set resegmentable(_i2.bool value) {
    _i5.setProperty(
      this,
      'resegmentable',
      value,
    );
  }

  /* #22706
  source: 
    /**
     * Gets or sets whether this Link is part of the tree for tree operations
     * such as Node#findTreeChildrenNodes or Node#collapseTree.
     *
     * The initial value is true.
     * @since 1.2
     */
    get isTreeLink(): boolean; */
  /// Gets or sets whether this Link is part of the tree for tree operations
  /// such as Node#findTreeChildrenNodes or Node#collapseTree.
  ///
  /// The initial value is true.
  _i2.bool get isTreeLink => _i5.getProperty(
        this,
        'isTreeLink',
      );
  /* #22706
  source: 
    /**
     * Gets or sets whether this Link is part of the tree for tree operations
     * such as Node#findTreeChildrenNodes or Node#collapseTree.
     *
     * The initial value is true.
     * @since 1.2
     */
    get isTreeLink(): boolean; */
  // Type InteropStaticType.boolean
  set isTreeLink(_i2.bool value) {
    _i5.setProperty(
      this,
      'isTreeLink',
      value,
    );
  }

  /* #22724
  source: 
    /**
     * This read-only property returns the main Shape representing the path of this Link.
     *
     * The value depends on there being an element in this Link that is
     * a Shape and that has GraphObject#isPanelMain set to true.
     * This shape is what displays the stroke going from one node to another node.
     *
     * This path shape's geometry is automatically generated based on the #points
     * of this link's route, depending on other properties such as #curve.
     * Note that the points are in document coordinates, but the path's Shape#geometry
     * will have points that are in local Shape coordinates.
     * This Shape's GraphObject#scale should be one and GraphObject#angle should be zero.
     *
     * If there is no Shape with GraphObject#isPanelMain set to true,
     * the Link will use the first Shape for its path.
     */
    get path(): Shape | null; */
  /// This read-only property returns the main Shape representing the path of this Link.
  ///
  /// The value depends on there being an element in this Link that is
  /// a Shape and that has GraphObject#isPanelMain set to true.
  /// This shape is what displays the stroke going from one node to another node.
  ///
  /// This path shape's geometry is automatically generated based on the #points
  /// of this link's route, depending on other properties such as #curve.
  /// Note that the points are in document coordinates, but the path's Shape#geometry
  /// will have points that are in local Shape coordinates.
  /// This Shape's GraphObject#scale should be one and GraphObject#angle should be zero.
  ///
  /// If there is no Shape with GraphObject#isPanelMain set to true,
  /// the Link will use the first Shape for its path.
  _i3.Shape? get path => _i5.getProperty(
        this,
        'path',
      );
  /* #22724
  source: 
    /**
     * This read-only property returns the main Shape representing the path of this Link.
     *
     * The value depends on there being an element in this Link that is
     * a Shape and that has GraphObject#isPanelMain set to true.
     * This shape is what displays the stroke going from one node to another node.
     *
     * This path shape's geometry is automatically generated based on the #points
     * of this link's route, depending on other properties such as #curve.
     * Note that the points are in document coordinates, but the path's Shape#geometry
     * will have points that are in local Shape coordinates.
     * This Shape's GraphObject#scale should be one and GraphObject#angle should be zero.
     *
     * If there is no Shape with GraphObject#isPanelMain set to true,
     * the Link will use the first Shape for its path.
     */
    get path(): Shape | null; */
  // Type InteropUnion#397875400(parent: InteropGetter#325217368(name: path))
  set path(_i3.Shape? value) {
    _i5.setProperty(
      this,
      'path',
      value ?? _i4.undefined,
    );
  }

  /* #22729
  source: 
    /**
     * This read-only property returns the bounds of the link geometry in document coordinates.
     * @since 2.2
     */
    get routeBounds(): Rect; */
  /// This read-only property returns the bounds of the link geometry in document coordinates.
  _i3.Rect get routeBounds => _i5.getProperty(
        this,
        'routeBounds',
      );
  /* #22729
  source: 
    /**
     * This read-only property returns the bounds of the link geometry in document coordinates.
     * @since 2.2
     */
    get routeBounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set routeBounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'routeBounds',
      value,
    );
  }

  /* #22733
  source: 
    /**
     * This read-only property returns the point at the middle of the path, in document coordinates.
     */
    get midPoint(): Point; */
  /// This read-only property returns the point at the middle of the path, in document coordinates.
  _i3.Point get midPoint => _i5.getProperty(
        this,
        'midPoint',
      );
  /* #22733
  source: 
    /**
     * This read-only property returns the point at the middle of the path, in document coordinates.
     */
    get midPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set midPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'midPoint',
      value,
    );
  }

  /* #22737
  source: 
    /**
     * This read-only property returns the angle of the path at the #midPoint.
     */
    get midAngle(): number; */
  /// This read-only property returns the angle of the path at the #midPoint.
  _i2.num get midAngle => _i5.getProperty(
        this,
        'midAngle',
      );
  /* #22737
  source: 
    /**
     * This read-only property returns the angle of the path at the #midPoint.
     */
    get midAngle(): number; */
  // Type InteropStaticType.number
  set midAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'midAngle',
      value,
    );
  }

  /* #22752
  source: 
    /**
     * Gets or sets the List of Points in the route.
     * All of the Points must be Point#isReal -- no NaN or infinite values --
     * and all of the points are in document coordinates.
     * Although this list may be replaced by setting this property,
     * one must not modify the contents of the List directly.
     *
     * The setter also accepts an Array of alternating X,Y point values [1, 2, 3, 4, 5, 6],
     * or an Array of Objects each of which has (lowercase) 'x' and 'y' properties that are numbers
     * [{"x":1,"y":2}, {"x":3,"y":4}, {"x":5,"y":6}].
     *
     * Ownership of the List and all of its Points that is provided to the setter
     * is transferred to this Link.
     */
    get points(): List<Point>; */
  /// Gets or sets the List of Points in the route.
  /// All of the Points must be Point#isReal -- no NaN or infinite values --
  /// and all of the points are in document coordinates.
  /// Although this list may be replaced by setting this property,
  /// one must not modify the contents of the List directly.
  ///
  /// The setter also accepts an Array of alternating X,Y point values [1, 2, 3, 4, 5, 6],
  /// or an Array of Objects each of which has (lowercase) 'x' and 'y' properties that are numbers
  /// [{"x":1,"y":2}, {"x":3,"y":4}, {"x":5,"y":6}].
  ///
  /// Ownership of the List and all of its Points that is provided to the setter
  /// is transferred to this Link.
  _i3.List /*LIST InteropClass#847625641(name: List),334299092,[Instance of 'InteropRef<InteropType>']*/ <_i3.Point>
      get points => _i5.getProperty(
            this,
            'points',
          );
  /* #22752
  source: 
    /**
     * Gets or sets the List of Points in the route.
     * All of the Points must be Point#isReal -- no NaN or infinite values --
     * and all of the points are in document coordinates.
     * Although this list may be replaced by setting this property,
     * one must not modify the contents of the List directly.
     *
     * The setter also accepts an Array of alternating X,Y point values [1, 2, 3, 4, 5, 6],
     * or an Array of Objects each of which has (lowercase) 'x' and 'y' properties that are numbers
     * [{"x":1,"y":2}, {"x":3,"y":4}, {"x":5,"y":6}].
     *
     * Ownership of the List and all of its Points that is provided to the setter
     * is transferred to this Link.
     */
    get points(): List<Point>; */
  // Type Instance of 'InteropInterface'
  set points(
      _i3.List /*LIST InteropClass#847625641(name: List),842389355,[Instance of 'InteropRef<InteropType>']*/ <
              _i3.Point>
          value) {
    _i5.setProperty(
      this,
      'points',
      value,
    );
  }

  /* #22757
  source: 
    /**
     * This read-only property returns the number of points in the route.
     */
    get pointsCount(): number; */
  /// This read-only property returns the number of points in the route.
  _i2.num get pointsCount => _i5.getProperty(
        this,
        'pointsCount',
      );
  /* #22757
  source: 
    /**
     * This read-only property returns the number of points in the route.
     */
    get pointsCount(): number; */
  // Type InteropStaticType.number
  set pointsCount(_i2.num value) {
    _i5.setProperty(
      this,
      'pointsCount',
      value,
    );
  }

  /* #22868
  source: 
    /**
     * (undocumented)
     */
    get defaultFromPoint(): Point; */
  /// (undocumented)
  _i3.Point get defaultFromPoint => _i5.getProperty(
        this,
        'defaultFromPoint',
      );
  /* #22868
  source: 
    /**
     * (undocumented)
     */
    get defaultFromPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set defaultFromPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'defaultFromPoint',
      value,
    );
  }

  /* #22873
  source: 
    /**
     * (undocumented)
     */
    get defaultToPoint(): Point; */
  /// (undocumented)
  _i3.Point get defaultToPoint => _i5.getProperty(
        this,
        'defaultToPoint',
      );
  /* #22873
  source: 
    /**
     * (undocumented)
     */
    get defaultToPoint(): Point; */
  // Type Instance of 'InteropInterface'
  set defaultToPoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'defaultToPoint',
      value,
    );
  }

  /* #23021
  source: 
    /**
     * This read-only property is true if #routing is a value that implies that the points
     * of the route should be orthogonal, such that each point shares a common X or a common Y value
     * with the immediately previous and next points.
     * This property is completely dependent on the #routing property.
     * Values of Link.Orthogonal and Link.AvoidsNodes causes this property to be true.
     *
     * The points in the route might not actually form an orthogonal route, but when the route is computed
     * the intent is to maintain orthogonality.
     * @since 1.2
     */
    get isOrthogonal(): boolean; */
  /// This read-only property is true if #routing is a value that implies that the points
  /// of the route should be orthogonal, such that each point shares a common X or a common Y value
  /// with the immediately previous and next points.
  /// This property is completely dependent on the #routing property.
  /// Values of Link.Orthogonal and Link.AvoidsNodes causes this property to be true.
  ///
  /// The points in the route might not actually form an orthogonal route, but when the route is computed
  /// the intent is to maintain orthogonality.
  _i2.bool get isOrthogonal => _i5.getProperty(
        this,
        'isOrthogonal',
      );
  /* #23021
  source: 
    /**
     * This read-only property is true if #routing is a value that implies that the points
     * of the route should be orthogonal, such that each point shares a common X or a common Y value
     * with the immediately previous and next points.
     * This property is completely dependent on the #routing property.
     * Values of Link.Orthogonal and Link.AvoidsNodes causes this property to be true.
     *
     * The points in the route might not actually form an orthogonal route, but when the route is computed
     * the intent is to maintain orthogonality.
     * @since 1.2
     */
    get isOrthogonal(): boolean; */
  // Type InteropStaticType.boolean
  set isOrthogonal(_i2.bool value) {
    _i5.setProperty(
      this,
      'isOrthogonal',
      value,
    );
  }

  /* #23026
  source: 
    /**
     * (undocumented)
     * This read-only property is true when the routing tries to be smart about not overlapping other parts.
     */
    get isAvoiding(): boolean; */
  /// (undocumented)
  /// This read-only property is true when the routing tries to be smart about not overlapping other parts.
  _i2.bool get isAvoiding => _i5.getProperty(
        this,
        'isAvoiding',
      );
  /* #23026
  source: 
    /**
     * (undocumented)
     * This read-only property is true when the routing tries to be smart about not overlapping other parts.
     */
    get isAvoiding(): boolean; */
  // Type InteropStaticType.boolean
  set isAvoiding(_i2.bool value) {
    _i5.setProperty(
      this,
      'isAvoiding',
      value,
    );
  }

  /* #23169
  source: 
    /**
     * This read-only property returns the Geometry that is used by the #path, the link Shape based on the route points.
     *
     * This geometry is automatically generated using the route points and other properties
     * such as the #curve.
     * The points of the Geometry are in local coordinates, whereas the #points of the link route are in document coordinates.
     *
     * More than one Shape may share this geometry as its Shape#geometry,
     * if there is more than one shape element in the Link with GraphObject#isPanelMain set to true.
     */
    get geometry(): Geometry; */
  /// This read-only property returns the Geometry that is used by the #path, the link Shape based on the route points.
  ///
  /// This geometry is automatically generated using the route points and other properties
  /// such as the #curve.
  /// The points of the Geometry are in local coordinates, whereas the #points of the link route are in document coordinates.
  ///
  /// More than one Shape may share this geometry as its Shape#geometry,
  /// if there is more than one shape element in the Link with GraphObject#isPanelMain set to true.
  _i3.Geometry get geometry => _i5.getProperty(
        this,
        'geometry',
      );
  /* #23169
  source: 
    /**
     * This read-only property returns the Geometry that is used by the #path, the link Shape based on the route points.
     *
     * This geometry is automatically generated using the route points and other properties
     * such as the #curve.
     * The points of the Geometry are in local coordinates, whereas the #points of the link route are in document coordinates.
     *
     * More than one Shape may share this geometry as its Shape#geometry,
     * if there is more than one shape element in the Link with GraphObject#isPanelMain set to true.
     */
    get geometry(): Geometry; */
  // Type Instance of 'InteropInterface'
  set geometry(_i3.Geometry value) {
    _i5.setProperty(
      this,
      'geometry',
      value,
    );
  }

  /* #23185
  source: 
    /**
     * (undocumented)
     */
    get firstPickIndex(): number; */
  /// (undocumented)
  _i2.num get firstPickIndex => _i5.getProperty(
        this,
        'firstPickIndex',
      );
  /* #23185
  source: 
    /**
     * (undocumented)
     */
    get firstPickIndex(): number; */
  // Type InteropStaticType.number
  set firstPickIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'firstPickIndex',
      value,
    );
  }

  /* #23189
  source: 
    /**
     * (undocumented)
     */
    get lastPickIndex(): number; */
  /// (undocumented)
  _i2.num get lastPickIndex => _i5.getProperty(
        this,
        'lastPickIndex',
      );
  /* #23189
  source: 
    /**
     * (undocumented)
     */
    get lastPickIndex(): number; */
  // Type InteropStaticType.number
  set lastPickIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'lastPickIndex',
      value,
    );
  }

  /* #23197
  source: 
    /**
     * Gets or sets how the route is computed, including whether it uses the points of its old route to determine the new route.
     * The value must be one of Link.None|None, Link.End|End, Link.Scale|Scale, or Link.Stretch|Stretch.
     *
     * The default value is Link.None|None -- the route is completely recalculated each time.
     * @see #computeAdjusting
     */
    get adjusting(): EnumValue; */
  /// Gets or sets how the route is computed, including whether it uses the points of its old route to determine the new route.
  /// The value must be one of Link.None|None, Link.End|End, Link.Scale|Scale, or Link.Stretch|Stretch.
  ///
  /// The default value is Link.None|None -- the route is completely recalculated each time.
  _i3.EnumValue get adjusting => _i5.getProperty(
        this,
        'adjusting',
      );
  /* #23197
  source: 
    /**
     * Gets or sets how the route is computed, including whether it uses the points of its old route to determine the new route.
     * The value must be one of Link.None|None, Link.End|End, Link.Scale|Scale, or Link.Stretch|Stretch.
     *
     * The default value is Link.None|None -- the route is completely recalculated each time.
     * @see #computeAdjusting
     */
    get adjusting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set adjusting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'adjusting',
      value,
    );
  }

  /* #23219
  source: 
    /**
     * Gets or sets how rounded the corners are for adjacent line segments when the #curve
     * is Link.None|None, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver and
     * the two line segments are orthogonal to each other.
     *
     * The default value is zero -- there is no curve at a corner.
     */
    get corner(): number; */
  /// Gets or sets how rounded the corners are for adjacent line segments when the #curve
  /// is Link.None|None, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver and
  /// the two line segments are orthogonal to each other.
  ///
  /// The default value is zero -- there is no curve at a corner.
  _i2.num get corner => _i5.getProperty(
        this,
        'corner',
      );
  /* #23219
  source: 
    /**
     * Gets or sets how rounded the corners are for adjacent line segments when the #curve
     * is Link.None|None, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver and
     * the two line segments are orthogonal to each other.
     *
     * The default value is zero -- there is no curve at a corner.
     */
    get corner(): number; */
  // Type InteropStaticType.number
  set corner(_i2.num value) {
    _i5.setProperty(
      this,
      'corner',
      value,
    );
  }

  /* #23233
  source: 
    /**
     * Gets or sets the way the path is generated from the route's points.
     * The value must be one of Link.None|None, Link.Bezier|Bezier, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver.
     *
     * Setting this property to Link.JumpOver|JumpOver or Link.JumpGap|JumpGap requires the Diagram to do
     * considerable computation when calculating Link routes. Consider not using
     * a Jump... value with Diagrams that contain large numbers of Links
     * if you are targeting slow devices.
     *
     * The default value is Link.None|None -- each link segment is a straight line.
     * @see #computeCurve
     */
    get curve(): EnumValue; */
  /// Gets or sets the way the path is generated from the route's points.
  /// The value must be one of Link.None|None, Link.Bezier|Bezier, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver.
  ///
  /// Setting this property to Link.JumpOver|JumpOver or Link.JumpGap|JumpGap requires the Diagram to do
  /// considerable computation when calculating Link routes. Consider not using
  /// a Jump... value with Diagrams that contain large numbers of Links
  /// if you are targeting slow devices.
  ///
  /// The default value is Link.None|None -- each link segment is a straight line.
  _i3.EnumValue get curve => _i5.getProperty(
        this,
        'curve',
      );
  /* #23233
  source: 
    /**
     * Gets or sets the way the path is generated from the route's points.
     * The value must be one of Link.None|None, Link.Bezier|Bezier, Link.JumpGap|JumpGap, or Link.JumpOver|JumpOver.
     *
     * Setting this property to Link.JumpOver|JumpOver or Link.JumpGap|JumpGap requires the Diagram to do
     * considerable computation when calculating Link routes. Consider not using
     * a Jump... value with Diagrams that contain large numbers of Links
     * if you are targeting slow devices.
     *
     * The default value is Link.None|None -- each link segment is a straight line.
     * @see #computeCurve
     */
    get curve(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set curve(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'curve',
      value,
    );
  }

  /* #23242
  source: 
    /**
     * Gets or sets how far the control points are offset when the #curve is Link.Bezier|Bezier
     * or when there are multiple links between the same two ports.
     *
     * The default value is NaN -- the actual curviness is computed based on how many links connect the same pair of ports.
     * @see #computeCurviness
     */
    get curviness(): number; */
  /// Gets or sets how far the control points are offset when the #curve is Link.Bezier|Bezier
  /// or when there are multiple links between the same two ports.
  ///
  /// The default value is NaN -- the actual curviness is computed based on how many links connect the same pair of ports.
  _i2.num get curviness => _i5.getProperty(
        this,
        'curviness',
      );
  /* #23242
  source: 
    /**
     * Gets or sets how far the control points are offset when the #curve is Link.Bezier|Bezier
     * or when there are multiple links between the same two ports.
     *
     * The default value is NaN -- the actual curviness is computed based on how many links connect the same pair of ports.
     * @see #computeCurviness
     */
    get curviness(): number; */
  // Type InteropStaticType.number
  set curviness(_i2.num value) {
    _i5.setProperty(
      this,
      'curviness',
      value,
    );
  }

  /* #23258
  source: 
    /**
     * Gets or sets whether the link's path tries to avoid other nodes.
     * The value must be one of Link.Normal|Normal, Link.Orthogonal|Orthogonal, or Link.AvoidsNodes|AvoidsNodes.
     *
     * Setting this property to Link.AvoidsNodes|AvoidsNodes requires the Diagram to do
     * considerable computation when calculating Link routes. Consider not using
     * the Link.AvoidsNodes|AvoidsNodes with Diagrams that contain large numbers of Nodes and Links
     * if you are targeting slow devices.
     * When using Link.AvoidsNodes|AvoidsNodes, dragging performance can be improved by setting DraggingTool#isComplexRoutingRealtime to false.
     *
     * The default value is Link.Normal|Normal -- the route is primarily a single straight segment,
     * with possible short end segments when connecting with ports that have a "spot" value
     * as the #fromSpot or GraphObject#fromSpot or #toSpot or GraphObject#toSpot.
     */
    get routing(): EnumValue; */
  /// Gets or sets whether the link's path tries to avoid other nodes.
  /// The value must be one of Link.Normal|Normal, Link.Orthogonal|Orthogonal, or Link.AvoidsNodes|AvoidsNodes.
  ///
  /// Setting this property to Link.AvoidsNodes|AvoidsNodes requires the Diagram to do
  /// considerable computation when calculating Link routes. Consider not using
  /// the Link.AvoidsNodes|AvoidsNodes with Diagrams that contain large numbers of Nodes and Links
  /// if you are targeting slow devices.
  /// When using Link.AvoidsNodes|AvoidsNodes, dragging performance can be improved by setting DraggingTool#isComplexRoutingRealtime to false.
  ///
  /// The default value is Link.Normal|Normal -- the route is primarily a single straight segment,
  /// with possible short end segments when connecting with ports that have a "spot" value
  /// as the #fromSpot or GraphObject#fromSpot or #toSpot or GraphObject#toSpot.
  _i3.EnumValue get routing => _i5.getProperty(
        this,
        'routing',
      );
  /* #23258
  source: 
    /**
     * Gets or sets whether the link's path tries to avoid other nodes.
     * The value must be one of Link.Normal|Normal, Link.Orthogonal|Orthogonal, or Link.AvoidsNodes|AvoidsNodes.
     *
     * Setting this property to Link.AvoidsNodes|AvoidsNodes requires the Diagram to do
     * considerable computation when calculating Link routes. Consider not using
     * the Link.AvoidsNodes|AvoidsNodes with Diagrams that contain large numbers of Nodes and Links
     * if you are targeting slow devices.
     * When using Link.AvoidsNodes|AvoidsNodes, dragging performance can be improved by setting DraggingTool#isComplexRoutingRealtime to false.
     *
     * The default value is Link.Normal|Normal -- the route is primarily a single straight segment,
     * with possible short end segments when connecting with ports that have a "spot" value
     * as the #fromSpot or GraphObject#fromSpot or #toSpot or GraphObject#toSpot.
     */
    get routing(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set routing(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'routing',
      value,
    );
  }

  /* #23274
  source: 
    /**
     * Gets or sets how far the control points are from the points of the route
     * when #routing is Link.Orthogonal|Orthogonal and #curve is Link.Bezier|Bezier.
     *
     * The default value is 0.5.
     * Values of this property typically fall in the range of 0.0 to 1.0.
     * A value of 0.0 indicates that the control points of the curve are at the end points,
     * which will result in straight line segments.
     * A value of 1.0 indicates that the control points are one-third of the link's
     * length away from the end point along the direction of the link,
     * and the same distance away in a perpendicular direction.
     * The distance scales linearly with the value of this property,
     * even with negative values and values greater than 1.0.
     */
    get smoothness(): number; */
  /// Gets or sets how far the control points are from the points of the route
  /// when #routing is Link.Orthogonal|Orthogonal and #curve is Link.Bezier|Bezier.
  ///
  /// The default value is 0.5.
  /// Values of this property typically fall in the range of 0.0 to 1.0.
  /// A value of 0.0 indicates that the control points of the curve are at the end points,
  /// which will result in straight line segments.
  /// A value of 1.0 indicates that the control points are one-third of the link's
  /// length away from the end point along the direction of the link,
  /// and the same distance away in a perpendicular direction.
  /// The distance scales linearly with the value of this property,
  /// even with negative values and values greater than 1.0.
  _i2.num get smoothness => _i5.getProperty(
        this,
        'smoothness',
      );
  /* #23274
  source: 
    /**
     * Gets or sets how far the control points are from the points of the route
     * when #routing is Link.Orthogonal|Orthogonal and #curve is Link.Bezier|Bezier.
     *
     * The default value is 0.5.
     * Values of this property typically fall in the range of 0.0 to 1.0.
     * A value of 0.0 indicates that the control points of the curve are at the end points,
     * which will result in straight line segments.
     * A value of 1.0 indicates that the control points are one-third of the link's
     * length away from the end point along the direction of the link,
     * and the same distance away in a perpendicular direction.
     * The distance scales linearly with the value of this property,
     * even with negative values and values greater than 1.0.
     */
    get smoothness(): number; */
  // Type InteropStaticType.number
  set smoothness(_i2.num value) {
    _i5.setProperty(
      this,
      'smoothness',
      value,
    );
  }

  /* #23284
  source: 
    /**
     * This read-only property returns the Links's Model data key if it is in a Diagram and is backed by Model data.
     * Otherwise this returns undefined.
     *
     * If the link data is in a GraphLinksModel, the GraphLinksModel#linkKeyProperty must not be an empty string.
     * @since 1.8
     * @see GraphLinksModel#getKeyForLinkData
     */
    get key(): Key; */
  /// This read-only property returns the Links's Model data key if it is in a Diagram and is backed by Model data.
  /// Otherwise this returns undefined.
  ///
  /// If the link data is in a GraphLinksModel, the GraphLinksModel#linkKeyProperty must not be an empty string.
  _i3.Key get key => _i5.getProperty(
        this,
        'key',
      );
  /* #23284
  source: 
    /**
     * This read-only property returns the Links's Model data key if it is in a Diagram and is backed by Model data.
     * Otherwise this returns undefined.
     *
     * If the link data is in a GraphLinksModel, the GraphLinksModel#linkKeyProperty must not be an empty string.
     * @since 1.8
     * @see GraphLinksModel#getKeyForLinkData
     */
    get key(): Key; */
  // Type InteropTypedef#911623829(name: Key)
  set key(_i3.Key value) {
    _i5.setProperty(
      this,
      'key',
      value ?? _i4.undefined,
    );
  }

  _i3.Node? getOtherNode(_i3.Node node) => _i5.callMethod(
        this,
        'getOtherNode',
        [node],
      );
  _i3.GraphObject? getOtherPort(_i3.GraphObject port) => _i5.callMethod(
        this,
        'getOtherPort',
        [port],
      );
  void move(
    _i3.Point newpos, [
    _i2.bool? useLocation,
  ]) {
    _i5.callMethod(
      this,
      'move',
      [
        newpos,
        useLocation ?? _i4.undefined,
      ],
    );
  }

  _i2.bool canRelinkFrom() => _i5.callMethod(
        this,
        'canRelinkFrom',
        [],
      );
  _i2.bool canRelinkTo() => _i5.callMethod(
        this,
        'canRelinkTo',
        [],
      );
  _i3.Point getPoint(_i2.num i) => _i5.callMethod(
        this,
        'getPoint',
        [i],
      );
  void setPoint(
    _i2.num i,
    _i3.Point p,
  ) {
    _i5.callMethod(
      this,
      'setPoint',
      [
        i,
        p,
      ],
    );
  }

  void setPointAt(
    _i2.num i,
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'setPointAt',
      [
        i,
        x,
        y,
      ],
    );
  }

  void insertPoint(
    _i2.num i,
    _i3.Point p,
  ) {
    _i5.callMethod(
      this,
      'insertPoint',
      [
        i,
        p,
      ],
    );
  }

  void insertPointAt(
    _i2.num i,
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'insertPointAt',
      [
        i,
        x,
        y,
      ],
    );
  }

  void addPoint(_i3.Point p) {
    _i5.callMethod(
      this,
      'addPoint',
      [p],
    );
  }

  void addPointAt(
    _i2.num x,
    _i2.num y,
  ) {
    _i5.callMethod(
      this,
      'addPointAt',
      [
        x,
        y,
      ],
    );
  }

  void removePoint(_i2.num i) {
    _i5.callMethod(
      this,
      'removePoint',
      [i],
    );
  }

  void clearPoints() {
    _i5.callMethod(
      this,
      'clearPoints',
      [],
    );
  }

  void startRoute() {
    _i5.callMethod(
      this,
      'startRoute',
      [],
    );
  }

  void commitRoute() {
    _i5.callMethod(
      this,
      'commitRoute',
      [],
    );
  }

  void rollbackRoute() {
    _i5.callMethod(
      this,
      'rollbackRoute',
      [],
    );
  }

  void invalidateRoute() {
    _i5.callMethod(
      this,
      'invalidateRoute',
      [],
    );
  }

  void updateRoute() {
    _i5.callMethod(
      this,
      'updateRoute',
      [],
    );
  }

  _i2.bool computePoints() => _i5.callMethod(
        this,
        'computePoints',
        [],
      );
  _i3.Point getLinkPointFromPoint(
    _i3.Node? node,
    _i3.GraphObject? port,
    _i3.Point focus,
    _i3.Point p,
    _i2.bool from, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'getLinkPointFromPoint',
        [
          node ?? _i4.undefined,
          port ?? _i4.undefined,
          focus,
          p,
          from,
          result ?? _i4.undefined,
        ],
      );
  _i3.Point getLinkPoint(
    _i3.Node? node,
    _i3.GraphObject port,
    _i3.Spot spot,
    _i2.bool from,
    _i2.bool ortho,
    _i3.Node? othernode,
    _i3.GraphObject otherport, [
    _i3.Point? result,
  ]) =>
      _i5.callMethod(
        this,
        'getLinkPoint',
        [
          node ?? _i4.undefined,
          port,
          spot,
          from,
          ortho,
          othernode ?? _i4.undefined,
          otherport,
          result ?? _i4.undefined,
        ],
      );
  _i2.num getLinkDirection(
    _i3.Node? node,
    _i3.GraphObject? port,
    _i3.Point linkpoint,
    _i3.Spot spot,
    _i2.bool from,
    _i2.bool ortho, [
    _i3.Node? othernode,
    _i3.GraphObject? otherport,
  ]) =>
      _i5.callMethod(
        this,
        'getLinkDirection',
        [
          node ?? _i4.undefined,
          port ?? _i4.undefined,
          linkpoint,
          spot,
          from,
          ortho,
          othernode ?? _i4.undefined,
          otherport ?? _i4.undefined,
        ],
      );
  _i2.num computeEndSegmentLength(
    _i3.Node? node,
    _i3.GraphObject? port,
    _i3.Spot spot,
    _i2.bool from,
  ) =>
      _i5.callMethod(
        this,
        'computeEndSegmentLength',
        [
          node ?? _i4.undefined,
          port ?? _i4.undefined,
          spot,
          from,
        ],
      );
  _i3.Spot computeSpot(
    _i2.bool from, [
    _i3.GraphObject? port,
  ]) =>
      _i5.callMethod(
        this,
        'computeSpot',
        [
          from,
          port ?? _i4.undefined,
        ],
      );
  _i3.Point computeOtherPoint(
    _i3.Node othernode,
    _i3.GraphObject otherport,
  ) =>
      _i5.callMethod(
        this,
        'computeOtherPoint',
        [
          othernode,
          otherport,
        ],
      );
  _i2.num computeShortLength(_i2.bool from) => _i5.callMethod(
        this,
        'computeShortLength',
        [from],
      );
  _i3.EnumValue computeCurve() => _i5.callMethod(
        this,
        'computeCurve',
        [],
      );
  _i2.num computeCorner() => _i5.callMethod(
        this,
        'computeCorner',
        [],
      );
  _i3.GraphObject? findMidLabel() => _i5.callMethod(
        this,
        'findMidLabel',
        [],
      );
  _i2.num computeSpacing() => _i5.callMethod(
        this,
        'computeSpacing',
        [],
      );
  void arrangeBundledLinks(
    _i4.Array links,
    _i2.bool reroute,
  ) {
    _i5.callMethod(
      this,
      'arrangeBundledLinks',
      [
        links,
        reroute,
      ],
    );
  }

  _i2.num computeCurviness() => _i5.callMethod(
        this,
        'computeCurviness',
        [],
      );
  _i2.num computeThickness() => _i5.callMethod(
        this,
        'computeThickness',
        [],
      );
  _i2.bool hasCurviness() => _i5.callMethod(
        this,
        'hasCurviness',
        [],
      );
  void addOrthoPoints(
    _i3.Point startFrom,
    _i2.num fromDir,
    _i3.Point endTo,
    _i2.num toDir,
    _i3.Node fromnode,
    _i3.Node tonode,
  ) {
    _i5.callMethod(
      this,
      'addOrthoPoints',
      [
        startFrom,
        fromDir,
        endTo,
        toDir,
        fromnode,
        tonode,
      ],
    );
  }

  _i2.num computeMidOrthoPosition(
    _i2.num fromX,
    _i2.num fromY,
    _i2.num toX,
    _i2.num toY,
    _i2.bool vertical,
  ) =>
      _i5.callMethod(
        this,
        'computeMidOrthoPosition',
        [
          fromX,
          fromY,
          toX,
          toY,
          vertical,
        ],
      );
  _i2.num findClosestSegment(_i3.Point p) => _i5.callMethod(
        this,
        'findClosestSegment',
        [p],
      );
  _i3.Geometry makeGeometry() => _i5.callMethod(
        this,
        'makeGeometry',
        [],
      );
  _i3.EnumValue computeAdjusting() => _i5.callMethod(
        this,
        'computeAdjusting',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class Layout {
  factory Layout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredLayout,
        [init ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Layout')
external _i2.Object _declaredLayout;

extension Layout$Typings on Layout {
  /* #23406
  source: 
    /**
     * Gets the Diagram that owns this layout, if it is the value of Diagram#layout.
     *
     * If this property and #group are non-null, the Group should be in this Diagram.
     * @see #group
     */
    get diagram(): Diagram | null; */
  /// Gets the Diagram that owns this layout, if it is the value of Diagram#layout.
  ///
  /// If this property and #group are non-null, the Group should be in this Diagram.
  _i3.Diagram? get diagram => _i5.getProperty(
        this,
        'diagram',
      );
  /* #23406
  source: 
    /**
     * Gets the Diagram that owns this layout, if it is the value of Diagram#layout.
     *
     * If this property and #group are non-null, the Group should be in this Diagram.
     * @see #group
     */
    get diagram(): Diagram | null; */
  // Type InteropUnion#475637666(parent: InteropGetter#558647404(name: diagram))
  set diagram(_i3.Diagram? value) {
    _i5.setProperty(
      this,
      'diagram',
      value ?? _i4.undefined,
    );
  }

  /* #23414
  source: 
    /**
     * Gets the Group that uses this layout, if it is the value of a group's Group#layout.
     *
     * If this property is set to a Group, the #diagram is automatically set to be the Group's Diagram.
     * @see #diagram
     */
    get group(): Group | null; */
  /// Gets the Group that uses this layout, if it is the value of a group's Group#layout.
  ///
  /// If this property is set to a Group, the #diagram is automatically set to be the Group's Diagram.
  _i3.Group? get group => _i5.getProperty(
        this,
        'group',
      );
  /* #23414
  source: 
    /**
     * Gets the Group that uses this layout, if it is the value of a group's Group#layout.
     *
     * If this property is set to a Group, the #diagram is automatically set to be the Group's Diagram.
     * @see #diagram
     */
    get group(): Group | null; */
  // Type InteropUnion#662763924(parent: InteropGetter#874437787(name: group))
  set group(_i3.Group? value) {
    _i5.setProperty(
      this,
      'group',
      value ?? _i4.undefined,
    );
  }

  /* #23431
  source: 
    /**
     * Gets or sets whether this layout can be invalidated by #invalidateLayout.
     * Set this to false to prevent actions such as adding or removing Parts from invalidating this layout.
     * The default value is true.
     * Setting this property does not invalidate this layout.
     *
     * If you set both #isInitial and #isOngoing to false,
     * there will be no automatic layout invalidation, because #invalidateLayout
     * will not set #isValidLayout to false.
     * To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
     * or GraphObject#position to real Point values, because automatic layout will not assign any positions.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#isLayoutPositioned or Part#layoutConditions.
     */
    get isOngoing(): boolean; */
  /// Gets or sets whether this layout can be invalidated by #invalidateLayout.
  /// Set this to false to prevent actions such as adding or removing Parts from invalidating this layout.
  /// The default value is true.
  /// Setting this property does not invalidate this layout.
  ///
  /// If you set both #isInitial and #isOngoing to false,
  /// there will be no automatic layout invalidation, because #invalidateLayout
  /// will not set #isValidLayout to false.
  /// To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
  /// or GraphObject#position to real Point values, because automatic layout will not assign any positions.
  ///
  /// Another way of controlling when layouts are invalidated is by setting
  /// Part#isLayoutPositioned or Part#layoutConditions.
  _i2.bool get isOngoing => _i5.getProperty(
        this,
        'isOngoing',
      );
  /* #23431
  source: 
    /**
     * Gets or sets whether this layout can be invalidated by #invalidateLayout.
     * Set this to false to prevent actions such as adding or removing Parts from invalidating this layout.
     * The default value is true.
     * Setting this property does not invalidate this layout.
     *
     * If you set both #isInitial and #isOngoing to false,
     * there will be no automatic layout invalidation, because #invalidateLayout
     * will not set #isValidLayout to false.
     * To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
     * or GraphObject#position to real Point values, because automatic layout will not assign any positions.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#isLayoutPositioned or Part#layoutConditions.
     */
    get isOngoing(): boolean; */
  // Type InteropStaticType.boolean
  set isOngoing(_i2.bool value) {
    _i5.setProperty(
      this,
      'isOngoing',
      value,
    );
  }

  /* #23448
  source: 
    /**
     * Gets or sets whether this layout is performed on an initial layout.
     * The default value is true.
     * Setting this property to false causes #isValidLayout to be set to true
     * so that the diagram does not perform this layout.
     *
     * If you set both #isInitial and #isOngoing to false,
     * there will be no automatic layout invalidation, because #invalidateLayout
     * will not set #isValidLayout to false.
     * To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
     * or GraphObject#position to real Point values, because automatic layout will not assign any positions.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#isLayoutPositioned or Part#layoutConditions.
     */
    get isInitial(): boolean; */
  /// Gets or sets whether this layout is performed on an initial layout.
  /// The default value is true.
  /// Setting this property to false causes #isValidLayout to be set to true
  /// so that the diagram does not perform this layout.
  ///
  /// If you set both #isInitial and #isOngoing to false,
  /// there will be no automatic layout invalidation, because #invalidateLayout
  /// will not set #isValidLayout to false.
  /// To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
  /// or GraphObject#position to real Point values, because automatic layout will not assign any positions.
  ///
  /// Another way of controlling when layouts are invalidated is by setting
  /// Part#isLayoutPositioned or Part#layoutConditions.
  _i2.bool get isInitial => _i5.getProperty(
        this,
        'isInitial',
      );
  /* #23448
  source: 
    /**
     * Gets or sets whether this layout is performed on an initial layout.
     * The default value is true.
     * Setting this property to false causes #isValidLayout to be set to true
     * so that the diagram does not perform this layout.
     *
     * If you set both #isInitial and #isOngoing to false,
     * there will be no automatic layout invalidation, because #invalidateLayout
     * will not set #isValidLayout to false.
     * To get your nodes to appear, you will need to explicitly set or data-bind their Part#location
     * or GraphObject#position to real Point values, because automatic layout will not assign any positions.
     *
     * Another way of controlling when layouts are invalidated is by setting
     * Part#isLayoutPositioned or Part#layoutConditions.
     */
    get isInitial(): boolean; */
  // Type InteropStaticType.boolean
  set isInitial(_i2.bool value) {
    _i5.setProperty(
      this,
      'isInitial',
      value,
    );
  }

  /* #23465
  source: 
    /**
     * Gets or sets whether this layout depends on the Diagram#viewportBounds's size.
     * If set to true, the layout will invalidate when the Diagram's viewport changes size.
     * This only applies to diagram layouts, not to group layouts,
     * and only when Diagram#autoScale is set to Diagram.None.
     *
     * The default value is false.
     * Setting this property to true will invalidate this layout.
     *
     * It is possible that a viewport-sized layout will trigger the Diagram to require scrollbars,
     * which modifies the Diagram#viewportBounds, which will in turn trigger another layout.
     * This is uncommon, but possible with GridLayout if the results require a vertical scrollbar,
     * and that vertical scrollbar shrinks the viewport width enough that a grid column can no longer fit.
     * When designing custom layouts, one should be careful that this behavior does not result in an infinite loop.
     */
    get isViewportSized(): boolean; */
  /// Gets or sets whether this layout depends on the Diagram#viewportBounds's size.
  /// If set to true, the layout will invalidate when the Diagram's viewport changes size.
  /// This only applies to diagram layouts, not to group layouts,
  /// and only when Diagram#autoScale is set to Diagram.None.
  ///
  /// The default value is false.
  /// Setting this property to true will invalidate this layout.
  ///
  /// It is possible that a viewport-sized layout will trigger the Diagram to require scrollbars,
  /// which modifies the Diagram#viewportBounds, which will in turn trigger another layout.
  /// This is uncommon, but possible with GridLayout if the results require a vertical scrollbar,
  /// and that vertical scrollbar shrinks the viewport width enough that a grid column can no longer fit.
  /// When designing custom layouts, one should be careful that this behavior does not result in an infinite loop.
  _i2.bool get isViewportSized => _i5.getProperty(
        this,
        'isViewportSized',
      );
  /* #23465
  source: 
    /**
     * Gets or sets whether this layout depends on the Diagram#viewportBounds's size.
     * If set to true, the layout will invalidate when the Diagram's viewport changes size.
     * This only applies to diagram layouts, not to group layouts,
     * and only when Diagram#autoScale is set to Diagram.None.
     *
     * The default value is false.
     * Setting this property to true will invalidate this layout.
     *
     * It is possible that a viewport-sized layout will trigger the Diagram to require scrollbars,
     * which modifies the Diagram#viewportBounds, which will in turn trigger another layout.
     * This is uncommon, but possible with GridLayout if the results require a vertical scrollbar,
     * and that vertical scrollbar shrinks the viewport width enough that a grid column can no longer fit.
     * When designing custom layouts, one should be careful that this behavior does not result in an infinite loop.
     */
    get isViewportSized(): boolean; */
  // Type InteropStaticType.boolean
  set isViewportSized(_i2.bool value) {
    _i5.setProperty(
      this,
      'isViewportSized',
      value,
    );
  }

  /* #23477
  source: 
    /**
     * Gets or sets whether this layout routes Links.
     * The default value is true.
     * When false, this layout will not explicitly set the Link#points,
     * and the default routing of each individual Link will take place after the Nodes are moved by #commitLayout.
     * Setting this property does not invalidate this layout.
     *
     * Some layouts ignore links, in which case this property is ignored.
     * @since 1.1
     */
    get isRouting(): boolean; */
  /// Gets or sets whether this layout routes Links.
  /// The default value is true.
  /// When false, this layout will not explicitly set the Link#points,
  /// and the default routing of each individual Link will take place after the Nodes are moved by #commitLayout.
  /// Setting this property does not invalidate this layout.
  ///
  /// Some layouts ignore links, in which case this property is ignored.
  _i2.bool get isRouting => _i5.getProperty(
        this,
        'isRouting',
      );
  /* #23477
  source: 
    /**
     * Gets or sets whether this layout routes Links.
     * The default value is true.
     * When false, this layout will not explicitly set the Link#points,
     * and the default routing of each individual Link will take place after the Nodes are moved by #commitLayout.
     * Setting this property does not invalidate this layout.
     *
     * Some layouts ignore links, in which case this property is ignored.
     * @since 1.1
     */
    get isRouting(): boolean; */
  // Type InteropStaticType.boolean
  set isRouting(_i2.bool value) {
    _i5.setProperty(
      this,
      'isRouting',
      value,
    );
  }

  /* #23487
  source: 
    /**
     * Gets or sets whether this layout be performed in real-time, before the end of a transaction.
     * All layouts that are invalidated will be performed at the end of a transaction.
     * The default value is null.
     * A null value is treated as true for a Diagram#layout but false for a Group#layout.
     * Setting this property does not invalidate this layout.
     * @since 1.2
     */
    get isRealtime(): boolean | null; */
  /// Gets or sets whether this layout be performed in real-time, before the end of a transaction.
  /// All layouts that are invalidated will be performed at the end of a transaction.
  /// The default value is null.
  /// A null value is treated as true for a Diagram#layout but false for a Group#layout.
  /// Setting this property does not invalidate this layout.
  _i2.bool? get isRealtime => _i5.getProperty(
        this,
        'isRealtime',
      );
  /* #23487
  source: 
    /**
     * Gets or sets whether this layout be performed in real-time, before the end of a transaction.
     * All layouts that are invalidated will be performed at the end of a transaction.
     * The default value is null.
     * A null value is treated as true for a Diagram#layout but false for a Group#layout.
     * Setting this property does not invalidate this layout.
     * @since 1.2
     */
    get isRealtime(): boolean | null; */
  // Type InteropUnion#309554249(parent: InteropGetter#264762316(name: isRealtime))
  set isRealtime(_i2.bool? value) {
    _i5.setProperty(
      this,
      'isRealtime',
      value ?? _i4.undefined,
    );
  }

  /* #23494
  source: 
    /**
     * Gets or sets whether this layout needs to be performed again (if false).
     * Instead of setting this property directly, it is normal to set it to false by calling #invalidateLayout,
     * since that also requests performing a layout in the near future.
     */
    get isValidLayout(): boolean; */
  /// Gets or sets whether this layout needs to be performed again (if false).
  /// Instead of setting this property directly, it is normal to set it to false by calling #invalidateLayout,
  /// since that also requests performing a layout in the near future.
  _i2.bool get isValidLayout => _i5.getProperty(
        this,
        'isValidLayout',
      );
  /* #23494
  source: 
    /**
     * Gets or sets whether this layout needs to be performed again (if false).
     * Instead of setting this property directly, it is normal to set it to false by calling #invalidateLayout,
     * since that also requests performing a layout in the near future.
     */
    get isValidLayout(): boolean; */
  // Type InteropStaticType.boolean
  set isValidLayout(_i2.bool value) {
    _i5.setProperty(
      this,
      'isValidLayout',
      value,
    );
  }

  /* #23519
  source: 
    /**
     * Gets or sets the LayoutNetwork used by this Layout, if any.
     * The default value is null.
     * Setting this property does not invalidate this layout.
     * Not all kinds of layout make use of a LayoutNetwork.
     * Call #createNetwork or #makeNetwork to create a network.
     */
    get network(): LayoutNetwork | null; */
  /// Gets or sets the LayoutNetwork used by this Layout, if any.
  /// The default value is null.
  /// Setting this property does not invalidate this layout.
  /// Not all kinds of layout make use of a LayoutNetwork.
  /// Call #createNetwork or #makeNetwork to create a network.
  _i3.LayoutNetwork? get network => _i5.getProperty(
        this,
        'network',
      );
  /* #23519
  source: 
    /**
     * Gets or sets the LayoutNetwork used by this Layout, if any.
     * The default value is null.
     * Setting this property does not invalidate this layout.
     * Not all kinds of layout make use of a LayoutNetwork.
     * Call #createNetwork or #makeNetwork to create a network.
     */
    get network(): LayoutNetwork | null; */
  // Type InteropUnion#520515344(parent: InteropGetter#482059914(name: network))
  set network(_i3.LayoutNetwork? value) {
    _i5.setProperty(
      this,
      'network',
      value ?? _i4.undefined,
    );
  }

  /* #23647
  source: 
    /**
     * Gets or sets a function that determines the initial size and position in document coordinates of a LayoutVertex corresponding to a Node.
     * This function is called by #getLayoutBounds.
     * The default value for this property is null, in which case the GraphObject#actualBounds of the Node is used.
     * Setting this property to a new value invalidates this layout.
     *
     * The non-null value must be a function that takes 3 arguments.
     * The first argument will be the Part whose bounds the Layout should use.
     * The second argument will be this Layout.
     * The third argument will be a Rect that must be modified and returned
     * The return value must be in document coordinates.  You may find it convenient to call GraphObject#getDocumentBounds
     * to get the bounds in document coordinates of an object within the node.
     * @since 2.0
     */
    get boundsComputation(): ((part: Part, lay: Layout, rect: Rect) => Rect) | null; */
  /// Gets or sets a function that determines the initial size and position in document coordinates of a LayoutVertex corresponding to a Node.
  /// This function is called by #getLayoutBounds.
  /// The default value for this property is null, in which case the GraphObject#actualBounds of the Node is used.
  /// Setting this property to a new value invalidates this layout.
  ///
  /// The non-null value must be a function that takes 3 arguments.
  /// The first argument will be the Part whose bounds the Layout should use.
  /// The second argument will be this Layout.
  /// The third argument will be a Rect that must be modified and returned
  /// The return value must be in document coordinates.  You may find it convenient to call GraphObject#getDocumentBounds
  /// to get the bounds in document coordinates of an object within the node.
  _i3.Rect Function(
    _i3.Part,
    _i3.Layout,
    _i3.Rect,
  )? get boundsComputation => _i5.getProperty(
        this,
        'boundsComputation',
      );
  /* #23647
  source: 
    /**
     * Gets or sets a function that determines the initial size and position in document coordinates of a LayoutVertex corresponding to a Node.
     * This function is called by #getLayoutBounds.
     * The default value for this property is null, in which case the GraphObject#actualBounds of the Node is used.
     * Setting this property to a new value invalidates this layout.
     *
     * The non-null value must be a function that takes 3 arguments.
     * The first argument will be the Part whose bounds the Layout should use.
     * The second argument will be this Layout.
     * The third argument will be a Rect that must be modified and returned
     * The return value must be in document coordinates.  You may find it convenient to call GraphObject#getDocumentBounds
     * to get the bounds in document coordinates of an object within the node.
     * @since 2.0
     */
    get boundsComputation(): ((part: Part, lay: Layout, rect: Rect) => Rect) | null; */
  // Type InteropUnion#661122195(parent: InteropGetter#503210293(name: boundsComputation))
  set boundsComputation(
      _i3.Rect Function(
        _i3.Part,
        _i3.Layout,
        _i3.Rect,
      )? value) {
    _i5.setProperty(
      this,
      'boundsComputation',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #23681
  source: 
    /**
     * Gets or sets the top-left point for where the graph should be positioned when laid out.
     * The default value for this property is the Point(0, 0).
     * Setting this property to a new value invalidates this layout.
     * This property is likely to be set by many Layouts that belong to a Group when the layout is performed.
     */
    get arrangementOrigin(): Point; */
  /// Gets or sets the top-left point for where the graph should be positioned when laid out.
  /// The default value for this property is the Point(0, 0).
  /// Setting this property to a new value invalidates this layout.
  /// This property is likely to be set by many Layouts that belong to a Group when the layout is performed.
  _i3.Point get arrangementOrigin => _i5.getProperty(
        this,
        'arrangementOrigin',
      );
  /* #23681
  source: 
    /**
     * Gets or sets the top-left point for where the graph should be positioned when laid out.
     * The default value for this property is the Point(0, 0).
     * Setting this property to a new value invalidates this layout.
     * This property is likely to be set by many Layouts that belong to a Group when the layout is performed.
     */
    get arrangementOrigin(): Point; */
  // Type Instance of 'InteropInterface'
  set arrangementOrigin(_i3.Point value) {
    _i5.setProperty(
      this,
      'arrangementOrigin',
      value,
    );
  }

  void cloneProtected(_i3.Layout copy) {
    _i5.callMethod(
      this,
      'cloneProtected',
      [copy],
    );
  }

  _i3.Layout copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  void invalidateLayout() {
    _i5.callMethod(
      this,
      'invalidateLayout',
      [],
    );
  }

  _i3.LayoutNetwork createNetwork() => _i5.callMethod(
        this,
        'createNetwork',
        [],
      );
  _i3.LayoutNetwork makeNetwork(_i2.Object coll) => _i5.callMethod(
        this,
        'makeNetwork',
        [coll],
      );
  void updateParts() {
    _i5.callMethod(
      this,
      'updateParts',
      [],
    );
  }

  void commitLayout() {
    _i5.callMethod(
      this,
      'commitLayout',
      [],
    );
  }

  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }

  _i3.Rect getLayoutBounds(
    _i3.Part part, [
    _i3.Rect? rect,
  ]) =>
      _i5.callMethod(
        this,
        'getLayoutBounds',
        [
          part,
          rect ?? _i4.undefined,
        ],
      );
  _i3.Set<_i3.Part> collectParts(_i2.Object coll) => _i5.callMethod(
        this,
        'collectParts',
        [coll],
      );
  _i3.Point initialOrigin(_i3.Point origin) => _i5.callMethod(
        this,
        'initialOrigin',
        [origin],
      );
}

@_i1.JS()
@_i1.staticInterop
class LayoutNetwork {
  factory LayoutNetwork(_i3.Layout layout) => _i5.callConstructor(
        _declaredLayoutNetwork,
        [layout],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayoutNetwork')
external _i2.Object _declaredLayoutNetwork;

extension LayoutNetwork$Typings on LayoutNetwork {
  /* #23728
  source: 
    /**
     * Gets the Layout that uses this network
     * of LayoutVertexes and LayoutEdges.
     * The default value is null.
     * It is set automatically for you when this setting Layout#network.
     */
    get layout(): Layout; */
  /// Gets the Layout that uses this network
  /// of LayoutVertexes and LayoutEdges.
  /// The default value is null.
  /// It is set automatically for you when this setting Layout#network.
  _i3.Layout get layout => _i5.getProperty(
        this,
        'layout',
      );
  /* #23728
  source: 
    /**
     * Gets the Layout that uses this network
     * of LayoutVertexes and LayoutEdges.
     * The default value is null.
     * It is set automatically for you when this setting Layout#network.
     */
    get layout(): Layout; */
  // Type Instance of 'InteropInterface'
  set layout(_i3.Layout value) {
    _i5.setProperty(
      this,
      'layout',
      value,
    );
  }

  /* #23735
  source: 
    /**
     * Gets a collection of all of the LayoutVertexes in this network.
     * Do not modify this collection directly.
     * Instead, call #addVertex, #deleteVertex, #addNode, or #deleteNode.
     */
    get vertexes(): Set<LayoutVertex>; */
  /// Gets a collection of all of the LayoutVertexes in this network.
  /// Do not modify this collection directly.
  /// Instead, call #addVertex, #deleteVertex, #addNode, or #deleteNode.
  _i3.Set<_i3.LayoutVertex> get vertexes => _i5.getProperty(
        this,
        'vertexes',
      );
  /* #23735
  source: 
    /**
     * Gets a collection of all of the LayoutVertexes in this network.
     * Do not modify this collection directly.
     * Instead, call #addVertex, #deleteVertex, #addNode, or #deleteNode.
     */
    get vertexes(): Set<LayoutVertex>; */
  // Type Instance of 'InteropInterface'
  set vertexes(_i3.Set<_i3.LayoutVertex> value) {
    _i5.setProperty(
      this,
      'vertexes',
      value,
    );
  }

  /* #23741
  source: 
    /**
     * Gets a collection of all of the LayoutEdges in this network.
     * Do not modify this collection directly.
     * Instead, call #addEdge, #deleteEdge, #addLink, or #deleteLink.
     */
    get edges(): Set<LayoutEdge>; */
  /// Gets a collection of all of the LayoutEdges in this network.
  /// Do not modify this collection directly.
  /// Instead, call #addEdge, #deleteEdge, #addLink, or #deleteLink.
  _i3.Set<_i3.LayoutEdge> get edges => _i5.getProperty(
        this,
        'edges',
      );
  /* #23741
  source: 
    /**
     * Gets a collection of all of the LayoutEdges in this network.
     * Do not modify this collection directly.
     * Instead, call #addEdge, #deleteEdge, #addLink, or #deleteLink.
     */
    get edges(): Set<LayoutEdge>; */
  // Type Instance of 'InteropInterface'
  set edges(_i3.Set<_i3.LayoutEdge> value) {
    _i5.setProperty(
      this,
      'edges',
      value,
    );
  }

  _i3.LayoutVertex createVertex() => _i5.callMethod(
        this,
        'createVertex',
        [],
      );
  _i3.LayoutEdge createEdge() => _i5.callMethod(
        this,
        'createEdge',
        [],
      );
  void addParts(
    _i3.Iterable<_i3.Part> parts, [
    _i2.bool? toplevelonly,
    _i2.bool Function(_i3.Part)? pred,
  ]) {
    _i5.callMethod(
      this,
      'addParts',
      [
        parts,
        toplevelonly ?? _i4.undefined,
        pred == null ? _i4.undefined : _i5.allowInterop(pred),
      ],
    );
  }

  void addVertex(_i3.LayoutVertex vertex) {
    _i5.callMethod(
      this,
      'addVertex',
      [vertex],
    );
  }

  _i3.LayoutVertex addNode(_i3.Node node) => _i5.callMethod(
        this,
        'addNode',
        [node],
      );
  void deleteVertex(_i3.LayoutVertex vertex) {
    _i5.callMethod(
      this,
      'deleteVertex',
      [vertex],
    );
  }

  void deleteNode(_i3.Node node) {
    _i5.callMethod(
      this,
      'deleteNode',
      [node],
    );
  }

  _i3.LayoutVertex? findVertex(_i3.Node node) => _i5.callMethod(
        this,
        'findVertex',
        [node],
      );
  void addEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'addEdge',
      [edge],
    );
  }

  _i3.LayoutEdge addLink(_i3.Link link) => _i5.callMethod(
        this,
        'addLink',
        [link],
      );
  void deleteEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'deleteEdge',
      [edge],
    );
  }

  void deleteLink(_i3.Link link) {
    _i5.callMethod(
      this,
      'deleteLink',
      [link],
    );
  }

  _i3.LayoutEdge? findEdge(_i3.Link link) => _i5.callMethod(
        this,
        'findEdge',
        [link],
      );
  _i3.LayoutEdge linkVertexes(
    _i3.LayoutVertex fromVertex,
    _i3.LayoutVertex toVertex, [
    _i3.Link? link,
  ]) =>
      _i5.callMethod(
        this,
        'linkVertexes',
        [
          fromVertex,
          toVertex,
          link ?? _i4.undefined,
        ],
      );
  void reverseEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'reverseEdge',
      [edge],
    );
  }

  void deleteSelfEdges() {
    _i5.callMethod(
      this,
      'deleteSelfEdges',
      [],
    );
  }

  void deleteArtificialVertexes() {
    _i5.callMethod(
      this,
      'deleteArtificialVertexes',
      [],
    );
  }

  _i3.List /*LIST InteropClass#847625641(name: List),39638134,[Instance of 'InteropRef<InteropType>']*/ <
      _i3.LayoutNetwork> splitIntoSubNetworks(
          [_i2.bool? clean]) =>
      _i5.callMethod(
        this,
        'splitIntoSubNetworks',
        [clean ?? _i4.undefined],
      );
  _i3.Set<_i3.Part> findAllParts() => _i5.callMethod(
        this,
        'findAllParts',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class LayoutVertex {
  factory LayoutVertex(_i3.LayoutNetwork network) => _i5.callConstructor(
        _declaredLayoutVertex,
        [network],
      );

  static _i2.num standardComparer(
    _i3.LayoutVertex m,
    _i3.LayoutVertex n,
  ) =>
      _i5.callMethod(
        _declaredLayoutVertex,
        'standardComparer',
        [
          m,
          n,
        ],
      );
  static _i2.num smartComparer(
    _i3.LayoutVertex m,
    _i3.LayoutVertex n,
  ) =>
      _i5.callMethod(
        _declaredLayoutVertex,
        'smartComparer',
        [
          m,
          n,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayoutVertex')
external _i2.Object _declaredLayoutVertex;

extension LayoutVertex$Typings on LayoutVertex {
  /* #23907
  source: 
    /**
     * (undocumented)
     */
    get sourceEdgesArrayAccess(): Array<LayoutEdge>; */
  /// (undocumented)
  _i4.Array get sourceEdgesArrayAccess => _i5.getProperty(
        this,
        'sourceEdgesArrayAccess',
      );
  /* #23907
  source: 
    /**
     * (undocumented)
     */
    get sourceEdgesArrayAccess(): Array<LayoutEdge>; */
  // Type Instance of 'ExternalInteropType'
  set sourceEdgesArrayAccess(_i4.Array value) {
    _i5.setProperty(
      this,
      'sourceEdgesArrayAccess',
      value,
    );
  }

  /* #23911
  source: 
    /**
     * (undocumented)
     */
    get destinationEdgesArrayAccess(): Array<LayoutEdge>; */
  /// (undocumented)
  _i4.Array get destinationEdgesArrayAccess => _i5.getProperty(
        this,
        'destinationEdgesArrayAccess',
      );
  /* #23911
  source: 
    /**
     * (undocumented)
     */
    get destinationEdgesArrayAccess(): Array<LayoutEdge>; */
  // Type Instance of 'ExternalInteropType'
  set destinationEdgesArrayAccess(_i4.Array value) {
    _i5.setProperty(
      this,
      'destinationEdgesArrayAccess',
      value,
    );
  }

  /* #23922
  source: 
    /**
     * Gets or sets the data object in the model that should be associated with this vertex, if any.
     * The value will be non-null if this vertex is virtualized,
     * not represented by a real Node in the Diagram.
     * Each data object should have a 'bounds' property that is a Rect
     * or any JavaScript Object with 'x', 'y', 'width', and 'height' properties that are real numbers,
     * and non-negative numbers for the width and the height.
     * Setting this data property will also set the #bounds and #focus properties.
     * @since 1.6
     */
    get data(): ObjectData | null; */
  /// Gets or sets the data object in the model that should be associated with this vertex, if any.
  /// The value will be non-null if this vertex is virtualized,
  /// not represented by a real Node in the Diagram.
  /// Each data object should have a 'bounds' property that is a Rect
  /// or any JavaScript Object with 'x', 'y', 'width', and 'height' properties that are real numbers,
  /// and non-negative numbers for the width and the height.
  /// Setting this data property will also set the #bounds and #focus properties.
  _i2.Object? get data => _i5.getProperty(
        this,
        'data',
      );
  /* #23922
  source: 
    /**
     * Gets or sets the data object in the model that should be associated with this vertex, if any.
     * The value will be non-null if this vertex is virtualized,
     * not represented by a real Node in the Diagram.
     * Each data object should have a 'bounds' property that is a Rect
     * or any JavaScript Object with 'x', 'y', 'width', and 'height' properties that are real numbers,
     * and non-negative numbers for the width and the height.
     * Setting this data property will also set the #bounds and #focus properties.
     * @since 1.6
     */
    get data(): ObjectData | null; */
  // Type InteropUnion#1000427547(parent: InteropGetter#681059056(name: data))
  set data(_i2.Object? value) {
    _i5.setProperty(
      this,
      'data',
      value ?? _i4.undefined,
    );
  }

  /* #23932
  source: 
    /**
     * Gets or sets the Node associated with this vertex, if any.
     * The value may be null if this vertex is a "dummy" vertex,
     * not represented by a real Node in the Diagram.
     *
     * This property setter also sets the #bounds and #focus properties
     * according to the value of the Node's actualBounds and its Part#locationObject's center point.
     */
    get node(): Node | null; */
  /// Gets or sets the Node associated with this vertex, if any.
  /// The value may be null if this vertex is a "dummy" vertex,
  /// not represented by a real Node in the Diagram.
  ///
  /// This property setter also sets the #bounds and #focus properties
  /// according to the value of the Node's actualBounds and its Part#locationObject's center point.
  _i3.Node? get node => _i5.getProperty(
        this,
        'node',
      );
  /* #23932
  source: 
    /**
     * Gets or sets the Node associated with this vertex, if any.
     * The value may be null if this vertex is a "dummy" vertex,
     * not represented by a real Node in the Diagram.
     *
     * This property setter also sets the #bounds and #focus properties
     * according to the value of the Node's actualBounds and its Part#locationObject's center point.
     */
    get node(): Node | null; */
  // Type InteropUnion#135713144(parent: InteropGetter#371565065(name: node))
  set node(_i3.Node? value) {
    _i5.setProperty(
      this,
      'node',
      value ?? _i4.undefined,
    );
  }

  /* #23940
  source: 
    /**
     * Gets or sets the bounds of this vertex, in document coordinates.
     * Setting this property does not directly modify the position of any Node,
     * but it will modify the value of #centerX and #centerY,
     * as well as the subsidiary convenience properties #x, #y, #width, and #height.
     */
    get bounds(): Rect; */
  /// Gets or sets the bounds of this vertex, in document coordinates.
  /// Setting this property does not directly modify the position of any Node,
  /// but it will modify the value of #centerX and #centerY,
  /// as well as the subsidiary convenience properties #x, #y, #width, and #height.
  _i3.Rect get bounds => _i5.getProperty(
        this,
        'bounds',
      );
  /* #23940
  source: 
    /**
     * Gets or sets the bounds of this vertex, in document coordinates.
     * Setting this property does not directly modify the position of any Node,
     * but it will modify the value of #centerX and #centerY,
     * as well as the subsidiary convenience properties #x, #y, #width, and #height.
     */
    get bounds(): Rect; */
  // Type Instance of 'InteropInterface'
  set bounds(_i3.Rect value) {
    _i5.setProperty(
      this,
      'bounds',
      value,
    );
  }

  /* #23950
  source: 
    /**
     * Gets or sets the offset of the #focusX and #focusY
     * from the #bounds position.
     * Setting this property does not directly modify the position of any Node,
     * but it does affect the value of #centerX and #centerY.
     *
     * The "focus" is normally the center of the Node's Part#locationObject.
     */
    get focus(): Point; */
  /// Gets or sets the offset of the #focusX and #focusY
  /// from the #bounds position.
  /// Setting this property does not directly modify the position of any Node,
  /// but it does affect the value of #centerX and #centerY.
  ///
  /// The "focus" is normally the center of the Node's Part#locationObject.
  _i3.Point get focus => _i5.getProperty(
        this,
        'focus',
      );
  /* #23950
  source: 
    /**
     * Gets or sets the offset of the #focusX and #focusY
     * from the #bounds position.
     * Setting this property does not directly modify the position of any Node,
     * but it does affect the value of #centerX and #centerY.
     *
     * The "focus" is normally the center of the Node's Part#locationObject.
     */
    get focus(): Point; */
  // Type Instance of 'InteropInterface'
  set focus(_i3.Point value) {
    _i5.setProperty(
      this,
      'focus',
      value,
    );
  }

  /* #23958
  source: 
    /**
     * Gets or sets the center Point#x of this vertex, in document coordinates.
     * This property depends on both #bounds and #focus.
     * Setting this property does not modify the position of any Node,
     * but it will modify the value of #bounds.
     */
    get centerX(): number; */
  /// Gets or sets the center Point#x of this vertex, in document coordinates.
  /// This property depends on both #bounds and #focus.
  /// Setting this property does not modify the position of any Node,
  /// but it will modify the value of #bounds.
  _i2.num get centerX => _i5.getProperty(
        this,
        'centerX',
      );
  /* #23958
  source: 
    /**
     * Gets or sets the center Point#x of this vertex, in document coordinates.
     * This property depends on both #bounds and #focus.
     * Setting this property does not modify the position of any Node,
     * but it will modify the value of #bounds.
     */
    get centerX(): number; */
  // Type InteropStaticType.number
  set centerX(_i2.num value) {
    _i5.setProperty(
      this,
      'centerX',
      value,
    );
  }

  /* #23966
  source: 
    /**
     * Gets or sets the center Point#y of this vertex, in document coordinates.
     * This property depends on both #bounds and #focus.
     * Setting this property does not modify the position of any Node,
     * but it will modify the value of #bounds.
     */
    get centerY(): number; */
  /// Gets or sets the center Point#y of this vertex, in document coordinates.
  /// This property depends on both #bounds and #focus.
  /// Setting this property does not modify the position of any Node,
  /// but it will modify the value of #bounds.
  _i2.num get centerY => _i5.getProperty(
        this,
        'centerY',
      );
  /* #23966
  source: 
    /**
     * Gets or sets the center Point#y of this vertex, in document coordinates.
     * This property depends on both #bounds and #focus.
     * Setting this property does not modify the position of any Node,
     * but it will modify the value of #bounds.
     */
    get centerY(): number; */
  // Type InteropStaticType.number
  set centerY(_i2.num value) {
    _i5.setProperty(
      this,
      'centerY',
      value,
    );
  }

  /* #23971
  source: 
    /**
     * Gets or sets the relative X position of the "center" point, the focus.
     */
    get focusX(): number; */
  /// Gets or sets the relative X position of the "center" point, the focus.
  _i2.num get focusX => _i5.getProperty(
        this,
        'focusX',
      );
  /* #23971
  source: 
    /**
     * Gets or sets the relative X position of the "center" point, the focus.
     */
    get focusX(): number; */
  // Type InteropStaticType.number
  set focusX(_i2.num value) {
    _i5.setProperty(
      this,
      'focusX',
      value,
    );
  }

  /* #23976
  source: 
    /**
     * Gets or sets the relative Y position of the "center" point, the focus.
     */
    get focusY(): number; */
  /// Gets or sets the relative Y position of the "center" point, the focus.
  _i2.num get focusY => _i5.getProperty(
        this,
        'focusY',
      );
  /* #23976
  source: 
    /**
     * Gets or sets the relative Y position of the "center" point, the focus.
     */
    get focusY(): number; */
  // Type InteropStaticType.number
  set focusY(_i2.num value) {
    _i5.setProperty(
      this,
      'focusY',
      value,
    );
  }

  /* #23981
  source: 
    /**
     * Gets or sets the left point of this vertex.
     */
    get x(): number; */
  /// Gets or sets the left point of this vertex.
  _i2.num get x => _i5.getProperty(
        this,
        'x',
      );
  /* #23981
  source: 
    /**
     * Gets or sets the left point of this vertex.
     */
    get x(): number; */
  // Type InteropStaticType.number
  set x(_i2.num value) {
    _i5.setProperty(
      this,
      'x',
      value,
    );
  }

  /* #23986
  source: 
    /**
     * Gets or sets the top point of this vertex.
     */
    get y(): number; */
  /// Gets or sets the top point of this vertex.
  _i2.num get y => _i5.getProperty(
        this,
        'y',
      );
  /* #23986
  source: 
    /**
     * Gets or sets the top point of this vertex.
     */
    get y(): number; */
  // Type InteropStaticType.number
  set y(_i2.num value) {
    _i5.setProperty(
      this,
      'y',
      value,
    );
  }

  /* #23992
  source: 
    /**
     * Gets or sets the width of this vertex.
     * This is always the horizontal distance reserved for the node.
     */
    get width(): number; */
  /// Gets or sets the width of this vertex.
  /// This is always the horizontal distance reserved for the node.
  _i2.num get width => _i5.getProperty(
        this,
        'width',
      );
  /* #23992
  source: 
    /**
     * Gets or sets the width of this vertex.
     * This is always the horizontal distance reserved for the node.
     */
    get width(): number; */
  // Type InteropStaticType.number
  set width(_i2.num value) {
    _i5.setProperty(
      this,
      'width',
      value,
    );
  }

  /* #23998
  source: 
    /**
     * Gets or sets the height of this vertex.
     * This is always the vertical distance reserved for the node.
     */
    get height(): number; */
  /// Gets or sets the height of this vertex.
  /// This is always the vertical distance reserved for the node.
  _i2.num get height => _i5.getProperty(
        this,
        'height',
      );
  /* #23998
  source: 
    /**
     * Gets or sets the height of this vertex.
     * This is always the vertical distance reserved for the node.
     */
    get height(): number; */
  // Type InteropStaticType.number
  set height(_i2.num value) {
    _i5.setProperty(
      this,
      'height',
      value,
    );
  }

  /* #24044
  source: 
    /**
     * Gets the LayoutNetwork that owns this vertex.
     * The default value is null.
     * It is set automatically for you in LayoutNetwork#createVertex.
     */
    get network(): LayoutNetwork; */
  /// Gets the LayoutNetwork that owns this vertex.
  /// The default value is null.
  /// It is set automatically for you in LayoutNetwork#createVertex.
  _i3.LayoutNetwork get network => _i5.getProperty(
        this,
        'network',
      );
  /* #24044
  source: 
    /**
     * Gets the LayoutNetwork that owns this vertex.
     * The default value is null.
     * It is set automatically for you in LayoutNetwork#createVertex.
     */
    get network(): LayoutNetwork; */
  // Type Instance of 'InteropInterface'
  set network(_i3.LayoutNetwork value) {
    _i5.setProperty(
      this,
      'network',
      value,
    );
  }

  /* #24052
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected with edges coming into this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#sourceEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get sourceVertexes(): Iterator<LayoutVertex>; */
  /// This read-only property returns an iterator for all of the vertexes that are connected with edges coming into this vertex.
  ///
  /// Note that this is inefficient compared to iterating over the edges (#sourceEdges) due to the need
  /// to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
  _i3.Iterator<_i3.LayoutVertex> get sourceVertexes => _i5.getProperty(
        this,
        'sourceVertexes',
      );
  /* #24052
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected with edges coming into this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#sourceEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get sourceVertexes(): Iterator<LayoutVertex>; */
  // Type Instance of 'InteropInterface'
  set sourceVertexes(_i3.Iterator<_i3.LayoutVertex> value) {
    _i5.setProperty(
      this,
      'sourceVertexes',
      value,
    );
  }

  /* #24059
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected with edges going out of this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#destinationEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get destinationVertexes(): Iterator<LayoutVertex>; */
  /// This read-only property returns an iterator for all of the vertexes that are connected with edges going out of this vertex.
  ///
  /// Note that this is inefficient compared to iterating over the edges (#destinationEdges) due to the need
  /// to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
  _i3.Iterator<_i3.LayoutVertex> get destinationVertexes => _i5.getProperty(
        this,
        'destinationVertexes',
      );
  /* #24059
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected with edges going out of this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#destinationEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get destinationVertexes(): Iterator<LayoutVertex>; */
  // Type Instance of 'InteropInterface'
  set destinationVertexes(_i3.Iterator<_i3.LayoutVertex> value) {
    _i5.setProperty(
      this,
      'destinationVertexes',
      value,
    );
  }

  /* #24066
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected in either direction with this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#sourceEdges and #destinationEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get vertexes(): Iterator<LayoutVertex>; */
  /// This read-only property returns an iterator for all of the vertexes that are connected in either direction with this vertex.
  ///
  /// Note that this is inefficient compared to iterating over the edges (#sourceEdges and #destinationEdges) due to the need
  /// to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
  _i3.Iterator<_i3.LayoutVertex> get vertexes => _i5.getProperty(
        this,
        'vertexes',
      );
  /* #24066
  source: 
    /**
     * This read-only property returns an iterator for all of the vertexes that are connected in either direction with this vertex.
     *
     * Note that this is inefficient compared to iterating over the edges (#sourceEdges and #destinationEdges) due to the need
     * to avoid duplicate vertexes if there happen to be multiple edges connecting with the same vertex.
     */
    get vertexes(): Iterator<LayoutVertex>; */
  // Type Instance of 'InteropInterface'
  set vertexes(_i3.Iterator<_i3.LayoutVertex> value) {
    _i5.setProperty(
      this,
      'vertexes',
      value,
    );
  }

  /* #24070
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that come into this vertex.
     */
    get sourceEdges(): Iterator<LayoutEdge>; */
  /// This read-only property returns an iterator for all of the edges that come into this vertex.
  _i3.Iterator<_i3.LayoutEdge> get sourceEdges => _i5.getProperty(
        this,
        'sourceEdges',
      );
  /* #24070
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that come into this vertex.
     */
    get sourceEdges(): Iterator<LayoutEdge>; */
  // Type Instance of 'InteropInterface'
  set sourceEdges(_i3.Iterator<_i3.LayoutEdge> value) {
    _i5.setProperty(
      this,
      'sourceEdges',
      value,
    );
  }

  /* #24074
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that go out of this vertex.
     */
    get destinationEdges(): Iterator<LayoutEdge>; */
  /// This read-only property returns an iterator for all of the edges that go out of this vertex.
  _i3.Iterator<_i3.LayoutEdge> get destinationEdges => _i5.getProperty(
        this,
        'destinationEdges',
      );
  /* #24074
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that go out of this vertex.
     */
    get destinationEdges(): Iterator<LayoutEdge>; */
  // Type Instance of 'InteropInterface'
  set destinationEdges(_i3.Iterator<_i3.LayoutEdge> value) {
    _i5.setProperty(
      this,
      'destinationEdges',
      value,
    );
  }

  /* #24080
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that are connected with this vertex in either direction.
     *
     * Note that this is inefficient compared to iterating over the edges: #sourceEdges and #destinationEdges.
     */
    get edges(): Iterator<LayoutEdge>; */
  /// This read-only property returns an iterator for all of the edges that are connected with this vertex in either direction.
  ///
  /// Note that this is inefficient compared to iterating over the edges: #sourceEdges and #destinationEdges.
  _i3.Iterator<_i3.LayoutEdge> get edges => _i5.getProperty(
        this,
        'edges',
      );
  /* #24080
  source: 
    /**
     * This read-only property returns an iterator for all of the edges that are connected with this vertex in either direction.
     *
     * Note that this is inefficient compared to iterating over the edges: #sourceEdges and #destinationEdges.
     */
    get edges(): Iterator<LayoutEdge>; */
  // Type Instance of 'InteropInterface'
  set edges(_i3.Iterator<_i3.LayoutEdge> value) {
    _i5.setProperty(
      this,
      'edges',
      value,
    );
  }

  /* #24084
  source: 
    /**
     * This read-only property returns the total number of edges that are connected with this vertex in either direction.
     */
    get edgesCount(): number; */
  /// This read-only property returns the total number of edges that are connected with this vertex in either direction.
  _i2.num get edgesCount => _i5.getProperty(
        this,
        'edgesCount',
      );
  /* #24084
  source: 
    /**
     * This read-only property returns the total number of edges that are connected with this vertex in either direction.
     */
    get edgesCount(): number; */
  // Type InteropStaticType.number
  set edgesCount(_i2.num value) {
    _i5.setProperty(
      this,
      'edgesCount',
      value,
    );
  }

  void commit() {
    _i5.callMethod(
      this,
      'commit',
      [],
    );
  }

  void addSourceEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'addSourceEdge',
      [edge],
    );
  }

  void deleteSourceEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'deleteSourceEdge',
      [edge],
    );
  }

  void addDestinationEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'addDestinationEdge',
      [edge],
    );
  }

  void deleteDestinationEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'deleteDestinationEdge',
      [edge],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class LayoutEdge {
  factory LayoutEdge(_i3.LayoutNetwork network) => _i5.callConstructor(
        _declaredLayoutEdge,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayoutEdge')
external _i2.Object _declaredLayoutEdge;

extension LayoutEdge$Typings on LayoutEdge {
  /* #24146
  source: 
    /**
     * Gets the LayoutNetwork that owns this edge.
     * The default value is null.
     * It is set automatically for you in LayoutNetwork#createEdge.
     */
    get network(): LayoutNetwork; */
  /// Gets the LayoutNetwork that owns this edge.
  /// The default value is null.
  /// It is set automatically for you in LayoutNetwork#createEdge.
  _i3.LayoutNetwork get network => _i5.getProperty(
        this,
        'network',
      );
  /* #24146
  source: 
    /**
     * Gets the LayoutNetwork that owns this edge.
     * The default value is null.
     * It is set automatically for you in LayoutNetwork#createEdge.
     */
    get network(): LayoutNetwork; */
  // Type Instance of 'InteropInterface'
  set network(_i3.LayoutNetwork value) {
    _i5.setProperty(
      this,
      'network',
      value,
    );
  }

  /* #24152
  source: 
    /**
     * For virtualized layouts working on model data instead of a Link.
     * @since 1.6
     */
    get data(): ObjectData | null; */
  /// For virtualized layouts working on model data instead of a Link.
  _i2.Object? get data => _i5.getProperty(
        this,
        'data',
      );
  /* #24152
  source: 
    /**
     * For virtualized layouts working on model data instead of a Link.
     * @since 1.6
     */
    get data(): ObjectData | null; */
  // Type InteropUnion#374063993(parent: InteropGetter#165059946(name: data))
  set data(_i2.Object? value) {
    _i5.setProperty(
      this,
      'data',
      value ?? _i4.undefined,
    );
  }

  /* #24159
  source: 
    /**
     * Gets or sets the Link associated with this edge, if any.
     * The value may be null if this edge is a "dummy" edge,
     * not represented by a real Link in the Diagram.
     */
    get link(): Link | null; */
  /// Gets or sets the Link associated with this edge, if any.
  /// The value may be null if this edge is a "dummy" edge,
  /// not represented by a real Link in the Diagram.
  _i3.Link? get link => _i5.getProperty(
        this,
        'link',
      );
  /* #24159
  source: 
    /**
     * Gets or sets the Link associated with this edge, if any.
     * The value may be null if this edge is a "dummy" edge,
     * not represented by a real Link in the Diagram.
     */
    get link(): Link | null; */
  // Type InteropUnion#893362165(parent: InteropGetter#87281765(name: link))
  set link(_i3.Link? value) {
    _i5.setProperty(
      this,
      'link',
      value ?? _i4.undefined,
    );
  }

  /* #24165
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): LayoutVertex | null; */
  /// Gets or sets the LayoutVertex that this edge comes from.
  /// Setting this property does not change any LayoutVertex#destinationEdges collection.
  _i3.LayoutVertex? get fromVertex => _i5.getProperty(
        this,
        'fromVertex',
      );
  /* #24165
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): LayoutVertex | null; */
  // Type InteropUnion#1022527231(parent: InteropGetter#487527128(name: fromVertex))
  set fromVertex(_i3.LayoutVertex? value) {
    _i5.setProperty(
      this,
      'fromVertex',
      value ?? _i4.undefined,
    );
  }

  /* #24171
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): LayoutVertex | null; */
  /// Gets or sets the LayoutVertex that this edge goes to.
  /// Setting this property does not change any LayoutVertex#sourceEdges collection.
  _i3.LayoutVertex? get toVertex => _i5.getProperty(
        this,
        'toVertex',
      );
  /* #24171
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): LayoutVertex | null; */
  // Type InteropUnion#48002475(parent: InteropGetter#958415454(name: toVertex))
  set toVertex(_i3.LayoutVertex? value) {
    _i5.setProperty(
      this,
      'toVertex',
      value ?? _i4.undefined,
    );
  }

  void commit() {
    _i5.callMethod(
      this,
      'commit',
      [],
    );
  }

  _i3.LayoutVertex? getOtherVertex(_i3.LayoutVertex v) => _i5.callMethod(
        this,
        'getOtherVertex',
        [v],
      );
}

@_i1.JS()
@_i1.staticInterop
class GridLayout implements _i3.Layout {
  factory GridLayout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredGridLayout,
        [init ?? _i4.undefined],
      );

  /* #24309
  source: 
    /**
     * Position the top-left corner of each part at a grid point;
     * This value is used for GridLayout#alignment.
     * @constant
     */
    static Position: EnumValue; */
  /// Position the top-left corner of each part at a grid point;
  /// This value is used for GridLayout#alignment.
  static _i3.EnumValue get position => _i5.getProperty(
        _declaredGridLayout,
        'Position',
      );
  /* #24309
  source: 
    /**
     * Position the top-left corner of each part at a grid point;
     * This value is used for GridLayout#alignment.
     * @constant
     */
    static Position: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set position(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Position',
      value,
    );
  }

  /* #24315
  source: 
    /**
     * Position the part's Part#location at a grid point;
     * This value is used for GridLayout#alignment.
     * @constant
     */
    static Location: EnumValue; */
  /// Position the part's Part#location at a grid point;
  /// This value is used for GridLayout#alignment.
  static _i3.EnumValue get location => _i5.getProperty(
        _declaredGridLayout,
        'Location',
      );
  /* #24315
  source: 
    /**
     * Position the part's Part#location at a grid point;
     * This value is used for GridLayout#alignment.
     * @constant
     */
    static Location: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set location(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Location',
      value,
    );
  }

  /* #24321
  source: 
    /**
     * Fill each row from left to right;
     * This value is used for GridLayout#arrangement.
     * @constant
     */
    static LeftToRight: EnumValue; */
  /// Fill each row from left to right;
  /// This value is used for GridLayout#arrangement.
  static _i3.EnumValue get leftToRight => _i5.getProperty(
        _declaredGridLayout,
        'LeftToRight',
      );
  /* #24321
  source: 
    /**
     * Fill each row from left to right;
     * This value is used for GridLayout#arrangement.
     * @constant
     */
    static LeftToRight: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set leftToRight(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'LeftToRight',
      value,
    );
  }

  /* #24327
  source: 
    /**
     * Fill each row from right to left;
     * This value is used for GridLayout#arrangement.
     * @constant
     */
    static RightToLeft: EnumValue; */
  /// Fill each row from right to left;
  /// This value is used for GridLayout#arrangement.
  static _i3.EnumValue get rightToLeft => _i5.getProperty(
        _declaredGridLayout,
        'RightToLeft',
      );
  /* #24327
  source: 
    /**
     * Fill each row from right to left;
     * This value is used for GridLayout#arrangement.
     * @constant
     */
    static RightToLeft: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set rightToLeft(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'RightToLeft',
      value,
    );
  }

  /* #24333
  source: 
    /**
     * Lay out each child in the order in which they were found;
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Forward: EnumValue; */
  /// Lay out each child in the order in which they were found;
  /// This value is used for GridLayout#sorting.
  static _i3.EnumValue get forward => _i5.getProperty(
        _declaredGridLayout,
        'Forward',
      );
  /* #24333
  source: 
    /**
     * Lay out each child in the order in which they were found;
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Forward: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set forward(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Forward',
      value,
    );
  }

  /* #24339
  source: 
    /**
     * Lay out each child in reverse order from which they were found;
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Reverse: EnumValue; */
  /// Lay out each child in reverse order from which they were found;
  /// This value is used for GridLayout#sorting.
  static _i3.EnumValue get reverse => _i5.getProperty(
        _declaredGridLayout,
        'Reverse',
      );
  /* #24339
  source: 
    /**
     * Lay out each child in reverse order from which they were found;
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Reverse: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set reverse(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Reverse',
      value,
    );
  }

  /* #24345
  source: 
    /**
     * Lay out each child according to the sort order given by GridLayout#comparer
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Ascending: EnumValue; */
  /// Lay out each child according to the sort order given by GridLayout#comparer
  /// This value is used for GridLayout#sorting.
  static _i3.EnumValue get ascending => _i5.getProperty(
        _declaredGridLayout,
        'Ascending',
      );
  /* #24345
  source: 
    /**
     * Lay out each child according to the sort order given by GridLayout#comparer
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Ascending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set ascending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Ascending',
      value,
    );
  }

  /* #24351
  source: 
    /**
     * Lay out each child in reverse sort order given by GridLayout#comparer
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Descending: EnumValue; */
  /// Lay out each child in reverse sort order given by GridLayout#comparer
  /// This value is used for GridLayout#sorting.
  static _i3.EnumValue get descending => _i5.getProperty(
        _declaredGridLayout,
        'Descending',
      );
  /* #24351
  source: 
    /**
     * Lay out each child in reverse sort order given by GridLayout#comparer
     * This value is used for GridLayout#sorting.
     * @constant
     */
    static Descending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set descending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredGridLayout,
      'Descending',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('GridLayout')
external _i2.Object _declaredGridLayout;

extension GridLayout$Typings on GridLayout {
  /* #24226
  source: 
    /**
     * Gets or sets the wrapping width.
     *
     * The default is NaN, meaning to use the width of the diagram's panel's viewport.
     * Must be a value greater than 0.
     */
    get wrappingWidth(): number; */
  /// Gets or sets the wrapping width.
  ///
  /// The default is NaN, meaning to use the width of the diagram's panel's viewport.
  /// Must be a value greater than 0.
  _i2.num get wrappingWidth => _i5.getProperty(
        this,
        'wrappingWidth',
      );
  /* #24226
  source: 
    /**
     * Gets or sets the wrapping width.
     *
     * The default is NaN, meaning to use the width of the diagram's panel's viewport.
     * Must be a value greater than 0.
     */
    get wrappingWidth(): number; */
  // Type InteropStaticType.number
  set wrappingWidth(_i2.num value) {
    _i5.setProperty(
      this,
      'wrappingWidth',
      value,
    );
  }

  /* #24234
  source: 
    /**
     * Gets or sets the maximum number of columns.
     *
     * The default is NaN, meaning not to limit the number of columns.
     * 1 is a common value to produce a single column of parts.
     */
    get wrappingColumn(): number; */
  /// Gets or sets the maximum number of columns.
  ///
  /// The default is NaN, meaning not to limit the number of columns.
  /// 1 is a common value to produce a single column of parts.
  _i2.num get wrappingColumn => _i5.getProperty(
        this,
        'wrappingColumn',
      );
  /* #24234
  source: 
    /**
     * Gets or sets the maximum number of columns.
     *
     * The default is NaN, meaning not to limit the number of columns.
     * 1 is a common value to produce a single column of parts.
     */
    get wrappingColumn(): number; */
  // Type InteropStaticType.number
  set wrappingColumn(_i2.num value) {
    _i5.setProperty(
      this,
      'wrappingColumn',
      value,
    );
  }

  /* #24246
  source: 
    /**
     * Gets or sets the minimum part size by which each part is positioned in the grid.
     *
     * The default value is NaN x NaN.
     * The units are in document coordinates.
     *
     * When the cell size is smaller than a part, the part will occupy more than one cell.
     * This allows parts to be positioned closer to each other, but then variations in part
     * sizes may cause them not to be aligned in perfect rows or columns.
     */
    get cellSize(): Size; */
  /// Gets or sets the minimum part size by which each part is positioned in the grid.
  ///
  /// The default value is NaN x NaN.
  /// The units are in document coordinates.
  ///
  /// When the cell size is smaller than a part, the part will occupy more than one cell.
  /// This allows parts to be positioned closer to each other, but then variations in part
  /// sizes may cause them not to be aligned in perfect rows or columns.
  _i3.Size get cellSize => _i5.getProperty(
        this,
        'cellSize',
      );
  /* #24246
  source: 
    /**
     * Gets or sets the minimum part size by which each part is positioned in the grid.
     *
     * The default value is NaN x NaN.
     * The units are in document coordinates.
     *
     * When the cell size is smaller than a part, the part will occupy more than one cell.
     * This allows parts to be positioned closer to each other, but then variations in part
     * sizes may cause them not to be aligned in perfect rows or columns.
     */
    get cellSize(): Size; */
  // Type Instance of 'InteropInterface'
  set cellSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'cellSize',
      value,
    );
  }

  /* #24254
  source: 
    /**
     * Gets or sets the minimum horizontal and vertical space between parts.
     *
     * The default value is 10 x 10.
     * The units are in document coordinates.
     */
    get spacing(): Size; */
  /// Gets or sets the minimum horizontal and vertical space between parts.
  ///
  /// The default value is 10 x 10.
  /// The units are in document coordinates.
  _i3.Size get spacing => _i5.getProperty(
        this,
        'spacing',
      );
  /* #24254
  source: 
    /**
     * Gets or sets the minimum horizontal and vertical space between parts.
     *
     * The default value is 10 x 10.
     * The units are in document coordinates.
     */
    get spacing(): Size; */
  // Type Instance of 'InteropInterface'
  set spacing(_i3.Size value) {
    _i5.setProperty(
      this,
      'spacing',
      value,
    );
  }

  /* #24263
  source: 
    /**
     * Gets or sets whether the Part#location or the position should be used
     * to arrange each part.
     *
     * The default value is GridLayout.Location -- the Part#locations will
     * be aligned in a grid.
     */
    get alignment(): EnumValue; */
  /// Gets or sets whether the Part#location or the position should be used
  /// to arrange each part.
  ///
  /// The default value is GridLayout.Location -- the Part#locations will
  /// be aligned in a grid.
  _i3.EnumValue get alignment => _i5.getProperty(
        this,
        'alignment',
      );
  /* #24263
  source: 
    /**
     * Gets or sets whether the Part#location or the position should be used
     * to arrange each part.
     *
     * The default value is GridLayout.Location -- the Part#locations will
     * be aligned in a grid.
     */
    get alignment(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alignment(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alignment',
      value,
    );
  }

  /* #24271
  source: 
    /**
     * Gets or sets how to arrange the parts.
     * Must be GridLayout.LeftToRight or GridLayout.RightToLeft.
     *
     * The default value is GridLayout.LeftToRight.
     */
    get arrangement(): EnumValue; */
  /// Gets or sets how to arrange the parts.
  /// Must be GridLayout.LeftToRight or GridLayout.RightToLeft.
  ///
  /// The default value is GridLayout.LeftToRight.
  _i3.EnumValue get arrangement => _i5.getProperty(
        this,
        'arrangement',
      );
  /* #24271
  source: 
    /**
     * Gets or sets how to arrange the parts.
     * Must be GridLayout.LeftToRight or GridLayout.RightToLeft.
     *
     * The default value is GridLayout.LeftToRight.
     */
    get arrangement(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set arrangement(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'arrangement',
      value,
    );
  }

  /* #24280
  source: 
    /**
     * Gets or sets what order to place the parts.
     * Must be GridLayout.Forward, GridLayout.Reverse,
     * GridLayout.Ascending, or GridLayout.Descending.
     *
     * The default value is GridLayout.Ascending.
     */
    get sorting(): EnumValue; */
  /// Gets or sets what order to place the parts.
  /// Must be GridLayout.Forward, GridLayout.Reverse,
  /// GridLayout.Ascending, or GridLayout.Descending.
  ///
  /// The default value is GridLayout.Ascending.
  _i3.EnumValue get sorting => _i5.getProperty(
        this,
        'sorting',
      );
  /* #24280
  source: 
    /**
     * Gets or sets what order to place the parts.
     * Must be GridLayout.Forward, GridLayout.Reverse,
     * GridLayout.Ascending, or GridLayout.Descending.
     *
     * The default value is GridLayout.Ascending.
     */
    get sorting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set sorting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'sorting',
      value,
    );
  }

  /* #24302
  source: 
    /**
     * Gets or sets the comparison function used to sort the parts.
     *
     * The default value is a case-insensitive alphabetic comparison
     * using the Part#text property of each part.
     * ```js
     *   $(go.GridLayout,
     *     {
     *       sorting: go.GridLayout.Ascending,
     *       comparer: (pa, pb) => {
     *         var da = pa.data;
     *         var db = pb.data;
     *         if (da.someProperty < db.someProperty) return -1;
     *         if (da.someProperty > db.someProperty) return 1;
     *         return 0;
     *       }
     *     }
     *   )
     * ```
     */
    get comparer(): ((a: Part, b: Part) => number); */
  /// Gets or sets the comparison function used to sort the parts.
  ///
  /// The default value is a case-insensitive alphabetic comparison
  /// using the Part#text property of each part.
  /// ```js
  ///   $(go.GridLayout,
  ///     {
  ///       sorting: go.GridLayout.Ascending,
  ///       comparer: (pa, pb) => {
  ///         var da = pa.data;
  ///         var db = pb.data;
  ///         if (da.someProperty < db.someProperty) return -1;
  ///         if (da.someProperty > db.someProperty) return 1;
  ///         return 0;
  ///       }
  ///     }
  ///   )
  /// ```
  _i2.num Function(
    _i3.Part,
    _i3.Part,
  ) get comparer => _i5.getProperty(
        this,
        'comparer',
      );
  /* #24302
  source: 
    /**
     * Gets or sets the comparison function used to sort the parts.
     *
     * The default value is a case-insensitive alphabetic comparison
     * using the Part#text property of each part.
     * ```js
     *   $(go.GridLayout,
     *     {
     *       sorting: go.GridLayout.Ascending,
     *       comparer: (pa, pb) => {
     *         var da = pa.data;
     *         var db = pb.data;
     *         if (da.someProperty < db.someProperty) return -1;
     *         if (da.someProperty > db.someProperty) return 1;
     *         return 0;
     *       }
     *     }
     *   )
     * ```
     */
    get comparer(): ((a: Part, b: Part) => number); */
  // Type InteropFunction#507218598(parent: InteropGetter#387653343(name: comparer), library: go.d.ts)
  set comparer(
      _i2.num Function(
        _i3.Part,
        _i3.Part,
      ) value) {
    _i5.setProperty(
      this,
      'comparer',
      _i5.allowInterop(value),
    );
  }

  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IncrementalData {
  external factory IncrementalData._({
    _i2.dynamic modelData,
    _i2.dynamic insertedNodeKeys,
    _i2.dynamic modifiedNodeData,
    _i2.dynamic removedNodeKeys,
    _i2.dynamic insertedLinkKeys,
    _i2.dynamic modifiedLinkData,
    _i2.dynamic removedLinkKeys,
  });

  factory IncrementalData({
    _i2.Object? modelData,
    _i4.Array? insertedNodeKeys,
    _i4.Array? modifiedNodeData,
    _i4.Array? removedNodeKeys,
    _i4.Array? insertedLinkKeys,
    _i4.Array? modifiedLinkData,
    _i4.Array? removedLinkKeys,
  }) =>
      IncrementalData._(
        modelData: modelData ?? _i4.undefined,
        insertedNodeKeys: insertedNodeKeys ?? _i4.undefined,
        modifiedNodeData: modifiedNodeData ?? _i4.undefined,
        removedNodeKeys: removedNodeKeys ?? _i4.undefined,
        insertedLinkKeys: insertedLinkKeys ?? _i4.undefined,
        modifiedLinkData: modifiedLinkData ?? _i4.undefined,
        removedLinkKeys: removedLinkKeys ?? _i4.undefined,
      );
}

extension IncrementalData$Typings on IncrementalData {
  /* #24386
  source: 
    /**
     * Object containing the modified Model#modelData.
     */
    modelData?: ObjectData; */
  /// Object containing the modified Model#modelData.
  _i2.Object? get modelData => _i5.getProperty(
        this,
        'modelData',
      );
  /* #24386
  source: 
    /**
     * Object containing the modified Model#modelData.
     */
    modelData?: ObjectData; */
  // Type Instance of 'InteropInterface'
  set modelData(_i2.Object? value) {
    _i5.setProperty(
      this,
      'modelData',
      value ?? _i4.undefined,
    );
  }

  /* #24390
  source: 
    /**
     * Array of node keys added. Any key included will also be included in the modifiedNodeData array.
     */
    insertedNodeKeys?: Array<Key>; */
  /// Array of node keys added. Any key included will also be included in the modifiedNodeData array.
  _i4.Array? get insertedNodeKeys => _i5.getProperty(
        this,
        'insertedNodeKeys',
      );
  /* #24390
  source: 
    /**
     * Array of node keys added. Any key included will also be included in the modifiedNodeData array.
     */
    insertedNodeKeys?: Array<Key>; */
  // Type Instance of 'ExternalInteropType'
  set insertedNodeKeys(_i4.Array? value) {
    _i5.setProperty(
      this,
      'insertedNodeKeys',
      value ?? _i4.undefined,
    );
  }

  /* #24394
  source: 
    /**
     * Array of node data objects modified.
     */
    modifiedNodeData?: Array<ObjectData>; */
  /// Array of node data objects modified.
  _i4.Array? get modifiedNodeData => _i5.getProperty(
        this,
        'modifiedNodeData',
      );
  /* #24394
  source: 
    /**
     * Array of node data objects modified.
     */
    modifiedNodeData?: Array<ObjectData>; */
  // Type Instance of 'ExternalInteropType'
  set modifiedNodeData(_i4.Array? value) {
    _i5.setProperty(
      this,
      'modifiedNodeData',
      value ?? _i4.undefined,
    );
  }

  /* #24398
  source: 
    /**
     * Array of node keys deleted.
     */
    removedNodeKeys?: Array<Key>; */
  /// Array of node keys deleted.
  _i4.Array? get removedNodeKeys => _i5.getProperty(
        this,
        'removedNodeKeys',
      );
  /* #24398
  source: 
    /**
     * Array of node keys deleted.
     */
    removedNodeKeys?: Array<Key>; */
  // Type Instance of 'ExternalInteropType'
  set removedNodeKeys(_i4.Array? value) {
    _i5.setProperty(
      this,
      'removedNodeKeys',
      value ?? _i4.undefined,
    );
  }

  /* #24402
  source: 
    /**
     * Array of link keys added. Any key included will also be included in the modifiedLinkData array.
     */
    insertedLinkKeys?: Array<Key>; */
  /// Array of link keys added. Any key included will also be included in the modifiedLinkData array.
  _i4.Array? get insertedLinkKeys => _i5.getProperty(
        this,
        'insertedLinkKeys',
      );
  /* #24402
  source: 
    /**
     * Array of link keys added. Any key included will also be included in the modifiedLinkData array.
     */
    insertedLinkKeys?: Array<Key>; */
  // Type Instance of 'ExternalInteropType'
  set insertedLinkKeys(_i4.Array? value) {
    _i5.setProperty(
      this,
      'insertedLinkKeys',
      value ?? _i4.undefined,
    );
  }

  /* #24406
  source: 
    /**
     * Array of link data objects modified.
     */
    modifiedLinkData?: Array<ObjectData>; */
  /// Array of link data objects modified.
  _i4.Array? get modifiedLinkData => _i5.getProperty(
        this,
        'modifiedLinkData',
      );
  /* #24406
  source: 
    /**
     * Array of link data objects modified.
     */
    modifiedLinkData?: Array<ObjectData>; */
  // Type Instance of 'ExternalInteropType'
  set modifiedLinkData(_i4.Array? value) {
    _i5.setProperty(
      this,
      'modifiedLinkData',
      value ?? _i4.undefined,
    );
  }

  /* #24410
  source: 
    /**
     * Array of link keys deleted.
     */
    removedLinkKeys?: Array<Key>; */
  /// Array of link keys deleted.
  _i4.Array? get removedLinkKeys => _i5.getProperty(
        this,
        'removedLinkKeys',
      );
  /* #24410
  source: 
    /**
     * Array of link keys deleted.
     */
    removedLinkKeys?: Array<Key>; */
  // Type Instance of 'ExternalInteropType'
  set removedLinkKeys(_i4.Array? value) {
    _i5.setProperty(
      this,
      'removedLinkKeys',
      value ?? _i4.undefined,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Model {
  factory Model.$1() => _i5.callConstructor(
        _declaredModel,
        [],
      );

  factory Model.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredModel,
        [init ?? _i4.undefined],
      );

  factory Model.$3([
    _i4.Array? nodedataarray,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredModel,
        [
          nodedataarray ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );

  static _i3.Model fromJson(
    _i2.Object s, [
    _i3.Model? model,
  ]) =>
      _i5.callMethod(
        _declaredModel,
        'fromJson',
        [
          s,
          model ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Model')
external _i2.Object _declaredModel;

extension Model$Typings on Model {
  /* #24767
  source: 
    /**
     * Gets or sets the name of this model.
     * The initial name is an empty string.
     * The value must not be null.
     */
    get name(): string; */
  /// Gets or sets the name of this model.
  /// The initial name is an empty string.
  /// The value must not be null.
  _i2.String get name => _i5.getProperty(
        this,
        'name',
      );
  /* #24767
  source: 
    /**
     * Gets or sets the name of this model.
     * The initial name is an empty string.
     * The value must not be null.
     */
    get name(): string; */
  // Type InteropStaticType.string
  set name(_i2.String value) {
    _i5.setProperty(
      this,
      'name',
      value,
    );
  }

  /* #24775
  source: 
    /**
     * Gets or sets the name of the format of the diagram data.
     * The default value is the empty string.
     * The value must not be null.
     * Use different values to prevent parts from one model to be copy/pasted or drag-and-dropped into another diagram/model.
     */
    get dataFormat(): string; */
  /// Gets or sets the name of the format of the diagram data.
  /// The default value is the empty string.
  /// The value must not be null.
  /// Use different values to prevent parts from one model to be copy/pasted or drag-and-dropped into another diagram/model.
  _i2.String get dataFormat => _i5.getProperty(
        this,
        'dataFormat',
      );
  /* #24775
  source: 
    /**
     * Gets or sets the name of the format of the diagram data.
     * The default value is the empty string.
     * The value must not be null.
     * Use different values to prevent parts from one model to be copy/pasted or drag-and-dropped into another diagram/model.
     */
    get dataFormat(): string; */
  // Type InteropStaticType.string
  set dataFormat(_i2.String value) {
    _i5.setProperty(
      this,
      'dataFormat',
      value,
    );
  }

  /* #24787
  source: 
    /**
     * Gets or sets whether this model may be modified, such as adding nodes.
     * By default this value is false.
     * Setting the #nodeDataArray to something that is not a true Array of Objects
     * will cause this to be set to true.
     *
     * Model methods and property setters do not heed this property.
     * It is up to code that uses a model to check this property when it might want to
     * prevent changes to the model.
     */
    get isReadOnly(): boolean; */
  /// Gets or sets whether this model may be modified, such as adding nodes.
  /// By default this value is false.
  /// Setting the #nodeDataArray to something that is not a true Array of Objects
  /// will cause this to be set to true.
  ///
  /// Model methods and property setters do not heed this property.
  /// It is up to code that uses a model to check this property when it might want to
  /// prevent changes to the model.
  _i2.bool get isReadOnly => _i5.getProperty(
        this,
        'isReadOnly',
      );
  /* #24787
  source: 
    /**
     * Gets or sets whether this model may be modified, such as adding nodes.
     * By default this value is false.
     * Setting the #nodeDataArray to something that is not a true Array of Objects
     * will cause this to be set to true.
     *
     * Model methods and property setters do not heed this property.
     * It is up to code that uses a model to check this property when it might want to
     * prevent changes to the model.
     */
    get isReadOnly(): boolean; */
  // Type InteropStaticType.boolean
  set isReadOnly(_i2.bool value) {
    _i5.setProperty(
      this,
      'isReadOnly',
      value,
    );
  }

  /* #24812
  source: 
    /**
     * Gets a JavaScript Object that can hold programmer-defined property values for the model as a whole,
     * rather than just for one node or one link.
     *
     * By default this an object with no properties.
     * Any properties that you add to this object will be written out by #toJson
     * and will be restored by Model.fromJson, if the following conditions are true:
     *   - the property is enumerable and its name does not start with an underscore ('_')
     *   - the property value is not undefined and is not a function
     *   - the model knows how to convert the property value to JSON format
     *   - property values that are Objects or Arrays form a tree structure -- no shared or cyclical references
     *
     * Most object classes cannot be serialized into JSON without special knowledge and processing at both ends.
     * The #toJson and Model.fromJson methods automatically do such processing for numbers that are NaN
     * and for objects that are of class Point, Size, Rect, Margin, Spot,
     * Brush (but not for brush patterns), and for Geometry.
     *
     * At the current time one cannot have a Diagram as a binding target.
     * Calling #setDataProperty will work to change a property value, but there are no target bindings in any Diagrams to be updated.
     * Because the binding mechanism is unavailable for this object, we recommend that when you want to save a model
     * that you explicitly set properties on this object just before calling #toJson.
     * When loading a model, call Model.fromJson and explicitly get the properties that you want to set on a Diagram.
     */
    get modelData(): ObjectData; */
  /// Gets a JavaScript Object that can hold programmer-defined property values for the model as a whole,
  /// rather than just for one node or one link.
  ///
  /// By default this an object with no properties.
  /// Any properties that you add to this object will be written out by #toJson
  /// and will be restored by Model.fromJson, if the following conditions are true:
  ///   - the property is enumerable and its name does not start with an underscore ('_')
  ///   - the property value is not undefined and is not a function
  ///   - the model knows how to convert the property value to JSON format
  ///   - property values that are Objects or Arrays form a tree structure -- no shared or cyclical references
  ///
  /// Most object classes cannot be serialized into JSON without special knowledge and processing at both ends.
  /// The #toJson and Model.fromJson methods automatically do such processing for numbers that are NaN
  /// and for objects that are of class Point, Size, Rect, Margin, Spot,
  /// Brush (but not for brush patterns), and for Geometry.
  ///
  /// At the current time one cannot have a Diagram as a binding target.
  /// Calling #setDataProperty will work to change a property value, but there are no target bindings in any Diagrams to be updated.
  /// Because the binding mechanism is unavailable for this object, we recommend that when you want to save a model
  /// that you explicitly set properties on this object just before calling #toJson.
  /// When loading a model, call Model.fromJson and explicitly get the properties that you want to set on a Diagram.
  _i2.Object get modelData => _i5.getProperty(
        this,
        'modelData',
      );
  /* #24812
  source: 
    /**
     * Gets a JavaScript Object that can hold programmer-defined property values for the model as a whole,
     * rather than just for one node or one link.
     *
     * By default this an object with no properties.
     * Any properties that you add to this object will be written out by #toJson
     * and will be restored by Model.fromJson, if the following conditions are true:
     *   - the property is enumerable and its name does not start with an underscore ('_')
     *   - the property value is not undefined and is not a function
     *   - the model knows how to convert the property value to JSON format
     *   - property values that are Objects or Arrays form a tree structure -- no shared or cyclical references
     *
     * Most object classes cannot be serialized into JSON without special knowledge and processing at both ends.
     * The #toJson and Model.fromJson methods automatically do such processing for numbers that are NaN
     * and for objects that are of class Point, Size, Rect, Margin, Spot,
     * Brush (but not for brush patterns), and for Geometry.
     *
     * At the current time one cannot have a Diagram as a binding target.
     * Calling #setDataProperty will work to change a property value, but there are no target bindings in any Diagrams to be updated.
     * Because the binding mechanism is unavailable for this object, we recommend that when you want to save a model
     * that you explicitly set properties on this object just before calling #toJson.
     * When loading a model, call Model.fromJson and explicitly get the properties that you want to set on a Diagram.
     */
    get modelData(): ObjectData; */
  // Type Instance of 'InteropInterface'
  set modelData(_i2.Object value) {
    _i5.setProperty(
      this,
      'modelData',
      value,
    );
  }

  /* #24873
  source: 
    /**
     * Gets or sets the UndoManager for this Model.
     *
     * The default UndoManager has its UndoManager#isEnabled property set to false.
     * If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
     *
     * This property setter does not raise a ChangedEvent.
     */
    get undoManager(): UndoManager; */
  /// Gets or sets the UndoManager for this Model.
  ///
  /// The default UndoManager has its UndoManager#isEnabled property set to false.
  /// If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
  ///
  /// This property setter does not raise a ChangedEvent.
  _i3.UndoManager get undoManager => _i5.getProperty(
        this,
        'undoManager',
      );
  /* #24873
  source: 
    /**
     * Gets or sets the UndoManager for this Model.
     *
     * The default UndoManager has its UndoManager#isEnabled property set to false.
     * If you want users to undo and redo, you should set that property to true once you have initialized the Diagram or its Model.
     *
     * This property setter does not raise a ChangedEvent.
     */
    get undoManager(): UndoManager; */
  // Type Instance of 'InteropInterface'
  set undoManager(_i3.UndoManager value) {
    _i5.setProperty(
      this,
      'undoManager',
      value,
    );
  }

  /* #24895
  source: 
    /**
     * Gets or sets whether ChangedEvents are not recorded by the UndoManager.
     * The initial and normal value is false.
     * WARNING: while this property is true do not perform any changes that cause any previous transactions
     * to become impossible to undo.
     *
     * When this property is true, changing the Model or any data object does not call UndoManager#handleChanged.
     * Even when this property is true,
     * transactions (such as calls to #startTransaction) and undo/redo (such as calls to CommandHandler#undo)
     * are still delegated to the #undoManager.
     *
     * You should set this to true only temporarily, and you should remember its previous value before setting this to true.
     * When finishing the period for which you want the UndoManager to be disabled,
     * do not blindly set this property to false.
     * You should set this back to the value it had before you set it to true.
     * For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
     *
     * This property is also set when setting Diagram#skipsUndoManager.
     * Setting this property does not raise a ChangedEvent.
     */
    get skipsUndoManager(): boolean; */
  /// Gets or sets whether ChangedEvents are not recorded by the UndoManager.
  /// The initial and normal value is false.
  /// WARNING: while this property is true do not perform any changes that cause any previous transactions
  /// to become impossible to undo.
  ///
  /// When this property is true, changing the Model or any data object does not call UndoManager#handleChanged.
  /// Even when this property is true,
  /// transactions (such as calls to #startTransaction) and undo/redo (such as calls to CommandHandler#undo)
  /// are still delegated to the #undoManager.
  ///
  /// You should set this to true only temporarily, and you should remember its previous value before setting this to true.
  /// When finishing the period for which you want the UndoManager to be disabled,
  /// do not blindly set this property to false.
  /// You should set this back to the value it had before you set it to true.
  /// For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
  ///
  /// This property is also set when setting Diagram#skipsUndoManager.
  /// Setting this property does not raise a ChangedEvent.
  _i2.bool get skipsUndoManager => _i5.getProperty(
        this,
        'skipsUndoManager',
      );
  /* #24895
  source: 
    /**
     * Gets or sets whether ChangedEvents are not recorded by the UndoManager.
     * The initial and normal value is false.
     * WARNING: while this property is true do not perform any changes that cause any previous transactions
     * to become impossible to undo.
     *
     * When this property is true, changing the Model or any data object does not call UndoManager#handleChanged.
     * Even when this property is true,
     * transactions (such as calls to #startTransaction) and undo/redo (such as calls to CommandHandler#undo)
     * are still delegated to the #undoManager.
     *
     * You should set this to true only temporarily, and you should remember its previous value before setting this to true.
     * When finishing the period for which you want the UndoManager to be disabled,
     * do not blindly set this property to false.
     * You should set this back to the value it had before you set it to true.
     * For more permanent disabling of the UndoManager, set UndoManager#isEnabled to false.
     *
     * This property is also set when setting Diagram#skipsUndoManager.
     * Setting this property does not raise a ChangedEvent.
     */
    get skipsUndoManager(): boolean; */
  // Type InteropStaticType.boolean
  set skipsUndoManager(_i2.bool value) {
    _i5.setProperty(
      this,
      'skipsUndoManager',
      value,
    );
  }

  /* #24973
  source: 
    /**
     * Gets or sets the name of the data property that returns a unique id number or string for each node data object.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the unique key value;
     * if the second argument is supplied, the function should modify the node data object so that it has that new value as its unique key value.
     * The default value is the name 'key', meaning that it expects the data to have a property named 'key' if it has a key value.
     * The name must not be null or the empty string.
     * You must set this property before assigning the #nodeDataArray.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getKeyForNodeData
     */
    get nodeKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the data property that returns a unique id number or string for each node data object.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return the unique key value;
  /// if the second argument is supplied, the function should modify the node data object so that it has that new value as its unique key value.
  /// The default value is the name 'key', meaning that it expects the data to have a property named 'key' if it has a key value.
  /// The name must not be null or the empty string.
  /// You must set this property before assigning the #nodeDataArray.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get nodeKeyProperty => _i5.getProperty(
        this,
        'nodeKeyProperty',
      );
  /* #24973
  source: 
    /**
     * Gets or sets the name of the data property that returns a unique id number or string for each node data object.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the unique key value;
     * if the second argument is supplied, the function should modify the node data object so that it has that new value as its unique key value.
     * The default value is the name 'key', meaning that it expects the data to have a property named 'key' if it has a key value.
     * The name must not be null or the empty string.
     * You must set this property before assigning the #nodeDataArray.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getKeyForNodeData
     */
    get nodeKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#418188260(parent: InteropGetter#422099830(name: nodeKeyProperty))
  set nodeKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'nodeKeyProperty',
      value,
    );
  }

  /* #25028
  source: 
    /**
     * Gets or sets a function that returns a unique id number or string for a node data object.
     * This function is called by #makeNodeDataKeyUnique
     * when a node data object is added to the model, either as part of a new
     * #nodeDataArray or by a call to #addNodeData, to make sure the value of
     * #getKeyForNodeData is unique within the model.
     *
     * The value may be null in order to cause #makeNodeDataKeyUnique behave in the standard manner.
     * (The default value is null.)
     * You may want to supply a function here in order to make sure all of the automatically generated keys
     * are in a particular format.
     * Setting this property after setting #nodeDataArray has no real effect until there is a call
     * to #addNodeData.
     *
     * If you want to ensure that this function is called when copying data that already has a key,
     * set #copiesKey to false.
     * This is typically useful when copying a node from a Palette, where the key it has in the Palette's Model
     * happens to be unique within the target Diagram's Model.
     * Unless you set #copiesKey to false, the original key value will be copied and retained
     * if it is already unique within the target model.
     *
     * If a node data object is already in the model and you want to change its key value,
     * call #setKeyForNodeData with a new and unique key.
     */
    get makeUniqueKeyFunction(): ((model: Model, data: ObjectData) => Key) | null; */
  /// Gets or sets a function that returns a unique id number or string for a node data object.
  /// This function is called by #makeNodeDataKeyUnique
  /// when a node data object is added to the model, either as part of a new
  /// #nodeDataArray or by a call to #addNodeData, to make sure the value of
  /// #getKeyForNodeData is unique within the model.
  ///
  /// The value may be null in order to cause #makeNodeDataKeyUnique behave in the standard manner.
  /// (The default value is null.)
  /// You may want to supply a function here in order to make sure all of the automatically generated keys
  /// are in a particular format.
  /// Setting this property after setting #nodeDataArray has no real effect until there is a call
  /// to #addNodeData.
  ///
  /// If you want to ensure that this function is called when copying data that already has a key,
  /// set #copiesKey to false.
  /// This is typically useful when copying a node from a Palette, where the key it has in the Palette's Model
  /// happens to be unique within the target Diagram's Model.
  /// Unless you set #copiesKey to false, the original key value will be copied and retained
  /// if it is already unique within the target model.
  ///
  /// If a node data object is already in the model and you want to change its key value,
  /// call #setKeyForNodeData with a new and unique key.
  _i3.Key Function(
    _i3.Model,
    _i2.Object,
  )? get makeUniqueKeyFunction => _i5.getProperty(
        this,
        'makeUniqueKeyFunction',
      );
  /* #25028
  source: 
    /**
     * Gets or sets a function that returns a unique id number or string for a node data object.
     * This function is called by #makeNodeDataKeyUnique
     * when a node data object is added to the model, either as part of a new
     * #nodeDataArray or by a call to #addNodeData, to make sure the value of
     * #getKeyForNodeData is unique within the model.
     *
     * The value may be null in order to cause #makeNodeDataKeyUnique behave in the standard manner.
     * (The default value is null.)
     * You may want to supply a function here in order to make sure all of the automatically generated keys
     * are in a particular format.
     * Setting this property after setting #nodeDataArray has no real effect until there is a call
     * to #addNodeData.
     *
     * If you want to ensure that this function is called when copying data that already has a key,
     * set #copiesKey to false.
     * This is typically useful when copying a node from a Palette, where the key it has in the Palette's Model
     * happens to be unique within the target Diagram's Model.
     * Unless you set #copiesKey to false, the original key value will be copied and retained
     * if it is already unique within the target model.
     *
     * If a node data object is already in the model and you want to change its key value,
     * call #setKeyForNodeData with a new and unique key.
     */
    get makeUniqueKeyFunction(): ((model: Model, data: ObjectData) => Key) | null; */
  // Type InteropUnion#361265441(parent: InteropGetter#1071888197(name: makeUniqueKeyFunction))
  set makeUniqueKeyFunction(
      _i3.Key Function(
        _i3.Model,
        _i2.Object,
      )? value) {
    _i5.setProperty(
      this,
      'makeUniqueKeyFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #25071
  source: 
    /**
     * Gets or sets the array of node data objects that correspond to Nodes,
     * Groups, or non-Link Parts in the Diagram.
     * The initial value is an empty Array.
     *
     * For each Object in the Array, #getKeyForNodeData should return a number or string
     * uniquely identifying the node data within the model.
     * If it returns undefined, this calls #makeNodeDataKeyUnique,
     * to make sure the node data has a unique key.
     * These key values may be used by other objects to refer to that particular node data object.
     * If more than one node data object has the same key,
     * there may be some confusion about which object to reference.
     *
     * If you want to use a custom data property for holding the unique key value on a node data object,
     * you should set #nodeKeyProperty before you set this `nodeDataArray` property.
     *
     * Adding or removing data from this Array will not notify this model or the diagram
     * that there are any new nodes or that any nodes have been deleted.
     * Instead you should call #addNodeData or #removeNodeData.
     */
    get nodeDataArray(): Array<ObjectData>; */
  /// Gets or sets the array of node data objects that correspond to Nodes,
  /// Groups, or non-Link Parts in the Diagram.
  /// The initial value is an empty Array.
  ///
  /// For each Object in the Array, #getKeyForNodeData should return a number or string
  /// uniquely identifying the node data within the model.
  /// If it returns undefined, this calls #makeNodeDataKeyUnique,
  /// to make sure the node data has a unique key.
  /// These key values may be used by other objects to refer to that particular node data object.
  /// If more than one node data object has the same key,
  /// there may be some confusion about which object to reference.
  ///
  /// If you want to use a custom data property for holding the unique key value on a node data object,
  /// you should set #nodeKeyProperty before you set this `nodeDataArray` property.
  ///
  /// Adding or removing data from this Array will not notify this model or the diagram
  /// that there are any new nodes or that any nodes have been deleted.
  /// Instead you should call #addNodeData or #removeNodeData.
  _i4.Array get nodeDataArray => _i5.getProperty(
        this,
        'nodeDataArray',
      );
  /* #25071
  source: 
    /**
     * Gets or sets the array of node data objects that correspond to Nodes,
     * Groups, or non-Link Parts in the Diagram.
     * The initial value is an empty Array.
     *
     * For each Object in the Array, #getKeyForNodeData should return a number or string
     * uniquely identifying the node data within the model.
     * If it returns undefined, this calls #makeNodeDataKeyUnique,
     * to make sure the node data has a unique key.
     * These key values may be used by other objects to refer to that particular node data object.
     * If more than one node data object has the same key,
     * there may be some confusion about which object to reference.
     *
     * If you want to use a custom data property for holding the unique key value on a node data object,
     * you should set #nodeKeyProperty before you set this `nodeDataArray` property.
     *
     * Adding or removing data from this Array will not notify this model or the diagram
     * that there are any new nodes or that any nodes have been deleted.
     * Instead you should call #addNodeData or #removeNodeData.
     */
    get nodeDataArray(): Array<ObjectData>; */
  // Type Instance of 'ExternalInteropType'
  set nodeDataArray(_i4.Array value) {
    _i5.setProperty(
      this,
      'nodeDataArray',
      value,
    );
  }

  /* #25176
  source: 
    /**
     * Gets or sets a function that makes a copy of a node data object.
     *
     * You may need to set this property in order to ensure that a copied Node is bound
     * to data that does not share certain data structures between the original node data and the copied node data.
     * This property value may be null in order to cause #copyNodeData to make a shallow copy of a JavaScript Object.
     * The default value is null.
     *
     * The first argument to the function will be a node data object (potentially a Part's Panel#data).
     * The second argument to the function will be this Model itself.
     *
     * It is common to implement a copying function when the node data has an Array of data
     * and that Array needs to be copied rather than shared.
     * Often the objects that are in the Array also need to be copied.
     */
    get copyNodeDataFunction(): ((data: ObjectData, model: Model) => ObjectData) | null; */
  /// Gets or sets a function that makes a copy of a node data object.
  ///
  /// You may need to set this property in order to ensure that a copied Node is bound
  /// to data that does not share certain data structures between the original node data and the copied node data.
  /// This property value may be null in order to cause #copyNodeData to make a shallow copy of a JavaScript Object.
  /// The default value is null.
  ///
  /// The first argument to the function will be a node data object (potentially a Part's Panel#data).
  /// The second argument to the function will be this Model itself.
  ///
  /// It is common to implement a copying function when the node data has an Array of data
  /// and that Array needs to be copied rather than shared.
  /// Often the objects that are in the Array also need to be copied.
  _i2.Object Function(
    _i2.Object,
    _i3.Model,
  )? get copyNodeDataFunction => _i5.getProperty(
        this,
        'copyNodeDataFunction',
      );
  /* #25176
  source: 
    /**
     * Gets or sets a function that makes a copy of a node data object.
     *
     * You may need to set this property in order to ensure that a copied Node is bound
     * to data that does not share certain data structures between the original node data and the copied node data.
     * This property value may be null in order to cause #copyNodeData to make a shallow copy of a JavaScript Object.
     * The default value is null.
     *
     * The first argument to the function will be a node data object (potentially a Part's Panel#data).
     * The second argument to the function will be this Model itself.
     *
     * It is common to implement a copying function when the node data has an Array of data
     * and that Array needs to be copied rather than shared.
     * Often the objects that are in the Array also need to be copied.
     */
    get copyNodeDataFunction(): ((data: ObjectData, model: Model) => ObjectData) | null; */
  // Type InteropUnion#1033677083(parent: InteropGetter#388342501(name: copyNodeDataFunction))
  set copyNodeDataFunction(
      _i2.Object Function(
        _i2.Object,
        _i3.Model,
      )? value) {
    _i5.setProperty(
      this,
      'copyNodeDataFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #25198
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * makes copies of property values that are Arrays.
     * This only copies Arrays that are top-level property values in data objects, not for Arrays that are in nested objects.
     * Copying Arrays will also copy any array items that are Objects when #copiesArrayObjects is true.
     *
     * The default value is false.
     * It is commonplace to set #copiesArrayObjects to true when setting this property to true.
     * This property does not affect any behavior when the value of #copyNodeDataFunction
     * or GraphLinksModel#copyLinkDataFunction has been set to a function.
     *
     * Caution: if you want a copied data object to share some Arrays but not others,
     * you will need to provide your own copying function as #copyNodeDataFunction rather than setting
     * this property to true.
     *
     * Warning: there should not be any cyclical references within the model data.
     * @see #copiesArrayObjects
     * @see #copyNodeDataFunction
     * @since 1.5
     */
    get copiesArrays(): boolean; */
  /// Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
  /// makes copies of property values that are Arrays.
  /// This only copies Arrays that are top-level property values in data objects, not for Arrays that are in nested objects.
  /// Copying Arrays will also copy any array items that are Objects when #copiesArrayObjects is true.
  ///
  /// The default value is false.
  /// It is commonplace to set #copiesArrayObjects to true when setting this property to true.
  /// This property does not affect any behavior when the value of #copyNodeDataFunction
  /// or GraphLinksModel#copyLinkDataFunction has been set to a function.
  ///
  /// Caution: if you want a copied data object to share some Arrays but not others,
  /// you will need to provide your own copying function as #copyNodeDataFunction rather than setting
  /// this property to true.
  ///
  /// Warning: there should not be any cyclical references within the model data.
  _i2.bool get copiesArrays => _i5.getProperty(
        this,
        'copiesArrays',
      );
  /* #25198
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * makes copies of property values that are Arrays.
     * This only copies Arrays that are top-level property values in data objects, not for Arrays that are in nested objects.
     * Copying Arrays will also copy any array items that are Objects when #copiesArrayObjects is true.
     *
     * The default value is false.
     * It is commonplace to set #copiesArrayObjects to true when setting this property to true.
     * This property does not affect any behavior when the value of #copyNodeDataFunction
     * or GraphLinksModel#copyLinkDataFunction has been set to a function.
     *
     * Caution: if you want a copied data object to share some Arrays but not others,
     * you will need to provide your own copying function as #copyNodeDataFunction rather than setting
     * this property to true.
     *
     * Warning: there should not be any cyclical references within the model data.
     * @see #copiesArrayObjects
     * @see #copyNodeDataFunction
     * @since 1.5
     */
    get copiesArrays(): boolean; */
  // Type InteropStaticType.boolean
  set copiesArrays(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesArrays',
      value,
    );
  }

  /* #25221
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * when copying Arrays also copies array items that are Objects.
     * This only covers copying Objects that are items in Arrays that are copied when #copiesArrays is true.
     * Copying an Object when this property is true also recursively copies any Arrays that are property values.
     * It also assumes that the object's constructor can be called with no arguments.
     *
     * The default value is false.
     * This property does not affect any behavior when the value of #copyNodeDataFunction
     * or GraphLinksModel#copyLinkDataFunction has been set to a function.
     * This property has no effect unless #copiesArrays is true.
     *
     * Caution: if you want a copied data object to share some references but not others,
     * you will need to provide your own copying function as #copyNodeDataFunction rather than setting
     * this property and #copiesArrays to true.
     *
     * Warning: there should not be any cyclical references within the model data.
     * @see #copiesArrays
     * @see #copyNodeDataFunction
     * @since 1.5
     */
    get copiesArrayObjects(): boolean; */
  /// Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
  /// when copying Arrays also copies array items that are Objects.
  /// This only covers copying Objects that are items in Arrays that are copied when #copiesArrays is true.
  /// Copying an Object when this property is true also recursively copies any Arrays that are property values.
  /// It also assumes that the object's constructor can be called with no arguments.
  ///
  /// The default value is false.
  /// This property does not affect any behavior when the value of #copyNodeDataFunction
  /// or GraphLinksModel#copyLinkDataFunction has been set to a function.
  /// This property has no effect unless #copiesArrays is true.
  ///
  /// Caution: if you want a copied data object to share some references but not others,
  /// you will need to provide your own copying function as #copyNodeDataFunction rather than setting
  /// this property and #copiesArrays to true.
  ///
  /// Warning: there should not be any cyclical references within the model data.
  _i2.bool get copiesArrayObjects => _i5.getProperty(
        this,
        'copiesArrayObjects',
      );
  /* #25221
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * when copying Arrays also copies array items that are Objects.
     * This only covers copying Objects that are items in Arrays that are copied when #copiesArrays is true.
     * Copying an Object when this property is true also recursively copies any Arrays that are property values.
     * It also assumes that the object's constructor can be called with no arguments.
     *
     * The default value is false.
     * This property does not affect any behavior when the value of #copyNodeDataFunction
     * or GraphLinksModel#copyLinkDataFunction has been set to a function.
     * This property has no effect unless #copiesArrays is true.
     *
     * Caution: if you want a copied data object to share some references but not others,
     * you will need to provide your own copying function as #copyNodeDataFunction rather than setting
     * this property and #copiesArrays to true.
     *
     * Warning: there should not be any cyclical references within the model data.
     * @see #copiesArrays
     * @see #copyNodeDataFunction
     * @since 1.5
     */
    get copiesArrayObjects(): boolean; */
  // Type InteropStaticType.boolean
  set copiesArrayObjects(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesArrayObjects',
      value,
    );
  }

  /* #25235
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * when copying properties of a data object also copies the key property value.
     * Set this to false in order to force a unique key generation for data copied from another Diagram, such as a Palette.
     *
     * The default value is true.
     * This property does not affect any behavior when the value of #copyNodeDataFunction has been set to a function.
     *
     * @see #copiesArrays
     * @see #copyNodeDataFunction
     * @since 2.0
     */
    get copiesKey(): boolean; */
  /// Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
  /// when copying properties of a data object also copies the key property value.
  /// Set this to false in order to force a unique key generation for data copied from another Diagram, such as a Palette.
  ///
  /// The default value is true.
  /// This property does not affect any behavior when the value of #copyNodeDataFunction has been set to a function.
  _i2.bool get copiesKey => _i5.getProperty(
        this,
        'copiesKey',
      );
  /* #25235
  source: 
    /**
     * Gets or sets whether the default behavior for #copyNodeData or GraphLinksModel#copyLinkData
     * when copying properties of a data object also copies the key property value.
     * Set this to false in order to force a unique key generation for data copied from another Diagram, such as a Palette.
     *
     * The default value is true.
     * This property does not affect any behavior when the value of #copyNodeDataFunction has been set to a function.
     *
     * @see #copiesArrays
     * @see #copyNodeDataFunction
     * @since 2.0
     */
    get copiesKey(): boolean; */
  // Type InteropStaticType.boolean
  set copiesKey(_i2.bool value) {
    _i5.setProperty(
      this,
      'copiesKey',
      value,
    );
  }

  /* #25277
  source: 
    /**
     * (undocumented)
     * This function (if not null) is called towards the end of Diagram#copyParts
     * in order to support custom data copying operations that depend on references between the parts.
     *
     * The first argument to the function is a Map mapping original data objects to copied data objects.
     * The second argument to the function is this Model, the destination model for the copied parts.
     * The third argument to the function is the source Model, of the original data objects.
     */
    get afterCopyFunction(): ((map: Map<ObjectData, ObjectData>, destModel: Model, srcModel: Model) => void) | null; */
  /// (undocumented)
  /// This function (if not null) is called towards the end of Diagram#copyParts
  /// in order to support custom data copying operations that depend on references between the parts.
  ///
  /// The first argument to the function is a Map mapping original data objects to copied data objects.
  /// The second argument to the function is this Model, the destination model for the copied parts.
  /// The third argument to the function is the source Model, of the original data objects.
  void Function(
    _i3.Map<_i2.Object, _i2.Object>,
    _i3.Model,
    _i3.Model,
  )? get afterCopyFunction => _i5.getProperty(
        this,
        'afterCopyFunction',
      );
  /* #25277
  source: 
    /**
     * (undocumented)
     * This function (if not null) is called towards the end of Diagram#copyParts
     * in order to support custom data copying operations that depend on references between the parts.
     *
     * The first argument to the function is a Map mapping original data objects to copied data objects.
     * The second argument to the function is this Model, the destination model for the copied parts.
     * The third argument to the function is the source Model, of the original data objects.
     */
    get afterCopyFunction(): ((map: Map<ObjectData, ObjectData>, destModel: Model, srcModel: Model) => void) | null; */
  // Type InteropUnion#749820627(parent: InteropGetter#853391217(name: afterCopyFunction))
  set afterCopyFunction(
      void Function(
        _i3.Map<_i2.Object, _i2.Object>,
        _i3.Model,
        _i3.Model,
      )? value) {
    _i5.setProperty(
      this,
      'afterCopyFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #25386
  source: 
    /**
     * Gets or sets the name of the node data property that returns a string naming that data's category.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the category name;
     * if the second argument is supplied, the function should modify the node data object so that it has that new category name.
     * The default value is the string 'category', meaning that it expects the data to have a property named 'category' if it cares to name a category.
     * This is used by the diagram to distinguish between different kinds of nodes.
     * The name must not be null.
     * If the value is an empty string,
     * #getCategoryForNodeData will return an empty string for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getCategoryForNodeData
     * @see #setCategoryForNodeData
     */
    get nodeCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  /// Gets or sets the name of the node data property that returns a string naming that data's category.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return the category name;
  /// if the second argument is supplied, the function should modify the node data object so that it has that new category name.
  /// The default value is the string 'category', meaning that it expects the data to have a property named 'category' if it cares to name a category.
  /// This is used by the diagram to distinguish between different kinds of nodes.
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getCategoryForNodeData will return an empty string for all node data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get nodeCategoryProperty => _i5.getProperty(
        this,
        'nodeCategoryProperty',
      );
  /* #25386
  source: 
    /**
     * Gets or sets the name of the node data property that returns a string naming that data's category.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the category name;
     * if the second argument is supplied, the function should modify the node data object so that it has that new category name.
     * The default value is the string 'category', meaning that it expects the data to have a property named 'category' if it cares to name a category.
     * This is used by the diagram to distinguish between different kinds of nodes.
     * The name must not be null.
     * If the value is an empty string,
     * #getCategoryForNodeData will return an empty string for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getCategoryForNodeData
     * @see #setCategoryForNodeData
     */
    get nodeCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  // Type InteropUnion#158926506(parent: InteropGetter#314301994(name: nodeCategoryProperty))
  set nodeCategoryProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'nodeCategoryProperty',
      value,
    );
  }

  void cloneProtected(_i3.Model copy) {
    _i5.callMethod(
      this,
      'cloneProtected',
      [copy],
    );
  }

  _i3.Model copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  void clear() {
    _i5.callMethod(
      this,
      'clear',
      [],
    );
  }

  _i3.IncrementalData toIncrementalData(_i3.ChangedEvent e) => _i5.callMethod(
        this,
        'toIncrementalData',
        [e],
      );
  T cloneDeep<T>(T obj) => _i5.callMethod(
        this,
        'cloneDeep',
        [obj],
      );
  _i2.String toIncrementalJson(
    _i3.ChangedEvent e, [
    _i2.String? classname,
  ]) =>
      _i5.callMethod(
        this,
        'toIncrementalJson',
        [
          e,
          classname ?? _i4.undefined,
        ],
      );
  _i2.String toJson([_i2.String? classname]) => _i5.callMethod(
        this,
        'toJson',
        [classname ?? _i4.undefined],
      );
  void applyIncrementalJson(_i2.Object s) {
    _i5.callMethod(
      this,
      'applyIncrementalJson',
      [s],
    );
  }

  _i3.Model addChangedListener(void Function(_i3.ChangedEvent) listener) =>
      _i5.callMethod(
        this,
        'addChangedListener',
        [_i5.allowInterop(listener)],
      );
  void removeChangedListener(void Function(_i3.ChangedEvent) listener) {
    _i5.callMethod(
      this,
      'removeChangedListener',
      [_i5.allowInterop(listener)],
    );
  }

  void raiseChangedEvent(
    _i3.EnumValue change,
    _i2.Object propertyname,
    _i2.Object obj,
    _i2.dynamic oldval,
    _i2.dynamic newval, [
    _i2.dynamic oldparam,
    _i2.dynamic newparam,
  ]) {
    _i5.callMethod(
      this,
      'raiseChangedEvent',
      [
        change,
        propertyname,
        obj,
        oldval,
        newval,
        oldparam ?? _i4.undefined,
        newparam ?? _i4.undefined,
      ],
    );
  }

  void raiseDataChanged(
    _i2.Object data,
    _i2.Object propertyname,
    _i2.dynamic oldval,
    _i2.dynamic newval, [
    _i2.dynamic oldparam,
    _i2.dynamic newparam,
  ]) {
    _i5.callMethod(
      this,
      'raiseDataChanged',
      [
        data,
        propertyname,
        oldval,
        newval,
        oldparam ?? _i4.undefined,
        newparam ?? _i4.undefined,
      ],
    );
  }

  void changeState(
    _i3.ChangedEvent e,
    _i2.bool undo,
  ) {
    _i5.callMethod(
      this,
      'changeState',
      [
        e,
        undo,
      ],
    );
  }

  _i2.bool startTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'startTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool commitTransaction([_i2.String? tname]) => _i5.callMethod(
        this,
        'commitTransaction',
        [tname ?? _i4.undefined],
      );
  _i2.bool rollbackTransaction() => _i5.callMethod(
        this,
        'rollbackTransaction',
        [],
      );
  void commit(
    void Function(_i3.Model) func, [
    _i2.String? tname,
  ]) {
    _i5.callMethod(
      this,
      'commit',
      [
        _i5.allowInterop(func),
        tname ?? _i4.undefined,
      ],
    );
  }

  void updateTargetBindings(
    _i2.Object data, [
    _i2.String? srcpropname,
  ]) {
    _i5.callMethod(
      this,
      'updateTargetBindings',
      [
        data,
        srcpropname ?? _i4.undefined,
      ],
    );
  }

  _i3.Key getKeyForNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'getKeyForNodeData',
        [nodedata],
      );
  void setKeyForNodeData(
    _i2.Object nodedata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setKeyForNodeData',
      [
        nodedata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i2.bool containsNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'containsNodeData',
        [nodedata],
      );
  _i2.Object? findNodeDataForKey(_i3.Key key) => _i5.callMethod(
        this,
        'findNodeDataForKey',
        [key ?? _i4.undefined],
      );
  void makeNodeDataKeyUnique(_i2.Object nodedata) {
    _i5.callMethod(
      this,
      'makeNodeDataKeyUnique',
      [nodedata],
    );
  }

  void addNodeData(_i2.Object nodedata) {
    _i5.callMethod(
      this,
      'addNodeData',
      [nodedata],
    );
  }

  void addNodeDataCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'addNodeDataCollection',
      [coll],
    );
  }

  void removeNodeData(_i2.Object nodedata) {
    _i5.callMethod(
      this,
      'removeNodeData',
      [nodedata],
    );
  }

  void removeNodeDataCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'removeNodeDataCollection',
      [coll],
    );
  }

  void mergeNodeDataArray(_i4.Array arr) {
    _i5.callMethod(
      this,
      'mergeNodeDataArray',
      [arr],
    );
  }

  void clearUnresolvedReferences([_i3.Key? key]) {
    _i5.callMethod(
      this,
      'clearUnresolvedReferences',
      [key ?? _i4.undefined ?? _i4.undefined],
    );
  }

  _i2.Object? copyNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'copyNodeData',
        [nodedata],
      );
  void setDataProperty(
    _i2.Object data,
    _i2.String propname,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'setDataProperty',
      [
        data,
        propname,
        val,
      ],
    );
  }

  void set(
    _i2.Object data,
    _i2.String propname,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'set',
      [
        data,
        propname,
        val,
      ],
    );
  }

  void assignAllDataProperties(
    _i2.Object data,
    _i2.Object props,
  ) {
    _i5.callMethod(
      this,
      'assignAllDataProperties',
      [
        data,
        props,
      ],
    );
  }

  void addArrayItem(
    _i4.Array arr,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'addArrayItem',
      [
        arr,
        val,
      ],
    );
  }

  void insertArrayItem(
    _i4.Array arr,
    _i2.num idx,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'insertArrayItem',
      [
        arr,
        idx,
        val,
      ],
    );
  }

  void removeArrayItem(
    _i4.Array arr, [
    _i2.num? idx,
  ]) {
    _i5.callMethod(
      this,
      'removeArrayItem',
      [
        arr,
        idx ?? _i4.undefined,
      ],
    );
  }

  _i2.String getCategoryForNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'getCategoryForNodeData',
        [nodedata],
      );
  void setCategoryForNodeData(
    _i2.Object nodedata,
    _i2.String cat,
  ) {
    _i5.callMethod(
      this,
      'setCategoryForNodeData',
      [
        nodedata,
        cat,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class Binding {
  factory Binding([
    _i2.String? targetprop,
    _i2.String? sourceprop,
    _i3.TargetConversion? conv,
    _i3.BackConversion? backconv,
  ]) =>
      _i5.callConstructor(
        _declaredBinding,
        [
          targetprop ?? _i4.undefined,
          sourceprop ?? _i4.undefined,
          conv == null ? _i4.undefined : _i5.allowInterop(conv),
          backconv == null ? _i4.undefined : _i5.allowInterop(backconv),
        ],
      );

  /* #25678
  source: 
    /**
     * This value for Binding#mode uses data source values and sets GraphObject properties.
     * Bindings are evaluated when Panel#updateTargetBindings is called.
     * @constant
     */
    static OneWay: EnumValue; */
  /// This value for Binding#mode uses data source values and sets GraphObject properties.
  /// Bindings are evaluated when Panel#updateTargetBindings is called.
  static _i3.EnumValue get oneWay => _i5.getProperty(
        _declaredBinding,
        'OneWay',
      );
  /* #25678
  source: 
    /**
     * This value for Binding#mode uses data source values and sets GraphObject properties.
     * Bindings are evaluated when Panel#updateTargetBindings is called.
     * @constant
     */
    static OneWay: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set oneWay(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBinding,
      'OneWay',
      value,
    );
  }

  /* #25685
  source: 
    /**
     * This value for Binding#mode uses data source values and GraphObject properties and keeps them in sync.
     * When Panel#updateTargetBindings is called, the GraphObject properties are set.
     * When GraphObject properties are modified, the Panel#data properties are set.
     * @constant
     */
    static TwoWay: EnumValue; */
  /// This value for Binding#mode uses data source values and GraphObject properties and keeps them in sync.
  /// When Panel#updateTargetBindings is called, the GraphObject properties are set.
  /// When GraphObject properties are modified, the Panel#data properties are set.
  static _i3.EnumValue get twoWay => _i5.getProperty(
        _declaredBinding,
        'TwoWay',
      );
  /* #25685
  source: 
    /**
     * This value for Binding#mode uses data source values and GraphObject properties and keeps them in sync.
     * When Panel#updateTargetBindings is called, the GraphObject properties are set.
     * When GraphObject properties are modified, the Panel#data properties are set.
     * @constant
     */
    static TwoWay: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set twoWay(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredBinding,
      'TwoWay',
      value,
    );
  }

  static _i3.EnumValue Function(_i2.String) parseEnum(
    _i2.dynamic ctor,
    _i3.EnumValue defval,
  ) =>
      _i5.callMethod(
        _declaredBinding,
        'parseEnum',
        [
          ctor,
          defval,
        ],
      );
  static _i2.String toString$([_i2.dynamic val]) => _i5.callMethod(
        _declaredBinding,
        'toString',
        [val ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('Binding')
external _i2.Object _declaredBinding;

extension Binding$Typings on Binding {
  /* #25717
  source: 
    /**
     * Gets or sets the name of the property to be set on the target GraphObject.
     * The default value is the empty string; you should set this to be the name of a property.
     */
    get targetProperty(): string; */
  /// Gets or sets the name of the property to be set on the target GraphObject.
  /// The default value is the empty string; you should set this to be the name of a property.
  _i2.String get targetProperty => _i5.getProperty(
        this,
        'targetProperty',
      );
  /* #25717
  source: 
    /**
     * Gets or sets the name of the property to be set on the target GraphObject.
     * The default value is the empty string; you should set this to be the name of a property.
     */
    get targetProperty(): string; */
  // Type InteropStaticType.string
  set targetProperty(_i2.String value) {
    _i5.setProperty(
      this,
      'targetProperty',
      value,
    );
  }

  /* #25734
  source: 
    /**
     * Gets or sets the name of the GraphObject that should act as a source object
     * whose property should be gotten by this data binding.
     * The default value is null, which uses the bound Panel#data as the source.
     * If the value is a string, it should be the name of a GraphObject in the
     * visual tree of the Panel that is bound to the data.
     * Use the empty string to refer to the root panel, which is typically the whole Node or Link,
     * but will be a Panel if used in a Panel#itemTemplate.
     * The name must not contain a period.
     *
     * Binding only works if the source property is settable, not on computed or read-only properties,
     * and if it supports notification.
     * The documentation for the GraphObject (or subclass of GraphObject) property will indicate if the property is settable
     * and if it does not notify.
     */
    get sourceName(): string | null; */
  /// Gets or sets the name of the GraphObject that should act as a source object
  /// whose property should be gotten by this data binding.
  /// The default value is null, which uses the bound Panel#data as the source.
  /// If the value is a string, it should be the name of a GraphObject in the
  /// visual tree of the Panel that is bound to the data.
  /// Use the empty string to refer to the root panel, which is typically the whole Node or Link,
  /// but will be a Panel if used in a Panel#itemTemplate.
  /// The name must not contain a period.
  ///
  /// Binding only works if the source property is settable, not on computed or read-only properties,
  /// and if it supports notification.
  /// The documentation for the GraphObject (or subclass of GraphObject) property will indicate if the property is settable
  /// and if it does not notify.
  _i2.String? get sourceName => _i5.getProperty(
        this,
        'sourceName',
      );
  /* #25734
  source: 
    /**
     * Gets or sets the name of the GraphObject that should act as a source object
     * whose property should be gotten by this data binding.
     * The default value is null, which uses the bound Panel#data as the source.
     * If the value is a string, it should be the name of a GraphObject in the
     * visual tree of the Panel that is bound to the data.
     * Use the empty string to refer to the root panel, which is typically the whole Node or Link,
     * but will be a Panel if used in a Panel#itemTemplate.
     * The name must not contain a period.
     *
     * Binding only works if the source property is settable, not on computed or read-only properties,
     * and if it supports notification.
     * The documentation for the GraphObject (or subclass of GraphObject) property will indicate if the property is settable
     * and if it does not notify.
     */
    get sourceName(): string | null; */
  // Type InteropUnion#1068360801(parent: InteropGetter#599326250(name: sourceName))
  set sourceName(_i2.String? value) {
    _i5.setProperty(
      this,
      'sourceName',
      value ?? _i4.undefined,
    );
  }

  /* #25742
  source: 
    /**
     * Gets or sets whether the source data is Model#modelData rather than a node data or link data object in the model.
     * The default value is false -- the source data object will not be the shared Model.modelData object.
     * @see #ofModel
     * @since 1.7
     */
    get isToModel(): boolean; */
  /// Gets or sets whether the source data is Model#modelData rather than a node data or link data object in the model.
  /// The default value is false -- the source data object will not be the shared Model.modelData object.
  _i2.bool get isToModel => _i5.getProperty(
        this,
        'isToModel',
      );
  /* #25742
  source: 
    /**
     * Gets or sets whether the source data is Model#modelData rather than a node data or link data object in the model.
     * The default value is false -- the source data object will not be the shared Model.modelData object.
     * @see #ofModel
     * @since 1.7
     */
    get isToModel(): boolean; */
  // Type InteropStaticType.boolean
  set isToModel(_i2.bool value) {
    _i5.setProperty(
      this,
      'isToModel',
      value,
    );
  }

  /* #25753
  source: 
    /**
     * Gets or sets the name of the property to get from the bound data object,
     * the value of Panel#data.
     * The default value is the empty string, which results in setting the target
     * property to the whole data object, rather than to a property value of the data object.
     * If #sourceName is not null, then this property names the settable
     * property on the GraphObject or RowColumnDefinition
     * that acts as the source.
     */
    get sourceProperty(): string; */
  /// Gets or sets the name of the property to get from the bound data object,
  /// the value of Panel#data.
  /// The default value is the empty string, which results in setting the target
  /// property to the whole data object, rather than to a property value of the data object.
  /// If #sourceName is not null, then this property names the settable
  /// property on the GraphObject or RowColumnDefinition
  /// that acts as the source.
  _i2.String get sourceProperty => _i5.getProperty(
        this,
        'sourceProperty',
      );
  /* #25753
  source: 
    /**
     * Gets or sets the name of the property to get from the bound data object,
     * the value of Panel#data.
     * The default value is the empty string, which results in setting the target
     * property to the whole data object, rather than to a property value of the data object.
     * If #sourceName is not null, then this property names the settable
     * property on the GraphObject or RowColumnDefinition
     * that acts as the source.
     */
    get sourceProperty(): string; */
  // Type InteropStaticType.string
  set sourceProperty(_i2.String value) {
    _i5.setProperty(
      this,
      'sourceProperty',
      value,
    );
  }

  /* #25777
  source: 
    /**
     * Gets or sets a converter function to apply to the data property value
     * in order to produce the value to set to the target property.
     * This conversion function is used in both OneWay and TwoWay bindings,
     * when transferring a value from the source to the target.
     * The default value is null -- no conversion takes place.
     * Otherwise the value should be a function that takes one or two arguments
     * and returns the desired value.
     * However, the return value is ignored when the #targetProperty
     * is the empty string.
     *
     * Conversion functions must not have any side-effects other than setting
     * the target property.  In particular you should not try to modify the
     * structure of the visual tree in the target GraphObject's Part's visual tree.
     *
     * The function is passed the value from the source
     * (the first argument) and the target GraphObject (the second argument).
     * If the #targetProperty is a property name, that property is set to
     * the function's return value.
     * If the #targetProperty is the empty string, the function should
     * set a property on the second argument, which will be the target GraphObject.
     */
    get converter(): TargetConversion; */
  /// Gets or sets a converter function to apply to the data property value
  /// in order to produce the value to set to the target property.
  /// This conversion function is used in both OneWay and TwoWay bindings,
  /// when transferring a value from the source to the target.
  /// The default value is null -- no conversion takes place.
  /// Otherwise the value should be a function that takes one or two arguments
  /// and returns the desired value.
  /// However, the return value is ignored when the #targetProperty
  /// is the empty string.
  ///
  /// Conversion functions must not have any side-effects other than setting
  /// the target property.  In particular you should not try to modify the
  /// structure of the visual tree in the target GraphObject's Part's visual tree.
  ///
  /// The function is passed the value from the source
  /// (the first argument) and the target GraphObject (the second argument).
  /// If the #targetProperty is a property name, that property is set to
  /// the function's return value.
  /// If the #targetProperty is the empty string, the function should
  /// set a property on the second argument, which will be the target GraphObject.
  _i3.TargetConversion get converter => _i5.getProperty(
        this,
        'converter',
      );
  /* #25777
  source: 
    /**
     * Gets or sets a converter function to apply to the data property value
     * in order to produce the value to set to the target property.
     * This conversion function is used in both OneWay and TwoWay bindings,
     * when transferring a value from the source to the target.
     * The default value is null -- no conversion takes place.
     * Otherwise the value should be a function that takes one or two arguments
     * and returns the desired value.
     * However, the return value is ignored when the #targetProperty
     * is the empty string.
     *
     * Conversion functions must not have any side-effects other than setting
     * the target property.  In particular you should not try to modify the
     * structure of the visual tree in the target GraphObject's Part's visual tree.
     *
     * The function is passed the value from the source
     * (the first argument) and the target GraphObject (the second argument).
     * If the #targetProperty is a property name, that property is set to
     * the function's return value.
     * If the #targetProperty is the empty string, the function should
     * set a property on the second argument, which will be the target GraphObject.
     */
    get converter(): TargetConversion; */
  // Type InteropTypedef#319543839(name: TargetConversion)
  set converter(_i3.TargetConversion value) {
    _i5.setProperty(
      this,
      'converter',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #25801
  source: 
    /**
     * Gets or sets a converter function to apply to the GraphObject property value
     * in order to produce the value to set to a data property.
     * This conversion function is only used in a TwoWay binding,
     * when transferring a value from the target to the source.
     * The default value is null -- no conversion takes place.
     * Otherwise the value should be a function that takes one or two arguments
     * and returns the desired value.
     * However, the return value is ignored when the #sourceProperty
     * is the empty string.
     *
     * Conversion functions must not have any side-effects other than setting
     * the source property.
     *
     * The function is passed the value from the target
     * (the first argument), the source Panel#data object (the second argument),
     * and the Model (the third argument).
     * If the #sourceProperty is a property name, that property is set to
     * the function's return value.
     * If the #sourceProperty is the empty string, the function should
     * modify the second argument, which will be the source data object.
     */
    get backConverter(): BackConversion; */
  /// Gets or sets a converter function to apply to the GraphObject property value
  /// in order to produce the value to set to a data property.
  /// This conversion function is only used in a TwoWay binding,
  /// when transferring a value from the target to the source.
  /// The default value is null -- no conversion takes place.
  /// Otherwise the value should be a function that takes one or two arguments
  /// and returns the desired value.
  /// However, the return value is ignored when the #sourceProperty
  /// is the empty string.
  ///
  /// Conversion functions must not have any side-effects other than setting
  /// the source property.
  ///
  /// The function is passed the value from the target
  /// (the first argument), the source Panel#data object (the second argument),
  /// and the Model (the third argument).
  /// If the #sourceProperty is a property name, that property is set to
  /// the function's return value.
  /// If the #sourceProperty is the empty string, the function should
  /// modify the second argument, which will be the source data object.
  _i3.BackConversion get backConverter => _i5.getProperty(
        this,
        'backConverter',
      );
  /* #25801
  source: 
    /**
     * Gets or sets a converter function to apply to the GraphObject property value
     * in order to produce the value to set to a data property.
     * This conversion function is only used in a TwoWay binding,
     * when transferring a value from the target to the source.
     * The default value is null -- no conversion takes place.
     * Otherwise the value should be a function that takes one or two arguments
     * and returns the desired value.
     * However, the return value is ignored when the #sourceProperty
     * is the empty string.
     *
     * Conversion functions must not have any side-effects other than setting
     * the source property.
     *
     * The function is passed the value from the target
     * (the first argument), the source Panel#data object (the second argument),
     * and the Model (the third argument).
     * If the #sourceProperty is a property name, that property is set to
     * the function's return value.
     * If the #sourceProperty is the empty string, the function should
     * modify the second argument, which will be the source data object.
     */
    get backConverter(): BackConversion; */
  // Type InteropTypedef#416671858(name: BackConversion)
  set backConverter(_i3.BackConversion value) {
    _i5.setProperty(
      this,
      'backConverter',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #25815
  source: 
    /**
     * Gets or sets the directions and frequency in which the binding may be evaluated.
     * The default value is Binding.OneWay.
     * Binding.TwoWay is the other choice.
     *
     * Use OneWay bindings to initialize GraphObject properties based on model data,
     * or to modify GraphObject properties when the model data changes with a call to Model#setDataProperty.
     * Use TwoWay bindings to keep model data in sync with changes to GraphObject properties.
     * For efficiency, avoid TwoWay bindings on GraphObject properties that do not change value in your app.
     *
     * You should not have a TwoWay binding on a node data object's key property.
     */
    get mode(): EnumValue; */
  /// Gets or sets the directions and frequency in which the binding may be evaluated.
  /// The default value is Binding.OneWay.
  /// Binding.TwoWay is the other choice.
  ///
  /// Use OneWay bindings to initialize GraphObject properties based on model data,
  /// or to modify GraphObject properties when the model data changes with a call to Model#setDataProperty.
  /// Use TwoWay bindings to keep model data in sync with changes to GraphObject properties.
  /// For efficiency, avoid TwoWay bindings on GraphObject properties that do not change value in your app.
  ///
  /// You should not have a TwoWay binding on a node data object's key property.
  _i3.EnumValue get mode => _i5.getProperty(
        this,
        'mode',
      );
  /* #25815
  source: 
    /**
     * Gets or sets the directions and frequency in which the binding may be evaluated.
     * The default value is Binding.OneWay.
     * Binding.TwoWay is the other choice.
     *
     * Use OneWay bindings to initialize GraphObject properties based on model data,
     * or to modify GraphObject properties when the model data changes with a call to Model#setDataProperty.
     * Use TwoWay bindings to keep model data in sync with changes to GraphObject properties.
     * For efficiency, avoid TwoWay bindings on GraphObject properties that do not change value in your app.
     *
     * You should not have a TwoWay binding on a node data object's key property.
     */
    get mode(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set mode(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'mode',
      value,
    );
  }

  _i3.Binding copy() => _i5.callMethod(
        this,
        'copy',
        [],
      );
  _i3.Binding makeTwoWay([_i3.BackConversion? backconv]) => _i5.callMethod(
        this,
        'makeTwoWay',
        [backconv == null ? _i4.undefined : _i5.allowInterop(backconv)],
      );
  _i3.Binding ofObject([_i2.String? srcname]) => _i5.callMethod(
        this,
        'ofObject',
        [srcname ?? _i4.undefined],
      );
  _i3.Binding ofModel() => _i5.callMethod(
        this,
        'ofModel',
        [],
      );
}

@_i1.JS()
@_i1.staticInterop
class GraphLinksModel implements _i3.Model {
  factory GraphLinksModel.$1() => _i5.callConstructor(
        _declaredGraphLinksModel,
        [],
      );

  factory GraphLinksModel.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredGraphLinksModel,
        [init ?? _i4.undefined],
      );

  factory GraphLinksModel.$3([
    _i4.Array? nodedataarray,
    _i4.Array? linkdataarray,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredGraphLinksModel,
        [
          nodedataarray ?? _i4.undefined,
          linkdataarray ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('GraphLinksModel')
external _i2.Object _declaredGraphLinksModel;

extension GraphLinksModel$Typings on GraphLinksModel {
  /* #25995
  source: 
    /**
     * Gets or sets a data object that will be copied and added to the model as a new node data each time there
     * is a link reference (either the "to" or the "from" of a link data) to a node key that does not yet exist in the model.
     *
     * The default value is null -- node data is not automatically copied and added to the model
     * when there is an unresolved reference in a link data.
     * When adding or modifying a link data if there is a "from" or "to" key value for which Model#findNodeDataForKey returns null,
     * it will call Model#copyNodeData on this property value and Model#addNodeData on the result.
     * @since 1.1
     */
    get archetypeNodeData(): ObjectData | null; */
  /// Gets or sets a data object that will be copied and added to the model as a new node data each time there
  /// is a link reference (either the "to" or the "from" of a link data) to a node key that does not yet exist in the model.
  ///
  /// The default value is null -- node data is not automatically copied and added to the model
  /// when there is an unresolved reference in a link data.
  /// When adding or modifying a link data if there is a "from" or "to" key value for which Model#findNodeDataForKey returns null,
  /// it will call Model#copyNodeData on this property value and Model#addNodeData on the result.
  _i2.Object? get archetypeNodeData => _i5.getProperty(
        this,
        'archetypeNodeData',
      );
  /* #25995
  source: 
    /**
     * Gets or sets a data object that will be copied and added to the model as a new node data each time there
     * is a link reference (either the "to" or the "from" of a link data) to a node key that does not yet exist in the model.
     *
     * The default value is null -- node data is not automatically copied and added to the model
     * when there is an unresolved reference in a link data.
     * When adding or modifying a link data if there is a "from" or "to" key value for which Model#findNodeDataForKey returns null,
     * it will call Model#copyNodeData on this property value and Model#addNodeData on the result.
     * @since 1.1
     */
    get archetypeNodeData(): ObjectData | null; */
  // Type InteropUnion#999812021(parent: InteropGetter#543767081(name: archetypeNodeData))
  set archetypeNodeData(_i2.Object? value) {
    _i5.setProperty(
      this,
      'archetypeNodeData',
      value ?? _i4.undefined,
    );
  }

  /* #26016
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the key of the node data that the link data is coming from.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the key of the link's source node;
     * if the second argument is supplied, the function should modify the link data object so that it has that new key
     * (which may be undefined to refer to no node) as the identifier to the "from" node.
     * The default value is the name 'from', meaning that it expects the data to have a property named 'from' to refer to the link's source node.
     * The name must not be null.
     * If the value is an empty string,
     * #getFromKeyForLinkData will return undefined for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getFromKeyForLinkData
     * @see #setFromKeyForLinkData
     */
    get linkFromKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the data property that returns
  /// the key of the node data that the link data is coming from.
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the key of the link's source node;
  /// if the second argument is supplied, the function should modify the link data object so that it has that new key
  /// (which may be undefined to refer to no node) as the identifier to the "from" node.
  /// The default value is the name 'from', meaning that it expects the data to have a property named 'from' to refer to the link's source node.
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getFromKeyForLinkData will return undefined for all link data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkFromKeyProperty => _i5.getProperty(
        this,
        'linkFromKeyProperty',
      );
  /* #26016
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the key of the node data that the link data is coming from.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the key of the link's source node;
     * if the second argument is supplied, the function should modify the link data object so that it has that new key
     * (which may be undefined to refer to no node) as the identifier to the "from" node.
     * The default value is the name 'from', meaning that it expects the data to have a property named 'from' to refer to the link's source node.
     * The name must not be null.
     * If the value is an empty string,
     * #getFromKeyForLinkData will return undefined for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getFromKeyForLinkData
     * @see #setFromKeyForLinkData
     */
    get linkFromKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#617921093(parent: InteropGetter#22902972(name: linkFromKeyProperty))
  set linkFromKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkFromKeyProperty',
      value,
    );
  }

  /* #26057
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the key of the node data that the link data is going to,
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the key of the link's destination node;
     * if the second argument is supplied, the function should modify the link data object so that it has that new key
     * (which may be undefined to refer to no node) as the identifier to the "to" node.
     * The default value is the name 'to', meaning that it expects the data to have a property named 'to' to refer to the link's destination node.
     * The name must not be null.
     * If the value is an empty string,
     * #getToKeyForLinkData will return undefined for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getToKeyForLinkData
     * @see #setToKeyForLinkData
     */
    get linkToKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the data property that returns
  /// the key of the node data that the link data is going to,
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the key of the link's destination node;
  /// if the second argument is supplied, the function should modify the link data object so that it has that new key
  /// (which may be undefined to refer to no node) as the identifier to the "to" node.
  /// The default value is the name 'to', meaning that it expects the data to have a property named 'to' to refer to the link's destination node.
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getToKeyForLinkData will return undefined for all link data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkToKeyProperty => _i5.getProperty(
        this,
        'linkToKeyProperty',
      );
  /* #26057
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the key of the node data that the link data is going to,
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the key of the link's destination node;
     * if the second argument is supplied, the function should modify the link data object so that it has that new key
     * (which may be undefined to refer to no node) as the identifier to the "to" node.
     * The default value is the name 'to', meaning that it expects the data to have a property named 'to' to refer to the link's destination node.
     * The name must not be null.
     * If the value is an empty string,
     * #getToKeyForLinkData will return undefined for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getToKeyForLinkData
     * @see #setToKeyForLinkData
     */
    get linkToKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#156470296(parent: InteropGetter#591003040(name: linkToKeyProperty))
  set linkToKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkToKeyProperty',
      value,
    );
  }

  /* #26098
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the optional parameter naming a "port" element on the node that the link data is connected from.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the string identifier of the link's source port;
     * if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "from" port.
     * The default value is the empty string indicating that one cannot distinguish
     * different logical connection points for any links.
     * The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
     * If the value is an empty string,
     * #getFromPortIdForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getFromPortIdForLinkData
     * @see #setFromPortIdForLinkData
     */
    get linkFromPortIdProperty(): string | ((a: ObjectData, b?: string) => string); */
  /// Gets or sets the name of the data property that returns
  /// the optional parameter naming a "port" element on the node that the link data is connected from.
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the string identifier of the link's source port;
  /// if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "from" port.
  /// The default value is the empty string indicating that one cannot distinguish
  /// different logical connection points for any links.
  /// The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
  /// If the value is an empty string,
  /// #getFromPortIdForLinkData will return an empty string for all link data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkFromPortIdProperty => _i5.getProperty(
        this,
        'linkFromPortIdProperty',
      );
  /* #26098
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the optional parameter naming a "port" element on the node that the link data is connected from.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the string identifier of the link's source port;
     * if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "from" port.
     * The default value is the empty string indicating that one cannot distinguish
     * different logical connection points for any links.
     * The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
     * If the value is an empty string,
     * #getFromPortIdForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getFromPortIdForLinkData
     * @see #setFromPortIdForLinkData
     */
    get linkFromPortIdProperty(): string | ((a: ObjectData, b?: string) => string); */
  // Type InteropUnion#111593505(parent: InteropGetter#649513661(name: linkFromPortIdProperty))
  set linkFromPortIdProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkFromPortIdProperty',
      value,
    );
  }

  /* #26139
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the optional parameter naming a "port" element on the node that the link data is connected to.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the string identifier of the link's destination port;
     * if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "to" port.
     * The default value is the empty string indicating that one cannot distinguish
     * different logical connection points for any links.
     * The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
     * If the value is an empty string,
     * #getToPortIdForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getToPortIdForLinkData
     * @see #setToPortIdForLinkData
     */
    get linkToPortIdProperty(): string | ((a: ObjectData, b?: string) => string); */
  /// Gets or sets the name of the data property that returns
  /// the optional parameter naming a "port" element on the node that the link data is connected to.
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the string identifier of the link's destination port;
  /// if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "to" port.
  /// The default value is the empty string indicating that one cannot distinguish
  /// different logical connection points for any links.
  /// The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
  /// If the value is an empty string,
  /// #getToPortIdForLinkData will return an empty string for all link data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkToPortIdProperty => _i5.getProperty(
        this,
        'linkToPortIdProperty',
      );
  /* #26139
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * the optional parameter naming a "port" element on the node that the link data is connected to.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the string identifier of the link's destination port;
     * if the second argument is supplied, the function should modify the link data object so that it has that string as the identifier to the "to" port.
     * The default value is the empty string indicating that one cannot distinguish
     * different logical connection points for any links.
     * The name must not be null nor the value of #linkFromKeyProperty or #linkToKeyProperty.
     * If the value is an empty string,
     * #getToPortIdForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getToPortIdForLinkData
     * @see #setToPortIdForLinkData
     */
    get linkToPortIdProperty(): string | ((a: ObjectData, b?: string) => string); */
  // Type InteropUnion#265388380(parent: InteropGetter#199558321(name: linkToPortIdProperty))
  set linkToPortIdProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkToPortIdProperty',
      value,
    );
  }

  /* #26181
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * an array of keys of node data that are labels on that link data.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the array of label node keys for the link;
     * if the second argument is supplied, the function should modify the link data object so that it holds that Array of node keys as references to label nodes.
     * The default value is the empty string: '', meaning that the model does not support links owning label nodes.
     *
     * The name must not be null.
     * If the value is an empty string,
     * #getLabelKeysForLinkData will return an empty array for all link data objects.
     * You will need to set this property in order to support nodes as link labels.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getLabelKeysForLinkData
     * @see #setLabelKeysForLinkData
     */
    get linkLabelKeysProperty(): string | ((a: ObjectData, b?: Array<Key>) => Array<Key>); */
  /// Gets or sets the name of the data property that returns
  /// an array of keys of node data that are labels on that link data.
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the array of label node keys for the link;
  /// if the second argument is supplied, the function should modify the link data object so that it holds that Array of node keys as references to label nodes.
  /// The default value is the empty string: '', meaning that the model does not support links owning label nodes.
  ///
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getLabelKeysForLinkData will return an empty array for all link data objects.
  /// You will need to set this property in order to support nodes as link labels.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkLabelKeysProperty => _i5.getProperty(
        this,
        'linkLabelKeysProperty',
      );
  /* #26181
  source: 
    /**
     * Gets or sets the name of the data property that returns
     * an array of keys of node data that are labels on that link data.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the array of label node keys for the link;
     * if the second argument is supplied, the function should modify the link data object so that it holds that Array of node keys as references to label nodes.
     * The default value is the empty string: '', meaning that the model does not support links owning label nodes.
     *
     * The name must not be null.
     * If the value is an empty string,
     * #getLabelKeysForLinkData will return an empty array for all link data objects.
     * You will need to set this property in order to support nodes as link labels.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getLabelKeysForLinkData
     * @see #setLabelKeysForLinkData
     */
    get linkLabelKeysProperty(): string | ((a: ObjectData, b?: Array<Key>) => Array<Key>); */
  // Type InteropUnion#317058379(parent: InteropGetter#332054773(name: linkLabelKeysProperty))
  set linkLabelKeysProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkLabelKeysProperty',
      value,
    );
  }

  /* #26234
  source: 
    /**
     * Gets or sets the array of link data objects that correspond to Links in the Diagram.
     * The initial value is an empty Array.
     */
    get linkDataArray(): Array<ObjectData>; */
  /// Gets or sets the array of link data objects that correspond to Links in the Diagram.
  /// The initial value is an empty Array.
  _i4.Array get linkDataArray => _i5.getProperty(
        this,
        'linkDataArray',
      );
  /* #26234
  source: 
    /**
     * Gets or sets the array of link data objects that correspond to Links in the Diagram.
     * The initial value is an empty Array.
     */
    get linkDataArray(): Array<ObjectData>; */
  // Type Instance of 'ExternalInteropType'
  set linkDataArray(_i4.Array value) {
    _i5.setProperty(
      this,
      'linkDataArray',
      value,
    );
  }

  /* #26254
  source: 
    /**
     * Gets or sets the name of the data property that returns a unique id number or string for each link data object.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the unique string or number key for that link data object;
     * if the second argument is supplied, the function should modify the link data object so that it has that string or number as the unique key for that link.
     * The default value is the empty string, which means the model will not maintain a key property value on link data objects.
     * The name must not be null.
     *
     * When this property has a value of an empty string (the default value),
     * #getKeyForLinkData will return undefined, and #findLinkDataForKey will always return null.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getKeyForLinkData
     * @since 1.6
     */
    get linkKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the data property that returns a unique id number or string for each link data object.
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the unique string or number key for that link data object;
  /// if the second argument is supplied, the function should modify the link data object so that it has that string or number as the unique key for that link.
  /// The default value is the empty string, which means the model will not maintain a key property value on link data objects.
  /// The name must not be null.
  ///
  /// When this property has a value of an empty string (the default value),
  /// #getKeyForLinkData will return undefined, and #findLinkDataForKey will always return null.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkKeyProperty => _i5.getProperty(
        this,
        'linkKeyProperty',
      );
  /* #26254
  source: 
    /**
     * Gets or sets the name of the data property that returns a unique id number or string for each link data object.
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the unique string or number key for that link data object;
     * if the second argument is supplied, the function should modify the link data object so that it has that string or number as the unique key for that link.
     * The default value is the empty string, which means the model will not maintain a key property value on link data objects.
     * The name must not be null.
     *
     * When this property has a value of an empty string (the default value),
     * #getKeyForLinkData will return undefined, and #findLinkDataForKey will always return null.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getKeyForLinkData
     * @since 1.6
     */
    get linkKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#974430193(parent: InteropGetter#98402190(name: linkKeyProperty))
  set linkKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkKeyProperty',
      value,
    );
  }

  /* #26306
  source: 
    /**
     * Gets or sets a function that returns a unique id number or string for a link data object.
     * This function is called by #makeLinkDataKeyUnique
     * when a link data object is added to the model, either as part of a new
     * #linkDataArray or by a call to #addLinkData, to make sure the value of
     * #getKeyForLinkData is unique within the model.
     * However it will not be called when #linkKeyProperty is the default value, an empty string.
     *
     * The value may be null in order to cause #makeLinkDataKeyUnique behave in the standard manner.
     * (The default value is null.)
     * You may want to supply a function here in order to make sure all of the automatically generated keys
     * are in a particular format.
     * Setting this property after setting #linkDataArray has no real effect until there is a call
     * to #addLinkData.
     *
     * If a link data object is already in the model and you want to change its key value,
     * call #setKeyForLinkData with a new and unique key.
     * @since 1.6
     */
    get makeUniqueLinkKeyFunction(): ((a: GraphLinksModel, b: ObjectData) => Key) | null; */
  /// Gets or sets a function that returns a unique id number or string for a link data object.
  /// This function is called by #makeLinkDataKeyUnique
  /// when a link data object is added to the model, either as part of a new
  /// #linkDataArray or by a call to #addLinkData, to make sure the value of
  /// #getKeyForLinkData is unique within the model.
  /// However it will not be called when #linkKeyProperty is the default value, an empty string.
  ///
  /// The value may be null in order to cause #makeLinkDataKeyUnique behave in the standard manner.
  /// (The default value is null.)
  /// You may want to supply a function here in order to make sure all of the automatically generated keys
  /// are in a particular format.
  /// Setting this property after setting #linkDataArray has no real effect until there is a call
  /// to #addLinkData.
  ///
  /// If a link data object is already in the model and you want to change its key value,
  /// call #setKeyForLinkData with a new and unique key.
  _i3.Key Function(
    _i3.GraphLinksModel,
    _i2.Object,
  )? get makeUniqueLinkKeyFunction => _i5.getProperty(
        this,
        'makeUniqueLinkKeyFunction',
      );
  /* #26306
  source: 
    /**
     * Gets or sets a function that returns a unique id number or string for a link data object.
     * This function is called by #makeLinkDataKeyUnique
     * when a link data object is added to the model, either as part of a new
     * #linkDataArray or by a call to #addLinkData, to make sure the value of
     * #getKeyForLinkData is unique within the model.
     * However it will not be called when #linkKeyProperty is the default value, an empty string.
     *
     * The value may be null in order to cause #makeLinkDataKeyUnique behave in the standard manner.
     * (The default value is null.)
     * You may want to supply a function here in order to make sure all of the automatically generated keys
     * are in a particular format.
     * Setting this property after setting #linkDataArray has no real effect until there is a call
     * to #addLinkData.
     *
     * If a link data object is already in the model and you want to change its key value,
     * call #setKeyForLinkData with a new and unique key.
     * @since 1.6
     */
    get makeUniqueLinkKeyFunction(): ((a: GraphLinksModel, b: ObjectData) => Key) | null; */
  // Type InteropUnion#303224886(parent: InteropGetter#317281368(name: makeUniqueLinkKeyFunction))
  set makeUniqueLinkKeyFunction(
      _i3.Key Function(
        _i3.GraphLinksModel,
        _i2.Object,
      )? value) {
    _i5.setProperty(
      this,
      'makeUniqueLinkKeyFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #26430
  source: 
    /**
     * Gets or sets a function that makes a copy of a link data object.
     *
     * You may need to set this property in order to ensure that a copied Link is bound
     * to data that does not share certain data structures between the original link data and the copied link data.
     * This property value may be null in order to cause #copyLinkData to make a shallow copy of a JavaScript Object.
     * The default value is null.
     */
    get copyLinkDataFunction(): ((a: ObjectData, b: GraphLinksModel) => ObjectData) | null; */
  /// Gets or sets a function that makes a copy of a link data object.
  ///
  /// You may need to set this property in order to ensure that a copied Link is bound
  /// to data that does not share certain data structures between the original link data and the copied link data.
  /// This property value may be null in order to cause #copyLinkData to make a shallow copy of a JavaScript Object.
  /// The default value is null.
  _i2.Object Function(
    _i2.Object,
    _i3.GraphLinksModel,
  )? get copyLinkDataFunction => _i5.getProperty(
        this,
        'copyLinkDataFunction',
      );
  /* #26430
  source: 
    /**
     * Gets or sets a function that makes a copy of a link data object.
     *
     * You may need to set this property in order to ensure that a copied Link is bound
     * to data that does not share certain data structures between the original link data and the copied link data.
     * This property value may be null in order to cause #copyLinkData to make a shallow copy of a JavaScript Object.
     * The default value is null.
     */
    get copyLinkDataFunction(): ((a: ObjectData, b: GraphLinksModel) => ObjectData) | null; */
  // Type InteropUnion#435600102(parent: InteropGetter#161999847(name: copyLinkDataFunction))
  set copyLinkDataFunction(
      _i2.Object Function(
        _i2.Object,
        _i3.GraphLinksModel,
      )? value) {
    _i5.setProperty(
      this,
      'copyLinkDataFunction',
      value == null ? _i4.undefined : _i5.allowInterop(value),
    );
  }

  /* #26462
  source: 
    /**
     * Gets or sets the name of the boolean property on node data that indicates
     * whether the data should be represented as a group of nodes and links or as a simple node.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return true if the node data object should be represented by a Group and false otherwise.
     * At the current time the function will not be called to change whether the node is a group or not.
     * The default value is the name 'isGroup', meaning that it expects the data to have a property named 'isGroup' on those node data objects that should be represented by Groups.
     *
     * The value must not be null.
     * If the value is an empty string,
     * #isGroupForNodeData will return false for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     */
    get nodeIsGroupProperty(): string | ((a: ObjectData, b?: boolean) => boolean); */
  /// Gets or sets the name of the boolean property on node data that indicates
  /// whether the data should be represented as a group of nodes and links or as a simple node.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return true if the node data object should be represented by a Group and false otherwise.
  /// At the current time the function will not be called to change whether the node is a group or not.
  /// The default value is the name 'isGroup', meaning that it expects the data to have a property named 'isGroup' on those node data objects that should be represented by Groups.
  ///
  /// The value must not be null.
  /// If the value is an empty string,
  /// #isGroupForNodeData will return false for all node data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get nodeIsGroupProperty => _i5.getProperty(
        this,
        'nodeIsGroupProperty',
      );
  /* #26462
  source: 
    /**
     * Gets or sets the name of the boolean property on node data that indicates
     * whether the data should be represented as a group of nodes and links or as a simple node.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return true if the node data object should be represented by a Group and false otherwise.
     * At the current time the function will not be called to change whether the node is a group or not.
     * The default value is the name 'isGroup', meaning that it expects the data to have a property named 'isGroup' on those node data objects that should be represented by Groups.
     *
     * The value must not be null.
     * If the value is an empty string,
     * #isGroupForNodeData will return false for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     */
    get nodeIsGroupProperty(): string | ((a: ObjectData, b?: boolean) => boolean); */
  // Type InteropUnion#361942940(parent: InteropGetter#729239648(name: nodeIsGroupProperty))
  set nodeIsGroupProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'nodeIsGroupProperty',
      value,
    );
  }

  /* #26494
  source: 
    /**
     * Gets or sets the name of the property on node data that specifies
     * the string or number key of the group data that "owns" that node data.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the string or number key for the group data object of which the given data object is a member;
     * if the second argument is supplied, the function should modify the node data object so that it has that new key
     * (which may be undefined to refer to no node) as the containing group key for that node.
     * The default value is the name 'group', meaning that it expects the data to have a property named 'group' to refer to any containing group.
     *
     * The value must not be null.
     * If the value is an empty string,
     * #getGroupKeyForNodeData will return undefined for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getGroupKeyForNodeData
     * @see #setGroupKeyForNodeData
     */
    get nodeGroupKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the property on node data that specifies
  /// the string or number key of the group data that "owns" that node data.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return the string or number key for the group data object of which the given data object is a member;
  /// if the second argument is supplied, the function should modify the node data object so that it has that new key
  /// (which may be undefined to refer to no node) as the containing group key for that node.
  /// The default value is the name 'group', meaning that it expects the data to have a property named 'group' to refer to any containing group.
  ///
  /// The value must not be null.
  /// If the value is an empty string,
  /// #getGroupKeyForNodeData will return undefined for all node data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get nodeGroupKeyProperty => _i5.getProperty(
        this,
        'nodeGroupKeyProperty',
      );
  /* #26494
  source: 
    /**
     * Gets or sets the name of the property on node data that specifies
     * the string or number key of the group data that "owns" that node data.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the string or number key for the group data object of which the given data object is a member;
     * if the second argument is supplied, the function should modify the node data object so that it has that new key
     * (which may be undefined to refer to no node) as the containing group key for that node.
     * The default value is the name 'group', meaning that it expects the data to have a property named 'group' to refer to any containing group.
     *
     * The value must not be null.
     * If the value is an empty string,
     * #getGroupKeyForNodeData will return undefined for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getGroupKeyForNodeData
     * @see #setGroupKeyForNodeData
     */
    get nodeGroupKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#400158209(parent: InteropGetter#464928654(name: nodeGroupKeyProperty))
  set nodeGroupKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'nodeGroupKeyProperty',
      value,
    );
  }

  /* #26559
  source: 
    /**
     * Gets or sets the name of the data property that returns a string naming that data's category,
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the category name;
     * if the second argument is supplied, the function should modify the link data object so that it has that new category name.
     * The default value is the name 'category', meaning that it expects the data to have a property named 'category' if it cares to name the category for the Link.
     * This is used by the diagram to distinguish between different kinds of links.
     * The name must not be null.
     * If the value is an empty string,
     * #getCategoryForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getCategoryForLinkData
     * @see #setCategoryForLinkData
     */
    get linkCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  /// Gets or sets the name of the data property that returns a string naming that data's category,
  /// The value may also be a function taking two arguments, where the first argument will be a link data object.
  /// If the second argument is not supplied, the function should return the category name;
  /// if the second argument is supplied, the function should modify the link data object so that it has that new category name.
  /// The default value is the name 'category', meaning that it expects the data to have a property named 'category' if it cares to name the category for the Link.
  /// This is used by the diagram to distinguish between different kinds of links.
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getCategoryForLinkData will return an empty string for all link data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get linkCategoryProperty => _i5.getProperty(
        this,
        'linkCategoryProperty',
      );
  /* #26559
  source: 
    /**
     * Gets or sets the name of the data property that returns a string naming that data's category,
     * The value may also be a function taking two arguments, where the first argument will be a link data object.
     * If the second argument is not supplied, the function should return the category name;
     * if the second argument is supplied, the function should modify the link data object so that it has that new category name.
     * The default value is the name 'category', meaning that it expects the data to have a property named 'category' if it cares to name the category for the Link.
     * This is used by the diagram to distinguish between different kinds of links.
     * The name must not be null.
     * If the value is an empty string,
     * #getCategoryForLinkData will return an empty string for all link data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getCategoryForLinkData
     * @see #setCategoryForLinkData
     */
    get linkCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  // Type InteropUnion#175689495(parent: InteropGetter#616515891(name: linkCategoryProperty))
  set linkCategoryProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'linkCategoryProperty',
      value,
    );
  }

  _i3.Key getFromKeyForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getFromKeyForLinkData',
        [linkdata],
      );
  void setFromKeyForLinkData(
    _i2.Object linkdata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setFromKeyForLinkData',
      [
        linkdata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i3.Key getToKeyForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getToKeyForLinkData',
        [linkdata],
      );
  void setToKeyForLinkData(
    _i2.Object linkdata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setToKeyForLinkData',
      [
        linkdata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i2.String getFromPortIdForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getFromPortIdForLinkData',
        [linkdata],
      );
  void setFromPortIdForLinkData(
    _i2.Object linkdata,
    _i2.String portname,
  ) {
    _i5.callMethod(
      this,
      'setFromPortIdForLinkData',
      [
        linkdata,
        portname,
      ],
    );
  }

  _i2.String getToPortIdForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getToPortIdForLinkData',
        [linkdata],
      );
  void setToPortIdForLinkData(
    _i2.Object linkdata,
    _i2.String portname,
  ) {
    _i5.callMethod(
      this,
      'setToPortIdForLinkData',
      [
        linkdata,
        portname,
      ],
    );
  }

  _i4.Array getLabelKeysForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getLabelKeysForLinkData',
        [linkdata],
      );
  void setLabelKeysForLinkData(
    _i2.Object linkdata,
    _i4.Array arr,
  ) {
    _i5.callMethod(
      this,
      'setLabelKeysForLinkData',
      [
        linkdata,
        arr,
      ],
    );
  }

  void addLabelKeyForLinkData(
    _i2.Object linkdata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'addLabelKeyForLinkData',
      [
        linkdata,
        key ?? _i4.undefined,
      ],
    );
  }

  void removeLabelKeyForLinkData(
    _i2.Object linkdata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'removeLabelKeyForLinkData',
      [
        linkdata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i3.Key getKeyForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getKeyForLinkData',
        [linkdata],
      );
  void setKeyForLinkData(
    _i2.Object linkdata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setKeyForLinkData',
      [
        linkdata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i2.Object? findLinkDataForKey(_i3.Key key) => _i5.callMethod(
        this,
        'findLinkDataForKey',
        [key ?? _i4.undefined],
      );
  void makeLinkDataKeyUnique(_i2.Object linkdata) {
    _i5.callMethod(
      this,
      'makeLinkDataKeyUnique',
      [linkdata],
    );
  }

  _i2.bool containsLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'containsLinkData',
        [linkdata],
      );
  void addLinkData(_i2.Object linkdata) {
    _i5.callMethod(
      this,
      'addLinkData',
      [linkdata],
    );
  }

  void addLinkDataCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'addLinkDataCollection',
      [coll],
    );
  }

  void removeLinkData(_i2.Object linkdata) {
    _i5.callMethod(
      this,
      'removeLinkData',
      [linkdata],
    );
  }

  void removeLinkDataCollection(_i2.Object coll) {
    _i5.callMethod(
      this,
      'removeLinkDataCollection',
      [coll],
    );
  }

  void mergeLinkDataArray(_i4.Array arr) {
    _i5.callMethod(
      this,
      'mergeLinkDataArray',
      [arr],
    );
  }

  _i2.Object copyLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'copyLinkData',
        [linkdata],
      );
  _i2.bool isGroupForNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'isGroupForNodeData',
        [nodedata],
      );
  _i3.Key getGroupKeyForNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'getGroupKeyForNodeData',
        [nodedata],
      );
  void setGroupKeyForNodeData(
    _i2.Object nodedata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setGroupKeyForNodeData',
      [
        nodedata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i2.Object? copyNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'copyNodeData',
        [nodedata],
      );
  void setDataProperty(
    _i2.Object data,
    _i2.String propname,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'setDataProperty',
      [
        data,
        propname,
        val,
      ],
    );
  }

  void assignAllDataProperties(
    _i2.Object data,
    _i2.Object props,
  ) {
    _i5.callMethod(
      this,
      'assignAllDataProperties',
      [
        data,
        props,
      ],
    );
  }

  _i2.String getCategoryForLinkData(_i2.Object linkdata) => _i5.callMethod(
        this,
        'getCategoryForLinkData',
        [linkdata],
      );
  void setCategoryForLinkData(
    _i2.Object linkdata,
    _i2.String cat,
  ) {
    _i5.callMethod(
      this,
      'setCategoryForLinkData',
      [
        linkdata,
        cat,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class TreeModel implements _i3.Model {
  factory TreeModel.$1() => _i5.callConstructor(
        _declaredTreeModel,
        [],
      );

  factory TreeModel.$2([_i4.Partial? init]) => _i5.callConstructor(
        _declaredTreeModel,
        [init ?? _i4.undefined],
      );

  factory TreeModel.$3([
    _i4.Array? nodedataarray,
    _i4.Partial? init,
  ]) =>
      _i5.callConstructor(
        _declaredTreeModel,
        [
          nodedataarray ?? _i4.undefined,
          init ?? _i4.undefined,
        ],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('TreeModel')
external _i2.Object _declaredTreeModel;

extension TreeModel$Typings on TreeModel {
  /* #26648
  source: 
    /**
     * Gets or sets the name of the property on node data that specifies
     * the string or number key of the node data that acts as the "parent" for this "child" node data.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the string or number key for the parent node data object of which the given data object is a child;
     * if the second argument is supplied, the function should modify the node data object so that it has that new key
     * (which may be undefined to refer to no node) as the parent key for that node..
     * The default value is the name 'parent', meaning that it expects the data to have a property named 'parent' if the node wants to refer to the parent node by its key.
     * The value must not be null nor an empty string.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getParentKeyForNodeData
     * @see #setParentKeyForNodeData
     */
    get nodeParentKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  /// Gets or sets the name of the property on node data that specifies
  /// the string or number key of the node data that acts as the "parent" for this "child" node data.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return the string or number key for the parent node data object of which the given data object is a child;
  /// if the second argument is supplied, the function should modify the node data object so that it has that new key
  /// (which may be undefined to refer to no node) as the parent key for that node..
  /// The default value is the name 'parent', meaning that it expects the data to have a property named 'parent' if the node wants to refer to the parent node by its key.
  /// The value must not be null nor an empty string.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get nodeParentKeyProperty => _i5.getProperty(
        this,
        'nodeParentKeyProperty',
      );
  /* #26648
  source: 
    /**
     * Gets or sets the name of the property on node data that specifies
     * the string or number key of the node data that acts as the "parent" for this "child" node data.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the string or number key for the parent node data object of which the given data object is a child;
     * if the second argument is supplied, the function should modify the node data object so that it has that new key
     * (which may be undefined to refer to no node) as the parent key for that node..
     * The default value is the name 'parent', meaning that it expects the data to have a property named 'parent' if the node wants to refer to the parent node by its key.
     * The value must not be null nor an empty string.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getParentKeyForNodeData
     * @see #setParentKeyForNodeData
     */
    get nodeParentKeyProperty(): string | ((a: ObjectData, b?: Key) => Key); */
  // Type InteropUnion#303427192(parent: InteropGetter#1034470877(name: nodeParentKeyProperty))
  set nodeParentKeyProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'nodeParentKeyProperty',
      value,
    );
  }

  /* #26684
  source: 
    /**
     * Gets or sets the name of the data property that returns a string describing that node data's parent link's category.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the category name for any parent link;
     * if the second argument is supplied, the function should modify the node data object so that its parent link has that new category name.
     * The default value is the name 'parentLinkCategory'.
     * This is used by the diagram to distinguish between different kinds of links.
     * The name must not be null.
     * If the value is an empty string,
     * #getParentLinkCategoryForNodeData will return an empty string for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getParentLinkCategoryForNodeData
     * @see #setParentLinkCategoryForNodeData
     */
    get parentLinkCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  /// Gets or sets the name of the data property that returns a string describing that node data's parent link's category.
  /// The value may also be a function taking two arguments, where the first argument will be a node data object.
  /// If the second argument is not supplied, the function should return the category name for any parent link;
  /// if the second argument is supplied, the function should modify the node data object so that its parent link has that new category name.
  /// The default value is the name 'parentLinkCategory'.
  /// This is used by the diagram to distinguish between different kinds of links.
  /// The name must not be null.
  /// If the value is an empty string,
  /// #getParentLinkCategoryForNodeData will return an empty string for all node data objects.
  ///
  /// If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
  /// Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
  /// and if you want this property to be a function, you will need to assign this property to your desired function
  /// immediately after creating the model, including when it is created by Model.fromJson.
  _i2.Object get parentLinkCategoryProperty => _i5.getProperty(
        this,
        'parentLinkCategoryProperty',
      );
  /* #26684
  source: 
    /**
     * Gets or sets the name of the data property that returns a string describing that node data's parent link's category.
     * The value may also be a function taking two arguments, where the first argument will be a node data object.
     * If the second argument is not supplied, the function should return the category name for any parent link;
     * if the second argument is supplied, the function should modify the node data object so that its parent link has that new category name.
     * The default value is the name 'parentLinkCategory'.
     * This is used by the diagram to distinguish between different kinds of links.
     * The name must not be null.
     * If the value is an empty string,
     * #getParentLinkCategoryForNodeData will return an empty string for all node data objects.
     *
     * If you want to set this property you must do so before using the model, and especially before you assign Diagram#model.
     * Note that functions cannot be serialized into JSON-formatted text, so if you are using #toJson and Model.fromJson,
     * and if you want this property to be a function, you will need to assign this property to your desired function
     * immediately after creating the model, including when it is created by Model.fromJson.
     * @see #getParentLinkCategoryForNodeData
     * @see #setParentLinkCategoryForNodeData
     */
    get parentLinkCategoryProperty(): string | ((a: ObjectData, b?: string) => string); */
  // Type InteropUnion#564795020(parent: InteropGetter#1069704098(name: parentLinkCategoryProperty))
  set parentLinkCategoryProperty(_i2.Object value) {
    _i5.setProperty(
      this,
      'parentLinkCategoryProperty',
      value,
    );
  }

  _i3.Key getParentKeyForNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'getParentKeyForNodeData',
        [nodedata],
      );
  void setParentKeyForNodeData(
    _i2.Object nodedata,
    _i3.Key key,
  ) {
    _i5.callMethod(
      this,
      'setParentKeyForNodeData',
      [
        nodedata,
        key ?? _i4.undefined,
      ],
    );
  }

  _i2.String getParentLinkCategoryForNodeData(_i2.Object childdata) =>
      _i5.callMethod(
        this,
        'getParentLinkCategoryForNodeData',
        [childdata],
      );
  void setParentLinkCategoryForNodeData(
    _i2.Object childdata,
    _i2.String cat,
  ) {
    _i5.callMethod(
      this,
      'setParentLinkCategoryForNodeData',
      [
        childdata,
        cat,
      ],
    );
  }

  _i2.Object? copyNodeData(_i2.Object nodedata) => _i5.callMethod(
        this,
        'copyNodeData',
        [nodedata],
      );
  void setDataProperty(
    _i2.Object data,
    _i2.String propname,
    _i2.dynamic val,
  ) {
    _i5.callMethod(
      this,
      'setDataProperty',
      [
        data,
        propname,
        val,
      ],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class CircularLayout implements _i3.Layout {
  factory CircularLayout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredCircularLayout,
        [init ?? _i4.undefined],
      );

  /* #26916
  source: 
    /**
     * The spacing between the idealized boundaries of the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantSpacing: EnumValue; */
  /// The spacing between the idealized boundaries of the nodes is constant;
  /// This value is used for CircularLayout#arrangement.
  static _i3.EnumValue get constantSpacing => _i5.getProperty(
        _declaredCircularLayout,
        'ConstantSpacing',
      );
  /* #26916
  source: 
    /**
     * The spacing between the idealized boundaries of the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantSpacing: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set constantSpacing(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'ConstantSpacing',
      value,
    );
  }

  /* #26922
  source: 
    /**
     * The distance between the centers of the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantDistance: EnumValue; */
  /// The distance between the centers of the nodes is constant;
  /// This value is used for CircularLayout#arrangement.
  static _i3.EnumValue get constantDistance => _i5.getProperty(
        _declaredCircularLayout,
        'ConstantDistance',
      );
  /* #26922
  source: 
    /**
     * The distance between the centers of the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantDistance: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set constantDistance(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'ConstantDistance',
      value,
    );
  }

  /* #26928
  source: 
    /**
     * The angular distance between the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantAngle: EnumValue; */
  /// The angular distance between the nodes is constant;
  /// This value is used for CircularLayout#arrangement.
  static _i3.EnumValue get constantAngle => _i5.getProperty(
        _declaredCircularLayout,
        'ConstantAngle',
      );
  /* #26928
  source: 
    /**
     * The angular distance between the nodes is constant;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static ConstantAngle: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set constantAngle(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'ConstantAngle',
      value,
    );
  }

  /* #26935
  source: 
    /**
     * The vertices are arranged as close together as possible considering the CircularLayout#spacing,
     * assuming the nodes are rectangular;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static Packed: EnumValue; */
  /// The vertices are arranged as close together as possible considering the CircularLayout#spacing,
  /// assuming the nodes are rectangular;
  /// This value is used for CircularLayout#arrangement.
  static _i3.EnumValue get packed => _i5.getProperty(
        _declaredCircularLayout,
        'Packed',
      );
  /* #26935
  source: 
    /**
     * The vertices are arranged as close together as possible considering the CircularLayout#spacing,
     * assuming the nodes are rectangular;
     * This value is used for CircularLayout#arrangement.
     * @constant
     */
    static Packed: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set packed(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Packed',
      value,
    );
  }

  /* #26941
  source: 
    /**
     * Rings are filled clockwise;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static Clockwise: EnumValue; */
  /// Rings are filled clockwise;
  /// This value is used for CircularLayout#direction.
  static _i3.EnumValue get clockwise => _i5.getProperty(
        _declaredCircularLayout,
        'Clockwise',
      );
  /* #26941
  source: 
    /**
     * Rings are filled clockwise;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static Clockwise: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set clockwise(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Clockwise',
      value,
    );
  }

  /* #26947
  source: 
    /**
     * Rings are filled counterclockwise;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static Counterclockwise: EnumValue; */
  /// Rings are filled counterclockwise;
  /// This value is used for CircularLayout#direction.
  static _i3.EnumValue get counterclockwise => _i5.getProperty(
        _declaredCircularLayout,
        'Counterclockwise',
      );
  /* #26947
  source: 
    /**
     * Rings are filled counterclockwise;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static Counterclockwise: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set counterclockwise(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Counterclockwise',
      value,
    );
  }

  /* #26953
  source: 
    /**
     * The ring is filled by alternating sides; the second node is counterclockwise from the first node;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static BidirectionalLeft: EnumValue; */
  /// The ring is filled by alternating sides; the second node is counterclockwise from the first node;
  /// This value is used for CircularLayout#direction.
  static _i3.EnumValue get bidirectionalLeft => _i5.getProperty(
        _declaredCircularLayout,
        'BidirectionalLeft',
      );
  /* #26953
  source: 
    /**
     * The ring is filled by alternating sides; the second node is counterclockwise from the first node;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static BidirectionalLeft: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set bidirectionalLeft(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'BidirectionalLeft',
      value,
    );
  }

  /* #26959
  source: 
    /**
     * The ring is filled by alternating sides; the second node is clockwise from the first node;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static BidirectionalRight: EnumValue; */
  /// The ring is filled by alternating sides; the second node is clockwise from the first node;
  /// This value is used for CircularLayout#direction.
  static _i3.EnumValue get bidirectionalRight => _i5.getProperty(
        _declaredCircularLayout,
        'BidirectionalRight',
      );
  /* #26959
  source: 
    /**
     * The ring is filled by alternating sides; the second node is clockwise from the first node;
     * This value is used for CircularLayout#direction.
     * @constant
     */
    static BidirectionalRight: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set bidirectionalRight(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'BidirectionalRight',
      value,
    );
  }

  /* #26965
  source: 
    /**
     * Nodes are arranged in the order given;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Forwards: EnumValue; */
  /// Nodes are arranged in the order given;
  /// This value is used for CircularLayout#sorting.
  static _i3.EnumValue get forwards => _i5.getProperty(
        _declaredCircularLayout,
        'Forwards',
      );
  /* #26965
  source: 
    /**
     * Nodes are arranged in the order given;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Forwards: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set forwards(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Forwards',
      value,
    );
  }

  /* #26971
  source: 
    /**
     * Nodes are arranged in the reverse of the order given;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Reverse: EnumValue; */
  /// Nodes are arranged in the reverse of the order given;
  /// This value is used for CircularLayout#sorting.
  static _i3.EnumValue get reverse => _i5.getProperty(
        _declaredCircularLayout,
        'Reverse',
      );
  /* #26971
  source: 
    /**
     * Nodes are arranged in the reverse of the order given;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Reverse: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set reverse(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Reverse',
      value,
    );
  }

  /* #26977
  source: 
    /**
     * Nodes are sorted using the #comparer, in ascending order;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Ascending: EnumValue; */
  /// Nodes are sorted using the #comparer, in ascending order;
  /// This value is used for CircularLayout#sorting.
  static _i3.EnumValue get ascending => _i5.getProperty(
        _declaredCircularLayout,
        'Ascending',
      );
  /* #26977
  source: 
    /**
     * Nodes are sorted using the #comparer, in ascending order;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Ascending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set ascending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Ascending',
      value,
    );
  }

  /* #26983
  source: 
    /**
     * Nodes are sorted using the #comparer, in reverse ascending (descending) order;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Descending: EnumValue; */
  /// Nodes are sorted using the #comparer, in reverse ascending (descending) order;
  /// This value is used for CircularLayout#sorting.
  static _i3.EnumValue get descending => _i5.getProperty(
        _declaredCircularLayout,
        'Descending',
      );
  /* #26983
  source: 
    /**
     * Nodes are sorted using the #comparer, in reverse ascending (descending) order;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Descending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set descending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Descending',
      value,
    );
  }

  /* #26989
  source: 
    /**
     * Nodes are ordered to reduce link crossings;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Optimized: EnumValue; */
  /// Nodes are ordered to reduce link crossings;
  /// This value is used for CircularLayout#sorting.
  static _i3.EnumValue get optimized => _i5.getProperty(
        _declaredCircularLayout,
        'Optimized',
      );
  /* #26989
  source: 
    /**
     * Nodes are ordered to reduce link crossings;
     * This value is used for CircularLayout#sorting.
     * @constant
     */
    static Optimized: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set optimized(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Optimized',
      value,
    );
  }

  /* #26996
  source: 
    /**
     * The effective diameter is sqrt(width^2+height^2);
     * The corners of square nodes will touch at 45 degrees when CircularLayout#spacing is 0;
     * This value is used for CircularLayout#nodeDiameterFormula.
     * @constant
     */
    static Pythagorean: EnumValue; */
  /// The effective diameter is sqrt(width^2+height^2);
  /// The corners of square nodes will touch at 45 degrees when CircularLayout#spacing is 0;
  /// This value is used for CircularLayout#nodeDiameterFormula.
  static _i3.EnumValue get pythagorean => _i5.getProperty(
        _declaredCircularLayout,
        'Pythagorean',
      );
  /* #26996
  source: 
    /**
     * The effective diameter is sqrt(width^2+height^2);
     * The corners of square nodes will touch at 45 degrees when CircularLayout#spacing is 0;
     * This value is used for CircularLayout#nodeDiameterFormula.
     * @constant
     */
    static Pythagorean: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set pythagorean(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Pythagorean',
      value,
    );
  }

  /* #27004
  source: 
    /**
     * The effective diameter is either the width or height of the node, whichever is larger;
     * This will cause circular nodes to touch when CircularLayout#spacing is 0;
     * This is ideal when the nodes are circular.
     * This value is used for CircularLayout#nodeDiameterFormula.
     * @constant
     */
    static Circular: EnumValue; */
  /// The effective diameter is either the width or height of the node, whichever is larger;
  /// This will cause circular nodes to touch when CircularLayout#spacing is 0;
  /// This is ideal when the nodes are circular.
  /// This value is used for CircularLayout#nodeDiameterFormula.
  static _i3.EnumValue get circular => _i5.getProperty(
        _declaredCircularLayout,
        'Circular',
      );
  /* #27004
  source: 
    /**
     * The effective diameter is either the width or height of the node, whichever is larger;
     * This will cause circular nodes to touch when CircularLayout#spacing is 0;
     * This is ideal when the nodes are circular.
     * This value is used for CircularLayout#nodeDiameterFormula.
     * @constant
     */
    static Circular: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set circular(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredCircularLayout,
      'Circular',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('CircularLayout')
external _i2.Object _declaredCircularLayout;

extension CircularLayout$Typings on CircularLayout {
  /* #26797
  source: 
    /**
     * Gets or sets the horizontal radius of the elliptical arrangement.
     *
     * The default value is NaN.
     * NaN indicates that the #spacing will determine the size of the ring.
     * If #spacing is also NaN, the effective spacing will be 6.
     * If #spacing is a number, the effective radius will be > radius if and only if
     * the spacing between elements would otherwise be less than spacing.
     * The specified value for #radius will be ignored if #arrangement === CircularLayout.Packed.
     * This property must always be positive or NaN.
     */
    get radius(): number; */
  /// Gets or sets the horizontal radius of the elliptical arrangement.
  ///
  /// The default value is NaN.
  /// NaN indicates that the #spacing will determine the size of the ring.
  /// If #spacing is also NaN, the effective spacing will be 6.
  /// If #spacing is a number, the effective radius will be > radius if and only if
  /// the spacing between elements would otherwise be less than spacing.
  /// The specified value for #radius will be ignored if #arrangement === CircularLayout.Packed.
  /// This property must always be positive or NaN.
  _i2.num get radius => _i5.getProperty(
        this,
        'radius',
      );
  /* #26797
  source: 
    /**
     * Gets or sets the horizontal radius of the elliptical arrangement.
     *
     * The default value is NaN.
     * NaN indicates that the #spacing will determine the size of the ring.
     * If #spacing is also NaN, the effective spacing will be 6.
     * If #spacing is a number, the effective radius will be > radius if and only if
     * the spacing between elements would otherwise be less than spacing.
     * The specified value for #radius will be ignored if #arrangement === CircularLayout.Packed.
     * This property must always be positive or NaN.
     */
    get radius(): number; */
  // Type InteropStaticType.number
  set radius(_i2.num value) {
    _i5.setProperty(
      this,
      'radius',
      value,
    );
  }

  /* #26808
  source: 
    /**
     * Gets or sets the ratio of the arrangement's height to its width
     * (1 for a circle, &gt;1 for a vertically elongated ellipse).
     *
     * This is 1 by default.
     * The value must be a positive number.
     *
     * Modifying this value changes the height, but keeps the width and the #radius constant.
     */
    get aspectRatio(): number; */
  /// Gets or sets the ratio of the arrangement's height to its width
  /// (1 for a circle, &gt;1 for a vertically elongated ellipse).
  ///
  /// This is 1 by default.
  /// The value must be a positive number.
  ///
  /// Modifying this value changes the height, but keeps the width and the #radius constant.
  _i2.num get aspectRatio => _i5.getProperty(
        this,
        'aspectRatio',
      );
  /* #26808
  source: 
    /**
     * Gets or sets the ratio of the arrangement's height to its width
     * (1 for a circle, &gt;1 for a vertically elongated ellipse).
     *
     * This is 1 by default.
     * The value must be a positive number.
     *
     * Modifying this value changes the height, but keeps the width and the #radius constant.
     */
    get aspectRatio(): number; */
  // Type InteropStaticType.number
  set aspectRatio(_i2.num value) {
    _i5.setProperty(
      this,
      'aspectRatio',
      value,
    );
  }

  /* #26815
  source: 
    /**
     * Gets or sets the angle (in degrees, clockwise from the positive side of the X axis) of the first element.
     *
     * The default value is 0.
     */
    get startAngle(): number; */
  /// Gets or sets the angle (in degrees, clockwise from the positive side of the X axis) of the first element.
  ///
  /// The default value is 0.
  _i2.num get startAngle => _i5.getProperty(
        this,
        'startAngle',
      );
  /* #26815
  source: 
    /**
     * Gets or sets the angle (in degrees, clockwise from the positive side of the X axis) of the first element.
     *
     * The default value is 0.
     */
    get startAngle(): number; */
  // Type InteropStaticType.number
  set startAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'startAngle',
      value,
    );
  }

  /* #26830
  source: 
    /**
     * Gets or sets the absolute angle (in degrees) between the first and last node.
     *
     * The default value is 360.
     * The value must be greater than zero and less than or equal to 360.
     * If it is not in this range, it will be automatically set to 360.
     *
     * Whether the arrangement is clockwise or counterclockwise does not depend on the sign of this value.
     * The direction can be controlled by setting #direction.
     * If 360 is the specified value, the actual value will be less to keep the first and last
     * elements from overlapping, and the spacing between the first and last nodes will be determined
     * the same way as for all other adjacent nodes.
     */
    get sweepAngle(): number; */
  /// Gets or sets the absolute angle (in degrees) between the first and last node.
  ///
  /// The default value is 360.
  /// The value must be greater than zero and less than or equal to 360.
  /// If it is not in this range, it will be automatically set to 360.
  ///
  /// Whether the arrangement is clockwise or counterclockwise does not depend on the sign of this value.
  /// The direction can be controlled by setting #direction.
  /// If 360 is the specified value, the actual value will be less to keep the first and last
  /// elements from overlapping, and the spacing between the first and last nodes will be determined
  /// the same way as for all other adjacent nodes.
  _i2.num get sweepAngle => _i5.getProperty(
        this,
        'sweepAngle',
      );
  /* #26830
  source: 
    /**
     * Gets or sets the absolute angle (in degrees) between the first and last node.
     *
     * The default value is 360.
     * The value must be greater than zero and less than or equal to 360.
     * If it is not in this range, it will be automatically set to 360.
     *
     * Whether the arrangement is clockwise or counterclockwise does not depend on the sign of this value.
     * The direction can be controlled by setting #direction.
     * If 360 is the specified value, the actual value will be less to keep the first and last
     * elements from overlapping, and the spacing between the first and last nodes will be determined
     * the same way as for all other adjacent nodes.
     */
    get sweepAngle(): number; */
  // Type InteropStaticType.number
  set sweepAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'sweepAngle',
      value,
    );
  }

  /* #26839
  source: 
    /**
     * Gets or sets how the nodes are spaced.
     * If #arrangement === CircularLayout.Packed,
     * the specified #radius will be ignored.
     *
     * The default value is CircularLayout.ConstantSpacing.
     */
    get arrangement(): EnumValue; */
  /// Gets or sets how the nodes are spaced.
  /// If #arrangement === CircularLayout.Packed,
  /// the specified #radius will be ignored.
  ///
  /// The default value is CircularLayout.ConstantSpacing.
  _i3.EnumValue get arrangement => _i5.getProperty(
        this,
        'arrangement',
      );
  /* #26839
  source: 
    /**
     * Gets or sets how the nodes are spaced.
     * If #arrangement === CircularLayout.Packed,
     * the specified #radius will be ignored.
     *
     * The default value is CircularLayout.ConstantSpacing.
     */
    get arrangement(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set arrangement(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'arrangement',
      value,
    );
  }

  /* #26846
  source: 
    /**
     * Gets or sets whether the nodes are arranged clockwise or counterclockwise.
     *
     * The default value is CircularLayout.Clockwise.
     */
    get direction(): EnumValue; */
  /// Gets or sets whether the nodes are arranged clockwise or counterclockwise.
  ///
  /// The default value is CircularLayout.Clockwise.
  _i3.EnumValue get direction => _i5.getProperty(
        this,
        'direction',
      );
  /* #26846
  source: 
    /**
     * Gets or sets whether the nodes are arranged clockwise or counterclockwise.
     *
     * The default value is CircularLayout.Clockwise.
     */
    get direction(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set direction(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'direction',
      value,
    );
  }

  /* #26859
  source: 
    /**
     * Gets or sets if and how the nodes are sorted.
     *
     * CircularLayout.Forwards indicates that the nodes are arranged in the order the layout gets them.
     * CircularLayout.Reverse indicates that the nodes are arranged in the reverse order that the layout gets them.
     * CircularLayout.Ascending and CircularLayout.Descending indicate that the nodes
     * will be sorted using the #comparer.
     * CircularLayout.Optimized indicates that the nodes will be arranged to minimize link crossings.
     *
     * The default value is CircularLayout.Optimized.
     */
    get sorting(): EnumValue; */
  /// Gets or sets if and how the nodes are sorted.
  ///
  /// CircularLayout.Forwards indicates that the nodes are arranged in the order the layout gets them.
  /// CircularLayout.Reverse indicates that the nodes are arranged in the reverse order that the layout gets them.
  /// CircularLayout.Ascending and CircularLayout.Descending indicate that the nodes
  /// will be sorted using the #comparer.
  /// CircularLayout.Optimized indicates that the nodes will be arranged to minimize link crossings.
  ///
  /// The default value is CircularLayout.Optimized.
  _i3.EnumValue get sorting => _i5.getProperty(
        this,
        'sorting',
      );
  /* #26859
  source: 
    /**
     * Gets or sets if and how the nodes are sorted.
     *
     * CircularLayout.Forwards indicates that the nodes are arranged in the order the layout gets them.
     * CircularLayout.Reverse indicates that the nodes are arranged in the reverse order that the layout gets them.
     * CircularLayout.Ascending and CircularLayout.Descending indicate that the nodes
     * will be sorted using the #comparer.
     * CircularLayout.Optimized indicates that the nodes will be arranged to minimize link crossings.
     *
     * The default value is CircularLayout.Optimized.
     */
    get sorting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set sorting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'sorting',
      value,
    );
  }

  /* #26867
  source: 
    /**
     * Gets or sets the comparer which sorts the data when #sorting is
     * set to CircularLayout.Ascending or CircularLayout.Descending.
     *
     * The default function compares the Part#text values of the vertexes' LayoutVertex#nodes.
     */
    get comparer(): ((a: CircularVertex, b: CircularVertex) => number); */
  /// Gets or sets the comparer which sorts the data when #sorting is
  /// set to CircularLayout.Ascending or CircularLayout.Descending.
  ///
  /// The default function compares the Part#text values of the vertexes' LayoutVertex#nodes.
  _i2.num Function(
    _i3.CircularVertex,
    _i3.CircularVertex,
  ) get comparer => _i5.getProperty(
        this,
        'comparer',
      );
  /* #26867
  source: 
    /**
     * Gets or sets the comparer which sorts the data when #sorting is
     * set to CircularLayout.Ascending or CircularLayout.Descending.
     *
     * The default function compares the Part#text values of the vertexes' LayoutVertex#nodes.
     */
    get comparer(): ((a: CircularVertex, b: CircularVertex) => number); */
  // Type InteropFunction#797427196(parent: InteropGetter#449899863(name: comparer), library: go.d.ts)
  set comparer(
      _i2.num Function(
        _i3.CircularVertex,
        _i3.CircularVertex,
      ) value) {
    _i5.setProperty(
      this,
      'comparer',
      _i5.allowInterop(value),
    );
  }

  /* #26885
  source: 
    /**
     * Gets or sets the distance between nodes (if #radius is NaN)
     * or the minimum distance between nodes (if #radius is a number).
     *
     * The default value is 6.
     * The value may be NaN.
     *
     * If #spacing is NaN, there is no minimum spacing, allowing nodes to overlap,
     * unless #radius is NaN,
     * in which case the effective spacing will be 6 to determine an effective radius.
     * If #spacing is a number but #radius isn't,
     * the effective spacing will be spacing, and this will determine the effective radius.
     * If both #spacing and #radius are numbers,
     * the effective radius will be at least #radius,
     * but may be larger so that the minimum spacing between nodes is #spacing.
     */
    get spacing(): number; */
  /// Gets or sets the distance between nodes (if #radius is NaN)
  /// or the minimum distance between nodes (if #radius is a number).
  ///
  /// The default value is 6.
  /// The value may be NaN.
  ///
  /// If #spacing is NaN, there is no minimum spacing, allowing nodes to overlap,
  /// unless #radius is NaN,
  /// in which case the effective spacing will be 6 to determine an effective radius.
  /// If #spacing is a number but #radius isn't,
  /// the effective spacing will be spacing, and this will determine the effective radius.
  /// If both #spacing and #radius are numbers,
  /// the effective radius will be at least #radius,
  /// but may be larger so that the minimum spacing between nodes is #spacing.
  _i2.num get spacing => _i5.getProperty(
        this,
        'spacing',
      );
  /* #26885
  source: 
    /**
     * Gets or sets the distance between nodes (if #radius is NaN)
     * or the minimum distance between nodes (if #radius is a number).
     *
     * The default value is 6.
     * The value may be NaN.
     *
     * If #spacing is NaN, there is no minimum spacing, allowing nodes to overlap,
     * unless #radius is NaN,
     * in which case the effective spacing will be 6 to determine an effective radius.
     * If #spacing is a number but #radius isn't,
     * the effective spacing will be spacing, and this will determine the effective radius.
     * If both #spacing and #radius are numbers,
     * the effective radius will be at least #radius,
     * but may be larger so that the minimum spacing between nodes is #spacing.
     */
    get spacing(): number; */
  // Type InteropStaticType.number
  set spacing(_i2.num value) {
    _i5.setProperty(
      this,
      'spacing',
      value,
    );
  }

  /* #26893
  source: 
    /**
     * Specifies how the diameter of nodes will be calculated.
     * When a node is not circular, it is not clear what its diameter is.
     *
     * The default is CircularLayout.Pythagorean.
     */
    get nodeDiameterFormula(): EnumValue; */
  /// Specifies how the diameter of nodes will be calculated.
  /// When a node is not circular, it is not clear what its diameter is.
  ///
  /// The default is CircularLayout.Pythagorean.
  _i3.EnumValue get nodeDiameterFormula => _i5.getProperty(
        this,
        'nodeDiameterFormula',
      );
  /* #26893
  source: 
    /**
     * Specifies how the diameter of nodes will be calculated.
     * When a node is not circular, it is not clear what its diameter is.
     *
     * The default is CircularLayout.Pythagorean.
     */
    get nodeDiameterFormula(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set nodeDiameterFormula(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'nodeDiameterFormula',
      value,
    );
  }

  /* #26898
  source: 
    /**
     * This read-only property is the effective X radius that may have been calculated by the layout.
     */
    get actualXRadius(): number; */
  /// This read-only property is the effective X radius that may have been calculated by the layout.
  _i2.num get actualXRadius => _i5.getProperty(
        this,
        'actualXRadius',
      );
  /* #26898
  source: 
    /**
     * This read-only property is the effective X radius that may have been calculated by the layout.
     */
    get actualXRadius(): number; */
  // Type InteropStaticType.number
  set actualXRadius(_i2.num value) {
    _i5.setProperty(
      this,
      'actualXRadius',
      value,
    );
  }

  /* #26902
  source: 
    /**
     * This read-only property is the effective Y radius that may have been calculated by the layout.
     */
    get actualYRadius(): number; */
  /// This read-only property is the effective Y radius that may have been calculated by the layout.
  _i2.num get actualYRadius => _i5.getProperty(
        this,
        'actualYRadius',
      );
  /* #26902
  source: 
    /**
     * This read-only property is the effective Y radius that may have been calculated by the layout.
     */
    get actualYRadius(): number; */
  // Type InteropStaticType.number
  set actualYRadius(_i2.num value) {
    _i5.setProperty(
      this,
      'actualYRadius',
      value,
    );
  }

  /* #26906
  source: 
    /**
     * This read-only property is the effective spacing that may have been calculated by the layout.
     */
    get actualSpacing(): number; */
  /// This read-only property is the effective spacing that may have been calculated by the layout.
  _i2.num get actualSpacing => _i5.getProperty(
        this,
        'actualSpacing',
      );
  /* #26906
  source: 
    /**
     * This read-only property is the effective spacing that may have been calculated by the layout.
     */
    get actualSpacing(): number; */
  // Type InteropStaticType.number
  set actualSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'actualSpacing',
      value,
    );
  }

  /* #26910
  source: 
    /**
     * This read-only property is the coordinates of the center of the laid-out ellipse immediately after the layout.
     */
    get actualCenter(): Point; */
  /// This read-only property is the coordinates of the center of the laid-out ellipse immediately after the layout.
  _i3.Point get actualCenter => _i5.getProperty(
        this,
        'actualCenter',
      );
  /* #26910
  source: 
    /**
     * This read-only property is the coordinates of the center of the laid-out ellipse immediately after the layout.
     */
    get actualCenter(): Point; */
  // Type Instance of 'InteropInterface'
  set actualCenter(_i3.Point value) {
    _i5.setProperty(
      this,
      'actualCenter',
      value,
    );
  }

  _i3.CircularNetwork createNetwork() => _i5.callMethod(
        this,
        'createNetwork',
        [],
      );
  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }

  void commitLayout() {
    _i5.callMethod(
      this,
      'commitLayout',
      [],
    );
  }

  void commitNodes() {
    _i5.callMethod(
      this,
      'commitNodes',
      [],
    );
  }

  void commitLinks() {
    _i5.callMethod(
      this,
      'commitLinks',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class CircularNetwork implements _i3.LayoutNetwork {
  factory CircularNetwork(_i3.CircularLayout layout) => _i5.callConstructor(
        _declaredCircularNetwork,
        [layout],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('CircularNetwork')
external _i2.Object _declaredCircularNetwork;

@_i1.JS()
@_i1.staticInterop
class CircularVertex implements _i3.LayoutVertex {
  factory CircularVertex(_i3.CircularNetwork network) => _i5.callConstructor(
        _declaredCircularVertex,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('CircularVertex')
external _i2.Object _declaredCircularVertex;

extension CircularVertex$Typings on CircularVertex {
  /* #27038
  source: 
    /**
     * Gets or sets the value used as the vertex's diameter.
     *
     * By default the value depends on the CircularLayout#arrangement property.
     * Any computed value is cached, to avoid unnecessary expensive computations.
     */
    get diameter(): number; */
  /// Gets or sets the value used as the vertex's diameter.
  ///
  /// By default the value depends on the CircularLayout#arrangement property.
  /// Any computed value is cached, to avoid unnecessary expensive computations.
  _i2.num get diameter => _i5.getProperty(
        this,
        'diameter',
      );
  /* #27038
  source: 
    /**
     * Gets or sets the value used as the vertex's diameter.
     *
     * By default the value depends on the CircularLayout#arrangement property.
     * Any computed value is cached, to avoid unnecessary expensive computations.
     */
    get diameter(): number; */
  // Type InteropStaticType.number
  set diameter(_i2.num value) {
    _i5.setProperty(
      this,
      'diameter',
      value,
    );
  }

  /* #27043
  source: 
    /**
     * Gets or sets the value used as the vertex's angle.
     */
    get actualAngle(): number; */
  /// Gets or sets the value used as the vertex's angle.
  _i2.num get actualAngle => _i5.getProperty(
        this,
        'actualAngle',
      );
  /* #27043
  source: 
    /**
     * Gets or sets the value used as the vertex's angle.
     */
    get actualAngle(): number; */
  // Type InteropStaticType.number
  set actualAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'actualAngle',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class CircularEdge implements _i3.LayoutEdge {
  factory CircularEdge(_i3.CircularNetwork network) => _i5.callConstructor(
        _declaredCircularEdge,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('CircularEdge')
external _i2.Object _declaredCircularEdge;

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline12 {}

extension IInline12$Typings on IInline12 {
  /* #27409
  source: 
        random: () => number; */
  _i2.num Function() get random => _i5.getProperty(
        this,
        'random',
      );
  /* #27409
  source: 
        random: () => number; */
  // Type InteropFunction#360099879(parent: InteropGetter#514048502(name: random), library: go.d.ts)
  set random(_i2.num Function() value) {
    _i5.setProperty(
      this,
      'random',
      _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class IInline13 {}

extension IInline13$Typings on IInline13 {
  /* #27412
  source: 
        random: () => number; */
  _i2.num Function() get random => _i5.getProperty(
        this,
        'random',
      );
  /* #27412
  source: 
        random: () => number; */
  // Type InteropFunction#582521958(parent: InteropGetter#546093028(name: random), library: go.d.ts)
  set random(_i2.num Function() value) {
    _i5.setProperty(
      this,
      'random',
      _i5.allowInterop(value),
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ForceDirectedLayout implements _i3.Layout {
  factory ForceDirectedLayout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredForceDirectedLayout,
        [init ?? _i4.undefined],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ForceDirectedLayout')
external _i2.Object _declaredForceDirectedLayout;

extension ForceDirectedLayout$Typings on ForceDirectedLayout {
  /* #27330
  source: 
    /**
     * This read-only property returns the current iteration count, valid during a call to #doLayout.
     */
    get currentIteration(): number; */
  /// This read-only property returns the current iteration count, valid during a call to #doLayout.
  _i2.num get currentIteration => _i5.getProperty(
        this,
        'currentIteration',
      );
  /* #27330
  source: 
    /**
     * This read-only property returns the current iteration count, valid during a call to #doLayout.
     */
    get currentIteration(): number; */
  // Type InteropStaticType.number
  set currentIteration(_i2.num value) {
    _i5.setProperty(
      this,
      'currentIteration',
      value,
    );
  }

  /* #27340
  source: 
    /**
     * Gets or sets the space between which the layout
     * will position the connected graphs that together compose the network.
     * This defaults to Size(100, 100).
     * These distances are used during a clustered layout;
     * afterwards the normal force-directed layout
     * will likely cause the size of any space between connected graphs to change,
     * perhaps considerably.
     */
    get arrangementSpacing(): Size; */
  /// Gets or sets the space between which the layout
  /// will position the connected graphs that together compose the network.
  /// This defaults to Size(100, 100).
  /// These distances are used during a clustered layout;
  /// afterwards the normal force-directed layout
  /// will likely cause the size of any space between connected graphs to change,
  /// perhaps considerably.
  _i3.Size get arrangementSpacing => _i5.getProperty(
        this,
        'arrangementSpacing',
      );
  /* #27340
  source: 
    /**
     * Gets or sets the space between which the layout
     * will position the connected graphs that together compose the network.
     * This defaults to Size(100, 100).
     * These distances are used during a clustered layout;
     * afterwards the normal force-directed layout
     * will likely cause the size of any space between connected graphs to change,
     * perhaps considerably.
     */
    get arrangementSpacing(): Size; */
  // Type Instance of 'InteropInterface'
  set arrangementSpacing(_i3.Size value) {
    _i5.setProperty(
      this,
      'arrangementSpacing',
      value,
    );
  }

  /* #27349
  source: 
    /**
     * Gets or sets whether #commitNodes should move all of the
     * nodes so that the nodes all fit with the top-left corner at the
     * Layout#arrangementOrigin.
     * By default this is false -- the Layout#arrangementOrigin is ignored.
     * When this is true, nodes are moved even though #isFixed was true.
     */
    get arrangesToOrigin(): boolean; */
  /// Gets or sets whether #commitNodes should move all of the
  /// nodes so that the nodes all fit with the top-left corner at the
  /// Layout#arrangementOrigin.
  /// By default this is false -- the Layout#arrangementOrigin is ignored.
  /// When this is true, nodes are moved even though #isFixed was true.
  _i2.bool get arrangesToOrigin => _i5.getProperty(
        this,
        'arrangesToOrigin',
      );
  /* #27349
  source: 
    /**
     * Gets or sets whether #commitNodes should move all of the
     * nodes so that the nodes all fit with the top-left corner at the
     * Layout#arrangementOrigin.
     * By default this is false -- the Layout#arrangementOrigin is ignored.
     * When this is true, nodes are moved even though #isFixed was true.
     */
    get arrangesToOrigin(): boolean; */
  // Type InteropStaticType.boolean
  set arrangesToOrigin(_i2.bool value) {
    _i5.setProperty(
      this,
      'arrangesToOrigin',
      value,
    );
  }

  /* #27356
  source: 
    /**
     * Gets or sets whether the fromSpot and the toSpot of every Link
     * should be set to Spot.Default.
     * The default value is true.
     */
    get setsPortSpots(): boolean; */
  /// Gets or sets whether the fromSpot and the toSpot of every Link
  /// should be set to Spot.Default.
  /// The default value is true.
  _i2.bool get setsPortSpots => _i5.getProperty(
        this,
        'setsPortSpots',
      );
  /* #27356
  source: 
    /**
     * Gets or sets whether the fromSpot and the toSpot of every Link
     * should be set to Spot.Default.
     * The default value is true.
     */
    get setsPortSpots(): boolean; */
  // Type InteropStaticType.boolean
  set setsPortSpots(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsPortSpots',
      value,
    );
  }

  /* #27366
  source: 
    /**
     * Gets or sets whether this layout should find all Nodes
     * whose category is "Comment" and
     * whose anchors are nodes represented in the network,
     * and add ForceDirectedVertexes representing those balloon comments
     * as nodes in the network.
     * The default value is false.
     */
    get comments(): boolean; */
  /// Gets or sets whether this layout should find all Nodes
  /// whose category is "Comment" and
  /// whose anchors are nodes represented in the network,
  /// and add ForceDirectedVertexes representing those balloon comments
  /// as nodes in the network.
  /// The default value is false.
  _i2.bool get comments => _i5.getProperty(
        this,
        'comments',
      );
  /* #27366
  source: 
    /**
     * Gets or sets whether this layout should find all Nodes
     * whose category is "Comment" and
     * whose anchors are nodes represented in the network,
     * and add ForceDirectedVertexes representing those balloon comments
     * as nodes in the network.
     * The default value is false.
     */
    get comments(): boolean; */
  // Type InteropStaticType.boolean
  set comments(_i2.bool value) {
    _i5.setProperty(
      this,
      'comments',
      value,
    );
  }

  /* #27374
  source: 
    /**
     * Gets or sets the maximum number of iterations to perform when doing the
     * force-directed auto layout.
     * The value must be non-negative.
     * The default value is 100.
     */
    get maxIterations(): number; */
  /// Gets or sets the maximum number of iterations to perform when doing the
  /// force-directed auto layout.
  /// The value must be non-negative.
  /// The default value is 100.
  _i2.num get maxIterations => _i5.getProperty(
        this,
        'maxIterations',
      );
  /* #27374
  source: 
    /**
     * Gets or sets the maximum number of iterations to perform when doing the
     * force-directed auto layout.
     * The value must be non-negative.
     * The default value is 100.
     */
    get maxIterations(): number; */
  // Type InteropStaticType.number
  set maxIterations(_i2.num value) {
    _i5.setProperty(
      this,
      'maxIterations',
      value,
    );
  }

  /* #27381
  source: 
    /**
     * Gets or sets approximately how far a node must move in order for the iterations to continue.
     * The default value is 1.
     * The value must be larger than zero.
     */
    get epsilonDistance(): number; */
  /// Gets or sets approximately how far a node must move in order for the iterations to continue.
  /// The default value is 1.
  /// The value must be larger than zero.
  _i2.num get epsilonDistance => _i5.getProperty(
        this,
        'epsilonDistance',
      );
  /* #27381
  source: 
    /**
     * Gets or sets approximately how far a node must move in order for the iterations to continue.
     * The default value is 1.
     * The value must be larger than zero.
     */
    get epsilonDistance(): number; */
  // Type InteropStaticType.number
  set epsilonDistance(_i2.num value) {
    _i5.setProperty(
      this,
      'epsilonDistance',
      value,
    );
  }

  /* #27388
  source: 
    /**
     * Gets or sets a threshold for the distance beyond which the electrical charge forces may be ignored.
     * The default value is 1000.
     * The value must be larger than 1.
     */
    get infinityDistance(): number; */
  /// Gets or sets a threshold for the distance beyond which the electrical charge forces may be ignored.
  /// The default value is 1000.
  /// The value must be larger than 1.
  _i2.num get infinityDistance => _i5.getProperty(
        this,
        'infinityDistance',
      );
  /* #27388
  source: 
    /**
     * Gets or sets a threshold for the distance beyond which the electrical charge forces may be ignored.
     * The default value is 1000.
     * The value must be larger than 1.
     */
    get infinityDistance(): number; */
  // Type InteropStaticType.number
  set infinityDistance(_i2.num value) {
    _i5.setProperty(
      this,
      'infinityDistance',
      value,
    );
  }

  /* #27396
  source: 
    /**
     * Gets or sets how far a vertex may be moved in an iteration.
     * The default value is 10.
     * The value must be larger than 1.
     * @since 1.8
     */
    get moveLimit(): number; */
  /// Gets or sets how far a vertex may be moved in an iteration.
  /// The default value is 10.
  /// The value must be larger than 1.
  _i2.num get moveLimit => _i5.getProperty(
        this,
        'moveLimit',
      );
  /* #27396
  source: 
    /**
     * Gets or sets how far a vertex may be moved in an iteration.
     * The default value is 10.
     * The value must be larger than 1.
     * @since 1.8
     */
    get moveLimit(): number; */
  // Type InteropStaticType.number
  set moveLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'moveLimit',
      value,
    );
  }

  /* #27408
  source: 
    /**
     * Gets or sets a random number generator.
     * The default value is Math, which results in calling Math.random().
     * Change this to null in order to use an instance of an internal repeatable pseudo-random number generator,
     * which will become the new value of this property.
     *
     * The new value must be either null or an Object with a method named "random" taking zero arguments
     * and returning a random number between zero (inclusive) and one (exclusive).
     * @since 1.5
     */
    get randomNumberGenerator(): ({
        random: () => number;
    } | null); */
  /// Gets or sets a random number generator.
  /// The default value is Math, which results in calling Math.random().
  /// Change this to null in order to use an instance of an internal repeatable pseudo-random number generator,
  /// which will become the new value of this property.
  ///
  /// The new value must be either null or an Object with a method named "random" taking zero arguments
  /// and returning a random number between zero (inclusive) and one (exclusive).
  _i3.IInline12? get randomNumberGenerator => _i5.getProperty(
        this,
        'randomNumberGenerator',
      );
  /* #27408
  source: 
    /**
     * Gets or sets a random number generator.
     * The default value is Math, which results in calling Math.random().
     * Change this to null in order to use an instance of an internal repeatable pseudo-random number generator,
     * which will become the new value of this property.
     *
     * The new value must be either null or an Object with a method named "random" taking zero arguments
     * and returning a random number between zero (inclusive) and one (exclusive).
     * @since 1.5
     */
    get randomNumberGenerator(): ({
        random: () => number;
    } | null); */
  // Type InteropUnion#348017121(parent: InteropGetter#1015173981(name: randomNumberGenerator))
  set randomNumberGenerator(_i3.IInline12? value) {
    _i5.setProperty(
      this,
      'randomNumberGenerator',
      value ?? _i4.undefined,
    );
  }

  /* #27418
  source: 
    /**
     * Gets or sets the default value computed by #springStiffness.
     * The initial value is 0.05.
     */
    get defaultSpringStiffness(): number; */
  /// Gets or sets the default value computed by #springStiffness.
  /// The initial value is 0.05.
  _i2.num get defaultSpringStiffness => _i5.getProperty(
        this,
        'defaultSpringStiffness',
      );
  /* #27418
  source: 
    /**
     * Gets or sets the default value computed by #springStiffness.
     * The initial value is 0.05.
     */
    get defaultSpringStiffness(): number; */
  // Type InteropStaticType.number
  set defaultSpringStiffness(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultSpringStiffness',
      value,
    );
  }

  /* #27424
  source: 
    /**
     * Gets or sets the default value computed by #springLength.
     * The initial value is 50.
     */
    get defaultSpringLength(): number; */
  /// Gets or sets the default value computed by #springLength.
  /// The initial value is 50.
  _i2.num get defaultSpringLength => _i5.getProperty(
        this,
        'defaultSpringLength',
      );
  /* #27424
  source: 
    /**
     * Gets or sets the default value computed by #springLength.
     * The initial value is 50.
     */
    get defaultSpringLength(): number; */
  // Type InteropStaticType.number
  set defaultSpringLength(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultSpringLength',
      value,
    );
  }

  /* #27430
  source: 
    /**
     * Gets or sets the default value computed by #electricalCharge.
     * The initial value is 150.
     */
    get defaultElectricalCharge(): number; */
  /// Gets or sets the default value computed by #electricalCharge.
  /// The initial value is 150.
  _i2.num get defaultElectricalCharge => _i5.getProperty(
        this,
        'defaultElectricalCharge',
      );
  /* #27430
  source: 
    /**
     * Gets or sets the default value computed by #electricalCharge.
     * The initial value is 150.
     */
    get defaultElectricalCharge(): number; */
  // Type InteropStaticType.number
  set defaultElectricalCharge(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultElectricalCharge',
      value,
    );
  }

  /* #27436
  source: 
    /**
     * Gets or sets the default value computed by #gravitationalMass.
     * The initial value is zero.
     */
    get defaultGravitationalMass(): number; */
  /// Gets or sets the default value computed by #gravitationalMass.
  /// The initial value is zero.
  _i2.num get defaultGravitationalMass => _i5.getProperty(
        this,
        'defaultGravitationalMass',
      );
  /* #27436
  source: 
    /**
     * Gets or sets the default value computed by #gravitationalMass.
     * The initial value is zero.
     */
    get defaultGravitationalMass(): number; */
  // Type InteropStaticType.number
  set defaultGravitationalMass(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultGravitationalMass',
      value,
    );
  }

  /* #27442
  source: 
    /**
     * Gets or sets the default value computed by #springLength.
     * The initial value is 10.
     */
    get defaultCommentSpringLength(): number; */
  /// Gets or sets the default value computed by #springLength.
  /// The initial value is 10.
  _i2.num get defaultCommentSpringLength => _i5.getProperty(
        this,
        'defaultCommentSpringLength',
      );
  /* #27442
  source: 
    /**
     * Gets or sets the default value computed by #springLength.
     * The initial value is 10.
     */
    get defaultCommentSpringLength(): number; */
  // Type InteropStaticType.number
  set defaultCommentSpringLength(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultCommentSpringLength',
      value,
    );
  }

  /* #27448
  source: 
    /**
     * Gets or sets the default value computed by #electricalCharge.
     * The initial value is 5.
     */
    get defaultCommentElectricalCharge(): number; */
  /// Gets or sets the default value computed by #electricalCharge.
  /// The initial value is 5.
  _i2.num get defaultCommentElectricalCharge => _i5.getProperty(
        this,
        'defaultCommentElectricalCharge',
      );
  /* #27448
  source: 
    /**
     * Gets or sets the default value computed by #electricalCharge.
     * The initial value is 5.
     */
    get defaultCommentElectricalCharge(): number; */
  // Type InteropStaticType.number
  set defaultCommentElectricalCharge(_i2.num value) {
    _i5.setProperty(
      this,
      'defaultCommentElectricalCharge',
      value,
    );
  }

  _i3.ForceDirectedNetwork createNetwork() => _i5.callMethod(
        this,
        'createNetwork',
        [],
      );
  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }

  void addComments(_i3.ForceDirectedVertex v) {
    _i5.callMethod(
      this,
      'addComments',
      [v],
    );
  }

  _i2.num moveVertex(_i3.ForceDirectedVertex v) => _i5.callMethod(
        this,
        'moveVertex',
        [v],
      );
  void moveFixedVertex(_i3.ForceDirectedVertex v) {
    _i5.callMethod(
      this,
      'moveFixedVertex',
      [v],
    );
  }

  void commitLayout() {
    _i5.callMethod(
      this,
      'commitLayout',
      [],
    );
  }

  void commitNodes() {
    _i5.callMethod(
      this,
      'commitNodes',
      [],
    );
  }

  void commitLinks() {
    _i5.callMethod(
      this,
      'commitLinks',
      [],
    );
  }

  _i2.num springStiffness(_i3.ForceDirectedEdge e) => _i5.callMethod(
        this,
        'springStiffness',
        [e],
      );
  _i2.num springLength(_i3.ForceDirectedEdge e) => _i5.callMethod(
        this,
        'springLength',
        [e],
      );
  _i2.num electricalCharge(_i3.ForceDirectedVertex v) => _i5.callMethod(
        this,
        'electricalCharge',
        [v],
      );
  _i2.num electricalFieldX(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'electricalFieldX',
        [
          x,
          y,
        ],
      );
  _i2.num electricalFieldY(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'electricalFieldY',
        [
          x,
          y,
        ],
      );
  _i2.num gravitationalMass(_i3.ForceDirectedVertex v) => _i5.callMethod(
        this,
        'gravitationalMass',
        [v],
      );
  _i2.num gravitationalFieldX(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'gravitationalFieldX',
        [
          x,
          y,
        ],
      );
  _i2.num gravitationalFieldY(
    _i2.num x,
    _i2.num y,
  ) =>
      _i5.callMethod(
        this,
        'gravitationalFieldY',
        [
          x,
          y,
        ],
      );
  _i2.bool isFixed(_i3.ForceDirectedVertex v) => _i5.callMethod(
        this,
        'isFixed',
        [v],
      );
}

@_i1.JS()
@_i1.staticInterop
class ForceDirectedNetwork implements _i3.LayoutNetwork {
  factory ForceDirectedNetwork(_i3.ForceDirectedLayout layout) =>
      _i5.callConstructor(
        _declaredForceDirectedNetwork,
        [layout],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ForceDirectedNetwork')
external _i2.Object _declaredForceDirectedNetwork;

@_i1.JS()
@_i1.staticInterop
class ForceDirectedVertex implements _i3.LayoutVertex {
  factory ForceDirectedVertex(_i3.ForceDirectedNetwork network) =>
      _i5.callConstructor(
        _declaredForceDirectedVertex,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ForceDirectedVertex')
external _i2.Object _declaredForceDirectedVertex;

extension ForceDirectedVertex$Typings on ForceDirectedVertex {
  /* #27481
  source: 
    /**
     * Gets or sets whether the vertex may be moved by any forces.
     * The default value is false.
     */
    get isFixed(): boolean; */
  /// Gets or sets whether the vertex may be moved by any forces.
  /// The default value is false.
  _i2.bool get isFixed => _i5.getProperty(
        this,
        'isFixed',
      );
  /* #27481
  source: 
    /**
     * Gets or sets whether the vertex may be moved by any forces.
     * The default value is false.
     */
    get isFixed(): boolean; */
  // Type InteropStaticType.boolean
  set isFixed(_i2.bool value) {
    _i5.setProperty(
      this,
      'isFixed',
      value,
    );
  }

  /* #27487
  source: 
    /**
     * Gets or sets the electrical charge for this vertex.
     * The default value is NaN.
     */
    get charge(): number; */
  /// Gets or sets the electrical charge for this vertex.
  /// The default value is NaN.
  _i2.num get charge => _i5.getProperty(
        this,
        'charge',
      );
  /* #27487
  source: 
    /**
     * Gets or sets the electrical charge for this vertex.
     * The default value is NaN.
     */
    get charge(): number; */
  // Type InteropStaticType.number
  set charge(_i2.num value) {
    _i5.setProperty(
      this,
      'charge',
      value,
    );
  }

  /* #27493
  source: 
    /**
     * Gets or sets the gravitational mass for this vertex.
     * The default value is NaN.
     */
    get mass(): number; */
  /// Gets or sets the gravitational mass for this vertex.
  /// The default value is NaN.
  _i2.num get mass => _i5.getProperty(
        this,
        'mass',
      );
  /* #27493
  source: 
    /**
     * Gets or sets the gravitational mass for this vertex.
     * The default value is NaN.
     */
    get mass(): number; */
  // Type InteropStaticType.number
  set mass(_i2.num value) {
    _i5.setProperty(
      this,
      'mass',
      value,
    );
  }

  /* #27499
  source: 
    /**
     * Gets or sets the cumulative force on the vertex in the X direction.
     * The default value is zero.
     */
    get forceX(): number; */
  /// Gets or sets the cumulative force on the vertex in the X direction.
  /// The default value is zero.
  _i2.num get forceX => _i5.getProperty(
        this,
        'forceX',
      );
  /* #27499
  source: 
    /**
     * Gets or sets the cumulative force on the vertex in the X direction.
     * The default value is zero.
     */
    get forceX(): number; */
  // Type InteropStaticType.number
  set forceX(_i2.num value) {
    _i5.setProperty(
      this,
      'forceX',
      value,
    );
  }

  /* #27505
  source: 
    /**
     * Gets or sets the cumulative force on the vertex in the Y direction.
     * The default value is zero.
     */
    get forceY(): number; */
  /// Gets or sets the cumulative force on the vertex in the Y direction.
  /// The default value is zero.
  _i2.num get forceY => _i5.getProperty(
        this,
        'forceY',
      );
  /* #27505
  source: 
    /**
     * Gets or sets the cumulative force on the vertex in the Y direction.
     * The default value is zero.
     */
    get forceY(): number; */
  // Type InteropStaticType.number
  set forceY(_i2.num value) {
    _i5.setProperty(
      this,
      'forceY',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class ForceDirectedEdge implements _i3.LayoutEdge {
  factory ForceDirectedEdge(_i3.ForceDirectedNetwork network) =>
      _i5.callConstructor(
        _declaredForceDirectedEdge,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('ForceDirectedEdge')
external _i2.Object _declaredForceDirectedEdge;

extension ForceDirectedEdge$Typings on ForceDirectedEdge {
  /* #27523
  source: 
    /**
     * Gets or sets this edge's stiffness or resistance to compression or stretching.
     * The default value is NaN.
     */
    get stiffness(): number; */
  /// Gets or sets this edge's stiffness or resistance to compression or stretching.
  /// The default value is NaN.
  _i2.num get stiffness => _i5.getProperty(
        this,
        'stiffness',
      );
  /* #27523
  source: 
    /**
     * Gets or sets this edge's stiffness or resistance to compression or stretching.
     * The default value is NaN.
     */
    get stiffness(): number; */
  // Type InteropStaticType.number
  set stiffness(_i2.num value) {
    _i5.setProperty(
      this,
      'stiffness',
      value,
    );
  }

  /* #27529
  source: 
    /**
     * Gets or sets the length of this edge.
     * The default value is NaN.
     */
    get length(): number; */
  /// Gets or sets the length of this edge.
  /// The default value is NaN.
  _i2.num get length => _i5.getProperty(
        this,
        'length',
      );
  /* #27529
  source: 
    /**
     * Gets or sets the length of this edge.
     * The default value is NaN.
     */
    get length(): number; */
  // Type InteropStaticType.number
  set length(_i2.num value) {
    _i5.setProperty(
      this,
      'length',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class LayeredDigraphLayout implements _i3.Layout {
  factory LayeredDigraphLayout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredLayeredDigraphLayout,
        [init ?? _i4.undefined],
      );

  /* #27946
  source: 
    /**
     * Remove cycles using depth first cycle removal;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleDepthFirst: EnumValue; */
  /// Remove cycles using depth first cycle removal;
  /// a valid value of LayeredDigraphLayout#cycleRemoveOption.
  static _i3.EnumValue get cycleDepthFirst => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'CycleDepthFirst',
      );
  /* #27946
  source: 
    /**
     * Remove cycles using depth first cycle removal;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleDepthFirst: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleDepthFirst(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'CycleDepthFirst',
      value,
    );
  }

  /* #27952
  source: 
    /**
     * Remove cycles using greedy cycle removal;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleGreedy: EnumValue; */
  /// Remove cycles using greedy cycle removal;
  /// a valid value of LayeredDigraphLayout#cycleRemoveOption.
  static _i3.EnumValue get cycleGreedy => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'CycleGreedy',
      );
  /* #27952
  source: 
    /**
     * Remove cycles using greedy cycle removal;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleGreedy: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleGreedy(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'CycleGreedy',
      value,
    );
  }

  /* #27958
  source: 
    /**
     * Remove cycles depending on #assignLayers determining entirely which links are backwards links;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleFromLayers: EnumValue; */
  /// Remove cycles depending on #assignLayers determining entirely which links are backwards links;
  /// a valid value of LayeredDigraphLayout#cycleRemoveOption.
  static _i3.EnumValue get cycleFromLayers => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'CycleFromLayers',
      );
  /* #27958
  source: 
    /**
     * Remove cycles depending on #assignLayers determining entirely which links are backwards links;
     * a valid value of LayeredDigraphLayout#cycleRemoveOption.
     * @constant
     */
    static CycleFromLayers: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set cycleFromLayers(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'CycleFromLayers',
      value,
    );
  }

  /* #27964
  source: 
    /**
     * Assign layers using optimal link length layering;
     * A valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerOptimalLinkLength: EnumValue; */
  /// Assign layers using optimal link length layering;
  /// A valid value for LayeredDigraphLayout#layeringOption.
  static _i3.EnumValue get layerOptimalLinkLength => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'LayerOptimalLinkLength',
      );
  /* #27964
  source: 
    /**
     * Assign layers using optimal link length layering;
     * A valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerOptimalLinkLength: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerOptimalLinkLength(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'LayerOptimalLinkLength',
      value,
    );
  }

  /* #27970
  source: 
    /**
     * Assign layers using longest path sink layering;
     * a valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerLongestPathSink: EnumValue; */
  /// Assign layers using longest path sink layering;
  /// a valid value for LayeredDigraphLayout#layeringOption.
  static _i3.EnumValue get layerLongestPathSink => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'LayerLongestPathSink',
      );
  /* #27970
  source: 
    /**
     * Assign layers using longest path sink layering;
     * a valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerLongestPathSink: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerLongestPathSink(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'LayerLongestPathSink',
      value,
    );
  }

  /* #27976
  source: 
    /**
     * Assign layers using longest path source layering;
     * a valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerLongestPathSource: EnumValue; */
  /// Assign layers using longest path source layering;
  /// a valid value for LayeredDigraphLayout#layeringOption.
  static _i3.EnumValue get layerLongestPathSource => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'LayerLongestPathSource',
      );
  /* #27976
  source: 
    /**
     * Assign layers using longest path source layering;
     * a valid value for LayeredDigraphLayout#layeringOption.
     * @constant
     */
    static LayerLongestPathSource: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerLongestPathSource(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'LayerLongestPathSource',
      value,
    );
  }

  /* #27982
  source: 
    /**
     * Initialize using depth first out initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitDepthFirstOut: EnumValue; */
  /// Initialize using depth first out initialization;
  /// a valid value for LayeredDigraphLayout#initializeOption.
  static _i3.EnumValue get initDepthFirstOut => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'InitDepthFirstOut',
      );
  /* #27982
  source: 
    /**
     * Initialize using depth first out initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitDepthFirstOut: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set initDepthFirstOut(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'InitDepthFirstOut',
      value,
    );
  }

  /* #27988
  source: 
    /**
     * Initialize using depth first in initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitDepthFirstIn: EnumValue; */
  /// Initialize using depth first in initialization;
  /// a valid value for LayeredDigraphLayout#initializeOption.
  static _i3.EnumValue get initDepthFirstIn => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'InitDepthFirstIn',
      );
  /* #27988
  source: 
    /**
     * Initialize using depth first in initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitDepthFirstIn: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set initDepthFirstIn(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'InitDepthFirstIn',
      value,
    );
  }

  /* #27994
  source: 
    /**
     * Initialize using naive initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitNaive: EnumValue; */
  /// Initialize using naive initialization;
  /// a valid value for LayeredDigraphLayout#initializeOption.
  static _i3.EnumValue get initNaive => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'InitNaive',
      );
  /* #27994
  source: 
    /**
     * Initialize using naive initialization;
     * a valid value for LayeredDigraphLayout#initializeOption.
     * @constant
     */
    static InitNaive: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set initNaive(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'InitNaive',
      value,
    );
  }

  /* #28000
  source: 
    /**
     * The fastest, but poorest, crossing reduction algorithm;
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveNone: EnumValue; */
  /// The fastest, but poorest, crossing reduction algorithm;
  /// a valid value for LayeredDigraphLayout#aggressiveOption.
  static _i3.EnumValue get aggressiveNone => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AggressiveNone',
      );
  /* #28000
  source: 
    /**
     * The fastest, but poorest, crossing reduction algorithm;
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set aggressiveNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AggressiveNone',
      value,
    );
  }

  /* #28006
  source: 
    /**
     * The faster, less aggressive, crossing reduction algorithm;
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveLess: EnumValue; */
  /// The faster, less aggressive, crossing reduction algorithm;
  /// a valid value for LayeredDigraphLayout#aggressiveOption.
  static _i3.EnumValue get aggressiveLess => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AggressiveLess',
      );
  /* #28006
  source: 
    /**
     * The faster, less aggressive, crossing reduction algorithm;
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveLess: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set aggressiveLess(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AggressiveLess',
      value,
    );
  }

  /* #28012
  source: 
    /**
     * The slower, more aggressive, crossing reduction algorithm,
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveMore: EnumValue; */
  /// The slower, more aggressive, crossing reduction algorithm,
  /// a valid value for LayeredDigraphLayout#aggressiveOption.
  static _i3.EnumValue get aggressiveMore => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AggressiveMore',
      );
  /* #28012
  source: 
    /**
     * The slower, more aggressive, crossing reduction algorithm,
     * a valid value for LayeredDigraphLayout#aggressiveOption.
     * @constant
     */
    static AggressiveMore: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set aggressiveMore(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AggressiveMore',
      value,
    );
  }

  /* #28018
  source: 
    /**
     * Does minimal work in packing the nodes;
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackNone: number; */
  /// Does minimal work in packing the nodes;
  /// a valid value for LayeredDigraphLayout#packOption.
  static _i2.num get packNone => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'PackNone',
      );
  /* #28018
  source: 
    /**
     * Does minimal work in packing the nodes;
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackNone: number; */
  // Type InteropStaticType.number
  static set packNone(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'PackNone',
      value,
    );
  }

  /* #28025
  source: 
    /**
     * This option gives more chances for the packing algorithm to improve the network,
     * but is very expensive in time for large networks;
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackExpand: number; */
  /// This option gives more chances for the packing algorithm to improve the network,
  /// but is very expensive in time for large networks;
  /// a valid value for LayeredDigraphLayout#packOption.
  static _i2.num get packExpand => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'PackExpand',
      );
  /* #28025
  source: 
    /**
     * This option gives more chances for the packing algorithm to improve the network,
     * but is very expensive in time for large networks;
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackExpand: number; */
  // Type InteropStaticType.number
  static set packExpand(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'PackExpand',
      value,
    );
  }

  /* #28032
  source: 
    /**
     * This option tries to have the packing algorithm straighten many of the
     * links that cross layers,
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackStraighten: number; */
  /// This option tries to have the packing algorithm straighten many of the
  /// links that cross layers,
  /// a valid value for LayeredDigraphLayout#packOption.
  static _i2.num get packStraighten => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'PackStraighten',
      );
  /* #28032
  source: 
    /**
     * This option tries to have the packing algorithm straighten many of the
     * links that cross layers,
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackStraighten: number; */
  // Type InteropStaticType.number
  static set packStraighten(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'PackStraighten',
      value,
    );
  }

  /* #28039
  source: 
    /**
     * This option tries to have the packing algorithm center groups of nodes
     * based on their relationships with nodes in other layers,
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackMedian: number; */
  /// This option tries to have the packing algorithm center groups of nodes
  /// based on their relationships with nodes in other layers,
  /// a valid value for LayeredDigraphLayout#packOption.
  static _i2.num get packMedian => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'PackMedian',
      );
  /* #28039
  source: 
    /**
     * This option tries to have the packing algorithm center groups of nodes
     * based on their relationships with nodes in other layers,
     * a valid value for LayeredDigraphLayout#packOption.
     * @constant
     */
    static PackMedian: number; */
  // Type InteropStaticType.number
  static set packMedian(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'PackMedian',
      value,
    );
  }

  /* #28046
  source: 
    /**
     * Enable all options for the LayeredDigraphLayout#packOption property;
     * See also LayeredDigraphLayout.PackExpand, LayeredDigraphLayout.PackStraighten,
     * and LayeredDigraphLayout.PackMedian.
     * @constant
     */
    static PackAll: number; */
  /// Enable all options for the LayeredDigraphLayout#packOption property;
  /// See also LayeredDigraphLayout.PackExpand, LayeredDigraphLayout.PackStraighten,
  /// and LayeredDigraphLayout.PackMedian.
  static _i2.num get packAll => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'PackAll',
      );
  /* #28046
  source: 
    /**
     * Enable all options for the LayeredDigraphLayout#packOption property;
     * See also LayeredDigraphLayout.PackExpand, LayeredDigraphLayout.PackStraighten,
     * and LayeredDigraphLayout.PackMedian.
     * @constant
     */
    static PackAll: number; */
  // Type InteropStaticType.number
  static set packAll(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'PackAll',
      value,
    );
  }

  /* #28052
  source: 
    /**
     * This option means the the layout will pack nodes using the LayeredDigraphLayout#packOption instead of LayeredDigraphLayout#alignOption,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignNone: number; */
  /// This option means the the layout will pack nodes using the LayeredDigraphLayout#packOption instead of LayeredDigraphLayout#alignOption,
  /// a valid value for LayeredDigraphLayout#alignOption.
  static _i2.num get alignNone => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignNone',
      );
  /* #28052
  source: 
    /**
     * This option means the the layout will pack nodes using the LayeredDigraphLayout#packOption instead of LayeredDigraphLayout#alignOption,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignNone: number; */
  // Type InteropStaticType.number
  static set alignNone(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignNone',
      value,
    );
  }

  /* #28058
  source: 
    /**
     * This option aligns and compacts nodes based on upper neighbors, favoring leftmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignUpperLeft: number; */
  /// This option aligns and compacts nodes based on upper neighbors, favoring leftmost neighbors,
  /// a valid value for LayeredDigraphLayout#alignOption.
  static _i2.num get alignUpperLeft => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignUpperLeft',
      );
  /* #28058
  source: 
    /**
     * This option aligns and compacts nodes based on upper neighbors, favoring leftmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignUpperLeft: number; */
  // Type InteropStaticType.number
  static set alignUpperLeft(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignUpperLeft',
      value,
    );
  }

  /* #28064
  source: 
    /**
     * This option aligns and compacts nodes based on upper neighbors, favoring rightmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignUpperRight: number; */
  /// This option aligns and compacts nodes based on upper neighbors, favoring rightmost neighbors,
  /// a valid value for LayeredDigraphLayout#alignOption.
  static _i2.num get alignUpperRight => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignUpperRight',
      );
  /* #28064
  source: 
    /**
     * This option aligns and compacts nodes based on upper neighbors, favoring rightmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignUpperRight: number; */
  // Type InteropStaticType.number
  static set alignUpperRight(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignUpperRight',
      value,
    );
  }

  /* #28070
  source: 
    /**
     * This option aligns and compacts nodes based on lower neighbors, favoring leftmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignLowerLeft: number; */
  /// This option aligns and compacts nodes based on lower neighbors, favoring leftmost neighbors,
  /// a valid value for LayeredDigraphLayout#alignOption.
  static _i2.num get alignLowerLeft => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignLowerLeft',
      );
  /* #28070
  source: 
    /**
     * This option aligns and compacts nodes based on lower neighbors, favoring leftmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignLowerLeft: number; */
  // Type InteropStaticType.number
  static set alignLowerLeft(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignLowerLeft',
      value,
    );
  }

  /* #28076
  source: 
    /**
     * This option aligns and compacts nodes based on lower neighbors, favoring rightmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignLowerRight: number; */
  /// This option aligns and compacts nodes based on lower neighbors, favoring rightmost neighbors,
  /// a valid value for LayeredDigraphLayout#alignOption.
  static _i2.num get alignLowerRight => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignLowerRight',
      );
  /* #28076
  source: 
    /**
     * This option aligns and compacts nodes based on lower neighbors, favoring rightmost neighbors,
     * a valid value for LayeredDigraphLayout#alignOption.
     * @constant
     */
    static AlignLowerRight: number; */
  // Type InteropStaticType.number
  static set alignLowerRight(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignLowerRight',
      value,
    );
  }

  /* #28085
  source: 
    /**
     * Enable all options for the LayeredDigraphLayout#alignOption property;
     * See also LayeredDigraphLayout.AlignUpperLeft, LayeredDigraphLayout.AlignUpperRight,
     * LayeredDigraphLayout.AlignLowerLeft, and LayeredDigraphLayout.AlignLowerRight.
     *
     * This option will tend to balance nodes compared to their neighbors.
     * @constant
     */
    static AlignAll: number; */
  /// Enable all options for the LayeredDigraphLayout#alignOption property;
  /// See also LayeredDigraphLayout.AlignUpperLeft, LayeredDigraphLayout.AlignUpperRight,
  /// LayeredDigraphLayout.AlignLowerLeft, and LayeredDigraphLayout.AlignLowerRight.
  ///
  /// This option will tend to balance nodes compared to their neighbors.
  static _i2.num get alignAll => _i5.getProperty(
        _declaredLayeredDigraphLayout,
        'AlignAll',
      );
  /* #28085
  source: 
    /**
     * Enable all options for the LayeredDigraphLayout#alignOption property;
     * See also LayeredDigraphLayout.AlignUpperLeft, LayeredDigraphLayout.AlignUpperRight,
     * LayeredDigraphLayout.AlignLowerLeft, and LayeredDigraphLayout.AlignLowerRight.
     *
     * This option will tend to balance nodes compared to their neighbors.
     * @constant
     */
    static AlignAll: number; */
  // Type InteropStaticType.number
  static set alignAll(_i2.num value) {
    _i5.setProperty(
      _declaredLayeredDigraphLayout,
      'AlignAll',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('LayeredDigraphLayout')
external _i2.Object _declaredLayeredDigraphLayout;

extension LayeredDigraphLayout$Typings on LayeredDigraphLayout {
  /* #27785
  source: 
    /**
     * Gets or sets the space between each layer.
     * This value must be non-negative and it defaults to 25.
     */
    get layerSpacing(): number; */
  /// Gets or sets the space between each layer.
  /// This value must be non-negative and it defaults to 25.
  _i2.num get layerSpacing => _i5.getProperty(
        this,
        'layerSpacing',
      );
  /* #27785
  source: 
    /**
     * Gets or sets the space between each layer.
     * This value must be non-negative and it defaults to 25.
     */
    get layerSpacing(): number; */
  // Type InteropStaticType.number
  set layerSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'layerSpacing',
      value,
    );
  }

  /* #27793
  source: 
    /**
     * Gets or sets the size of each column.
     * This value must be positive and it defaults to 25.
     *
     * When using #alignOption, this will act as node spacing for nodes within a layer.
     */
    get columnSpacing(): number; */
  /// Gets or sets the size of each column.
  /// This value must be positive and it defaults to 25.
  ///
  /// When using #alignOption, this will act as node spacing for nodes within a layer.
  _i2.num get columnSpacing => _i5.getProperty(
        this,
        'columnSpacing',
      );
  /* #27793
  source: 
    /**
     * Gets or sets the size of each column.
     * This value must be positive and it defaults to 25.
     *
     * When using #alignOption, this will act as node spacing for nodes within a layer.
     */
    get columnSpacing(): number; */
  // Type InteropStaticType.number
  set columnSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'columnSpacing',
      value,
    );
  }

  /* #27800
  source: 
    /**
     * Gets or sets the direction the graph grows towards.
     * 0 is towards the right, 90 is downwards, 180 is towards the left, and 270 is upwards.
     * The default value is 0.
     */
    get direction(): number; */
  /// Gets or sets the direction the graph grows towards.
  /// 0 is towards the right, 90 is downwards, 180 is towards the left, and 270 is upwards.
  /// The default value is 0.
  _i2.num get direction => _i5.getProperty(
        this,
        'direction',
      );
  /* #27800
  source: 
    /**
     * Gets or sets the direction the graph grows towards.
     * 0 is towards the right, 90 is downwards, 180 is towards the left, and 270 is upwards.
     * The default value is 0.
     */
    get direction(): number; */
  // Type InteropStaticType.number
  set direction(_i2.num value) {
    _i5.setProperty(
      this,
      'direction',
      value,
    );
  }

  /* #27810
  source: 
    /**
     * Gets or set which cycle removal option is used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.CycleDepthFirst,
     * LayeredDigraphLayout.CycleGreedy, or
     * LayeredDigraphLayout.CycleFromLayers.
     * The default value is LayeredDigraphLayout.CycleDepthFirst.
     */
    get cycleRemoveOption(): EnumValue; */
  /// Gets or set which cycle removal option is used.
  /// The value must be one of the following values:
  /// LayeredDigraphLayout.CycleDepthFirst,
  /// LayeredDigraphLayout.CycleGreedy, or
  /// LayeredDigraphLayout.CycleFromLayers.
  /// The default value is LayeredDigraphLayout.CycleDepthFirst.
  _i3.EnumValue get cycleRemoveOption => _i5.getProperty(
        this,
        'cycleRemoveOption',
      );
  /* #27810
  source: 
    /**
     * Gets or set which cycle removal option is used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.CycleDepthFirst,
     * LayeredDigraphLayout.CycleGreedy, or
     * LayeredDigraphLayout.CycleFromLayers.
     * The default value is LayeredDigraphLayout.CycleDepthFirst.
     */
    get cycleRemoveOption(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set cycleRemoveOption(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'cycleRemoveOption',
      value,
    );
  }

  /* #27821
  source: 
    /**
     * Gets or sets which layering option is being used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.LayerLongestPathSink,
     * LayeredDigraphLayout.LayerLongestPathSource, or
     * LayeredDigraphLayout.LayerOptimalLinkLength.
     * The default value is LayeredDigraphLayout.LayerOptimalLinkLength,
     * which is also the slowest option.
     */
    get layeringOption(): EnumValue; */
  /// Gets or sets which layering option is being used.
  /// The value must be one of the following values:
  /// LayeredDigraphLayout.LayerLongestPathSink,
  /// LayeredDigraphLayout.LayerLongestPathSource, or
  /// LayeredDigraphLayout.LayerOptimalLinkLength.
  /// The default value is LayeredDigraphLayout.LayerOptimalLinkLength,
  /// which is also the slowest option.
  _i3.EnumValue get layeringOption => _i5.getProperty(
        this,
        'layeringOption',
      );
  /* #27821
  source: 
    /**
     * Gets or sets which layering option is being used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.LayerLongestPathSink,
     * LayeredDigraphLayout.LayerLongestPathSource, or
     * LayeredDigraphLayout.LayerOptimalLinkLength.
     * The default value is LayeredDigraphLayout.LayerOptimalLinkLength,
     * which is also the slowest option.
     */
    get layeringOption(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set layeringOption(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'layeringOption',
      value,
    );
  }

  /* #27831
  source: 
    /**
     * Gets or sets which indices initialization option is being used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.InitDepthFirstOut,
     * LayeredDigraphLayout.InitDepthFirstIn, or
     * LayeredDigraphLayout.InitNaive.
     * The default value is LayeredDigraphLayout.InitDepthFirstOut.
     */
    get initializeOption(): EnumValue; */
  /// Gets or sets which indices initialization option is being used.
  /// The value must be one of the following values:
  /// LayeredDigraphLayout.InitDepthFirstOut,
  /// LayeredDigraphLayout.InitDepthFirstIn, or
  /// LayeredDigraphLayout.InitNaive.
  /// The default value is LayeredDigraphLayout.InitDepthFirstOut.
  _i3.EnumValue get initializeOption => _i5.getProperty(
        this,
        'initializeOption',
      );
  /* #27831
  source: 
    /**
     * Gets or sets which indices initialization option is being used.
     * The value must be one of the following values:
     * LayeredDigraphLayout.InitDepthFirstOut,
     * LayeredDigraphLayout.InitDepthFirstIn, or
     * LayeredDigraphLayout.InitNaive.
     * The default value is LayeredDigraphLayout.InitDepthFirstOut.
     */
    get initializeOption(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set initializeOption(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'initializeOption',
      value,
    );
  }

  /* #27837
  source: 
    /**
     * Gets or sets the number of iterations to be done.
     * The value must be non-negative.  The default value is 4.
     */
    get iterations(): number; */
  /// Gets or sets the number of iterations to be done.
  /// The value must be non-negative.  The default value is 4.
  _i2.num get iterations => _i5.getProperty(
        this,
        'iterations',
      );
  /* #27837
  source: 
    /**
     * Gets or sets the number of iterations to be done.
     * The value must be non-negative.  The default value is 4.
     */
    get iterations(): number; */
  // Type InteropStaticType.number
  set iterations(_i2.num value) {
    _i5.setProperty(
      this,
      'iterations',
      value,
    );
  }

  /* #27844
  source: 
    /**
     * Gets or sets which aggressive option is being used to look for link crossings.
     * The default value is LayeredDigraphLayout.AggressiveLess.
     * The fastest option is LayeredDigraphLayout.AggressiveNone.
     */
    get aggressiveOption(): EnumValue; */
  /// Gets or sets which aggressive option is being used to look for link crossings.
  /// The default value is LayeredDigraphLayout.AggressiveLess.
  /// The fastest option is LayeredDigraphLayout.AggressiveNone.
  _i3.EnumValue get aggressiveOption => _i5.getProperty(
        this,
        'aggressiveOption',
      );
  /* #27844
  source: 
    /**
     * Gets or sets which aggressive option is being used to look for link crossings.
     * The default value is LayeredDigraphLayout.AggressiveLess.
     * The fastest option is LayeredDigraphLayout.AggressiveNone.
     */
    get aggressiveOption(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set aggressiveOption(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'aggressiveOption',
      value,
    );
  }

  /* #27866
  source: 
    /**
     * Gets or sets the options used by the straighten and pack function.
     *
     * The value must be a combination of the following bit flags:
     * LayeredDigraphLayout.PackMedian,
     * LayeredDigraphLayout.PackStraighten, and
     * LayeredDigraphLayout.PackExpand.
     * The default value is LayeredDigraphLayout.PackAll, which is a combination of all three flags.
     *
     * Each of the flags has a cost; PackExpand is particularly slow.
     * However if you do not set this property, this layout will automatically turn off the PackExpand
     * option for you if the graph is large enough.
     * You can set this property value to LayeredDigraphLayout.PackNone to avoid most of the work.
     *
     * This option is ignored if #alignOption is set to a value other than LayeredDigraphLayout.AlignNone.
     * This tends to be slower than #alignOption, particularly for larger graphs.
     * Larger graphs, however, will usually be more compact than when using alignOption.
     *
     * @see #alignOption
     */
    get packOption(): number; */
  /// Gets or sets the options used by the straighten and pack function.
  ///
  /// The value must be a combination of the following bit flags:
  /// LayeredDigraphLayout.PackMedian,
  /// LayeredDigraphLayout.PackStraighten, and
  /// LayeredDigraphLayout.PackExpand.
  /// The default value is LayeredDigraphLayout.PackAll, which is a combination of all three flags.
  ///
  /// Each of the flags has a cost; PackExpand is particularly slow.
  /// However if you do not set this property, this layout will automatically turn off the PackExpand
  /// option for you if the graph is large enough.
  /// You can set this property value to LayeredDigraphLayout.PackNone to avoid most of the work.
  ///
  /// This option is ignored if #alignOption is set to a value other than LayeredDigraphLayout.AlignNone.
  /// This tends to be slower than #alignOption, particularly for larger graphs.
  /// Larger graphs, however, will usually be more compact than when using alignOption.
  _i2.num get packOption => _i5.getProperty(
        this,
        'packOption',
      );
  /* #27866
  source: 
    /**
     * Gets or sets the options used by the straighten and pack function.
     *
     * The value must be a combination of the following bit flags:
     * LayeredDigraphLayout.PackMedian,
     * LayeredDigraphLayout.PackStraighten, and
     * LayeredDigraphLayout.PackExpand.
     * The default value is LayeredDigraphLayout.PackAll, which is a combination of all three flags.
     *
     * Each of the flags has a cost; PackExpand is particularly slow.
     * However if you do not set this property, this layout will automatically turn off the PackExpand
     * option for you if the graph is large enough.
     * You can set this property value to LayeredDigraphLayout.PackNone to avoid most of the work.
     *
     * This option is ignored if #alignOption is set to a value other than LayeredDigraphLayout.AlignNone.
     * This tends to be slower than #alignOption, particularly for larger graphs.
     * Larger graphs, however, will usually be more compact than when using alignOption.
     *
     * @see #alignOption
     */
    get packOption(): number; */
  // Type InteropStaticType.number
  set packOption(_i2.num value) {
    _i5.setProperty(
      this,
      'packOption',
      value,
    );
  }

  /* #27897
  source: 
    /**
     * Gets or sets the options used by the straighten and pack function, as a potentially faster
     * alternative to #packOption.
     *
     * When using this option, nodes are assigned coordinates within their layers
     * to produce straighter paths of nodes and small edge lengths.
     *
     * When used as an alternative to #packOption, this tends to be faster,
     * particularly for larger graphs.
     * Larger graphs, however, will usually be less compact than when using packOption.
     * If this option is set, packOption is ignored.
     *
     * This option does not use columns, but rather uses #columnSpacing to space nodes within a layer.
     *
     * The value must be a combination of the following bit flags:
     * LayeredDigraphLayout.AlignUpperLeft,
     * LayeredDigraphLayout.AlignUpperRight,
     * LayeredDigraphLayout.AlignLowerLeft, and
     * LayeredDigraphLayout.AlignLowerRight.
     *
     * Using LayeredDigraphLayout.AlignAll will tend to provide the most balanced results
     * and is what we recommend starting with.
     *
     * The default value is LayeredDigraphLayout.AlignNone, meaning #packOption is used.
     * LayeredDigraphLayout.AlignAll may become the default in a future major version.
     *
     * @see #packOption
     * @since 2.3
     */
    get alignOption(): number; */
  /// Gets or sets the options used by the straighten and pack function, as a potentially faster
  /// alternative to #packOption.
  ///
  /// When using this option, nodes are assigned coordinates within their layers
  /// to produce straighter paths of nodes and small edge lengths.
  ///
  /// When used as an alternative to #packOption, this tends to be faster,
  /// particularly for larger graphs.
  /// Larger graphs, however, will usually be less compact than when using packOption.
  /// If this option is set, packOption is ignored.
  ///
  /// This option does not use columns, but rather uses #columnSpacing to space nodes within a layer.
  ///
  /// The value must be a combination of the following bit flags:
  /// LayeredDigraphLayout.AlignUpperLeft,
  /// LayeredDigraphLayout.AlignUpperRight,
  /// LayeredDigraphLayout.AlignLowerLeft, and
  /// LayeredDigraphLayout.AlignLowerRight.
  ///
  /// Using LayeredDigraphLayout.AlignAll will tend to provide the most balanced results
  /// and is what we recommend starting with.
  ///
  /// The default value is LayeredDigraphLayout.AlignNone, meaning #packOption is used.
  /// LayeredDigraphLayout.AlignAll may become the default in a future major version.
  _i2.num get alignOption => _i5.getProperty(
        this,
        'alignOption',
      );
  /* #27897
  source: 
    /**
     * Gets or sets the options used by the straighten and pack function, as a potentially faster
     * alternative to #packOption.
     *
     * When using this option, nodes are assigned coordinates within their layers
     * to produce straighter paths of nodes and small edge lengths.
     *
     * When used as an alternative to #packOption, this tends to be faster,
     * particularly for larger graphs.
     * Larger graphs, however, will usually be less compact than when using packOption.
     * If this option is set, packOption is ignored.
     *
     * This option does not use columns, but rather uses #columnSpacing to space nodes within a layer.
     *
     * The value must be a combination of the following bit flags:
     * LayeredDigraphLayout.AlignUpperLeft,
     * LayeredDigraphLayout.AlignUpperRight,
     * LayeredDigraphLayout.AlignLowerLeft, and
     * LayeredDigraphLayout.AlignLowerRight.
     *
     * Using LayeredDigraphLayout.AlignAll will tend to provide the most balanced results
     * and is what we recommend starting with.
     *
     * The default value is LayeredDigraphLayout.AlignNone, meaning #packOption is used.
     * LayeredDigraphLayout.AlignAll may become the default in a future major version.
     *
     * @see #packOption
     * @since 2.3
     */
    get alignOption(): number; */
  // Type InteropStaticType.number
  set alignOption(_i2.num value) {
    _i5.setProperty(
      this,
      'alignOption',
      value,
    );
  }

  /* #27908
  source: 
    /**
     * Gets or sets whether the FromSpot and ToSpot of each link should be set
     * to values appropriate for the given value of LayeredDigraphLayout#direction.
     * The default value is true.
     *
     * If you set this to false, the spot values of the links and port objects will be used.
     * If you do not set the spot values to sensible values matching the #direction,
     * the routing results may be poor and they may cross over nodes.
     */
    get setsPortSpots(): boolean; */
  /// Gets or sets whether the FromSpot and ToSpot of each link should be set
  /// to values appropriate for the given value of LayeredDigraphLayout#direction.
  /// The default value is true.
  ///
  /// If you set this to false, the spot values of the links and port objects will be used.
  /// If you do not set the spot values to sensible values matching the #direction,
  /// the routing results may be poor and they may cross over nodes.
  _i2.bool get setsPortSpots => _i5.getProperty(
        this,
        'setsPortSpots',
      );
  /* #27908
  source: 
    /**
     * Gets or sets whether the FromSpot and ToSpot of each link should be set
     * to values appropriate for the given value of LayeredDigraphLayout#direction.
     * The default value is true.
     *
     * If you set this to false, the spot values of the links and port objects will be used.
     * If you do not set the spot values to sensible values matching the #direction,
     * the routing results may be poor and they may cross over nodes.
     */
    get setsPortSpots(): boolean; */
  // Type InteropStaticType.boolean
  set setsPortSpots(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsPortSpots',
      value,
    );
  }

  /* #27919
  source: 
    /**
     * (undocumented)
     * Gets or sets the distance between link segments for unrelated links that would otherwise be overlapping.
     * The default value is 4.  The value must be non-negative.
     *
     * If there are a lot of possibly overlapping links and the #layerSpacing is not large enough,
     * some links may cross over nodes.
     * You will either need to increase the layerSpacing or decrease this linkSpacing property.
     */
    get linkSpacing(): number; */
  /// (undocumented)
  /// Gets or sets the distance between link segments for unrelated links that would otherwise be overlapping.
  /// The default value is 4.  The value must be non-negative.
  ///
  /// If there are a lot of possibly overlapping links and the #layerSpacing is not large enough,
  /// some links may cross over nodes.
  /// You will either need to increase the layerSpacing or decrease this linkSpacing property.
  _i2.num get linkSpacing => _i5.getProperty(
        this,
        'linkSpacing',
      );
  /* #27919
  source: 
    /**
     * (undocumented)
     * Gets or sets the distance between link segments for unrelated links that would otherwise be overlapping.
     * The default value is 4.  The value must be non-negative.
     *
     * If there are a lot of possibly overlapping links and the #layerSpacing is not large enough,
     * some links may cross over nodes.
     * You will either need to increase the layerSpacing or decrease this linkSpacing property.
     */
    get linkSpacing(): number; */
  // Type InteropStaticType.number
  set linkSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'linkSpacing',
      value,
    );
  }

  /* #27924
  source: 
    /**
     * This read-only property returns the largest layer value.
     */
    get maxLayer(): number; */
  /// This read-only property returns the largest layer value.
  _i2.num get maxLayer => _i5.getProperty(
        this,
        'maxLayer',
      );
  /* #27924
  source: 
    /**
     * This read-only property returns the largest layer value.
     */
    get maxLayer(): number; */
  // Type InteropStaticType.number
  set maxLayer(_i2.num value) {
    _i5.setProperty(
      this,
      'maxLayer',
      value,
    );
  }

  /* #27928
  source: 
    /**
     * This read-only property returns the largest index value.
     */
    get maxIndex(): number; */
  /// This read-only property returns the largest index value.
  _i2.num get maxIndex => _i5.getProperty(
        this,
        'maxIndex',
      );
  /* #27928
  source: 
    /**
     * This read-only property returns the largest index value.
     */
    get maxIndex(): number; */
  // Type InteropStaticType.number
  set maxIndex(_i2.num value) {
    _i5.setProperty(
      this,
      'maxIndex',
      value,
    );
  }

  /* #27932
  source: 
    /**
     * This read-only property returns the largest column value.
     */
    get maxColumn(): number; */
  /// This read-only property returns the largest column value.
  _i2.num get maxColumn => _i5.getProperty(
        this,
        'maxColumn',
      );
  /* #27932
  source: 
    /**
     * This read-only property returns the largest column value.
     */
    get maxColumn(): number; */
  // Type InteropStaticType.number
  set maxColumn(_i2.num value) {
    _i5.setProperty(
      this,
      'maxColumn',
      value,
    );
  }

  /* #27936
  source: 
    /**
     * This read-only property returns the smallest index layer.
     */
    get minIndexLayer(): number; */
  /// This read-only property returns the smallest index layer.
  _i2.num get minIndexLayer => _i5.getProperty(
        this,
        'minIndexLayer',
      );
  /* #27936
  source: 
    /**
     * This read-only property returns the smallest index layer.
     */
    get minIndexLayer(): number; */
  // Type InteropStaticType.number
  set minIndexLayer(_i2.num value) {
    _i5.setProperty(
      this,
      'minIndexLayer',
      value,
    );
  }

  /* #27940
  source: 
    /**
     * This read-only property returns the larges index layer.
     */
    get maxIndexLayer(): number; */
  /// This read-only property returns the larges index layer.
  _i2.num get maxIndexLayer => _i5.getProperty(
        this,
        'maxIndexLayer',
      );
  /* #27940
  source: 
    /**
     * This read-only property returns the larges index layer.
     */
    get maxIndexLayer(): number; */
  // Type InteropStaticType.number
  set maxIndexLayer(_i2.num value) {
    _i5.setProperty(
      this,
      'maxIndexLayer',
      value,
    );
  }

  _i3.LayeredDigraphNetwork createNetwork() => _i5.callMethod(
        this,
        'createNetwork',
        [],
      );
  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }

  _i2.num linkMinLength(_i3.LayeredDigraphEdge edge) => _i5.callMethod(
        this,
        'linkMinLength',
        [edge],
      );
  _i2.num nodeMinLayerSpace(
    _i3.LayeredDigraphVertex v,
    _i2.bool topleft,
  ) =>
      _i5.callMethod(
        this,
        'nodeMinLayerSpace',
        [
          v,
          topleft,
        ],
      );
  _i2.num nodeMinColumnSpace(
    _i3.LayeredDigraphVertex v,
    _i2.bool topleft,
  ) =>
      _i5.callMethod(
        this,
        'nodeMinColumnSpace',
        [
          v,
          topleft,
        ],
      );
  void removeCycles() {
    _i5.callMethod(
      this,
      'removeCycles',
      [],
    );
  }

  void assignLayers() {
    _i5.callMethod(
      this,
      'assignLayers',
      [],
    );
  }

  void initializeIndices() {
    _i5.callMethod(
      this,
      'initializeIndices',
      [],
    );
  }

  void reduceCrossings() {
    _i5.callMethod(
      this,
      'reduceCrossings',
      [],
    );
  }

  void straightenAndPack() {
    _i5.callMethod(
      this,
      'straightenAndPack',
      [],
    );
  }

  void commitLayout() {
    _i5.callMethod(
      this,
      'commitLayout',
      [],
    );
  }

  void commitNodes() {
    _i5.callMethod(
      this,
      'commitNodes',
      [],
    );
  }

  void commitLayers(
    _i4.Array layerRects,
    _i3.Point offset,
  ) {
    _i5.callMethod(
      this,
      'commitLayers',
      [
        layerRects,
        offset,
      ],
    );
  }

  void commitLinks() {
    _i5.callMethod(
      this,
      'commitLinks',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class LayeredDigraphNetwork implements _i3.LayoutNetwork {
  factory LayeredDigraphNetwork(_i3.LayeredDigraphLayout layout) =>
      _i5.callConstructor(
        _declaredLayeredDigraphNetwork,
        [layout],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayeredDigraphNetwork')
external _i2.Object _declaredLayeredDigraphNetwork;

@_i1.JS()
@_i1.staticInterop
class LayeredDigraphVertex implements _i3.LayoutVertex {
  factory LayeredDigraphVertex(_i3.LayeredDigraphNetwork network) =>
      _i5.callConstructor(
        _declaredLayeredDigraphVertex,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayeredDigraphVertex')
external _i2.Object _declaredLayeredDigraphVertex;

extension LayeredDigraphVertex$Typings on LayeredDigraphVertex {
  /* #28133
  source: 
    /**
     * Gets or sets the layer to which the node is assigned.
     * The default value is -1.
     */
    get layer(): number; */
  /// Gets or sets the layer to which the node is assigned.
  /// The default value is -1.
  _i2.num get layer => _i5.getProperty(
        this,
        'layer',
      );
  /* #28133
  source: 
    /**
     * Gets or sets the layer to which the node is assigned.
     * The default value is -1.
     */
    get layer(): number; */
  // Type InteropStaticType.number
  set layer(_i2.num value) {
    _i5.setProperty(
      this,
      'layer',
      value,
    );
  }

  /* #28142
  source: 
    /**
     * Gets or sets the column to which the node is assigned.
     * The default value is -1.
     *
     * This property is not used during straightening and packing of nodes
     * when using LayeredDigraphLayout#alignOption.
     */
    get column(): number; */
  /// Gets or sets the column to which the node is assigned.
  /// The default value is -1.
  ///
  /// This property is not used during straightening and packing of nodes
  /// when using LayeredDigraphLayout#alignOption.
  _i2.num get column => _i5.getProperty(
        this,
        'column',
      );
  /* #28142
  source: 
    /**
     * Gets or sets the column to which the node is assigned.
     * The default value is -1.
     *
     * This property is not used during straightening and packing of nodes
     * when using LayeredDigraphLayout#alignOption.
     */
    get column(): number; */
  // Type InteropStaticType.number
  set column(_i2.num value) {
    _i5.setProperty(
      this,
      'column',
      value,
    );
  }

  /* #28148
  source: 
    /**
     * Gets or sets the index to which the node is assigned.
     * The default value is -1.
     */
    get index(): number; */
  /// Gets or sets the index to which the node is assigned.
  /// The default value is -1.
  _i2.num get index => _i5.getProperty(
        this,
        'index',
      );
  /* #28148
  source: 
    /**
     * Gets or sets the index to which the node is assigned.
     * The default value is -1.
     */
    get index(): number; */
  // Type InteropStaticType.number
  set index(_i2.num value) {
    _i5.setProperty(
      this,
      'index',
      value,
    );
  }

  /* #28157
  source: 
    /**
     * Gets or sets the connected component to which the node is assigned.
     * The default value is NaN.
     *
     * This property is not used during straightening and packing of nodes
     * when using LayeredDigraphLayout#alignOption.
     */
    get component(): number; */
  /// Gets or sets the connected component to which the node is assigned.
  /// The default value is NaN.
  ///
  /// This property is not used during straightening and packing of nodes
  /// when using LayeredDigraphLayout#alignOption.
  _i2.num get component => _i5.getProperty(
        this,
        'component',
      );
  /* #28157
  source: 
    /**
     * Gets or sets the connected component to which the node is assigned.
     * The default value is NaN.
     *
     * This property is not used during straightening and packing of nodes
     * when using LayeredDigraphLayout#alignOption.
     */
    get component(): number; */
  // Type InteropStaticType.number
  set component(_i2.num value) {
    _i5.setProperty(
      this,
      'component',
      value,
    );
  }

  /* #28163
  source: 
    /**
     * Gets or sets another LayeredDigraphVertex in the same layer that this node should be near.
     * The default value is null.
     */
    get near(): LayeredDigraphVertex; */
  /// Gets or sets another LayeredDigraphVertex in the same layer that this node should be near.
  /// The default value is null.
  _i3.LayeredDigraphVertex get near => _i5.getProperty(
        this,
        'near',
      );
  /* #28163
  source: 
    /**
     * Gets or sets another LayeredDigraphVertex in the same layer that this node should be near.
     * The default value is null.
     */
    get near(): LayeredDigraphVertex; */
  // Type Instance of 'InteropInterface'
  set near(_i3.LayeredDigraphVertex value) {
    _i5.setProperty(
      this,
      'near',
      value,
    );
  }

  void addSourceEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'addSourceEdge',
      [edge],
    );
  }

  void deleteSourceEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'deleteSourceEdge',
      [edge],
    );
  }

  void addDestinationEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'addDestinationEdge',
      [edge],
    );
  }

  void deleteDestinationEdge(_i3.LayoutEdge edge) {
    _i5.callMethod(
      this,
      'deleteDestinationEdge',
      [edge],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class LayeredDigraphEdge implements _i3.LayoutEdge {
  factory LayeredDigraphEdge(_i3.LayeredDigraphNetwork network) =>
      _i5.callConstructor(
        _declaredLayeredDigraphEdge,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('LayeredDigraphEdge')
external _i2.Object _declaredLayeredDigraphEdge;

extension LayeredDigraphEdge$Typings on LayeredDigraphEdge {
  /* #28181
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): LayeredDigraphVertex | null; */
  /// Gets or sets the LayoutVertex that this edge comes from.
  /// Setting this property does not change any LayoutVertex#destinationEdges collection.
  _i3.LayeredDigraphVertex? get fromVertex => _i5.getProperty(
        this,
        'fromVertex',
      );
  /* #28181
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): LayeredDigraphVertex | null; */
  // Type InteropUnion#700454673(parent: InteropGetter#182349594(name: fromVertex))
  set fromVertex(_i3.LayeredDigraphVertex? value) {
    _i5.setProperty(
      this,
      'fromVertex',
      value ?? _i4.undefined,
    );
  }

  /* #28187
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): LayeredDigraphVertex | null; */
  /// Gets or sets the LayoutVertex that this edge goes to.
  /// Setting this property does not change any LayoutVertex#sourceEdges collection.
  _i3.LayeredDigraphVertex? get toVertex => _i5.getProperty(
        this,
        'toVertex',
      );
  /* #28187
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): LayeredDigraphVertex | null; */
  // Type InteropUnion#59395529(parent: InteropGetter#448401578(name: toVertex))
  set toVertex(_i3.LayeredDigraphVertex? value) {
    _i5.setProperty(
      this,
      'toVertex',
      value ?? _i4.undefined,
    );
  }

  /* #28193
  source: 
    /**
     * True if the link is part of the proper digraph.
     * The default value is false.
     */
    get valid(): boolean; */
  /// True if the link is part of the proper digraph.
  /// The default value is false.
  _i2.bool get valid => _i5.getProperty(
        this,
        'valid',
      );
  /* #28193
  source: 
    /**
     * True if the link is part of the proper digraph.
     * The default value is false.
     */
    get valid(): boolean; */
  // Type InteropStaticType.boolean
  set valid(_i2.bool value) {
    _i5.setProperty(
      this,
      'valid',
      value,
    );
  }

  /* #28199
  source: 
    /**
     * True if the link was reversed during cycle removal.
     * The default value is false.
     */
    get rev(): boolean; */
  /// True if the link was reversed during cycle removal.
  /// The default value is false.
  _i2.bool get rev => _i5.getProperty(
        this,
        'rev',
      );
  /* #28199
  source: 
    /**
     * True if the link was reversed during cycle removal.
     * The default value is false.
     */
    get rev(): boolean; */
  // Type InteropStaticType.boolean
  set rev(_i2.bool value) {
    _i5.setProperty(
      this,
      'rev',
      value,
    );
  }

  /* #28205
  source: 
    /**
     * True if the link is part of the depth first forest.
     * The default value is false.
     */
    get forest(): boolean; */
  /// True if the link is part of the depth first forest.
  /// The default value is false.
  _i2.bool get forest => _i5.getProperty(
        this,
        'forest',
      );
  /* #28205
  source: 
    /**
     * True if the link is part of the depth first forest.
     * The default value is false.
     */
    get forest(): boolean; */
  // Type InteropStaticType.boolean
  set forest(_i2.bool value) {
    _i5.setProperty(
      this,
      'forest',
      value,
    );
  }

  /* #28214
  source: 
    /**
     * Location of the port at the from node of the link.
     * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
     * The default value is NaN.
     *
     * This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
     */
    get portFromPos(): number; */
  /// Location of the port at the from node of the link.
  /// Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
  /// The default value is NaN.
  ///
  /// This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
  _i2.num get portFromPos => _i5.getProperty(
        this,
        'portFromPos',
      );
  /* #28214
  source: 
    /**
     * Location of the port at the from node of the link.
     * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
     * The default value is NaN.
     *
     * This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
     */
    get portFromPos(): number; */
  // Type InteropStaticType.number
  set portFromPos(_i2.num value) {
    _i5.setProperty(
      this,
      'portFromPos',
      value,
    );
  }

  /* #28223
  source: 
    /**
     * Location of the port at the to node of the link.
     * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
     * The default value is NaN.
     *
     * This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
     */
    get portToPos(): number; */
  /// Location of the port at the to node of the link.
  /// Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
  /// The default value is NaN.
  ///
  /// This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
  _i2.num get portToPos => _i5.getProperty(
        this,
        'portToPos',
      );
  /* #28223
  source: 
    /**
     * Location of the port at the to node of the link.
     * Allows the crossing matrix to correctly calculate the crossings for nodes with multiple ports.
     * The default value is NaN.
     *
     * This property is also used to align link ports when using LayeredDigraphLayout#alignOption.
     */
    get portToPos(): number; */
  // Type InteropStaticType.number
  set portToPos(_i2.num value) {
    _i5.setProperty(
      this,
      'portToPos',
      value,
    );
  }

  /* #28229
  source: 
    /**
     * Approximate column offset of the from port of the link from the from node column used in straightening.
     * The default value is 0.
     */
    get portFromColOffset(): number; */
  /// Approximate column offset of the from port of the link from the from node column used in straightening.
  /// The default value is 0.
  _i2.num get portFromColOffset => _i5.getProperty(
        this,
        'portFromColOffset',
      );
  /* #28229
  source: 
    /**
     * Approximate column offset of the from port of the link from the from node column used in straightening.
     * The default value is 0.
     */
    get portFromColOffset(): number; */
  // Type InteropStaticType.number
  set portFromColOffset(_i2.num value) {
    _i5.setProperty(
      this,
      'portFromColOffset',
      value,
    );
  }

  /* #28235
  source: 
    /**
     * Approximate column offset of the to port of the link from the to node column used in straightening.
     * The default value is 0.
     */
    get portToColOffset(): number; */
  /// Approximate column offset of the to port of the link from the to node column used in straightening.
  /// The default value is 0.
  _i2.num get portToColOffset => _i5.getProperty(
        this,
        'portToColOffset',
      );
  /* #28235
  source: 
    /**
     * Approximate column offset of the to port of the link from the to node column used in straightening.
     * The default value is 0.
     */
    get portToColOffset(): number; */
  // Type InteropStaticType.number
  set portToColOffset(_i2.num value) {
    _i5.setProperty(
      this,
      'portToColOffset',
      value,
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class TreeLayout implements _i3.Layout {
  factory TreeLayout([_i4.Partial? init]) => _i5.callConstructor(
        _declaredTreeLayout,
        [init ?? _i4.undefined],
      );

  /* #29159
  source: 
    /**
     * This value for TreeLayout#path causes the value of Diagram#isTreePathToChildren
     * to effectively choose either TreeLayout.PathDestination (if true) or TreeLayout.PathSource (if false).
     * @constant
     */
    static PathDefault: EnumValue; */
  /// This value for TreeLayout#path causes the value of Diagram#isTreePathToChildren
  /// to effectively choose either TreeLayout.PathDestination (if true) or TreeLayout.PathSource (if false).
  static _i3.EnumValue get pathDefault => _i5.getProperty(
        _declaredTreeLayout,
        'PathDefault',
      );
  /* #29159
  source: 
    /**
     * This value for TreeLayout#path causes the value of Diagram#isTreePathToChildren
     * to effectively choose either TreeLayout.PathDestination (if true) or TreeLayout.PathSource (if false).
     * @constant
     */
    static PathDefault: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set pathDefault(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'PathDefault',
      value,
    );
  }

  /* #29168
  source: 
    /**
     * The children of a TreeVertex are its LayoutVertex#destinationVertexes,
     * the collection of connected LayoutEdge#toVertexes;
     * this value is used for TreeLayout#path.
     *
     * The tree roots are those TreeVertexes that have zero source edges.
     * @constant
     */
    static PathDestination: EnumValue; */
  /// The children of a TreeVertex are its LayoutVertex#destinationVertexes,
  /// the collection of connected LayoutEdge#toVertexes;
  /// this value is used for TreeLayout#path.
  ///
  /// The tree roots are those TreeVertexes that have zero source edges.
  static _i3.EnumValue get pathDestination => _i5.getProperty(
        _declaredTreeLayout,
        'PathDestination',
      );
  /* #29168
  source: 
    /**
     * The children of a TreeVertex are its LayoutVertex#destinationVertexes,
     * the collection of connected LayoutEdge#toVertexes;
     * this value is used for TreeLayout#path.
     *
     * The tree roots are those TreeVertexes that have zero source edges.
     * @constant
     */
    static PathDestination: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set pathDestination(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'PathDestination',
      value,
    );
  }

  /* #29177
  source: 
    /**
     * The children of a TreeVertex are its LayoutVertex#sourceVertexes,
     * the collection of connected LayoutEdge#fromVertexes;
     * this value is used for TreeLayout#path.
     *
     * The tree roots are those TreeVertexes that have zero destination edges.
     * @constant
     */
    static PathSource: EnumValue; */
  /// The children of a TreeVertex are its LayoutVertex#sourceVertexes,
  /// the collection of connected LayoutEdge#fromVertexes;
  /// this value is used for TreeLayout#path.
  ///
  /// The tree roots are those TreeVertexes that have zero destination edges.
  static _i3.EnumValue get pathSource => _i5.getProperty(
        _declaredTreeLayout,
        'PathSource',
      );
  /* #29177
  source: 
    /**
     * The children of a TreeVertex are its LayoutVertex#sourceVertexes,
     * the collection of connected LayoutEdge#fromVertexes;
     * this value is used for TreeLayout#path.
     *
     * The tree roots are those TreeVertexes that have zero destination edges.
     * @constant
     */
    static PathSource: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set pathSource(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'PathSource',
      value,
    );
  }

  /* #29183
  source: 
    /**
     * Lay out each child in the order in which they were found;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingForwards: EnumValue; */
  /// Lay out each child in the order in which they were found;
  /// this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
  static _i3.EnumValue get sortingForwards => _i5.getProperty(
        _declaredTreeLayout,
        'SortingForwards',
      );
  /* #29183
  source: 
    /**
     * Lay out each child in the order in which they were found;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingForwards: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set sortingForwards(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'SortingForwards',
      value,
    );
  }

  /* #29189
  source: 
    /**
     * Lay out each child in reverse order from which they were found;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingReverse: EnumValue; */
  /// Lay out each child in reverse order from which they were found;
  /// this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
  static _i3.EnumValue get sortingReverse => _i5.getProperty(
        _declaredTreeLayout,
        'SortingReverse',
      );
  /* #29189
  source: 
    /**
     * Lay out each child in reverse order from which they were found;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingReverse: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set sortingReverse(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'SortingReverse',
      value,
    );
  }

  /* #29195
  source: 
    /**
     * Lay out each child according to the sort order given by TreeVertex#comparer;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingAscending: EnumValue; */
  /// Lay out each child according to the sort order given by TreeVertex#comparer;
  /// this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
  static _i3.EnumValue get sortingAscending => _i5.getProperty(
        _declaredTreeLayout,
        'SortingAscending',
      );
  /* #29195
  source: 
    /**
     * Lay out each child according to the sort order given by TreeVertex#comparer;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingAscending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set sortingAscending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'SortingAscending',
      value,
    );
  }

  /* #29201
  source: 
    /**
     * Lay out each child in reverse sort order given by TreeVertex#comparer;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingDescending: EnumValue; */
  /// Lay out each child in reverse sort order given by TreeVertex#comparer;
  /// this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
  static _i3.EnumValue get sortingDescending => _i5.getProperty(
        _declaredTreeLayout,
        'SortingDescending',
      );
  /* #29201
  source: 
    /**
     * Lay out each child in reverse sort order given by TreeVertex#comparer;
     * this value is used for TreeLayout#sorting or TreeLayout#alternateSorting.
     * @constant
     */
    static SortingDescending: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set sortingDescending(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'SortingDescending',
      value,
    );
  }

  /* #29211
  source: 
    /**
     * The parent is centered at the middle of the range of its child subtrees;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * When there is a breadth limit that causes there to be multiple rows,
     * the links that extend from the parent to those children in rows past
     * the first one may cross over the nodes that are in earlier rows.
     * @constant
     */
    static AlignmentCenterSubtrees: EnumValue; */
  /// The parent is centered at the middle of the range of its child subtrees;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// When there is a breadth limit that causes there to be multiple rows,
  /// the links that extend from the parent to those children in rows past
  /// the first one may cross over the nodes that are in earlier rows.
  static _i3.EnumValue get alignmentCenterSubtrees => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentCenterSubtrees',
      );
  /* #29211
  source: 
    /**
     * The parent is centered at the middle of the range of its child subtrees;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * When there is a breadth limit that causes there to be multiple rows,
     * the links that extend from the parent to those children in rows past
     * the first one may cross over the nodes that are in earlier rows.
     * @constant
     */
    static AlignmentCenterSubtrees: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentCenterSubtrees(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentCenterSubtrees',
      value,
    );
  }

  /* #29221
  source: 
    /**
     * The parent is centered at the middle of the range of its immediate child nodes;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * When there is a breadth limit that causes there to be multiple rows,
     * the links that extend from the parent to those children in rows past
     * the first one may cross over the nodes that are in earlier rows.
     * @constant
     */
    static AlignmentCenterChildren: EnumValue; */
  /// The parent is centered at the middle of the range of its immediate child nodes;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// When there is a breadth limit that causes there to be multiple rows,
  /// the links that extend from the parent to those children in rows past
  /// the first one may cross over the nodes that are in earlier rows.
  static _i3.EnumValue get alignmentCenterChildren => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentCenterChildren',
      );
  /* #29221
  source: 
    /**
     * The parent is centered at the middle of the range of its immediate child nodes;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * When there is a breadth limit that causes there to be multiple rows,
     * the links that extend from the parent to those children in rows past
     * the first one may cross over the nodes that are in earlier rows.
     * @constant
     */
    static AlignmentCenterChildren: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentCenterChildren(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentCenterChildren',
      value,
    );
  }

  /* #29227
  source: 
    /**
     * The parent is positioned near the first of its children;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     * @constant
     */
    static AlignmentStart: EnumValue; */
  /// The parent is positioned near the first of its children;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  static _i3.EnumValue get alignmentStart => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentStart',
      );
  /* #29227
  source: 
    /**
     * The parent is positioned near the first of its children;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     * @constant
     */
    static AlignmentStart: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentStart(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentStart',
      value,
    );
  }

  /* #29233
  source: 
    /**
     * The parent is positioned near the last of its children;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     * @constant
     */
    static AlignmentEnd: EnumValue; */
  /// The parent is positioned near the last of its children;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  static _i3.EnumValue get alignmentEnd => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentEnd',
      );
  /* #29233
  source: 
    /**
     * The parent is positioned near the last of its children;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     * @constant
     */
    static AlignmentEnd: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentEnd(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentEnd',
      value,
    );
  }

  /* #29246
  source: 
    /**
     * The children are positioned in a bus on both sides of an "aisle" where the links to them go,
     * with the last odd child (if any) placed at the end of the aisle in the middle;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * The children, if they are themselves parents, continue at the same inherited angle;
     * use TreeLayout.AlignmentBusBranching if you want grandchildren to proceed growing in
     * the different angle as determined by the side.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBus: EnumValue; */
  /// The children are positioned in a bus on both sides of an "aisle" where the links to them go,
  /// with the last odd child (if any) placed at the end of the aisle in the middle;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// The children, if they are themselves parents, continue at the same inherited angle;
  /// use TreeLayout.AlignmentBusBranching if you want grandchildren to proceed growing in
  /// the different angle as determined by the side.
  ///
  /// A bus does not take TreeVertex#breadthLimit into account.
  static _i3.EnumValue get alignmentBus => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentBus',
      );
  /* #29246
  source: 
    /**
     * The children are positioned in a bus on both sides of an "aisle" where the links to them go,
     * with the last odd child (if any) placed at the end of the aisle in the middle;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * The children, if they are themselves parents, continue at the same inherited angle;
     * use TreeLayout.AlignmentBusBranching if you want grandchildren to proceed growing in
     * the different angle as determined by the side.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBus: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentBus(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentBus',
      value,
    );
  }

  /* #29259
  source: 
    /**
     * Like TreeLayout.AlignmentBus with the children arranged on both sides of an "aisle"
     * with any last odd child placed at the end of the aisle,
     * but the children get an TreeVertex#angle that depends on which side of the aisle
     * they were placed;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * This only works well when the TreeLayout#treeStyle is TreeLayout.StyleLayered.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBusBranching: EnumValue; */
  /// Like TreeLayout.AlignmentBus with the children arranged on both sides of an "aisle"
  /// with any last odd child placed at the end of the aisle,
  /// but the children get an TreeVertex#angle that depends on which side of the aisle
  /// they were placed;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// This only works well when the TreeLayout#treeStyle is TreeLayout.StyleLayered.
  ///
  /// A bus does not take TreeVertex#breadthLimit into account.
  static _i3.EnumValue get alignmentBusBranching => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentBusBranching',
      );
  /* #29259
  source: 
    /**
     * Like TreeLayout.AlignmentBus with the children arranged on both sides of an "aisle"
     * with any last odd child placed at the end of the aisle,
     * but the children get an TreeVertex#angle that depends on which side of the aisle
     * they were placed;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * This only works well when the TreeLayout#treeStyle is TreeLayout.StyleLayered.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBusBranching: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentBusBranching(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentBusBranching',
      value,
    );
  }

  /* #29267
  source: 
    /**
     * The children are positioned in a bus, only on the top or left side of the parent;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentTopLeftBus: EnumValue; */
  /// The children are positioned in a bus, only on the top or left side of the parent;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// A bus does not take TreeVertex#breadthLimit into account.
  static _i3.EnumValue get alignmentTopLeftBus => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentTopLeftBus',
      );
  /* #29267
  source: 
    /**
     * The children are positioned in a bus, only on the top or left side of the parent;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentTopLeftBus: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentTopLeftBus(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentTopLeftBus',
      value,
    );
  }

  /* #29275
  source: 
    /**
     * The children are positioned in a bus, only on the bottom or right side of the parent;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBottomRightBus: EnumValue; */
  /// The children are positioned in a bus, only on the bottom or right side of the parent;
  /// this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
  ///
  /// A bus does not take TreeVertex#breadthLimit into account.
  static _i3.EnumValue get alignmentBottomRightBus => _i5.getProperty(
        _declaredTreeLayout,
        'AlignmentBottomRightBus',
      );
  /* #29275
  source: 
    /**
     * The children are positioned in a bus, only on the bottom or right side of the parent;
     * this value is used for TreeLayout#alignment or TreeLayout#alternateAlignment.
     *
     * A bus does not take TreeVertex#breadthLimit into account.
     * @constant
     */
    static AlignmentBottomRightBus: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set alignmentBottomRightBus(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'AlignmentBottomRightBus',
      value,
    );
  }

  /* #29285
  source: 
    /**
     * Only simple placement of children next to each other, as determined by their subtree breadth;
     * this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
     *
     * For any node, there will not be another node at any depth occupying the same breadth position,
     * unless there are multiple rows;  In other words, if there is no breadth limit resulting in
     * multiple rows, with this compaction mode it is as if every node were infinitely deep.
     * @constant
     */
    static CompactionNone: EnumValue; */
  /// Only simple placement of children next to each other, as determined by their subtree breadth;
  /// this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
  ///
  /// For any node, there will not be another node at any depth occupying the same breadth position,
  /// unless there are multiple rows;  In other words, if there is no breadth limit resulting in
  /// multiple rows, with this compaction mode it is as if every node were infinitely deep.
  static _i3.EnumValue get compactionNone => _i5.getProperty(
        _declaredTreeLayout,
        'CompactionNone',
      );
  /* #29285
  source: 
    /**
     * Only simple placement of children next to each other, as determined by their subtree breadth;
     * this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
     *
     * For any node, there will not be another node at any depth occupying the same breadth position,
     * unless there are multiple rows;  In other words, if there is no breadth limit resulting in
     * multiple rows, with this compaction mode it is as if every node were infinitely deep.
     * @constant
     */
    static CompactionNone: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set compactionNone(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'CompactionNone',
      value,
    );
  }

  /* #29298
  source: 
    /**
     * A simple fitting of subtrees;
     * this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
     *
     * This mode produces more compact trees -- often nicer looking too;
     * Nodes will not overlap each other, unless you have negative values
     * for some of the spacing properties;
     * However it is possible when the links are orthogonally styled that
     * occasionally the subtrees will be placed so close together that some
     * links may overlap the links or even the nodes of other subtrees.
     * @constant
     */
    static CompactionBlock: EnumValue; */
  /// A simple fitting of subtrees;
  /// this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
  ///
  /// This mode produces more compact trees -- often nicer looking too;
  /// Nodes will not overlap each other, unless you have negative values
  /// for some of the spacing properties;
  /// However it is possible when the links are orthogonally styled that
  /// occasionally the subtrees will be placed so close together that some
  /// links may overlap the links or even the nodes of other subtrees.
  static _i3.EnumValue get compactionBlock => _i5.getProperty(
        _declaredTreeLayout,
        'CompactionBlock',
      );
  /* #29298
  source: 
    /**
     * A simple fitting of subtrees;
     * this value is used for TreeLayout#compaction or TreeLayout#alternateCompaction.
     *
     * This mode produces more compact trees -- often nicer looking too;
     * Nodes will not overlap each other, unless you have negative values
     * for some of the spacing properties;
     * However it is possible when the links are orthogonally styled that
     * occasionally the subtrees will be placed so close together that some
     * links may overlap the links or even the nodes of other subtrees.
     * @constant
     */
    static CompactionBlock: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set compactionBlock(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'CompactionBlock',
      value,
    );
  }

  /* #29309
  source: 
    /**
     * The normal tree style, where all of the children of each TreeVertex are lined up
     * horizontally or vertically;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its parent node;
     * TreeLayout#rootDefaults is used for all default TreeVertex property values;
     * TreeLayout#alternateDefaults is ignored.
     * @constant
     */
    static StyleLayered: EnumValue; */
  /// The normal tree style, where all of the children of each TreeVertex are lined up
  /// horizontally or vertically;
  /// this value is used for TreeLayout#treeStyle.
  ///
  /// Each TreeVertex gets its properties from its parent node;
  /// TreeLayout#rootDefaults is used for all default TreeVertex property values;
  /// TreeLayout#alternateDefaults is ignored.
  static _i3.EnumValue get styleLayered => _i5.getProperty(
        _declaredTreeLayout,
        'StyleLayered',
      );
  /* #29309
  source: 
    /**
     * The normal tree style, where all of the children of each TreeVertex are lined up
     * horizontally or vertically;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its parent node;
     * TreeLayout#rootDefaults is used for all default TreeVertex property values;
     * TreeLayout#alternateDefaults is ignored.
     * @constant
     */
    static StyleLayered: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set styleLayered(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'StyleLayered',
      value,
    );
  }

  /* #29323
  source: 
    /**
     * Just like the standard layered tree style, except that the nodes with children but no grandchildren
     * have alternate properties;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its parent node;
     * However, for those nodes whose TreeVertex#maxGenerationCount is 1,
     * in other words when it has children but no grandchildren,
     * the properties are copied from TreeLayout#alternateDefaults.
     *
     * If the tree only has two levels, the root node gets the TreeLayout#rootDefaults.
     * @constant
     */
    static StyleLastParents: EnumValue; */
  /// Just like the standard layered tree style, except that the nodes with children but no grandchildren
  /// have alternate properties;
  /// this value is used for TreeLayout#treeStyle.
  ///
  /// Each TreeVertex gets its properties from its parent node;
  /// However, for those nodes whose TreeVertex#maxGenerationCount is 1,
  /// in other words when it has children but no grandchildren,
  /// the properties are copied from TreeLayout#alternateDefaults.
  ///
  /// If the tree only has two levels, the root node gets the TreeLayout#rootDefaults.
  static _i3.EnumValue get styleLastParents => _i5.getProperty(
        _declaredTreeLayout,
        'StyleLastParents',
      );
  /* #29323
  source: 
    /**
     * Just like the standard layered tree style, except that the nodes with children but no grandchildren
     * have alternate properties;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its parent node;
     * However, for those nodes whose TreeVertex#maxGenerationCount is 1,
     * in other words when it has children but no grandchildren,
     * the properties are copied from TreeLayout#alternateDefaults.
     *
     * If the tree only has two levels, the root node gets the TreeLayout#rootDefaults.
     * @constant
     */
    static StyleLastParents: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set styleLastParents(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'StyleLastParents',
      value,
    );
  }

  /* #29336
  source: 
    /**
     * Alternate layers of the tree have different properties, typically including the angle;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its grandparent node;
     * The root nodes get their defaults from TreeLayout#rootDefaults.
     *
     * The immediate children of root nodes get their defaults from TreeLayout#alternateDefaults.
     *
     * Depending on the properties used, it is possible for some link routes to cross over nodes.
     * @constant
     */
    static StyleAlternating: EnumValue; */
  /// Alternate layers of the tree have different properties, typically including the angle;
  /// this value is used for TreeLayout#treeStyle.
  ///
  /// Each TreeVertex gets its properties from its grandparent node;
  /// The root nodes get their defaults from TreeLayout#rootDefaults.
  ///
  /// The immediate children of root nodes get their defaults from TreeLayout#alternateDefaults.
  ///
  /// Depending on the properties used, it is possible for some link routes to cross over nodes.
  static _i3.EnumValue get styleAlternating => _i5.getProperty(
        _declaredTreeLayout,
        'StyleAlternating',
      );
  /* #29336
  source: 
    /**
     * Alternate layers of the tree have different properties, typically including the angle;
     * this value is used for TreeLayout#treeStyle.
     *
     * Each TreeVertex gets its properties from its grandparent node;
     * The root nodes get their defaults from TreeLayout#rootDefaults.
     *
     * The immediate children of root nodes get their defaults from TreeLayout#alternateDefaults.
     *
     * Depending on the properties used, it is possible for some link routes to cross over nodes.
     * @constant
     */
    static StyleAlternating: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set styleAlternating(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'StyleAlternating',
      value,
    );
  }

  /* #29346
  source: 
    /**
     * All of the nodes get the alternate properties, except the root node gets the default properties;
     * this value is used for TreeLayout#treeStyle.
     *
     * The root node gets the TreeLayout#rootDefaults properties,
     * the root node's children get the TreeLayout#alternateDefaults properties,
     * and all the rest of the TreeVertexes get their properties from their parent node.
     * @constant
     */
    static StyleRootOnly: EnumValue; */
  /// All of the nodes get the alternate properties, except the root node gets the default properties;
  /// this value is used for TreeLayout#treeStyle.
  ///
  /// The root node gets the TreeLayout#rootDefaults properties,
  /// the root node's children get the TreeLayout#alternateDefaults properties,
  /// and all the rest of the TreeVertexes get their properties from their parent node.
  static _i3.EnumValue get styleRootOnly => _i5.getProperty(
        _declaredTreeLayout,
        'StyleRootOnly',
      );
  /* #29346
  source: 
    /**
     * All of the nodes get the alternate properties, except the root node gets the default properties;
     * this value is used for TreeLayout#treeStyle.
     *
     * The root node gets the TreeLayout#rootDefaults properties,
     * the root node's children get the TreeLayout#alternateDefaults properties,
     * and all the rest of the TreeVertexes get their properties from their parent node.
     * @constant
     */
    static StyleRootOnly: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set styleRootOnly(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'StyleRootOnly',
      value,
    );
  }

  /* #29353
  source: 
    /**
     * Position each tree in a non-overlapping fashion by increasing Y coordinates,
     * starting at the Layout#arrangementOrigin;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementVertical: EnumValue; */
  /// Position each tree in a non-overlapping fashion by increasing Y coordinates,
  /// starting at the Layout#arrangementOrigin;
  /// this value is used for TreeLayout#arrangement.
  static _i3.EnumValue get arrangementVertical => _i5.getProperty(
        _declaredTreeLayout,
        'ArrangementVertical',
      );
  /* #29353
  source: 
    /**
     * Position each tree in a non-overlapping fashion by increasing Y coordinates,
     * starting at the Layout#arrangementOrigin;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementVertical: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set arrangementVertical(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'ArrangementVertical',
      value,
    );
  }

  /* #29360
  source: 
    /**
     * Position each tree in a non-overlapping fashion by increasing X coordinates,
     * starting at the Layout#arrangementOrigin;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementHorizontal: EnumValue; */
  /// Position each tree in a non-overlapping fashion by increasing X coordinates,
  /// starting at the Layout#arrangementOrigin;
  /// this value is used for TreeLayout#arrangement.
  static _i3.EnumValue get arrangementHorizontal => _i5.getProperty(
        _declaredTreeLayout,
        'ArrangementHorizontal',
      );
  /* #29360
  source: 
    /**
     * Position each tree in a non-overlapping fashion by increasing X coordinates,
     * starting at the Layout#arrangementOrigin;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementHorizontal: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set arrangementHorizontal(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'ArrangementHorizontal',
      value,
    );
  }

  /* #29366
  source: 
    /**
     * Do not move each root node, but position all of their descendants relative to their root;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementFixedRoots: EnumValue; */
  /// Do not move each root node, but position all of their descendants relative to their root;
  /// this value is used for TreeLayout#arrangement.
  static _i3.EnumValue get arrangementFixedRoots => _i5.getProperty(
        _declaredTreeLayout,
        'ArrangementFixedRoots',
      );
  /* #29366
  source: 
    /**
     * Do not move each root node, but position all of their descendants relative to their root;
     * this value is used for TreeLayout#arrangement.
     * @constant
     */
    static ArrangementFixedRoots: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set arrangementFixedRoots(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'ArrangementFixedRoots',
      value,
    );
  }

  /* #29373
  source: 
    /**
     * The normal layer style, where each node takes up only the depth that it needs;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerIndividual: EnumValue; */
  /// The normal layer style, where each node takes up only the depth that it needs;
  /// this value is used for TreeLayout#layerStyle.
  static _i3.EnumValue get layerIndividual => _i5.getProperty(
        _declaredTreeLayout,
        'LayerIndividual',
      );
  /* #29373
  source: 
    /**
     * The normal layer style, where each node takes up only the depth that it needs;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerIndividual: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerIndividual(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'LayerIndividual',
      value,
    );
  }

  /* #29381
  source: 
    /**
     * A layer style where all of the children of a parent node take up the same amount of depth --
     * this typically causes all cousins to be aligned;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerSiblings: EnumValue; */
  /// A layer style where all of the children of a parent node take up the same amount of depth --
  /// this typically causes all cousins to be aligned;
  /// this value is used for TreeLayout#layerStyle.
  static _i3.EnumValue get layerSiblings => _i5.getProperty(
        _declaredTreeLayout,
        'LayerSiblings',
      );
  /* #29381
  source: 
    /**
     * A layer style where all of the children of a parent node take up the same amount of depth --
     * this typically causes all cousins to be aligned;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerSiblings: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerSiblings(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'LayerSiblings',
      value,
    );
  }

  /* #29389
  source: 
    /**
     * A layer style where all nodes with the same TreeVertex#level throughout the tree take up the same amount of depth --
     * if the TreeVertex#angle is the same for all nodes, this will result in all nodes in the same layer to be aligned;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerUniform: EnumValue; */
  /// A layer style where all nodes with the same TreeVertex#level throughout the tree take up the same amount of depth --
  /// if the TreeVertex#angle is the same for all nodes, this will result in all nodes in the same layer to be aligned;
  /// this value is used for TreeLayout#layerStyle.
  static _i3.EnumValue get layerUniform => _i5.getProperty(
        _declaredTreeLayout,
        'LayerUniform',
      );
  /* #29389
  source: 
    /**
     * A layer style where all nodes with the same TreeVertex#level throughout the tree take up the same amount of depth --
     * if the TreeVertex#angle is the same for all nodes, this will result in all nodes in the same layer to be aligned;
     * this value is used for TreeLayout#layerStyle.
     * @constant
     * @since 1.4
     */
    static LayerUniform: EnumValue; */
  // Type Instance of 'InteropInterface'
  static set layerUniform(_i3.EnumValue value) {
    _i5.setProperty(
      _declaredTreeLayout,
      'LayerUniform',
      value,
    );
  }
}

/*
FieldExternal: 
*/
@_i1.JS('TreeLayout')
external _i2.Object _declaredTreeLayout;

extension TreeLayout$Typings on TreeLayout {
  /* #28558
  source: 
    /**
     * Gets or sets the collection of root vertexes.
     *
     * Initially this will be an empty Set.
     *
     * If the #path is either TreeLayout.PathDestination|PathDestination or
     * TreeLayout.PathSource|PathSource, this layout can easily
     * determine all of the tree roots by searching the whole network.
     * Otherwise, you should explicitly initialize this collection
     * with one or more TreeVertexes.
     */
    get roots(): Set<(TreeVertex | Node)>; */
  /// Gets or sets the collection of root vertexes.
  ///
  /// Initially this will be an empty Set.
  ///
  /// If the #path is either TreeLayout.PathDestination|PathDestination or
  /// TreeLayout.PathSource|PathSource, this layout can easily
  /// determine all of the tree roots by searching the whole network.
  /// Otherwise, you should explicitly initialize this collection
  /// with one or more TreeVertexes.
  _i3.Set<_i2.Object> get roots => _i5.getProperty(
        this,
        'roots',
      );
  /* #28558
  source: 
    /**
     * Gets or sets the collection of root vertexes.
     *
     * Initially this will be an empty Set.
     *
     * If the #path is either TreeLayout.PathDestination|PathDestination or
     * TreeLayout.PathSource|PathSource, this layout can easily
     * determine all of the tree roots by searching the whole network.
     * Otherwise, you should explicitly initialize this collection
     * with one or more TreeVertexes.
     */
    get roots(): Set<(TreeVertex | Node)>; */
  // Type Instance of 'InteropInterface'
  set roots(_i3.Set<_i2.Object> value) {
    _i5.setProperty(
      this,
      'roots',
      value,
    );
  }

  /* #28568
  source: 
    /**
     * Gets or sets how the tree should be constructed from the
     * TreeEdges connecting TreeVertexes.
     * Must be TreeLayout.PathDestination or TreeLayout.PathSource or TreeLayout.PathDefault.
     *
     * The default value is TreeLayout.PathDefault,
     * where the value of Diagram#isTreePathToChildren determines the effective value of this property.
     */
    get path(): EnumValue; */
  /// Gets or sets how the tree should be constructed from the
  /// TreeEdges connecting TreeVertexes.
  /// Must be TreeLayout.PathDestination or TreeLayout.PathSource or TreeLayout.PathDefault.
  ///
  /// The default value is TreeLayout.PathDefault,
  /// where the value of Diagram#isTreePathToChildren determines the effective value of this property.
  _i3.EnumValue get path => _i5.getProperty(
        this,
        'path',
      );
  /* #28568
  source: 
    /**
     * Gets or sets how the tree should be constructed from the
     * TreeEdges connecting TreeVertexes.
     * Must be TreeLayout.PathDestination or TreeLayout.PathSource or TreeLayout.PathDefault.
     *
     * The default value is TreeLayout.PathDefault,
     * where the value of Diagram#isTreePathToChildren determines the effective value of this property.
     */
    get path(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set path(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'path',
      value,
    );
  }

  /* #28577
  source: 
    /**
     * Gets or sets the Style for the resulting trees.
     * Must be TreeLayout.StyleLayered, TreeLayout.StyleAlternating,
     * TreeLayout.StyleLastParents, or TreeLayout.StyleRootOnly.
     *
     * The default value is TreeLayout.StyleLayered.
     */
    get treeStyle(): EnumValue; */
  /// Gets or sets the Style for the resulting trees.
  /// Must be TreeLayout.StyleLayered, TreeLayout.StyleAlternating,
  /// TreeLayout.StyleLastParents, or TreeLayout.StyleRootOnly.
  ///
  /// The default value is TreeLayout.StyleLayered.
  _i3.EnumValue get treeStyle => _i5.getProperty(
        this,
        'treeStyle',
      );
  /* #28577
  source: 
    /**
     * Gets or sets the Style for the resulting trees.
     * Must be TreeLayout.StyleLayered, TreeLayout.StyleAlternating,
     * TreeLayout.StyleLastParents, or TreeLayout.StyleRootOnly.
     *
     * The default value is TreeLayout.StyleLayered.
     */
    get treeStyle(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set treeStyle(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'treeStyle',
      value,
    );
  }

  /* #28587
  source: 
    /**
     * Gets or sets the manner in which the nodes are aligned in layers.
     * Must be TreeLayout.LayerIndividual, TreeLayout.LayerSiblings,
     * or TreeLayout.LayerUniform.
     *
     * The default value is TreeLayout.LayerIndividual.
     * @since 1.4
     */
    get layerStyle(): EnumValue; */
  /// Gets or sets the manner in which the nodes are aligned in layers.
  /// Must be TreeLayout.LayerIndividual, TreeLayout.LayerSiblings,
  /// or TreeLayout.LayerUniform.
  ///
  /// The default value is TreeLayout.LayerIndividual.
  _i3.EnumValue get layerStyle => _i5.getProperty(
        this,
        'layerStyle',
      );
  /* #28587
  source: 
    /**
     * Gets or sets the manner in which the nodes are aligned in layers.
     * Must be TreeLayout.LayerIndividual, TreeLayout.LayerSiblings,
     * or TreeLayout.LayerUniform.
     *
     * The default value is TreeLayout.LayerIndividual.
     * @since 1.4
     */
    get layerStyle(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set layerStyle(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'layerStyle',
      value,
    );
  }

  /* #28597
  source: 
    /**
     * Gets or sets whether this layout should find all Nodes
     * whose category is "Comment" and
     * whose anchors are nodes represented in the network,
     * and increase the size of the corresponding TreeVertex to make room for the comment nodes.
     * The default value is true.
     * @since 1.3
     */
    get comments(): boolean; */
  /// Gets or sets whether this layout should find all Nodes
  /// whose category is "Comment" and
  /// whose anchors are nodes represented in the network,
  /// and increase the size of the corresponding TreeVertex to make room for the comment nodes.
  /// The default value is true.
  _i2.bool get comments => _i5.getProperty(
        this,
        'comments',
      );
  /* #28597
  source: 
    /**
     * Gets or sets whether this layout should find all Nodes
     * whose category is "Comment" and
     * whose anchors are nodes represented in the network,
     * and increase the size of the corresponding TreeVertex to make room for the comment nodes.
     * The default value is true.
     * @since 1.3
     */
    get comments(): boolean; */
  // Type InteropStaticType.boolean
  set comments(_i2.bool value) {
    _i5.setProperty(
      this,
      'comments',
      value,
    );
  }

  /* #28606
  source: 
    /**
     * Gets or sets how #arrangeTrees should lay out the separate trees.
     * Must be TreeLayout.ArrangementVertical, TreeLayout.ArrangementHorizontal,
     * or TreeLayout.ArrangementFixedRoots.
     *
     * The default value is TreeLayout.ArrangementVertical
     */
    get arrangement(): EnumValue; */
  /// Gets or sets how #arrangeTrees should lay out the separate trees.
  /// Must be TreeLayout.ArrangementVertical, TreeLayout.ArrangementHorizontal,
  /// or TreeLayout.ArrangementFixedRoots.
  ///
  /// The default value is TreeLayout.ArrangementVertical
  _i3.EnumValue get arrangement => _i5.getProperty(
        this,
        'arrangement',
      );
  /* #28606
  source: 
    /**
     * Gets or sets how #arrangeTrees should lay out the separate trees.
     * Must be TreeLayout.ArrangementVertical, TreeLayout.ArrangementHorizontal,
     * or TreeLayout.ArrangementFixedRoots.
     *
     * The default value is TreeLayout.ArrangementVertical
     */
    get arrangement(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set arrangement(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'arrangement',
      value,
    );
  }

  /* #28615
  source: 
    /**
     * Gets or sets the space between which #arrangeTrees will position the trees.
     *
     * This defaults to the Size(10, 10).
     *
     * This property is ignored if #arrangement is TreeLayout.ArrangementFixedRoots.
     */
    get arrangementSpacing(): Size; */
  /// Gets or sets the space between which #arrangeTrees will position the trees.
  ///
  /// This defaults to the Size(10, 10).
  ///
  /// This property is ignored if #arrangement is TreeLayout.ArrangementFixedRoots.
  _i3.Size get arrangementSpacing => _i5.getProperty(
        this,
        'arrangementSpacing',
      );
  /* #28615
  source: 
    /**
     * Gets or sets the space between which #arrangeTrees will position the trees.
     *
     * This defaults to the Size(10, 10).
     *
     * This property is ignored if #arrangement is TreeLayout.ArrangementFixedRoots.
     */
    get arrangementSpacing(): Size; */
  // Type Instance of 'InteropInterface'
  set arrangementSpacing(_i3.Size value) {
    _i5.setProperty(
      this,
      'arrangementSpacing',
      value,
    );
  }

  /* #28629
  source: 
    /**
     * Gets or sets the object holding the default values for root TreeVertexes.
     *
     * The values for the following inheritable properties are actually stored in this object:
     * #sorting, #comparer, #angle,
     * #alignment, #nodeIndent, #nodeIndentPastParent,
     * #nodeSpacing, #layerSpacing, #layerSpacingParentOverlap,
     * #compaction, #breadthLimit, #rowSpacing, #rowIndent,
     * #commentSpacing, #commentMargin,
     * #setsPortSpot, #portSpot, #setsChildPortSpot, #childPortSpot.
     * The other properties of this TreeVertex are ignored.
     */
    get rootDefaults(): TreeVertex; */
  /// Gets or sets the object holding the default values for root TreeVertexes.
  ///
  /// The values for the following inheritable properties are actually stored in this object:
  /// #sorting, #comparer, #angle,
  /// #alignment, #nodeIndent, #nodeIndentPastParent,
  /// #nodeSpacing, #layerSpacing, #layerSpacingParentOverlap,
  /// #compaction, #breadthLimit, #rowSpacing, #rowIndent,
  /// #commentSpacing, #commentMargin,
  /// #setsPortSpot, #portSpot, #setsChildPortSpot, #childPortSpot.
  /// The other properties of this TreeVertex are ignored.
  _i3.TreeVertex get rootDefaults => _i5.getProperty(
        this,
        'rootDefaults',
      );
  /* #28629
  source: 
    /**
     * Gets or sets the object holding the default values for root TreeVertexes.
     *
     * The values for the following inheritable properties are actually stored in this object:
     * #sorting, #comparer, #angle,
     * #alignment, #nodeIndent, #nodeIndentPastParent,
     * #nodeSpacing, #layerSpacing, #layerSpacingParentOverlap,
     * #compaction, #breadthLimit, #rowSpacing, #rowIndent,
     * #commentSpacing, #commentMargin,
     * #setsPortSpot, #portSpot, #setsChildPortSpot, #childPortSpot.
     * The other properties of this TreeVertex are ignored.
     */
    get rootDefaults(): TreeVertex; */
  // Type Instance of 'InteropInterface'
  set rootDefaults(_i3.TreeVertex value) {
    _i5.setProperty(
      this,
      'rootDefaults',
      value,
    );
  }

  /* #28638
  source: 
    /**
     * Gets or sets the object holding the default values for alternate layer TreeVertexes,
     * used when the #treeStyle is TreeLayout.StyleAlternating|StyleAlternating or TreeLayout.StyleLastParents|StyleLastParents.
     *
     * See the list of inheritable properties in the documentation for #rootDefaults.
     * The other properties of this TreeVertex are ignored.
     */
    get alternateDefaults(): TreeVertex; */
  /// Gets or sets the object holding the default values for alternate layer TreeVertexes,
  /// used when the #treeStyle is TreeLayout.StyleAlternating|StyleAlternating or TreeLayout.StyleLastParents|StyleLastParents.
  ///
  /// See the list of inheritable properties in the documentation for #rootDefaults.
  /// The other properties of this TreeVertex are ignored.
  _i3.TreeVertex get alternateDefaults => _i5.getProperty(
        this,
        'alternateDefaults',
      );
  /* #28638
  source: 
    /**
     * Gets or sets the object holding the default values for alternate layer TreeVertexes,
     * used when the #treeStyle is TreeLayout.StyleAlternating|StyleAlternating or TreeLayout.StyleLastParents|StyleLastParents.
     *
     * See the list of inheritable properties in the documentation for #rootDefaults.
     * The other properties of this TreeVertex are ignored.
     */
    get alternateDefaults(): TreeVertex; */
  // Type Instance of 'InteropInterface'
  set alternateDefaults(_i3.TreeVertex value) {
    _i5.setProperty(
      this,
      'alternateDefaults',
      value,
    );
  }

  /* #28650
  source: 
    /**
     * Gets or sets the default sorting policy for ordering the immediate children of a vertex.
     * Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
     * TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
     *
     * The default value is TreeLayout.SortingForwards.
     *
     * This sets the #rootDefaults' property of the same name.
     * The sort order is determined by #comparer.
     */
    get sorting(): EnumValue; */
  /// Gets or sets the default sorting policy for ordering the immediate children of a vertex.
  /// Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
  /// TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
  ///
  /// The default value is TreeLayout.SortingForwards.
  ///
  /// This sets the #rootDefaults' property of the same name.
  /// The sort order is determined by #comparer.
  _i3.EnumValue get sorting => _i5.getProperty(
        this,
        'sorting',
      );
  /* #28650
  source: 
    /**
     * Gets or sets the default sorting policy for ordering the immediate children of a vertex.
     * Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
     * TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
     *
     * The default value is TreeLayout.SortingForwards.
     *
     * This sets the #rootDefaults' property of the same name.
     * The sort order is determined by #comparer.
     */
    get sorting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set sorting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'sorting',
      value,
    );
  }

  /* #28674
  source: 
    /**
     * Gets or sets the default comparison function used for sorting the immediate children of a vertex.
     *
     * The default comparer compares the LayoutVertex#node Text values.
     *
     * This sets the #rootDefaults' property of the same name.
     * Whether this comparison function is used is determined by the value of #sorting.
     * ```js
     *   $(go.TreeLayout,
     *     {
     *       sorting: go.TreeLayout.SortingAscending,
     *       comparer: (va, vb) => {
     *         var da = va.node.data;
     *         var db = vb.node.data;
     *         if (da.someProperty < db.someProperty) return -1;
     *         if (da.someProperty > db.someProperty) return 1;
     *         return 0;
     *       }
     *     }
     *   )
     * ```
     */
    get comparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  /// Gets or sets the default comparison function used for sorting the immediate children of a vertex.
  ///
  /// The default comparer compares the LayoutVertex#node Text values.
  ///
  /// This sets the #rootDefaults' property of the same name.
  /// Whether this comparison function is used is determined by the value of #sorting.
  /// ```js
  ///   $(go.TreeLayout,
  ///     {
  ///       sorting: go.TreeLayout.SortingAscending,
  ///       comparer: (va, vb) => {
  ///         var da = va.node.data;
  ///         var db = vb.node.data;
  ///         if (da.someProperty < db.someProperty) return -1;
  ///         if (da.someProperty > db.someProperty) return 1;
  ///         return 0;
  ///       }
  ///     }
  ///   )
  /// ```
  _i2.num Function(
    _i3.TreeVertex,
    _i3.TreeVertex,
  ) get comparer => _i5.getProperty(
        this,
        'comparer',
      );
  /* #28674
  source: 
    /**
     * Gets or sets the default comparison function used for sorting the immediate children of a vertex.
     *
     * The default comparer compares the LayoutVertex#node Text values.
     *
     * This sets the #rootDefaults' property of the same name.
     * Whether this comparison function is used is determined by the value of #sorting.
     * ```js
     *   $(go.TreeLayout,
     *     {
     *       sorting: go.TreeLayout.SortingAscending,
     *       comparer: (va, vb) => {
     *         var da = va.node.data;
     *         var db = vb.node.data;
     *         if (da.someProperty < db.someProperty) return -1;
     *         if (da.someProperty > db.someProperty) return 1;
     *         return 0;
     *       }
     *     }
     *   )
     * ```
     */
    get comparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  // Type InteropFunction#93411398(parent: InteropGetter#598874946(name: comparer), library: go.d.ts)
  set comparer(
      _i2.num Function(
        _i3.TreeVertex,
        _i3.TreeVertex,
      ) value) {
    _i5.setProperty(
      this,
      'comparer',
      _i5.allowInterop(value),
    );
  }

  /* #28686
  source: 
    /**
     * Gets or sets the default direction for tree growth.
     *
     * The default value is 0; the value must be one of: 0, 90, 180, 270.
     *
     * These values are in degrees, where 0 is along the positive X axis,
     * and where 90 is along the positive Y axis.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get angle(): number; */
  /// Gets or sets the default direction for tree growth.
  ///
  /// The default value is 0; the value must be one of: 0, 90, 180, 270.
  ///
  /// These values are in degrees, where 0 is along the positive X axis,
  /// and where 90 is along the positive Y axis.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get angle => _i5.getProperty(
        this,
        'angle',
      );
  /* #28686
  source: 
    /**
     * Gets or sets the default direction for tree growth.
     *
     * The default value is 0; the value must be one of: 0, 90, 180, 270.
     *
     * These values are in degrees, where 0 is along the positive X axis,
     * and where 90 is along the positive Y axis.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get angle(): number; */
  // Type InteropStaticType.number
  set angle(_i2.num value) {
    _i5.setProperty(
      this,
      'angle',
      value,
    );
  }

  /* #28696
  source: 
    /**
     * Gets or sets the default alignment of parents relative to their children.
     * Must be a static constant of TreeLayout whose name starts with "Alignment".
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get alignment(): EnumValue; */
  /// Gets or sets the default alignment of parents relative to their children.
  /// Must be a static constant of TreeLayout whose name starts with "Alignment".
  ///
  /// The default value is TreeLayout.AlignmentCenterChildren.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i3.EnumValue get alignment => _i5.getProperty(
        this,
        'alignment',
      );
  /* #28696
  source: 
    /**
     * Gets or sets the default alignment of parents relative to their children.
     * Must be a static constant of TreeLayout whose name starts with "Alignment".
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get alignment(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alignment(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alignment',
      value,
    );
  }

  /* #28712
  source: 
    /**
     * Gets or sets the default indentation of the first child.
     *
     * The default value is zero.  The value should be non-negative.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     * Having a positive value is useful if you want to reserve space
     * at the start of the row of children for some reason.
     * For example, if you want to pretend the parent node is infinitely deep,
     * you can set this to be the breadth of the parent node.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeIndent(): number; */
  /// Gets or sets the default indentation of the first child.
  ///
  /// The default value is zero.  The value should be non-negative.
  ///
  /// This property is only sensible when the #alignment
  /// is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
  /// Having a positive value is useful if you want to reserve space
  /// at the start of the row of children for some reason.
  /// For example, if you want to pretend the parent node is infinitely deep,
  /// you can set this to be the breadth of the parent node.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get nodeIndent => _i5.getProperty(
        this,
        'nodeIndent',
      );
  /* #28712
  source: 
    /**
     * Gets or sets the default indentation of the first child.
     *
     * The default value is zero.  The value should be non-negative.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     * Having a positive value is useful if you want to reserve space
     * at the start of the row of children for some reason.
     * For example, if you want to pretend the parent node is infinitely deep,
     * you can set this to be the breadth of the parent node.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeIndent(): number; */
  // Type InteropStaticType.number
  set nodeIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeIndent',
      value,
    );
  }

  /* #28726
  source: 
    /**
     * Gets or sets the fraction of this node's breadth is added to #nodeIndent
     * to determine any spacing at the start of the children.
     *
     * The default value is 0.0 -- the only indentation is specified by #nodeIndent.
     * When the value is 1.0, the children will be indented past the breadth of the parent node.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeIndentPastParent(): number; */
  /// Gets or sets the fraction of this node's breadth is added to #nodeIndent
  /// to determine any spacing at the start of the children.
  ///
  /// The default value is 0.0 -- the only indentation is specified by #nodeIndent.
  /// When the value is 1.0, the children will be indented past the breadth of the parent node.
  ///
  /// This property is only sensible when the #alignment
  /// is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get nodeIndentPastParent => _i5.getProperty(
        this,
        'nodeIndentPastParent',
      );
  /* #28726
  source: 
    /**
     * Gets or sets the fraction of this node's breadth is added to #nodeIndent
     * to determine any spacing at the start of the children.
     *
     * The default value is 0.0 -- the only indentation is specified by #nodeIndent.
     * When the value is 1.0, the children will be indented past the breadth of the parent node.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeIndentPastParent(): number; */
  // Type InteropStaticType.number
  set nodeIndentPastParent(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeIndentPastParent',
      value,
    );
  }

  /* #28739
  source: 
    /**
     * Gets or sets the distance between child nodes.
     *
     * This is the distance between sibling nodes.
     * A negative value causes sibling nodes to overlap.
     * The default value is 20.
     *
     * The #layerSpacing property determines the distance between a parent node and the layer of its children.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeSpacing(): number; */
  /// Gets or sets the distance between child nodes.
  ///
  /// This is the distance between sibling nodes.
  /// A negative value causes sibling nodes to overlap.
  /// The default value is 20.
  ///
  /// The #layerSpacing property determines the distance between a parent node and the layer of its children.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get nodeSpacing => _i5.getProperty(
        this,
        'nodeSpacing',
      );
  /* #28739
  source: 
    /**
     * Gets or sets the distance between child nodes.
     *
     * This is the distance between sibling nodes.
     * A negative value causes sibling nodes to overlap.
     * The default value is 20.
     *
     * The #layerSpacing property determines the distance between a parent node and the layer of its children.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get nodeSpacing(): number; */
  // Type InteropStaticType.number
  set nodeSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeSpacing',
      value,
    );
  }

  /* #28754
  source: 
    /**
     * Gets or sets the distance between a parent node and its children.
     *
     * This is the distance between a parent node and the layer of its children.
     * Negative values may cause children to overlap with the parent.
     * The default value is 50.
     *
     * The #nodeSpacing property determines the distance between siblings.
     * The #rowSpacing property determines the distance
     * between multiple rows or columns of children.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get layerSpacing(): number; */
  /// Gets or sets the distance between a parent node and its children.
  ///
  /// This is the distance between a parent node and the layer of its children.
  /// Negative values may cause children to overlap with the parent.
  /// The default value is 50.
  ///
  /// The #nodeSpacing property determines the distance between siblings.
  /// The #rowSpacing property determines the distance
  /// between multiple rows or columns of children.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get layerSpacing => _i5.getProperty(
        this,
        'layerSpacing',
      );
  /* #28754
  source: 
    /**
     * Gets or sets the distance between a parent node and its children.
     *
     * This is the distance between a parent node and the layer of its children.
     * Negative values may cause children to overlap with the parent.
     * The default value is 50.
     *
     * The #nodeSpacing property determines the distance between siblings.
     * The #rowSpacing property determines the distance
     * between multiple rows or columns of children.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get layerSpacing(): number; */
  // Type InteropStaticType.number
  set layerSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'layerSpacing',
      value,
    );
  }

  /* #28769
  source: 
    /**
     * Gets or sets the fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
     *
     * The default value is 0.0 -- there is overlap between layers only if #layerSpacing is negative.
     * A value of 1.0 and a zero #layerSpacing will cause child nodes to completely overlap the parent.
     *
     * A value greater than zero may still cause overlap between layers,
     * unless the value of #layerSpacing is large enough.
     * A value of zero might still allow overlap between layers,
     * if #layerSpacing is negative.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get layerSpacingParentOverlap(): number; */
  /// Gets or sets the fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
  ///
  /// The default value is 0.0 -- there is overlap between layers only if #layerSpacing is negative.
  /// A value of 1.0 and a zero #layerSpacing will cause child nodes to completely overlap the parent.
  ///
  /// A value greater than zero may still cause overlap between layers,
  /// unless the value of #layerSpacing is large enough.
  /// A value of zero might still allow overlap between layers,
  /// if #layerSpacing is negative.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get layerSpacingParentOverlap => _i5.getProperty(
        this,
        'layerSpacingParentOverlap',
      );
  /* #28769
  source: 
    /**
     * Gets or sets the fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
     *
     * The default value is 0.0 -- there is overlap between layers only if #layerSpacing is negative.
     * A value of 1.0 and a zero #layerSpacing will cause child nodes to completely overlap the parent.
     *
     * A value greater than zero may still cause overlap between layers,
     * unless the value of #layerSpacing is large enough.
     * A value of zero might still allow overlap between layers,
     * if #layerSpacing is negative.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get layerSpacingParentOverlap(): number; */
  // Type InteropStaticType.number
  set layerSpacingParentOverlap(_i2.num value) {
    _i5.setProperty(
      this,
      'layerSpacingParentOverlap',
      value,
    );
  }

  /* #28779
  source: 
    /**
     * Gets or sets how closely to pack the child nodes of a subtree.
     * Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
     *
     * The default value is TreeLayout.CompactionBlock|CompactionBlock.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get compaction(): EnumValue; */
  /// Gets or sets how closely to pack the child nodes of a subtree.
  /// Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
  ///
  /// The default value is TreeLayout.CompactionBlock|CompactionBlock.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i3.EnumValue get compaction => _i5.getProperty(
        this,
        'compaction',
      );
  /* #28779
  source: 
    /**
     * Gets or sets how closely to pack the child nodes of a subtree.
     * Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
     *
     * The default value is TreeLayout.CompactionBlock|CompactionBlock.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get compaction(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set compaction(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'compaction',
      value,
    );
  }

  /* #28805
  source: 
    /**
     * Gets or sets a limit on how broad a tree should be.
     *
     * A value of zero (the default) means there is no limit;
     * a positive value specifies a limit.
     * The default value is zero.
     *
     * This property is just a suggested constraint on how
     * broadly the tree will be laid out.
     * When there isn't enough breadth for all of the children of a node,
     *  the children are placed in as many rows as needed to try to stay
     * within the given breadth limit.
     * If the value is too small, since this layout algorithm
     * does not modify the size or shape of any node, the nodes will
     * just be laid out in a line, one per row, and the breadth is
     * determined by the broadest node.
     * The distance between rows is specified by #rowSpacing.
     * To make room for the links that go around earlier rows to get to
     * later rows, when the alignment is not a "center" alignment, the
     * #rowIndent property specifies that space at the
     * start of each row.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get breadthLimit(): number; */
  /// Gets or sets a limit on how broad a tree should be.
  ///
  /// A value of zero (the default) means there is no limit;
  /// a positive value specifies a limit.
  /// The default value is zero.
  ///
  /// This property is just a suggested constraint on how
  /// broadly the tree will be laid out.
  /// When there isn't enough breadth for all of the children of a node,
  ///  the children are placed in as many rows as needed to try to stay
  /// within the given breadth limit.
  /// If the value is too small, since this layout algorithm
  /// does not modify the size or shape of any node, the nodes will
  /// just be laid out in a line, one per row, and the breadth is
  /// determined by the broadest node.
  /// The distance between rows is specified by #rowSpacing.
  /// To make room for the links that go around earlier rows to get to
  /// later rows, when the alignment is not a "center" alignment, the
  /// #rowIndent property specifies that space at the
  /// start of each row.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get breadthLimit => _i5.getProperty(
        this,
        'breadthLimit',
      );
  /* #28805
  source: 
    /**
     * Gets or sets a limit on how broad a tree should be.
     *
     * A value of zero (the default) means there is no limit;
     * a positive value specifies a limit.
     * The default value is zero.
     *
     * This property is just a suggested constraint on how
     * broadly the tree will be laid out.
     * When there isn't enough breadth for all of the children of a node,
     *  the children are placed in as many rows as needed to try to stay
     * within the given breadth limit.
     * If the value is too small, since this layout algorithm
     * does not modify the size or shape of any node, the nodes will
     * just be laid out in a line, one per row, and the breadth is
     * determined by the broadest node.
     * The distance between rows is specified by #rowSpacing.
     * To make room for the links that go around earlier rows to get to
     * later rows, when the alignment is not a "center" alignment, the
     * #rowIndent property specifies that space at the
     * start of each row.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get breadthLimit(): number; */
  // Type InteropStaticType.number
  set breadthLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'breadthLimit',
      value,
    );
  }

  /* #28820
  source: 
    /**
     * Gets or sets the distance between rows or columns of a parent node's immediate children.
     *
     * The default value is 25.
     *
     * This property is only used when there is more than one
     * row of children for a given parent node.
     * The #nodeSpacing property determines the distance between siblings.
     * The #layerSpacing property determines the distance between
     * the parent node and its first row or column of child nodes.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get rowSpacing(): number; */
  /// Gets or sets the distance between rows or columns of a parent node's immediate children.
  ///
  /// The default value is 25.
  ///
  /// This property is only used when there is more than one
  /// row of children for a given parent node.
  /// The #nodeSpacing property determines the distance between siblings.
  /// The #layerSpacing property determines the distance between
  /// the parent node and its first row or column of child nodes.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get rowSpacing => _i5.getProperty(
        this,
        'rowSpacing',
      );
  /* #28820
  source: 
    /**
     * Gets or sets the distance between rows or columns of a parent node's immediate children.
     *
     * The default value is 25.
     *
     * This property is only used when there is more than one
     * row of children for a given parent node.
     * The #nodeSpacing property determines the distance between siblings.
     * The #layerSpacing property determines the distance between
     * the parent node and its first row or column of child nodes.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get rowSpacing(): number; */
  // Type InteropStaticType.number
  set rowSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'rowSpacing',
      value,
    );
  }

  /* #28833
  source: 
    /**
     * Gets or sets the default indentation of the first child of each row,
     * if the #alignment is not a "Center" alignment.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This is used to leave room for the links that connect a parent node
     * with the child nodes that are in additional rows.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get rowIndent(): number; */
  /// Gets or sets the default indentation of the first child of each row,
  /// if the #alignment is not a "Center" alignment.
  ///
  /// The default value is 10.  The value should be non-negative.
  ///
  /// This is used to leave room for the links that connect a parent node
  /// with the child nodes that are in additional rows.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get rowIndent => _i5.getProperty(
        this,
        'rowIndent',
      );
  /* #28833
  source: 
    /**
     * Gets or sets the default indentation of the first child of each row,
     * if the #alignment is not a "Center" alignment.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This is used to leave room for the links that connect a parent node
     * with the child nodes that are in additional rows.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get rowIndent(): number; */
  // Type InteropStaticType.number
  set rowIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'rowIndent',
      value,
    );
  }

  /* #28844
  source: 
    /**
     * Gets or sets the distance between comments.
     *
     * The default value is 10.
     *
     * This is used by #addComments and #layoutComments.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get commentSpacing(): number; */
  /// Gets or sets the distance between comments.
  ///
  /// The default value is 10.
  ///
  /// This is used by #addComments and #layoutComments.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get commentSpacing => _i5.getProperty(
        this,
        'commentSpacing',
      );
  /* #28844
  source: 
    /**
     * Gets or sets the distance between comments.
     *
     * The default value is 10.
     *
     * This is used by #addComments and #layoutComments.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get commentSpacing(): number; */
  // Type InteropStaticType.number
  set commentSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'commentSpacing',
      value,
    );
  }

  /* #28855
  source: 
    /**
     * Gets or sets the distance between a node and its comments.
     *
     * The default value is 20.
     *
     * This is used by #addComments and #layoutComments.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get commentMargin(): number; */
  /// Gets or sets the distance between a node and its comments.
  ///
  /// The default value is 20.
  ///
  /// This is used by #addComments and #layoutComments.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.num get commentMargin => _i5.getProperty(
        this,
        'commentMargin',
      );
  /* #28855
  source: 
    /**
     * Gets or sets the distance between a node and its comments.
     *
     * The default value is 20.
     *
     * This is used by #addComments and #layoutComments.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get commentMargin(): number; */
  // Type InteropStaticType.number
  set commentMargin(_i2.num value) {
    _i5.setProperty(
      this,
      'commentMargin',
      value,
    );
  }

  /* #28868
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #portSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get setsPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the
  /// FromSpot for this parent node port.
  ///
  /// The default value is true -- this may modify the spot of the port of this node, the parent,
  /// if the node has only a single port.
  ///
  /// The spot used depends on the value of #portSpot.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.bool get setsPortSpot => _i5.getProperty(
        this,
        'setsPortSpot',
      );
  /* #28868
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #portSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get setsPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set setsPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsPortSpot',
      value,
    );
  }

  /* #28883
  source: 
    /**
     * Gets or sets the spot that this node's port gets as its FromSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's ToSpot is set instead of the FromSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get portSpot(): Spot; */
  /// Gets or sets the spot that this node's port gets as its FromSpot.
  ///
  /// The default value is Spot.Default.
  ///
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a FromSpot based on the parent node's TreeVertex#angle.
  /// If the value is other than NoSpot, it is just assigned.
  /// When #path is TreeLayout.PathSource|PathSource,
  /// the port's ToSpot is set instead of the FromSpot.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i3.Spot get portSpot => _i5.getProperty(
        this,
        'portSpot',
      );
  /* #28883
  source: 
    /**
     * Gets or sets the spot that this node's port gets as its FromSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's ToSpot is set instead of the FromSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get portSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set portSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'portSpot',
      value,
    );
  }

  /* #28896
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spot of the ports of the children nodes,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #childPortSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get setsChildPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the
  /// ToSpot for each child node port.
  ///
  /// The default value is true -- this may modify the spot of the ports of the children nodes,
  /// if the node has only a single port.
  ///
  /// The spot used depends on the value of #childPortSpot.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i2.bool get setsChildPortSpot => _i5.getProperty(
        this,
        'setsChildPortSpot',
      );
  /* #28896
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spot of the ports of the children nodes,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #childPortSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get setsChildPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set setsChildPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsChildPortSpot',
      value,
    );
  }

  /* #28911
  source: 
    /**
     * Gets or sets the spot that children nodes' ports get as their ToSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's FromSpot is set instead of the ToSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get childPortSpot(): Spot; */
  /// Gets or sets the spot that children nodes' ports get as their ToSpot.
  ///
  /// The default value is Spot.Default.
  ///
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a ToSpot based on the parent node's TreeVertex#angle.
  /// If the value is other than NoSpot, it is just assigned.
  /// When #path is TreeLayout.PathSource|PathSource,
  /// the port's FromSpot is set instead of the ToSpot.
  ///
  /// This sets the #rootDefaults' property of the same name.
  _i3.Spot get childPortSpot => _i5.getProperty(
        this,
        'childPortSpot',
      );
  /* #28911
  source: 
    /**
     * Gets or sets the spot that children nodes' ports get as their ToSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's FromSpot is set instead of the ToSpot.
     *
     * This sets the #rootDefaults' property of the same name.
     */
    get childPortSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set childPortSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'childPortSpot',
      value,
    );
  }

  /* #28923
  source: 
    /**
     * Gets or sets the alternate sorting policy for ordering the immediate children of a vertex.
     * Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
     * TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
     *
     * The default value is TreeLayout.SortingForwards|SortingForwards.
     *
     * This sets the #alternateDefaults' property of the same name.
     * The sort order is determined by #alternateComparer.
     */
    get alternateSorting(): EnumValue; */
  /// Gets or sets the alternate sorting policy for ordering the immediate children of a vertex.
  /// Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
  /// TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
  ///
  /// The default value is TreeLayout.SortingForwards|SortingForwards.
  ///
  /// This sets the #alternateDefaults' property of the same name.
  /// The sort order is determined by #alternateComparer.
  _i3.EnumValue get alternateSorting => _i5.getProperty(
        this,
        'alternateSorting',
      );
  /* #28923
  source: 
    /**
     * Gets or sets the alternate sorting policy for ordering the immediate children of a vertex.
     * Must be TreeLayout.SortingForwards, TreeLayout.SortingReverse,
     * TreeLayout.SortingAscending, or TreeLayout.SortingDescending.
     *
     * The default value is TreeLayout.SortingForwards|SortingForwards.
     *
     * This sets the #alternateDefaults' property of the same name.
     * The sort order is determined by #alternateComparer.
     */
    get alternateSorting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alternateSorting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alternateSorting',
      value,
    );
  }

  /* #28933
  source: 
    /**
     * Gets or sets the alternate comparison function used for sorting the immediate children of a vertex.
     *
     * The default comparer compares the LayoutVertex#node Text values.
     *
     * This sets the #alternateDefaults' property of the same name.
     * Whether this comparison function is used is determined by the value of #alternateSorting.
     */
    get alternateComparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  /// Gets or sets the alternate comparison function used for sorting the immediate children of a vertex.
  ///
  /// The default comparer compares the LayoutVertex#node Text values.
  ///
  /// This sets the #alternateDefaults' property of the same name.
  /// Whether this comparison function is used is determined by the value of #alternateSorting.
  _i2.num Function(
    _i3.TreeVertex,
    _i3.TreeVertex,
  ) get alternateComparer => _i5.getProperty(
        this,
        'alternateComparer',
      );
  /* #28933
  source: 
    /**
     * Gets or sets the alternate comparison function used for sorting the immediate children of a vertex.
     *
     * The default comparer compares the LayoutVertex#node Text values.
     *
     * This sets the #alternateDefaults' property of the same name.
     * Whether this comparison function is used is determined by the value of #alternateSorting.
     */
    get alternateComparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  // Type InteropFunction#469877567(parent: InteropGetter#1029811579(name: alternateComparer), library: go.d.ts)
  set alternateComparer(
      _i2.num Function(
        _i3.TreeVertex,
        _i3.TreeVertex,
      ) value) {
    _i5.setProperty(
      this,
      'alternateComparer',
      _i5.allowInterop(value),
    );
  }

  /* #28944
  source: 
    /**
     * Gets or sets the alternate direction for tree growth.
     *
     * The default value is 0; the value must be one of: 0, 90, 180, 270.
     *
     * These values are in degrees, where 0 is along the positive X axis,
     * and where 90 is along the positive Y axis.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateAngle(): number; */
  /// Gets or sets the alternate direction for tree growth.
  ///
  /// The default value is 0; the value must be one of: 0, 90, 180, 270.
  ///
  /// These values are in degrees, where 0 is along the positive X axis,
  /// and where 90 is along the positive Y axis.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateAngle => _i5.getProperty(
        this,
        'alternateAngle',
      );
  /* #28944
  source: 
    /**
     * Gets or sets the alternate direction for tree growth.
     *
     * The default value is 0; the value must be one of: 0, 90, 180, 270.
     *
     * These values are in degrees, where 0 is along the positive X axis,
     * and where 90 is along the positive Y axis.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateAngle(): number; */
  // Type InteropStaticType.number
  set alternateAngle(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateAngle',
      value,
    );
  }

  /* #28954
  source: 
    /**
     * Gets or sets the alternate alignment of parents relative to their children.
     * Must be a static constant of TreeLayout whose name starts with "Alignment".
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateAlignment(): EnumValue; */
  /// Gets or sets the alternate alignment of parents relative to their children.
  /// Must be a static constant of TreeLayout whose name starts with "Alignment".
  ///
  /// The default value is TreeLayout.AlignmentCenterChildren.
  ///
  /// This sets the #alternateDefaults' property of the same name.
  _i3.EnumValue get alternateAlignment => _i5.getProperty(
        this,
        'alternateAlignment',
      );
  /* #28954
  source: 
    /**
     * Gets or sets the alternate alignment of parents relative to their children.
     * Must be a static constant of TreeLayout whose name starts with "Alignment".
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateAlignment(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alternateAlignment(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alternateAlignment',
      value,
    );
  }

  /* #28969
  source: 
    /**
     * Gets or sets the alternate indentation of the first child.
     *
     * The default value is zero.  The value should be non-negative.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     * Having a positive value is useful if you want to reserve space
     * at the start of the row of children for some reason.
     * For example, if you want to pretend the parent node is infinitely deep,
     * you can set this to be the breadth of the parent node.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateNodeIndent(): number; */
  /// Gets or sets the alternate indentation of the first child.
  ///
  /// The default value is zero.  The value should be non-negative.
  ///
  /// This property is only sensible when the #alignment
  /// is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
  /// Having a positive value is useful if you want to reserve space
  /// at the start of the row of children for some reason.
  /// For example, if you want to pretend the parent node is infinitely deep,
  /// you can set this to be the breadth of the parent node.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateNodeIndent => _i5.getProperty(
        this,
        'alternateNodeIndent',
      );
  /* #28969
  source: 
    /**
     * Gets or sets the alternate indentation of the first child.
     *
     * The default value is zero.  The value should be non-negative.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     * Having a positive value is useful if you want to reserve space
     * at the start of the row of children for some reason.
     * For example, if you want to pretend the parent node is infinitely deep,
     * you can set this to be the breadth of the parent node.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateNodeIndent(): number; */
  // Type InteropStaticType.number
  set alternateNodeIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateNodeIndent',
      value,
    );
  }

  /* #28981
  source: 
    /**
     * Gets or sets the fraction of this node's breadth is added to #alternateNodeIndent
     * to determine any spacing at the start of the children.
     *
     * The default value is 0.0 -- the only indentation is specified by #alternateNodeIndent.
     * When the value is 1.0, the children will be indented past the breadth of the parent node.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     */
    get alternateNodeIndentPastParent(): number; */
  /// Gets or sets the fraction of this node's breadth is added to #alternateNodeIndent
  /// to determine any spacing at the start of the children.
  ///
  /// The default value is 0.0 -- the only indentation is specified by #alternateNodeIndent.
  /// When the value is 1.0, the children will be indented past the breadth of the parent node.
  ///
  /// This property is only sensible when the #alignment
  /// is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
  _i2.num get alternateNodeIndentPastParent => _i5.getProperty(
        this,
        'alternateNodeIndentPastParent',
      );
  /* #28981
  source: 
    /**
     * Gets or sets the fraction of this node's breadth is added to #alternateNodeIndent
     * to determine any spacing at the start of the children.
     *
     * The default value is 0.0 -- the only indentation is specified by #alternateNodeIndent.
     * When the value is 1.0, the children will be indented past the breadth of the parent node.
     *
     * This property is only sensible when the #alignment
     * is TreeLayout.AlignmentStart|AlignmentStart or TreeLayout.AlignmentEnd|AlignmentEnd.
     */
    get alternateNodeIndentPastParent(): number; */
  // Type InteropStaticType.number
  set alternateNodeIndentPastParent(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateNodeIndentPastParent',
      value,
    );
  }

  /* #28991
  source: 
    /**
     * Gets or sets the alternate distance between child nodes.
     *
     * The default value is 20.
     *
     * A negative value causes sibling nodes to overlap.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateNodeSpacing(): number; */
  /// Gets or sets the alternate distance between child nodes.
  ///
  /// The default value is 20.
  ///
  /// A negative value causes sibling nodes to overlap.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateNodeSpacing => _i5.getProperty(
        this,
        'alternateNodeSpacing',
      );
  /* #28991
  source: 
    /**
     * Gets or sets the alternate distance between child nodes.
     *
     * The default value is 20.
     *
     * A negative value causes sibling nodes to overlap.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateNodeSpacing(): number; */
  // Type InteropStaticType.number
  set alternateNodeSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateNodeSpacing',
      value,
    );
  }

  /* #29006
  source: 
    /**
     * Gets or sets the alternate distance between a parent node and its children.
     *
     * The default value is 50.
     *
     * This is the distance between a parent node and its first row
     * of children, in case there are multiple rows of its children.
     * The #alternateNodeSpacing property determines the distance between siblings.
     * The #alternateRowSpacing property determines the distance
     * between rows of children.
     * Negative values may cause children to overlap with the parent.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateLayerSpacing(): number; */
  /// Gets or sets the alternate distance between a parent node and its children.
  ///
  /// The default value is 50.
  ///
  /// This is the distance between a parent node and its first row
  /// of children, in case there are multiple rows of its children.
  /// The #alternateNodeSpacing property determines the distance between siblings.
  /// The #alternateRowSpacing property determines the distance
  /// between rows of children.
  /// Negative values may cause children to overlap with the parent.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateLayerSpacing => _i5.getProperty(
        this,
        'alternateLayerSpacing',
      );
  /* #29006
  source: 
    /**
     * Gets or sets the alternate distance between a parent node and its children.
     *
     * The default value is 50.
     *
     * This is the distance between a parent node and its first row
     * of children, in case there are multiple rows of its children.
     * The #alternateNodeSpacing property determines the distance between siblings.
     * The #alternateRowSpacing property determines the distance
     * between rows of children.
     * Negative values may cause children to overlap with the parent.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateLayerSpacing(): number; */
  // Type InteropStaticType.number
  set alternateLayerSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateLayerSpacing',
      value,
    );
  }

  /* #29020
  source: 
    /**
     * Gets or sets the alternate fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
     *
     * The default value is 0.0 -- there is overlap between layers only if #alternateLayerSpacing is negative.
     * A value of 1.0 and a zero #alternateLayerSpacing will cause child nodes to completely overlap the parent.
     *
     * A value greater than zero may still cause overlap between layers,
     * unless the value of #alternateLayerSpacing is large enough.
     * A value of zero might still allow overlap between layers,
     * if #alternateLayerSpacing is negative.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateLayerSpacingParentOverlap(): number; */
  /// Gets or sets the alternate fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
  ///
  /// The default value is 0.0 -- there is overlap between layers only if #alternateLayerSpacing is negative.
  /// A value of 1.0 and a zero #alternateLayerSpacing will cause child nodes to completely overlap the parent.
  ///
  /// A value greater than zero may still cause overlap between layers,
  /// unless the value of #alternateLayerSpacing is large enough.
  /// A value of zero might still allow overlap between layers,
  /// if #alternateLayerSpacing is negative.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateLayerSpacingParentOverlap => _i5.getProperty(
        this,
        'alternateLayerSpacingParentOverlap',
      );
  /* #29020
  source: 
    /**
     * Gets or sets the alternate fraction of the node's depth for which the children's layer starts overlapped with the parent's layer.
     *
     * The default value is 0.0 -- there is overlap between layers only if #alternateLayerSpacing is negative.
     * A value of 1.0 and a zero #alternateLayerSpacing will cause child nodes to completely overlap the parent.
     *
     * A value greater than zero may still cause overlap between layers,
     * unless the value of #alternateLayerSpacing is large enough.
     * A value of zero might still allow overlap between layers,
     * if #alternateLayerSpacing is negative.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateLayerSpacingParentOverlap(): number; */
  // Type InteropStaticType.number
  set alternateLayerSpacingParentOverlap(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateLayerSpacingParentOverlap',
      value,
    );
  }

  /* #29030
  source: 
    /**
     * Gets or sets how closely to pack the child nodes of a subtree.
     * Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
     *
     * The default value is TreeLayout.CompactionBlock.
     *
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCompaction(): EnumValue; */
  /// Gets or sets how closely to pack the child nodes of a subtree.
  /// Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
  ///
  /// The default value is TreeLayout.CompactionBlock.
  ///
  /// This sets the #alternateDefaults' property of the same name.
  _i3.EnumValue get alternateCompaction => _i5.getProperty(
        this,
        'alternateCompaction',
      );
  /* #29030
  source: 
    /**
     * Gets or sets how closely to pack the child nodes of a subtree.
     * Must be either TreeLayout.CompactionBlock or TreeLayout.CompactionNone.
     *
     * The default value is TreeLayout.CompactionBlock.
     *
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCompaction(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alternateCompaction(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alternateCompaction',
      value,
    );
  }

  /* #29055
  source: 
    /**
     * Gets or sets an alternate limit on how broad a tree should be.
     *
     * A value of zero (the default) means there is no limit;
     * a positive value specifies a limit.
     * The default value is zero.
     *
     * This property is just a suggested constraint on how
     * broadly the tree will be laid out.
     * When there isn't enough breadth for all of the children of a node,
     *  the children are placed in as many rows as needed to try to stay
     * within the given breadth limit.
     * If the value is too small, since this layout algorithm
     * does not modify the size or shape of any node, the nodes will
     * just be laid out in a line, one per row, and the breadth is
     * determined by the broadest node.
     * The distance between rows is specified by #alternateRowSpacing.
     * To make room for the links that go around earlier rows to get to
     * later rows, when the alignment is not a "center" alignment, the
     * #alternateRowIndent property specifies that space at the
     * start of each row.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateBreadthLimit(): number; */
  /// Gets or sets an alternate limit on how broad a tree should be.
  ///
  /// A value of zero (the default) means there is no limit;
  /// a positive value specifies a limit.
  /// The default value is zero.
  ///
  /// This property is just a suggested constraint on how
  /// broadly the tree will be laid out.
  /// When there isn't enough breadth for all of the children of a node,
  ///  the children are placed in as many rows as needed to try to stay
  /// within the given breadth limit.
  /// If the value is too small, since this layout algorithm
  /// does not modify the size or shape of any node, the nodes will
  /// just be laid out in a line, one per row, and the breadth is
  /// determined by the broadest node.
  /// The distance between rows is specified by #alternateRowSpacing.
  /// To make room for the links that go around earlier rows to get to
  /// later rows, when the alignment is not a "center" alignment, the
  /// #alternateRowIndent property specifies that space at the
  /// start of each row.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateBreadthLimit => _i5.getProperty(
        this,
        'alternateBreadthLimit',
      );
  /* #29055
  source: 
    /**
     * Gets or sets an alternate limit on how broad a tree should be.
     *
     * A value of zero (the default) means there is no limit;
     * a positive value specifies a limit.
     * The default value is zero.
     *
     * This property is just a suggested constraint on how
     * broadly the tree will be laid out.
     * When there isn't enough breadth for all of the children of a node,
     *  the children are placed in as many rows as needed to try to stay
     * within the given breadth limit.
     * If the value is too small, since this layout algorithm
     * does not modify the size or shape of any node, the nodes will
     * just be laid out in a line, one per row, and the breadth is
     * determined by the broadest node.
     * The distance between rows is specified by #alternateRowSpacing.
     * To make room for the links that go around earlier rows to get to
     * later rows, when the alignment is not a "center" alignment, the
     * #alternateRowIndent property specifies that space at the
     * start of each row.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateBreadthLimit(): number; */
  // Type InteropStaticType.number
  set alternateBreadthLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateBreadthLimit',
      value,
    );
  }

  /* #29068
  source: 
    /**
     * Gets or sets the alternate distance between rows of children.
     *
     * The default value is 25.
     *
     * This property is only used when there is more than one
     * row of children for a given parent node.
     * The #alternateLayerSpacing property determines the distance between
     * the parent node and its first row of child nodes.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateRowSpacing(): number; */
  /// Gets or sets the alternate distance between rows of children.
  ///
  /// The default value is 25.
  ///
  /// This property is only used when there is more than one
  /// row of children for a given parent node.
  /// The #alternateLayerSpacing property determines the distance between
  /// the parent node and its first row of child nodes.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateRowSpacing => _i5.getProperty(
        this,
        'alternateRowSpacing',
      );
  /* #29068
  source: 
    /**
     * Gets or sets the alternate distance between rows of children.
     *
     * The default value is 25.
     *
     * This property is only used when there is more than one
     * row of children for a given parent node.
     * The #alternateLayerSpacing property determines the distance between
     * the parent node and its first row of child nodes.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateRowSpacing(): number; */
  // Type InteropStaticType.number
  set alternateRowSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateRowSpacing',
      value,
    );
  }

  /* #29080
  source: 
    /**
     * Gets or sets the alternate indentation of the first child of each row,
     * if the #alignment is not a "Center" alignment.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This is used to leave room for the links that connect a parent node
     * with the child nodes that are in additional rows.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateRowIndent(): number; */
  /// Gets or sets the alternate indentation of the first child of each row,
  /// if the #alignment is not a "Center" alignment.
  ///
  /// The default value is 10.  The value should be non-negative.
  ///
  /// This is used to leave room for the links that connect a parent node
  /// with the child nodes that are in additional rows.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateRowIndent => _i5.getProperty(
        this,
        'alternateRowIndent',
      );
  /* #29080
  source: 
    /**
     * Gets or sets the alternate indentation of the first child of each row,
     * if the #alignment is not a "Center" alignment.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This is used to leave room for the links that connect a parent node
     * with the child nodes that are in additional rows.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateRowIndent(): number; */
  // Type InteropStaticType.number
  set alternateRowIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateRowIndent',
      value,
    );
  }

  /* #29090
  source: 
    /**
     * Gets or sets the alternate distance between comments.
     *
     * The default value is 10.
     *
     * This is used by #addComments and #layoutComments.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCommentSpacing(): number; */
  /// Gets or sets the alternate distance between comments.
  ///
  /// The default value is 10.
  ///
  /// This is used by #addComments and #layoutComments.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateCommentSpacing => _i5.getProperty(
        this,
        'alternateCommentSpacing',
      );
  /* #29090
  source: 
    /**
     * Gets or sets the alternate distance between comments.
     *
     * The default value is 10.
     *
     * This is used by #addComments and #layoutComments.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCommentSpacing(): number; */
  // Type InteropStaticType.number
  set alternateCommentSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateCommentSpacing',
      value,
    );
  }

  /* #29100
  source: 
    /**
     * Gets or sets the alternate distance between a node and its comments.
     *
     * The default value is 20.
     *
     * This is used by #addComments and #layoutComments.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCommentMargin(): number; */
  /// Gets or sets the alternate distance between a node and its comments.
  ///
  /// The default value is 20.
  ///
  /// This is used by #addComments and #layoutComments.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.num get alternateCommentMargin => _i5.getProperty(
        this,
        'alternateCommentMargin',
      );
  /* #29100
  source: 
    /**
     * Gets or sets the alternate distance between a node and its comments.
     *
     * The default value is 20.
     *
     * This is used by #addComments and #layoutComments.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateCommentMargin(): number; */
  // Type InteropStaticType.number
  set alternateCommentMargin(_i2.num value) {
    _i5.setProperty(
      this,
      'alternateCommentMargin',
      value,
    );
  }

  /* #29112
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #alternatePortSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateSetsPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the
  /// FromSpot for this parent node port.
  ///
  /// The default value is true -- this may modify the spot of the port of this node, the parent,
  /// if the node has only a single port.
  ///
  /// The spot used depends on the value of #alternatePortSpot.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.bool get alternateSetsPortSpot => _i5.getProperty(
        this,
        'alternateSetsPortSpot',
      );
  /* #29112
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #alternatePortSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateSetsPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set alternateSetsPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'alternateSetsPortSpot',
      value,
    );
  }

  /* #29126
  source: 
    /**
     * Gets or sets the alternate spot that this node's port gets as its FromSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's ToSpot is set instead of the FromSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternatePortSpot(): Spot; */
  /// Gets or sets the alternate spot that this node's port gets as its FromSpot.
  ///
  /// The default value is Spot.Default.
  ///
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a FromSpot based on the parent node's TreeVertex#angle.
  /// If the value is other than NoSpot, it is just assigned.
  /// When #path is TreeLayout.PathSource|PathSource,
  /// the port's ToSpot is set instead of the FromSpot.
  /// This sets the #alternateDefaults' property of the same name.
  _i3.Spot get alternatePortSpot => _i5.getProperty(
        this,
        'alternatePortSpot',
      );
  /* #29126
  source: 
    /**
     * Gets or sets the alternate spot that this node's port gets as its FromSpot.
     *
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's ToSpot is set instead of the FromSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternatePortSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set alternatePortSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'alternatePortSpot',
      value,
    );
  }

  /* #29138
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spot of the ports of the children nodes,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #alternateChildPortSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateSetsChildPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the
  /// ToSpot for each child node port.
  ///
  /// The default value is true -- this may modify the spot of the ports of the children nodes,
  /// if the node has only a single port.
  ///
  /// The spot used depends on the value of #alternateChildPortSpot.
  /// This sets the #alternateDefaults' property of the same name.
  _i2.bool get alternateSetsChildPortSpot => _i5.getProperty(
        this,
        'alternateSetsChildPortSpot',
      );
  /* #29138
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the
     * ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spot of the ports of the children nodes,
     * if the node has only a single port.
     *
     * The spot used depends on the value of #alternateChildPortSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateSetsChildPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set alternateSetsChildPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'alternateSetsChildPortSpot',
      value,
    );
  }

  /* #29152
  source: 
    /**
     * Gets or sets the alternate spot that children nodes' ports get as their ToSpot
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     *
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's FromSpot is set instead of the ToSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateChildPortSpot(): Spot; */
  /// Gets or sets the alternate spot that children nodes' ports get as their ToSpot
  /// The default value is Spot.Default.
  ///
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a ToSpot based on the parent node's TreeVertex#angle.
  ///
  /// If the value is other than NoSpot, it is just assigned.
  /// When #path is TreeLayout.PathSource|PathSource,
  /// the port's FromSpot is set instead of the ToSpot.
  /// This sets the #alternateDefaults' property of the same name.
  _i3.Spot get alternateChildPortSpot => _i5.getProperty(
        this,
        'alternateChildPortSpot',
      );
  /* #29152
  source: 
    /**
     * Gets or sets the alternate spot that children nodes' ports get as their ToSpot
     * The default value is Spot.Default.
     *
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     *
     * If the value is other than NoSpot, it is just assigned.
     * When #path is TreeLayout.PathSource|PathSource,
     * the port's FromSpot is set instead of the ToSpot.
     * This sets the #alternateDefaults' property of the same name.
     */
    get alternateChildPortSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set alternateChildPortSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'alternateChildPortSpot',
      value,
    );
  }

  _i3.TreeNetwork createNetwork() => _i5.callMethod(
        this,
        'createNetwork',
        [],
      );
  _i3.LayoutNetwork makeNetwork(_i2.Object coll) => _i5.callMethod(
        this,
        'makeNetwork',
        [coll],
      );
  void doLayout(_i2.Object coll) {
    _i5.callMethod(
      this,
      'doLayout',
      [coll],
    );
  }

  void initializeTreeVertexValues(_i3.TreeVertex v) {
    _i5.callMethod(
      this,
      'initializeTreeVertexValues',
      [v],
    );
  }

  void assignTreeVertexValues(_i3.TreeVertex v) {
    _i5.callMethod(
      this,
      'assignTreeVertexValues',
      [v],
    );
  }

  void addComments(_i3.TreeVertex v) {
    _i5.callMethod(
      this,
      'addComments',
      [v],
    );
  }

  void layoutComments(_i3.TreeVertex v) {
    _i5.callMethod(
      this,
      'layoutComments',
      [v],
    );
  }

  _i4.Array customAlignment(
    _i3.TreeVertex v,
    _i2.num offx,
    _i2.num offy,
    _i2.num subw,
    _i2.num subh,
  ) =>
      _i5.callMethod(
        this,
        'customAlignment',
        [
          v,
          offx,
          offy,
          subw,
          subh,
        ],
      );
  _i2.num computeBusNodeSpacing(_i3.TreeVertex child) => _i5.callMethod(
        this,
        'computeBusNodeSpacing',
        [child],
      );
  _i2.num computeBusLastRowSpacing(
    _i3.TreeVertex lastchild,
    _i2.num dist,
  ) =>
      _i5.callMethod(
        this,
        'computeBusLastRowSpacing',
        [
          lastchild,
          dist,
        ],
      );
  void arrangeTrees() {
    _i5.callMethod(
      this,
      'arrangeTrees',
      [],
    );
  }

  void commitLayout() {
    _i5.callMethod(
      this,
      'commitLayout',
      [],
    );
  }

  void commitNodes() {
    _i5.callMethod(
      this,
      'commitNodes',
      [],
    );
  }

  void commitLayers(
    _i4.Array layerRects,
    _i3.Point offset,
  ) {
    _i5.callMethod(
      this,
      'commitLayers',
      [
        layerRects,
        offset,
      ],
    );
  }

  void commitLinks() {
    _i5.callMethod(
      this,
      'commitLinks',
      [],
    );
  }

  _i2.num computeLayerSpacing(_i3.TreeVertex v) => _i5.callMethod(
        this,
        'computeLayerSpacing',
        [v],
      );
  _i2.num computeNodeIndent(_i3.TreeVertex v) => _i5.callMethod(
        this,
        'computeNodeIndent',
        [v],
      );
}

@_i1.JS()
@_i1.staticInterop
class TreeNetwork implements _i3.LayoutNetwork {
  factory TreeNetwork(_i3.TreeLayout layout) => _i5.callConstructor(
        _declaredTreeNetwork,
        [layout],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('TreeNetwork')
external _i2.Object _declaredTreeNetwork;

@_i1.JS()
@_i1.staticInterop
class TreeVertex implements _i3.LayoutVertex {
  factory TreeVertex(_i3.TreeNetwork network) => _i5.callConstructor(
        _declaredTreeVertex,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('TreeVertex')
external _i2.Object _declaredTreeVertex;

extension TreeVertex$Typings on TreeVertex {
  /* #29428
  source: 
    /**
     * Gets or sets whether this node has been initialized as part of TreeLayout#doLayout when building the tree structures.
     *
     * The default value is false.
     */
    get initialized(): boolean; */
  /// Gets or sets whether this node has been initialized as part of TreeLayout#doLayout when building the tree structures.
  ///
  /// The default value is false.
  _i2.bool get initialized => _i5.getProperty(
        this,
        'initialized',
      );
  /* #29428
  source: 
    /**
     * Gets or sets whether this node has been initialized as part of TreeLayout#doLayout when building the tree structures.
     *
     * The default value is false.
     */
    get initialized(): boolean; */
  // Type InteropStaticType.boolean
  set initialized(_i2.bool value) {
    _i5.setProperty(
      this,
      'initialized',
      value,
    );
  }

  /* #29438
  source: 
    /**
     * Gets or sets the logical parent for this node.
     *
     * The default value is null.
     *
     * This structural property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get parent(): TreeVertex; */
  /// Gets or sets the logical parent for this node.
  ///
  /// The default value is null.
  ///
  /// This structural property is computed in TreeLayout#doLayout when building the tree structures.
  /// You should probably not be setting this property.
  _i3.TreeVertex get parent => _i5.getProperty(
        this,
        'parent',
      );
  /* #29438
  source: 
    /**
     * Gets or sets the logical parent for this node.
     *
     * The default value is null.
     *
     * This structural property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get parent(): TreeVertex; */
  // Type Instance of 'InteropInterface'
  set parent(_i3.TreeVertex value) {
    _i5.setProperty(
      this,
      'parent',
      value,
    );
  }

  /* #29448
  source: 
    /**
     * Gets or sets the logical children for this node.
     *
     * The default value is an empty array.
     *
     * This structural property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get children(): Array<TreeVertex>; */
  /// Gets or sets the logical children for this node.
  ///
  /// The default value is an empty array.
  ///
  /// This structural property is computed in TreeLayout#doLayout when building the tree structures.
  /// You should probably not be setting this property.
  _i4.Array get children => _i5.getProperty(
        this,
        'children',
      );
  /* #29448
  source: 
    /**
     * Gets or sets the logical children for this node.
     *
     * The default value is an empty array.
     *
     * This structural property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get children(): Array<TreeVertex>; */
  // Type Instance of 'ExternalInteropType'
  set children(_i4.Array value) {
    _i5.setProperty(
      this,
      'children',
      value,
    );
  }

  /* #29459
  source: 
    /**
     * Gets or sets the number of single-parent ancestors this node has.
     *
     * This could also be interpreted as which layer this node is in.
     * A root node will have a value of zero.
     *
     * This informational property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get level(): number; */
  /// Gets or sets the number of single-parent ancestors this node has.
  ///
  /// This could also be interpreted as which layer this node is in.
  /// A root node will have a value of zero.
  ///
  /// This informational property is computed in TreeLayout#doLayout when building the tree structures.
  /// You should probably not be setting this property.
  _i2.num get level => _i5.getProperty(
        this,
        'level',
      );
  /* #29459
  source: 
    /**
     * Gets or sets the number of single-parent ancestors this node has.
     *
     * This could also be interpreted as which layer this node is in.
     * A root node will have a value of zero.
     *
     * This informational property is computed in TreeLayout#doLayout when building the tree structures.
     * You should probably not be setting this property.
     */
    get level(): number; */
  // Type InteropStaticType.number
  set level(_i2.num value) {
    _i5.setProperty(
      this,
      'level',
      value,
    );
  }

  /* #29469
  source: 
    /**
     * Gets or sets the number of descendants this node has.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this property.
     */
    get descendantCount(): number; */
  /// Gets or sets the number of descendants this node has.
  ///
  /// For a leaf node, this will be zero.
  ///
  /// This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
  /// You should probably not be setting this property.
  _i2.num get descendantCount => _i5.getProperty(
        this,
        'descendantCount',
      );
  /* #29469
  source: 
    /**
     * Gets or sets the number of descendants this node has.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this property.
     */
    get descendantCount(): number; */
  // Type InteropStaticType.number
  set descendantCount(_i2.num value) {
    _i5.setProperty(
      this,
      'descendantCount',
      value,
    );
  }

  /* #29479
  source: 
    /**
     * Gets or sets the maximum number of children of any descendant of this node.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this property.
     */
    get maxChildrenCount(): number; */
  /// Gets or sets the maximum number of children of any descendant of this node.
  ///
  /// For a leaf node, this will be zero.
  ///
  /// This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
  /// You should probably not be setting this property.
  _i2.num get maxChildrenCount => _i5.getProperty(
        this,
        'maxChildrenCount',
      );
  /* #29479
  source: 
    /**
     * Gets or sets the maximum number of children of any descendant of this node.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this property.
     */
    get maxChildrenCount(): number; */
  // Type InteropStaticType.number
  set maxChildrenCount(_i2.num value) {
    _i5.setProperty(
      this,
      'maxChildrenCount',
      value,
    );
  }

  /* #29489
  source: 
    /**
     * Gets or sets the maximum depth of the subtrees below this node.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this value.
     */
    get maxGenerationCount(): number; */
  /// Gets or sets the maximum depth of the subtrees below this node.
  ///
  /// For a leaf node, this will be zero.
  ///
  /// This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
  /// You should probably not be setting this value.
  _i2.num get maxGenerationCount => _i5.getProperty(
        this,
        'maxGenerationCount',
      );
  /* #29489
  source: 
    /**
     * Gets or sets the maximum depth of the subtrees below this node.
     *
     * For a leaf node, this will be zero.
     *
     * This informational property is computed as part of the TreeLayout#initializeTreeVertexValues pass.
     * You should probably not be setting this value.
     */
    get maxGenerationCount(): number; */
  // Type InteropStaticType.number
  set maxGenerationCount(_i2.num value) {
    _i5.setProperty(
      this,
      'maxGenerationCount',
      value,
    );
  }

  /* #29500
  source: 
    /**
     * Gets or sets an array of Nodes that will be positioned near this node.
     *
     * The default value is null.
     *
     * These objects should not have their own TreeVertexes to be laid out.
     * Typically these will be Nodes whose Category is "Comment".
     * This array should be allocated and initialized in TreeLayout#addComments.
     */
    get comments(): Array<Node>; */
  /// Gets or sets an array of Nodes that will be positioned near this node.
  ///
  /// The default value is null.
  ///
  /// These objects should not have their own TreeVertexes to be laid out.
  /// Typically these will be Nodes whose Category is "Comment".
  /// This array should be allocated and initialized in TreeLayout#addComments.
  _i4.Array get comments => _i5.getProperty(
        this,
        'comments',
      );
  /* #29500
  source: 
    /**
     * Gets or sets an array of Nodes that will be positioned near this node.
     *
     * The default value is null.
     *
     * These objects should not have their own TreeVertexes to be laid out.
     * Typically these will be Nodes whose Category is "Comment".
     * This array should be allocated and initialized in TreeLayout#addComments.
     */
    get comments(): Array<Node>; */
  // Type Instance of 'ExternalInteropType'
  set comments(_i4.Array value) {
    _i5.setProperty(
      this,
      'comments',
      value,
    );
  }

  /* #29509
  source: 
    /**
     * Gets or sets whether and in what order the children should be sorted.
     *
     * The default value is TreeLayout.SortingForwards.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get sorting(): EnumValue; */
  /// Gets or sets whether and in what order the children should be sorted.
  ///
  /// The default value is TreeLayout.SortingForwards.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i3.EnumValue get sorting => _i5.getProperty(
        this,
        'sorting',
      );
  /* #29509
  source: 
    /**
     * Gets or sets whether and in what order the children should be sorted.
     *
     * The default value is TreeLayout.SortingForwards.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get sorting(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set sorting(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'sorting',
      value,
    );
  }

  /* #29516
  source: 
    /**
     * Gets or sets how the children should be sorted.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get comparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  /// Gets or sets how the children should be sorted.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num Function(
    _i3.TreeVertex,
    _i3.TreeVertex,
  ) get comparer => _i5.getProperty(
        this,
        'comparer',
      );
  /* #29516
  source: 
    /**
     * Gets or sets how the children should be sorted.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get comparer(): ((a: TreeVertex, b: TreeVertex) => number); */
  // Type InteropFunction#507787452(parent: InteropGetter#349120738(name: comparer), library: go.d.ts)
  set comparer(
      _i2.num Function(
        _i3.TreeVertex,
        _i3.TreeVertex,
      ) value) {
    _i5.setProperty(
      this,
      'comparer',
      _i5.allowInterop(value),
    );
  }

  /* #29529
  source: 
    /**
     * Gets or sets the absolute angle at which this subtree should grow from this vertex.
     *
     * The default value is zero, meaning that general tree growth should proceed rightwards along the X axis.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * By default this is the same as the Angle of the parent TreeVertex.
     * However, after the initial propagation of property values, perhaps in
     * an override of TreeLayout#assignTreeVertexValues,
     * you could just set this property to specify the angle at which this node grows its subtrees.
     */
    get angle(): number; */
  /// Gets or sets the absolute angle at which this subtree should grow from this vertex.
  ///
  /// The default value is zero, meaning that general tree growth should proceed rightwards along the X axis.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// By default this is the same as the Angle of the parent TreeVertex.
  /// However, after the initial propagation of property values, perhaps in
  /// an override of TreeLayout#assignTreeVertexValues,
  /// you could just set this property to specify the angle at which this node grows its subtrees.
  _i2.num get angle => _i5.getProperty(
        this,
        'angle',
      );
  /* #29529
  source: 
    /**
     * Gets or sets the absolute angle at which this subtree should grow from this vertex.
     *
     * The default value is zero, meaning that general tree growth should proceed rightwards along the X axis.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * By default this is the same as the Angle of the parent TreeVertex.
     * However, after the initial propagation of property values, perhaps in
     * an override of TreeLayout#assignTreeVertexValues,
     * you could just set this property to specify the angle at which this node grows its subtrees.
     */
    get angle(): number; */
  // Type InteropStaticType.number
  set angle(_i2.num value) {
    _i5.setProperty(
      this,
      'angle',
      value,
    );
  }

  /* #29538
  source: 
    /**
     * Gets or sets how this parent node should be aligned relative to its children.
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get alignment(): EnumValue; */
  /// Gets or sets how this parent node should be aligned relative to its children.
  ///
  /// The default value is TreeLayout.AlignmentCenterChildren.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i3.EnumValue get alignment => _i5.getProperty(
        this,
        'alignment',
      );
  /* #29538
  source: 
    /**
     * Gets or sets how this parent node should be aligned relative to its children.
     *
     * The default value is TreeLayout.AlignmentCenterChildren.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get alignment(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set alignment(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'alignment',
      value,
    );
  }

  /* #29549
  source: 
    /**
     * Gets or sets the distance the first child should be indented.
     *
     * The default value is zero. The value should be non-negative.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only sensible when the #alignment is
     * TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
     */
    get nodeIndent(): number; */
  /// Gets or sets the distance the first child should be indented.
  ///
  /// The default value is zero. The value should be non-negative.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// This property is only sensible when the #alignment is
  /// TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
  _i2.num get nodeIndent => _i5.getProperty(
        this,
        'nodeIndent',
      );
  /* #29549
  source: 
    /**
     * Gets or sets the distance the first child should be indented.
     *
     * The default value is zero. The value should be non-negative.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only sensible when the #alignment is
     * TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
     */
    get nodeIndent(): number; */
  // Type InteropStaticType.number
  set nodeIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeIndent',
      value,
    );
  }

  /* #29561
  source: 
    /**
     * Gets or sets whether the first child should be indented past the parent node's breadth.
     *
     * The default value is 0.0 -- the only start or end spacing is provided by #nodeIndent.
     * Values must range from 0.0 to 1.0, where 1.0 means the full breadth of this node.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only sensible when the #alignment is
     * TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
     */
    get nodeIndentPastParent(): number; */
  /// Gets or sets whether the first child should be indented past the parent node's breadth.
  ///
  /// The default value is 0.0 -- the only start or end spacing is provided by #nodeIndent.
  /// Values must range from 0.0 to 1.0, where 1.0 means the full breadth of this node.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// This property is only sensible when the #alignment is
  /// TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
  _i2.num get nodeIndentPastParent => _i5.getProperty(
        this,
        'nodeIndentPastParent',
      );
  /* #29561
  source: 
    /**
     * Gets or sets whether the first child should be indented past the parent node's breadth.
     *
     * The default value is 0.0 -- the only start or end spacing is provided by #nodeIndent.
     * Values must range from 0.0 to 1.0, where 1.0 means the full breadth of this node.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only sensible when the #alignment is
     * TreeLayout.AlignmentStart or TreeLayout.AlignmentEnd.
     */
    get nodeIndentPastParent(): number; */
  // Type InteropStaticType.number
  set nodeIndentPastParent(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeIndentPastParent',
      value,
    );
  }

  /* #29571
  source: 
    /**
     * Gets or sets the distance between child nodes.
     *
     * The default value is 20.
     *
     * A negative value will cause sibling nodes to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get nodeSpacing(): number; */
  /// Gets or sets the distance between child nodes.
  ///
  /// The default value is 20.
  ///
  /// A negative value will cause sibling nodes to overlap.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get nodeSpacing => _i5.getProperty(
        this,
        'nodeSpacing',
      );
  /* #29571
  source: 
    /**
     * Gets or sets the distance between child nodes.
     *
     * The default value is 20.
     *
     * A negative value will cause sibling nodes to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get nodeSpacing(): number; */
  // Type InteropStaticType.number
  set nodeSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'nodeSpacing',
      value,
    );
  }

  /* #29581
  source: 
    /**
     * Gets or sets the distance between this node and its children.
     *
     * The default value is 50.
     *
     * Negative values may cause children to overlap with the parent.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get layerSpacing(): number; */
  /// Gets or sets the distance between this node and its children.
  ///
  /// The default value is 50.
  ///
  /// Negative values may cause children to overlap with the parent.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get layerSpacing => _i5.getProperty(
        this,
        'layerSpacing',
      );
  /* #29581
  source: 
    /**
     * Gets or sets the distance between this node and its children.
     *
     * The default value is 50.
     *
     * Negative values may cause children to overlap with the parent.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get layerSpacing(): number; */
  // Type InteropStaticType.number
  set layerSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'layerSpacing',
      value,
    );
  }

  /* #29594
  source: 
    /**
     * Gets or sets the fraction of this node's depth that may overlap with the children's layer.
     *
     * The default value is 0.0 -- there is overlap only if #layerSpacing is negative.
     * Values must range from 0.0 to 1.0, where 1.0 means the full depth of this node.
     *
     * When this value is greater than 0.0, there might not be overlap if #layerSpacing
     * is larger than the depth of this node times this fraction.
     * Even when this value is 0.0, there may be overlap when #layerSpacing is negative.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get layerSpacingParentOverlap(): number; */
  /// Gets or sets the fraction of this node's depth that may overlap with the children's layer.
  ///
  /// The default value is 0.0 -- there is overlap only if #layerSpacing is negative.
  /// Values must range from 0.0 to 1.0, where 1.0 means the full depth of this node.
  ///
  /// When this value is greater than 0.0, there might not be overlap if #layerSpacing
  /// is larger than the depth of this node times this fraction.
  /// Even when this value is 0.0, there may be overlap when #layerSpacing is negative.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get layerSpacingParentOverlap => _i5.getProperty(
        this,
        'layerSpacingParentOverlap',
      );
  /* #29594
  source: 
    /**
     * Gets or sets the fraction of this node's depth that may overlap with the children's layer.
     *
     * The default value is 0.0 -- there is overlap only if #layerSpacing is negative.
     * Values must range from 0.0 to 1.0, where 1.0 means the full depth of this node.
     *
     * When this value is greater than 0.0, there might not be overlap if #layerSpacing
     * is larger than the depth of this node times this fraction.
     * Even when this value is 0.0, there may be overlap when #layerSpacing is negative.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get layerSpacingParentOverlap(): number; */
  // Type InteropStaticType.number
  set layerSpacingParentOverlap(_i2.num value) {
    _i5.setProperty(
      this,
      'layerSpacingParentOverlap',
      value,
    );
  }

  /* #29603
  source: 
    /**
     * Gets or sets how the children of this node should be packed together.
     *
     * The default value is TreeLayout.CompactionBlock.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get compaction(): EnumValue; */
  /// Gets or sets how the children of this node should be packed together.
  ///
  /// The default value is TreeLayout.CompactionBlock.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i3.EnumValue get compaction => _i5.getProperty(
        this,
        'compaction',
      );
  /* #29603
  source: 
    /**
     * Gets or sets how the children of this node should be packed together.
     *
     * The default value is TreeLayout.CompactionBlock.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get compaction(): EnumValue; */
  // Type Instance of 'InteropInterface'
  set compaction(_i3.EnumValue value) {
    _i5.setProperty(
      this,
      'compaction',
      value,
    );
  }

  /* #29613
  source: 
    /**
     * Gets or sets how broad a node and its descendants should be.
     *
     * By default this is zero.  A value of zero imposes no limit;
     * a positive value will specify a limit for the total width of this subtree.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get breadthLimit(): number; */
  /// Gets or sets how broad a node and its descendants should be.
  ///
  /// By default this is zero.  A value of zero imposes no limit;
  /// a positive value will specify a limit for the total width of this subtree.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get breadthLimit => _i5.getProperty(
        this,
        'breadthLimit',
      );
  /* #29613
  source: 
    /**
     * Gets or sets how broad a node and its descendants should be.
     *
     * By default this is zero.  A value of zero imposes no limit;
     * a positive value will specify a limit for the total width of this subtree.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get breadthLimit(): number; */
  // Type InteropStaticType.number
  set breadthLimit(_i2.num value) {
    _i5.setProperty(
      this,
      'breadthLimit',
      value,
    );
  }

  /* #29623
  source: 
    /**
     * Gets or sets the distance between rows within one layer, all sharing the same parent.
     *
     * The default value is 25.
     *
     * Negative values may cause nodes to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get rowSpacing(): number; */
  /// Gets or sets the distance between rows within one layer, all sharing the same parent.
  ///
  /// The default value is 25.
  ///
  /// Negative values may cause nodes to overlap.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get rowSpacing => _i5.getProperty(
        this,
        'rowSpacing',
      );
  /* #29623
  source: 
    /**
     * Gets or sets the distance between rows within one layer, all sharing the same parent.
     *
     * The default value is 25.
     *
     * Negative values may cause nodes to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get rowSpacing(): number; */
  // Type InteropStaticType.number
  set rowSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'rowSpacing',
      value,
    );
  }

  /* #29635
  source: 
    /**
     * Gets or sets the distance the first child of each row should be indented.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only used when the #breadthLimit is positive,
     * and some initial space needs to be reserved in each row of nodes for the links
     * that are routed around those rows.
     */
    get rowIndent(): number; */
  /// Gets or sets the distance the first child of each row should be indented.
  ///
  /// The default value is 10.  The value should be non-negative.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// This property is only used when the #breadthLimit is positive,
  /// and some initial space needs to be reserved in each row of nodes for the links
  /// that are routed around those rows.
  _i2.num get rowIndent => _i5.getProperty(
        this,
        'rowIndent',
      );
  /* #29635
  source: 
    /**
     * Gets or sets the distance the first child of each row should be indented.
     *
     * The default value is 10.  The value should be non-negative.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * This property is only used when the #breadthLimit is positive,
     * and some initial space needs to be reserved in each row of nodes for the links
     * that are routed around those rows.
     */
    get rowIndent(): number; */
  // Type InteropStaticType.number
  set rowIndent(_i2.num value) {
    _i5.setProperty(
      this,
      'rowIndent',
      value,
    );
  }

  /* #29645
  source: 
    /**
     * Gets or sets the space to leave between consecutive comments.
     *
     * The default value is 10.
     *
     * Negative values may cause comments to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get commentSpacing(): number; */
  /// Gets or sets the space to leave between consecutive comments.
  ///
  /// The default value is 10.
  ///
  /// Negative values may cause comments to overlap.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get commentSpacing => _i5.getProperty(
        this,
        'commentSpacing',
      );
  /* #29645
  source: 
    /**
     * Gets or sets the space to leave between consecutive comments.
     *
     * The default value is 10.
     *
     * Negative values may cause comments to overlap.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get commentSpacing(): number; */
  // Type InteropStaticType.number
  set commentSpacing(_i2.num value) {
    _i5.setProperty(
      this,
      'commentSpacing',
      value,
    );
  }

  /* #29655
  source: 
    /**
     * Gets or sets the space to leave between the node and the comments.
     *
     * The default value is 20.
     *
     * Negative values may cause comments to overlap with the node.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get commentMargin(): number; */
  /// Gets or sets the space to leave between the node and the comments.
  ///
  /// The default value is 20.
  ///
  /// Negative values may cause comments to overlap with the node.
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  _i2.num get commentMargin => _i5.getProperty(
        this,
        'commentMargin',
      );
  /* #29655
  source: 
    /**
     * Gets or sets the space to leave between the node and the comments.
     *
     * The default value is 20.
     *
     * Negative values may cause comments to overlap with the node.
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     */
    get commentMargin(): number; */
  // Type InteropStaticType.number
  set commentMargin(_i2.num value) {
    _i5.setProperty(
      this,
      'commentMargin',
      value,
    );
  }

  /* #29666
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * The spot used depends on the value of #portSpot.
     */
    get setsPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the FromSpot for this parent node port.
  ///
  /// The default value is true -- this may modify the spot of the port of this node, the parent,
  /// if the node has only a single port.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// The spot used depends on the value of #portSpot.
  _i2.bool get setsPortSpot => _i5.getProperty(
        this,
        'setsPortSpot',
      );
  /* #29666
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the FromSpot for this parent node port.
     *
     * The default value is true -- this may modify the spot of the port of this node, the parent,
     * if the node has only a single port.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * The spot used depends on the value of #portSpot.
     */
    get setsPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set setsPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsPortSpot',
      value,
    );
  }

  /* #29680
  source: 
    /**
     * Gets or sets the spot that this node's port gets as its FromSpot,
     * if #setsPortSpot is true and the node has only a single port.
     *
     * The default value is Spot.Default.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When TreeLayout#path is TreeLayout.PathSource, the port's ToSpot is set instead of the FromSpot.
     */
    get portSpot(): Spot; */
  /// Gets or sets the spot that this node's port gets as its FromSpot,
  /// if #setsPortSpot is true and the node has only a single port.
  ///
  /// The default value is Spot.Default.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a FromSpot based on the parent node's TreeVertex#angle.
  /// If the value is other than NoSpot, it is just assigned.
  /// When TreeLayout#path is TreeLayout.PathSource, the port's ToSpot is set instead of the FromSpot.
  _i3.Spot get portSpot => _i5.getProperty(
        this,
        'portSpot',
      );
  /* #29680
  source: 
    /**
     * Gets or sets the spot that this node's port gets as its FromSpot,
     * if #setsPortSpot is true and the node has only a single port.
     *
     * The default value is Spot.Default.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * A value of Spot.Default will cause the TreeLayout
     * to assign a FromSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When TreeLayout#path is TreeLayout.PathSource, the port's ToSpot is set instead of the FromSpot.
     */
    get portSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set portSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'portSpot',
      value,
    );
  }

  /* #29691
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spots of the ports of the children nodes,
     * if the node has only a single port.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * The spot used depends on the value of #childPortSpot.
     */
    get setsChildPortSpot(): boolean; */
  /// Gets or sets whether the TreeLayout should set the ToSpot for each child node port.
  ///
  /// The default value is true -- this may modify the spots of the ports of the children nodes,
  /// if the node has only a single port.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// The spot used depends on the value of #childPortSpot.
  _i2.bool get setsChildPortSpot => _i5.getProperty(
        this,
        'setsChildPortSpot',
      );
  /* #29691
  source: 
    /**
     * Gets or sets whether the TreeLayout should set the ToSpot for each child node port.
     *
     * The default value is true -- this may modify the spots of the ports of the children nodes,
     * if the node has only a single port.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * The spot used depends on the value of #childPortSpot.
     */
    get setsChildPortSpot(): boolean; */
  // Type InteropStaticType.boolean
  set setsChildPortSpot(_i2.bool value) {
    _i5.setProperty(
      this,
      'setsChildPortSpot',
      value,
    );
  }

  /* #29705
  source: 
    /**
     * Gets or sets the spot that children nodes' ports get as their ToSpot,
     * if #setsChildPortSpot is true and the node has only a single port.
     *
     * The default value is Spot.Default.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When TreeLayout#path is TreeLayout.PathSource, the port's FromSpot is set instead of the ToSpot.
     */
    get childPortSpot(): Spot; */
  /// Gets or sets the spot that children nodes' ports get as their ToSpot,
  /// if #setsChildPortSpot is true and the node has only a single port.
  ///
  /// The default value is Spot.Default.
  ///
  /// This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
  /// A value of Spot.Default will cause the TreeLayout
  /// to assign a ToSpot based on the parent node's TreeVertex#angle.
  /// If the value is other than NoSpot, it is just assigned.
  /// When TreeLayout#path is TreeLayout.PathSource, the port's FromSpot is set instead of the ToSpot.
  _i3.Spot get childPortSpot => _i5.getProperty(
        this,
        'childPortSpot',
      );
  /* #29705
  source: 
    /**
     * Gets or sets the spot that children nodes' ports get as their ToSpot,
     * if #setsChildPortSpot is true and the node has only a single port.
     *
     * The default value is Spot.Default.
     *
     * This inherited property is initialized in the TreeLayout#initializeTreeVertexValues pass.
     * A value of Spot.Default will cause the TreeLayout
     * to assign a ToSpot based on the parent node's TreeVertex#angle.
     * If the value is other than NoSpot, it is just assigned.
     * When TreeLayout#path is TreeLayout.PathSource, the port's FromSpot is set instead of the ToSpot.
     */
    get childPortSpot(): Spot; */
  // Type Instance of 'InteropInterface'
  set childPortSpot(_i3.Spot value) {
    _i5.setProperty(
      this,
      'childPortSpot',
      value,
    );
  }

  /* #29712
  source: 
    /**
     * This read-only property returns the number of immediate children this node has.
     *
     * The default value is zero.
     */
    get childrenCount(): number; */
  /// This read-only property returns the number of immediate children this node has.
  ///
  /// The default value is zero.
  _i2.num get childrenCount => _i5.getProperty(
        this,
        'childrenCount',
      );
  /* #29712
  source: 
    /**
     * This read-only property returns the number of immediate children this node has.
     *
     * The default value is zero.
     */
    get childrenCount(): number; */
  // Type InteropStaticType.number
  set childrenCount(_i2.num value) {
    _i5.setProperty(
      this,
      'childrenCount',
      value,
    );
  }

  /* #29719
  source: 
    /**
     * Gets or sets the position of this node relative to its parent node.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * You should probably not be setting this property.
     */
    get relativePosition(): Point; */
  /// Gets or sets the position of this node relative to its parent node.
  ///
  /// This informational property is computed during TreeLayout#doLayout.
  /// You should probably not be setting this property.
  _i3.Point get relativePosition => _i5.getProperty(
        this,
        'relativePosition',
      );
  /* #29719
  source: 
    /**
     * Gets or sets the position of this node relative to its parent node.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * You should probably not be setting this property.
     */
    get relativePosition(): Point; */
  // Type Instance of 'InteropInterface'
  set relativePosition(_i3.Point value) {
    _i5.setProperty(
      this,
      'relativePosition',
      value,
    );
  }

  /* #29728
  source: 
    /**
     * Gets or sets the size of the subtree (including all descendants) parented by this node.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * Of course if there are no children, this is just the same as Size.
     * You should probably not be setting this property.
     */
    get subtreeSize(): Size; */
  /// Gets or sets the size of the subtree (including all descendants) parented by this node.
  ///
  /// This informational property is computed during TreeLayout#doLayout.
  /// Of course if there are no children, this is just the same as Size.
  /// You should probably not be setting this property.
  _i3.Size get subtreeSize => _i5.getProperty(
        this,
        'subtreeSize',
      );
  /* #29728
  source: 
    /**
     * Gets or sets the size of the subtree (including all descendants) parented by this node.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * Of course if there are no children, this is just the same as Size.
     * You should probably not be setting this property.
     */
    get subtreeSize(): Size; */
  // Type Instance of 'InteropInterface'
  set subtreeSize(_i3.Size value) {
    _i5.setProperty(
      this,
      'subtreeSize',
      value,
    );
  }

  /* #29737
  source: 
    /**
     * Gets or sets the offset of this parent node relative to its whole subtree.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * Of course if there are no children, this is just (0, 0).
     * You should probably not be setting this property.
     */
    get subtreeOffset(): Point; */
  /// Gets or sets the offset of this parent node relative to its whole subtree.
  ///
  /// This informational property is computed during TreeLayout#doLayout.
  /// Of course if there are no children, this is just (0, 0).
  /// You should probably not be setting this property.
  _i3.Point get subtreeOffset => _i5.getProperty(
        this,
        'subtreeOffset',
      );
  /* #29737
  source: 
    /**
     * Gets or sets the offset of this parent node relative to its whole subtree.
     *
     * This informational property is computed during TreeLayout#doLayout.
     * Of course if there are no children, this is just (0, 0).
     * You should probably not be setting this property.
     */
    get subtreeOffset(): Point; */
  // Type Instance of 'InteropInterface'
  set subtreeOffset(_i3.Point value) {
    _i5.setProperty(
      this,
      'subtreeOffset',
      value,
    );
  }

  void copyInheritedPropertiesFrom(_i3.TreeVertex copy) {
    _i5.callMethod(
      this,
      'copyInheritedPropertiesFrom',
      [copy],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
class TreeEdge implements _i3.LayoutEdge {
  factory TreeEdge(_i3.TreeNetwork network) => _i5.callConstructor(
        _declaredTreeEdge,
        [network],
      );
}

/*
FieldExternal: 
*/
@_i1.JS('TreeEdge')
external _i2.Object _declaredTreeEdge;

extension TreeEdge$Typings on TreeEdge {
  /* #29759
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): TreeVertex; */
  /// Gets or sets the LayoutVertex that this edge comes from.
  /// Setting this property does not change any LayoutVertex#destinationEdges collection.
  _i3.TreeVertex get fromVertex => _i5.getProperty(
        this,
        'fromVertex',
      );
  /* #29759
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge comes from.
     * Setting this property does not change any LayoutVertex#destinationEdges collection.
     */
    get fromVertex(): TreeVertex; */
  // Type Instance of 'InteropInterface'
  set fromVertex(_i3.TreeVertex value) {
    _i5.setProperty(
      this,
      'fromVertex',
      value,
    );
  }

  /* #29765
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): TreeVertex | null; */
  /// Gets or sets the LayoutVertex that this edge goes to.
  /// Setting this property does not change any LayoutVertex#sourceEdges collection.
  _i3.TreeVertex? get toVertex => _i5.getProperty(
        this,
        'toVertex',
      );
  /* #29765
  source: 
    /**
     * Gets or sets the LayoutVertex that this edge goes to.
     * Setting this property does not change any LayoutVertex#sourceEdges collection.
     */
    get toVertex(): TreeVertex | null; */
  // Type InteropUnion#11607172(parent: InteropGetter#229593711(name: toVertex))
  set toVertex(_i3.TreeVertex? value) {
    _i5.setProperty(
      this,
      'toVertex',
      value ?? _i4.undefined,
    );
  }

  /* #29771
  source: 
    /**
     * Gets or sets a Point, relative to the parent node,
     * that may be useful in routing this link.
     */
    get relativePoint(): Point; */
  /// Gets or sets a Point, relative to the parent node,
  /// that may be useful in routing this link.
  _i3.Point get relativePoint => _i5.getProperty(
        this,
        'relativePoint',
      );
  /* #29771
  source: 
    /**
     * Gets or sets a Point, relative to the parent node,
     * that may be useful in routing this link.
     */
    get relativePoint(): Point; */
  // Type Instance of 'InteropInterface'
  set relativePoint(_i3.Point value) {
    _i5.setProperty(
      this,
      'relativePoint',
      value,
    );
  }

  void commit() {
    _i5.callMethod(
      this,
      'commit',
      [],
    );
  }
}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
class _IterableLike$<T> {}

@_i1.JS()
@_i1.staticInterop
@_i1.anonymous
abstract class _GlobalThis {}
